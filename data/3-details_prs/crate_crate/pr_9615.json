{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NTU5MjE2", "number": 9615, "title": "Returning clause for insert", "bodyText": "Summary of the changes / Why this improves CrateDB\nThis adds a new optional RETURNING clause for Insert to return specified values from each row inserted.\nChecklist\n\n User relevant changes are recorded in CHANGES.txt\n Touched code is covered by tests\n Documentation has been updated if necessary\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-01-31T12:29:00Z", "url": "https://github.com/crate/crate/pull/9615", "merged": true, "mergeCommit": {"oid": "07e4cb4435e1fa34d6172e01d924ff2c51a7fba5"}, "closed": true, "closedAt": "2020-02-13T12:04:34Z", "author": {"login": "mkleen"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_wiLcABqjI5OTczOTQ3NDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcD5R1-ABqjMwMzQ0Nzc4OTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4da3baa62787b0eea2e03df0c0abda8f100253e", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a4da3baa62787b0eea2e03df0c0abda8f100253e", "committedDate": "2020-01-31T12:28:04Z", "message": "Add documentation for returning clause for insert"}, "afterCommit": {"oid": "2c4e3f8840a877b34ff10c9e5d00faca32d96d1c", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/2c4e3f8840a877b34ff10c9e5d00faca32d96d1c", "committedDate": "2020-01-31T15:04:32Z", "message": "Add documentation for returning clause for insert"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "260c1a3ab81410320a971ea2425f6d10300e2df7", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/260c1a3ab81410320a971ea2425f6d10300e2df7", "committedDate": "2020-02-12T13:23:24Z", "message": "Add note of returning clause for insert to changes"}, "afterCommit": {"oid": "a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "committedDate": "2020-02-12T13:27:02Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "committedDate": "2020-02-12T13:27:02Z", "message": "Add returning clause for insert to storage engine"}, "afterCommit": {"oid": "aaac781f921142fc6fe6a2fa60b28379b5b6db98", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/aaac781f921142fc6fe6a2fa60b28379b5b6db98", "committedDate": "2020-02-12T13:37:53Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aaac781f921142fc6fe6a2fa60b28379b5b6db98", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/aaac781f921142fc6fe6a2fa60b28379b5b6db98", "committedDate": "2020-02-12T13:37:53Z", "message": "Add returning clause for insert to storage engine"}, "afterCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/108071f87108760beec4976bd2883282e29b108b", "committedDate": "2020-02-12T14:04:47Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTI1MDcz", "url": "https://github.com/crate/crate/pull/9615#pullrequestreview-357525073", "createdAt": "2020-02-12T15:04:04Z", "commit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTowNDowNVrOFoyE6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTozODo1NVrOFozgog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwNzgxNw==", "bodyText": "Are system columns not supported? Otherwise maybe add the same as here? 289d32d", "url": "https://github.com/crate/crate/pull/9615#discussion_r378307817", "createdAt": "2020-02-12T15:04:05Z", "author": {"login": "seut"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -119,14 +126,22 @@ Parameters\n ==========\n \n :table_ident:\n-  The identifier (optionally schema-qualified) of an existing table.\n+    The identifier (optionally schema-qualified) of an existing table.\n \n :column_ident:\n-  The name of a column or field in the table pointed to by *table_ident*.\n+    The name of a column or field in the table pointed to by *table_ident*.\n \n :expression:\n-  An expression or value to assign to the corresponding column.\n+    An expression or value to assign to the corresponding column.\n \n :query:\n-  A query (SELECT statement) that supplies the rows to be inserted.\n-  Refer to the ``SELECT`` statement for a description of the syntax.\n+    A query (``SELECT`` statement) that supplies the rows to be inserted.\n+    Refer to the ``SELECT`` statement for a description of the syntax.\n+\n+:output_expression:\n+    An expression to be computed and returned by the ``INSERT`` command\n+    after each row is updated. The expression can use any column names\n+    of the table or use ``*`` to return all columns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg==", "bodyText": "What does | relation.*  stand for, can you give me an example please? Maybe its just me ;)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378309932", "createdAt": "2020-02-12T15:07:23Z", "author": {"login": "seut"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxMjg1Nw==", "bodyText": "isn't onConflict still missing here?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378312857", "createdAt": "2020-02-12T15:11:41Z", "author": {"login": "seut"}, "path": "sql-parser/src/main/java/io/crate/sql/SqlFormatter.java", "diffHunk": "@@ -205,6 +206,41 @@ protected Void visitExplain(Explain node, Integer indent) {\n             return null;\n         }\n \n+        @Override\n+        public Void visitInsert(Insert<?> node, Integer indent) {\n+            append(indent, \"INSERT\");\n+            builder.append(' ');\n+            append(indent, \"INTO\");\n+            builder.append(' ');\n+            node.table().accept(this, indent);\n+            builder.append(' ');\n+            var columns = node.columns().iterator();\n+            if (columns.hasNext()) {\n+                builder.append('(');\n+                while (columns.hasNext()) {\n+                    builder.append(columns.next());\n+                    if (columns.hasNext()) {\n+                        builder.append(\", \");\n+                    }\n+                }\n+                builder.append(')');\n+            }\n+            builder.append(' ');\n+            node.insertSource().accept(this, indent);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzA5Mw==", "bodyText": "Please remove Nullable annotation as it is expected to not be null by next assertion", "url": "https://github.com/crate/crate/pull/9615#discussion_r378317093", "createdAt": "2020-02-12T15:18:03Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMTcyOA==", "bodyText": "shouldn't this be indexResult.getTerm()?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378321728", "createdAt": "2020-02-12T15:25:02Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzAxNg==", "bodyText": "why not passing in the rawSource here as well? don't we want to support _raw as returning for performance reasons? If this was already discussed, sorry. If so a reasoning comment would be helpful ;)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323016", "createdAt": "2020-02-12T15:27:00Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzMyOA==", "bodyText": "same here, no _raw support wanted?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323328", "createdAt": "2020-02-12T15:27:28Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(\n+                    fetchedDoc.docId(),\n+                    fetchedDoc.getIndex(),\n+                    fetchedDoc.getId(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    indexResult.getTerm(),\n+                    source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyOTg2NQ==", "bodyText": "very minor:  Isn't toArray(new Object[0]) still faster, safer than toArray(new Object[])? (see https://shipilev.net/blog/2016/arrays-wisdom-ancients/)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378329865", "createdAt": "2020-02-12T15:36:43Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java", "diffHunk": "@@ -94,20 +96,31 @@ public ColumnIndexWriterProjector(ClusterService clusterService,\n             updateColumnNames = convert.targetNames();\n             assignments = convert.sources();\n         }\n+\n+        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[]{});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzMTI5OA==", "bodyText": "format: indent issue (also @Test annotation missing)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378331298", "createdAt": "2020-02-12T15:38:55Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java", "diffHunk": "@@ -1458,4 +1458,133 @@ public void testInsertDefaultExpressions() {\n                \"5| cr8\\n\")\n         );\n     }\n+\n+    @Test\n+    public void test_insert_with_id_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.rows()[0][0], is(1));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_multiple_values_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id, owner\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.cols()[1], is(\"owner\"));\n+        assertThat(response.rows()[0][0], is(1));\n+        assertThat(response.rows()[0][1], is(\"crate\"));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_function_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id + 1 as bar\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"bar\"));\n+        assertThat(response.rows()[0][0], is(2));\n+\n+    }\n+\n+\n+    @Test\n+    public void test_insert_with_seq_no_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning _seq_no as seq\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"seq\"));\n+        assertThat(response.rows()[0][0], is(0L));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_owner_renamed_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning owner as name\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"name\"));\n+        assertThat(response.rows()[0][0], is(\"crate\"));\n+\n+    }\n+\n+        public void test_insert_from_subquery_with_id_field_in_returning_clause() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MDg1MjQx", "url": "https://github.com/crate/crate/pull/9615#pullrequestreview-358085241", "createdAt": "2020-02-13T09:57:28Z", "commit": {"oid": "a7364a73026510648ca500366063b6a44d199807"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7364a73026510648ca500366063b6a44d199807", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a7364a73026510648ca500366063b6a44d199807", "committedDate": "2020-02-13T09:10:30Z", "message": "Extend documentation to add system columns to output_expression"}, "afterCommit": {"oid": "033eb9eae500a53b0bdef25a64215edd153cd865", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/033eb9eae500a53b0bdef25a64215edd153cd865", "committedDate": "2020-02-13T10:16:57Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "510d6958902a565b1e13018c8a52247a25d17233", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/510d6958902a565b1e13018c8a52247a25d17233", "committedDate": "2020-02-13T11:28:56Z", "message": "Add documentation for returning clause for insert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9697c21f979cc260fdfc2d3e0013862778f3ca29", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/9697c21f979cc260fdfc2d3e0013862778f3ca29", "committedDate": "2020-02-13T11:28:56Z", "message": "Add returning clause for insert to grammar and parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61a3ca5d6cafc41bb1d6e416a486346ed4f7bffa", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/61a3ca5d6cafc41bb1d6e416a486346ed4f7bffa", "committedDate": "2020-02-13T11:31:25Z", "message": "Add returnvalues and output fields for insert to analyzer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "committedDate": "2020-02-13T11:31:30Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "033eb9eae500a53b0bdef25a64215edd153cd865", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/033eb9eae500a53b0bdef25a64215edd153cd865", "committedDate": "2020-02-13T10:16:57Z", "message": "Add returning clause for insert to storage engine"}, "afterCommit": {"oid": "f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "committedDate": "2020-02-13T11:31:30Z", "message": "Add returning clause for insert to storage engine"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3808, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}