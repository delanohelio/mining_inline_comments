{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDU0ODAx", "number": 9513, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxOTowMlrODYIBHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1OToxN1rODZandg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjIzNzczOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxOTowMlrOFdzcIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNTowNDowN1rOFd7T2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ==", "bodyText": "Added this condition just for now, so we always generated cast to object... Do you think we have to have a proper equal and isConvertible for object types, by proper i mean taking into account inner types and considering cases with different fields, undefined types, etc. I am not sure how straightforward that can be, coz isConvertible depends on equals now, but that would be now the way to go for object types and we would need to have a special handling for it. Probably, we have to do that anyways, just want to get some input on it.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366795809", "createdAt": "2020-01-15T10:19:02Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NzI5MA==", "bodyText": "Can you elaborate on the isConvertible relationship to equals?\nI think we should override equals on ObjectType to take inner-types into consideration.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366857290", "createdAt": "2020-01-15T12:49:05Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkyNDc2MA==", "bodyText": "because isConvertableTo uses equals. We can have cases where we check whether some literal of an object type that missing the inner types info checked whether it can be converted to target object type with some inner types. It can also be other way around, where the source type has inner types and the target type missing them. I'd say that it is still ok to covert object to object if one missing the inner type info completely, but implementing the equal in this way seems to be not that correct. Therefore, i was talking about special handling of object types in isConvertible, but not sure :/", "url": "https://github.com/crate/crate/pull/9513#discussion_r366924760", "createdAt": "2020-01-15T15:04:07Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjYyNDAxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0NTowMFrOFd3Fxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0Nzo0MVrOFd6u0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg==", "bodyText": "Would it make sense to always encode the return type into the cast function and generally remove the notion of having per type cast function names?\nSo that we don't have to treat object casts in a special way.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366855622", "createdAt": "2020-01-15T12:45:00Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2ODMzMA==", "bodyText": "we can only provide the return type as a function argument, because at this step https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/expression/BaseImplementationSymbolVisitor.java#L56 when we resolve a function the return type info from the FunctionInfo is discarded. Thus, we would then need to make all the cast functions to take two arguments (source symbol and target type), and build Function with arguments like List.of(sourceSymbol, Literal.NULL)). But actually then we don't have to distinguish between cast and cast object functions. So do you suggest to go with the changing of the cast function signatures to take two args?", "url": "https://github.com/crate/crate/pull/9513#discussion_r366868330", "createdAt": "2020-01-15T13:15:30Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MDk5OQ==", "bodyText": "So do you suggest to go with the changing of the cast function signatures to take two args?\n\nYes. It is also a hack, but so is encoding the return type into the function name. And I think we're better off with a single hack than multiple hacks + using a different hack depending on which type.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366870999", "createdAt": "2020-01-15T13:21:34Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MTQyNA==", "bodyText": "But we'll probably have to make sure that if a <4.0.12 node creates a plan with a old cast function name, it will still resolve on a node that includes this fix.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366871424", "createdAt": "2020-01-15T13:22:31Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNTI4Mg==", "bodyText": "maybe smth like that 4d7dcc3. it also stay backward compatible, coz resolvers either pick the provided pre-registered return data type or get it from the data types.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366915282", "createdAt": "2020-01-15T14:47:41Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3ODI1OTA2OnYy", "diffSide": "RIGHT", "path": "docs/appendices/release-notes/unreleased.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MDo1N1rOFfkYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MDo1N1rOFfkYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0NjIxMQ==", "bodyText": "can you wrap this item to 79 chars? you can break apart literal blocks if they have spaces in them no problem", "url": "https://github.com/crate/crate/pull/9513#discussion_r368646211", "createdAt": "2020-01-20T16:50:57Z", "author": {"login": "norosa"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -57,6 +57,13 @@ None\n Fixes\n =====\n \n+- Fixed a bug that would lead to insertion of records via", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3ODI2MTc0OnYy", "diffSide": "RIGHT", "path": "docs/appendices/release-notes/unreleased.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MTo0M1rOFfkZrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MTo0M1rOFfkZrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0NjU3Mw==", "bodyText": "can you add an empty line above this to start the new para. also wrap to 79 chars by breaking after timestamp if it fits", "url": "https://github.com/crate/crate/pull/9513#discussion_r368646573", "createdAt": "2020-01-20T16:51:43Z", "author": {"login": "norosa"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -57,6 +57,13 @@ None\n Fixes\n =====\n \n+- Fixed a bug that would lead to insertion of records via\n+  ``INSERT INTO ... (SELECT ... FROM ..)`` and\n+  ``INSERT INTO ... VALUES (...)``  into different partitions while using\n+  the same partition by value.\n+  This occurs only when the partition key is an object field of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTY3ODAwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNTowM1rOFfxkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNTowM1rOFfxkDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjIyMg==", "bodyText": "isn't it always 1 or 2 arguments?", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862222", "createdAt": "2020-01-21T08:25:03Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTY3ODkzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNToyNVrOFfxkrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNToyNVrOFfxkrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjM4Mw==", "bodyText": "Same here, I think this should be limited to 1 or 2 arguments", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862383", "createdAt": "2020-01-21T08:25:25Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTc3MDc4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1OToxN1rOFfycUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTo1MDo0NFrOFfz8_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ==", "bodyText": "Do we still need the CAST_SIGNATURES in the current form? I thought we're going to remove the to_<typeName> notation. Or is it still required for BWC?", "url": "https://github.com/crate/crate/pull/9513#discussion_r368876625", "createdAt": "2020-01-21T08:59:17Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n+            this.name = name;\n         }\n \n         @Override\n         public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n-            checkPreconditions(dataTypes);\n-            return new CastFunction(new FunctionInfo(new FunctionIdent(name, dataTypes), targetType));\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n         }\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        for (Map.Entry<String, DataType> function : CastFunctionResolver.CAST_SIGNATURES.entrySet()) {\n-            module.register(function.getKey(), new Resolver(function.getValue(), function.getKey()));\n+        for (Map.Entry<String, DataType> function : CAST_SIGNATURES.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5NDQ4MA==", "bodyText": "It is actually needed for bwc.", "url": "https://github.com/crate/crate/pull/9513#discussion_r368894480", "createdAt": "2020-01-21T09:36:33Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n+            this.name = name;\n         }\n \n         @Override\n         public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n-            checkPreconditions(dataTypes);\n-            return new CastFunction(new FunctionInfo(new FunctionIdent(name, dataTypes), targetType));\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n         }\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        for (Map.Entry<String, DataType> function : CastFunctionResolver.CAST_SIGNATURES.entrySet()) {\n-            module.register(function.getKey(), new Resolver(function.getValue(), function.getKey()));\n+        for (Map.Entry<String, DataType> function : CAST_SIGNATURES.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ=="}, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTM3Mg==", "bodyText": "Could you add a comment about this? Also noting at which point we can remove it.", "url": "https://github.com/crate/crate/pull/9513#discussion_r368901372", "createdAt": "2020-01-21T09:50:44Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n+            this.name = name;\n         }\n \n         @Override\n         public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n-            checkPreconditions(dataTypes);\n-            return new CastFunction(new FunctionInfo(new FunctionIdent(name, dataTypes), targetType));\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n         }\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        for (Map.Entry<String, DataType> function : CastFunctionResolver.CAST_SIGNATURES.entrySet()) {\n-            module.register(function.getKey(), new Resolver(function.getValue(), function.getKey()));\n+        for (Map.Entry<String, DataType> function : CAST_SIGNATURES.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ=="}, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 178}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1111, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}