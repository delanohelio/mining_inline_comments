{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MTU3MjIz", "number": 9684, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMDozMzoyNVrODjBgKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MjowNFrODjG0YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDUxMzcwOnYy", "diffSide": "LEFT", "path": "docs/general/builtins/table-functions.rst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMDozMzoyNVrOFumSZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMDozMzoyNVrOFumSZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQwNjExNw==", "bodyText": "This is now supported", "url": "https://github.com/crate/crate/pull/9684#discussion_r384406117", "createdAt": "2020-02-26T10:33:25Z", "author": {"login": "mfussenegger"}, "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -93,12 +93,6 @@ The columns are named ``colN`` where N is a number starting at 1.\n     +------+----------+\n     SELECT 3 rows in set (... sec)\n \n-If an array with object literals is passed into unnest the object will be\n-regarded as a object with column policy ``ignored``. This means that it is not\n-possible to access values of the object using the subscript notation::\n-\n-    cr> select col1['x'] from unnest([{x=10}]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad0cf4b74cb0890e2765a6b3990b8c2ec0083d0"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTIxMjM4OnYy", "diffSide": "LEFT", "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoxMDo0M1rOFus6sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToyNDozNlrOFuv8-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ==", "bodyText": "isn't this comment in general still valid/interesting?", "url": "https://github.com/crate/crate/pull/9684#discussion_r384514739", "createdAt": "2020-02-26T14:10:43Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "diffHunk": "@@ -22,46 +22,36 @@\n \n package io.crate.analyze.relations;\n \n-import io.crate.analyze.Fields;\n-import io.crate.analyze.HavingClause;\n-import io.crate.analyze.OrderBy;\n-import io.crate.analyze.Relations;\n-import io.crate.analyze.WhereClause;\n import io.crate.exceptions.ColumnUnknownException;\n-import io.crate.expression.symbol.Field;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n-import io.crate.sql.tree.QualifiedName;\n+import org.elasticsearch.common.UUIDs;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class UnionSelect implements AnalyzedRelation {\n \n-    private final Fields fields;\n     private final AnalyzedRelation left;\n     private final AnalyzedRelation right;\n-    private final List<Symbol> outputs;\n-    private final QualifiedName name;\n+    private final List<ScopedSymbol> outputs;\n+    private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n         this.left = left;\n         this.right = right;\n-        this.name = left.getQualifiedName();\n-\n-        List<Field> fieldsFromLeft = left.fields();\n-        fields = new Fields(fieldsFromLeft.size());\n-        for (Field field : fieldsFromLeft) {\n-            // Creating a field that points to the field of the left relation isn't 100% accurate.\n-            // We're pointing to *two* symbols (both left AND right).\n-            // We could either use a `InputColumn` to do that (by pointing to a position) - (but might be confusing to have InputColumns in the analysis already)\n-            // Or introduce a `UnionSymbol` or `UnionField` which would take two symbols it is pointing to\n-            // Since this currently has no effect we go with the left symbol until there is a good reason to change it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjEwMw==", "bodyText": "Not sure - the pointer stuff is gone. I could add a comment that due to SQL semantics it uses the name of the left relation or so?", "url": "https://github.com/crate/crate/pull/9684#discussion_r384556103", "createdAt": "2020-02-26T15:13:02Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "diffHunk": "@@ -22,46 +22,36 @@\n \n package io.crate.analyze.relations;\n \n-import io.crate.analyze.Fields;\n-import io.crate.analyze.HavingClause;\n-import io.crate.analyze.OrderBy;\n-import io.crate.analyze.Relations;\n-import io.crate.analyze.WhereClause;\n import io.crate.exceptions.ColumnUnknownException;\n-import io.crate.expression.symbol.Field;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n-import io.crate.sql.tree.QualifiedName;\n+import org.elasticsearch.common.UUIDs;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class UnionSelect implements AnalyzedRelation {\n \n-    private final Fields fields;\n     private final AnalyzedRelation left;\n     private final AnalyzedRelation right;\n-    private final List<Symbol> outputs;\n-    private final QualifiedName name;\n+    private final List<ScopedSymbol> outputs;\n+    private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n         this.left = left;\n         this.right = right;\n-        this.name = left.getQualifiedName();\n-\n-        List<Field> fieldsFromLeft = left.fields();\n-        fields = new Fields(fieldsFromLeft.size());\n-        for (Field field : fieldsFromLeft) {\n-            // Creating a field that points to the field of the left relation isn't 100% accurate.\n-            // We're pointing to *two* symbols (both left AND right).\n-            // We could either use a `InputColumn` to do that (by pointing to a position) - (but might be confusing to have InputColumns in the analysis already)\n-            // Or introduce a `UnionSymbol` or `UnionField` which would take two symbols it is pointing to\n-            // Since this currently has no effect we go with the left symbol until there is a good reason to change it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzU3MQ==", "bodyText": "Hm right, fine for me without a comment as well.", "url": "https://github.com/crate/crate/pull/9684#discussion_r384557571", "createdAt": "2020-02-26T15:15:02Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "diffHunk": "@@ -22,46 +22,36 @@\n \n package io.crate.analyze.relations;\n \n-import io.crate.analyze.Fields;\n-import io.crate.analyze.HavingClause;\n-import io.crate.analyze.OrderBy;\n-import io.crate.analyze.Relations;\n-import io.crate.analyze.WhereClause;\n import io.crate.exceptions.ColumnUnknownException;\n-import io.crate.expression.symbol.Field;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n-import io.crate.sql.tree.QualifiedName;\n+import org.elasticsearch.common.UUIDs;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class UnionSelect implements AnalyzedRelation {\n \n-    private final Fields fields;\n     private final AnalyzedRelation left;\n     private final AnalyzedRelation right;\n-    private final List<Symbol> outputs;\n-    private final QualifiedName name;\n+    private final List<ScopedSymbol> outputs;\n+    private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n         this.left = left;\n         this.right = right;\n-        this.name = left.getQualifiedName();\n-\n-        List<Field> fieldsFromLeft = left.fields();\n-        fields = new Fields(fieldsFromLeft.size());\n-        for (Field field : fieldsFromLeft) {\n-            // Creating a field that points to the field of the left relation isn't 100% accurate.\n-            // We're pointing to *two* symbols (both left AND right).\n-            // We could either use a `InputColumn` to do that (by pointing to a position) - (but might be confusing to have InputColumns in the analysis already)\n-            // Or introduce a `UnionSymbol` or `UnionField` which would take two symbols it is pointing to\n-            // Since this currently has no effect we go with the left symbol until there is a good reason to change it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2NDQ3NA==", "bodyText": "Added a comment anyways", "url": "https://github.com/crate/crate/pull/9684#discussion_r384564474", "createdAt": "2020-02-26T15:24:36Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "diffHunk": "@@ -22,46 +22,36 @@\n \n package io.crate.analyze.relations;\n \n-import io.crate.analyze.Fields;\n-import io.crate.analyze.HavingClause;\n-import io.crate.analyze.OrderBy;\n-import io.crate.analyze.Relations;\n-import io.crate.analyze.WhereClause;\n import io.crate.exceptions.ColumnUnknownException;\n-import io.crate.expression.symbol.Field;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n-import io.crate.sql.tree.QualifiedName;\n+import org.elasticsearch.common.UUIDs;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class UnionSelect implements AnalyzedRelation {\n \n-    private final Fields fields;\n     private final AnalyzedRelation left;\n     private final AnalyzedRelation right;\n-    private final List<Symbol> outputs;\n-    private final QualifiedName name;\n+    private final List<ScopedSymbol> outputs;\n+    private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n         this.left = left;\n         this.right = right;\n-        this.name = left.getQualifiedName();\n-\n-        List<Field> fieldsFromLeft = left.fields();\n-        fields = new Fields(fieldsFromLeft.size());\n-        for (Field field : fieldsFromLeft) {\n-            // Creating a field that points to the field of the left relation isn't 100% accurate.\n-            // We're pointing to *two* symbols (both left AND right).\n-            // We could either use a `InputColumn` to do that (by pointing to a position) - (but might be confusing to have InputColumns in the analysis already)\n-            // Or introduce a `UnionSymbol` or `UnionField` which would take two symbols it is pointing to\n-            // Since this currently has no effect we go with the left symbol until there is a good reason to change it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTI0Nzc2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoxOTozMFrOFutQlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoxOTozMFrOFutQlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDM0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n          \n          \n            \n                    assert newArg1 != null : arg1 + \" became NULL, symbols must never convert to NULL\";", "url": "https://github.com/crate/crate/pull/9684#discussion_r384520340", "createdAt": "2020-02-26T14:19:30Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "diffHunk": "@@ -84,10 +86,12 @@ private Function manyArgs(Function func, C context) {\n     private Function twoArgs(Function func, C context) {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n-        Symbol newArg1 = requireNonNull(arg1.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg1 = arg1.accept(this, context);\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTI0ODY5OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoxOTo0MlrOFutRFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoxOTo0MlrOFutRFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDQ2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";\n          \n          \n            \n                    assert newArg2 != null : arg2 + \" became NULL, symbols must never convert to NULL\";", "url": "https://github.com/crate/crate/pull/9684#discussion_r384520469", "createdAt": "2020-02-26T14:19:42Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "diffHunk": "@@ -84,10 +86,12 @@ private Function manyArgs(Function func, C context) {\n     private Function twoArgs(Function func, C context) {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n-        Symbol newArg1 = requireNonNull(arg1.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg1 = arg1.accept(this, context);\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n \n         Symbol arg2 = func.arguments().get(1);\n-        Symbol newArg2 = requireNonNull(arg2.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg2 = arg2.accept(this, context);\n+        assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTM4MTY5OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MToyNFrOFuujKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MToyNFrOFuujKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTQ4Mg==", "bodyText": "looks like renamed by mistake?", "url": "https://github.com/crate/crate/pull/9684#discussion_r384541482", "createdAt": "2020-02-26T14:51:24Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java", "diffHunk": "@@ -55,7 +55,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-public class NodeStatsContextFieldResolverTest {\n+public class NodeStatsContextScopedSymbolResolverTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTM4NDY0OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MjowNFrOFuuk8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToxMTozNFrOFuvYSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTkzNg==", "bodyText": "Renamed by mistake?", "url": "https://github.com/crate/crate/pull/9684#discussion_r384541936", "createdAt": "2020-02-26T14:52:04Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java", "diffHunk": "@@ -23,36 +23,34 @@\n package io.crate.analyze.relations;\n \n import io.crate.analyze.ValuesResolver;\n-import io.crate.expression.symbol.Field;\n-import io.crate.expression.symbol.InputColumn;\n import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n import io.crate.sql.tree.QualifiedName;\n import io.crate.types.DataTypes;\n import org.junit.Test;\n-import org.mockito.Mockito;\n \n import static io.crate.testing.SymbolMatchers.isField;\n import static io.crate.testing.SymbolMatchers.isLiteral;\n-import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertThat;\n \n-public class ExcludedFieldProviderTest {\n+public class ExcludedScopedSymbolProviderTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NTA4Mg==", "bodyText": "Yep, Intellij rename refactoring was too aggressive :(", "url": "https://github.com/crate/crate/pull/9684#discussion_r384555082", "createdAt": "2020-02-26T15:11:34Z", "author": {"login": "mfussenegger"}, "path": "sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java", "diffHunk": "@@ -23,36 +23,34 @@\n package io.crate.analyze.relations;\n \n import io.crate.analyze.ValuesResolver;\n-import io.crate.expression.symbol.Field;\n-import io.crate.expression.symbol.InputColumn;\n import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n import io.crate.sql.tree.QualifiedName;\n import io.crate.types.DataTypes;\n import org.junit.Test;\n-import org.mockito.Mockito;\n \n import static io.crate.testing.SymbolMatchers.isField;\n import static io.crate.testing.SymbolMatchers.isLiteral;\n-import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertThat;\n \n-public class ExcludedFieldProviderTest {\n+public class ExcludedScopedSymbolProviderTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTkzNg=="}, "originalCommit": {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1075, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}