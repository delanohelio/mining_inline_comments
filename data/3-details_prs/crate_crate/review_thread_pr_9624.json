{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMzI4Mjg5", "number": 9624, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyMjoyMlrODd-dpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODoyMjo0N1rODfFWUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzU4Njk0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyMjoyMlrOFm4kEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyMjoyMlrOFm4kEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNjk0NA==", "bodyText": "I am not sure if the ShardResponse.CompressedResult should have resultValues, it works, but seems to me semantically questionable.\nSo we could consider using the full ShardResponse when using return values instead or an own dedicated datastructure.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376316944", "createdAt": "2020-02-07T10:22:22Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final List<Object[]> resultValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d09063532acaa7dc407a01fdc8406b2f289e935f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTQ2Mjk0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo0Njo0NlrOFnbgFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNTozNlrOFoMfwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw==", "bodyText": "According to @mfussenegger this case should never happen since the source would be only null if it is created from a FromRawInsertSource which only applies to the COPY statement, which does not have a returning clause. However, this make sure values are only converted back from BytesReference to Map<String, Object if result values are requested.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376889367", "createdAt": "2020-02-10T06:46:46Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        final long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        final long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        final long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjA5Ng==", "bodyText": "I think I was wrong. a INSERT INTO tbl (_raw) ... could probably also trigger this case.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692096", "createdAt": "2020-02-11T15:05:36Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        final long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        final long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        final long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw=="}, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTQ3NjU5OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo1NTozMVrOFnboIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo1NTozMVrOFnboIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MTQyNQ==", "bodyText": "This change is needed to be able to retrieve the result as Map<String, Object>. In all cases except the one in FromRawInsertSource the data is already in the form of Map<String, Object> which is needed for the returnvalue evaluation. Otherwise the values would need to converted again from BytesReference, which is unnecessary and expensive.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376891425", "createdAt": "2020-02-10T06:55:31Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -28,13 +28,17 @@\n import io.crate.metadata.doc.DocSysColumns;\n import io.crate.metadata.doc.DocTableInfo;\n import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n \n import java.io.IOException;\n import java.util.List;\n+import java.util.Map;\n \n public interface InsertSourceGen {\n \n-    BytesReference generateSourceAndCheckConstraints(Object[] values) throws IOException;\n+    BytesReference generateSourceAndCheckConstraintsAsBytesReference(Object[] values) throws IOException;\n+\n+    Map<String, Object> generateSourceAndCheckConstraints(Object[] values) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTQ4OTA0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNzowMzowOVrOFnbvOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNToxMjoxMVrOFoMxCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ==", "bodyText": "Minor: The type of outputs is defined in multiple ways over the codebase, sometimes it is List<Symbol> sometimes it is List<? extends Symbol> and sometimes it is List<Field>. Are there any cases where the output is not a Field  ?", "url": "https://github.com/crate/crate/pull/9624#discussion_r376893241", "createdAt": "2020-02-10T07:03:09Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "diffHunk": "@@ -95,7 +95,7 @@ ColumnIndexWriterProjection columnIndexWriterProjection() {\n \n     @Override\n     public List<Symbol> outputs() {\n-        return MergeCountProjection.OUTPUTS;\n+        return (List<Symbol>) writeToTable.outputs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NjUyMQ==", "bodyText": "Yes, there can be function symbols or Reference symbols as well.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377696521", "createdAt": "2020-02-11T15:12:11Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "diffHunk": "@@ -95,7 +95,7 @@ ColumnIndexWriterProjection columnIndexWriterProjection() {\n \n     @Override\n     public List<Symbol> outputs() {\n-        return MergeCountProjection.OUTPUTS;\n+        return (List<Symbol>) writeToTable.outputs();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ=="}, "originalCommit": {"oid": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjE3OTM0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMTowOToxMFrOFniLuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNDo0MVrOFoMdTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw==", "bodyText": "This optimizes for the case where to insert value is already string-based.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376998843", "createdAt": "2020-02-10T11:09:10Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02cf964077f497226dcbdfc19642540f67a92a0"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MTQ3MQ==", "bodyText": "I think it would be worth adding the information that this is primarily a performance optimization as inline comment.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377691471", "createdAt": "2020-02-11T15:04:41Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw=="}, "originalCommit": {"oid": "e02cf964077f497226dcbdfc19642540f67a92a0"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjU5ODQyOnYy", "diffSide": "RIGHT", "path": "hs_err_pid15742.log", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1NzoyM1rOFoMKnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNzo0Mzo1M1rOFokWdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4NjY4NQ==", "bodyText": "Looks like this file was added by accident.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377686685", "createdAt": "2020-02-11T14:57:23Z", "author": {"login": "mfussenegger"}, "path": "hs_err_pid15742.log", "diffHunk": "@@ -0,0 +1,629 @@\n+#", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA4MjkzMw==", "bodyText": "ups", "url": "https://github.com/crate/crate/pull/9624#discussion_r378082933", "createdAt": "2020-02-12T07:43:53Z", "author": {"login": "mkleen"}, "path": "hs_err_pid15742.log", "diffHunk": "@@ -0,0 +1,629 @@\n+#", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4NjY4NQ=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjYwNTI0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1ODo1MFrOFoMOvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1ODo1MFrOFoMOvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4Nzc0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final ArrayList<Object[]> resultValues = new ArrayList<>();\n          \n          \n            \n                    private final ArrayList<Object[]> resultRows= new ArrayList<>();\n          \n      \n    \n    \n  \n\nI think rows would be less vague than values.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377687740", "createdAt": "2020-02-11T14:58:50Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final ArrayList<Object[]> resultValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjYwOTQwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1OTo1MVrOFoMRag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1OTo1MVrOFoMRag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4ODQyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public List<Object[]> resultValues() {\n          \n          \n            \n                    public List<Object[]> resultRows() {", "url": "https://github.com/crate/crate/pull/9624#discussion_r377688426", "createdAt": "2020-02-11T14:59:51Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -280,6 +285,10 @@ public boolean failed(int location) {\n             return failureLocations.get(location);\n         }\n \n+        public List<Object[]> resultValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjYxOTE1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowMjoxNlrOFoMXgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowMjoxNlrOFoMXgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4OTk4Nw==", "bodyText": "Would it be possible to add the default implementation to generateSourceAndCheckConstraintsAsBytesReference instead of adding an additional method?", "url": "https://github.com/crate/crate/pull/9624#discussion_r377689987", "createdAt": "2020-02-11T15:02:16Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -51,4 +55,8 @@ static InsertSourceGen of(TransactionContext txnCtx,\n         }\n         return new InsertSourceFromCells(txnCtx, functions, table, indexName, validation, targets);\n     }\n+\n+    default BytesReference toBytesReference(Map<String, Object> source) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjYzNjAyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNjozM1rOFoMiEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODo1MjozOVrOFomE3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA==", "bodyText": "The other parameters have a different indentation than the last one. I'm surprised that checkstyle doesn't complain aobut this.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692688", "createdAt": "2020-02-11T15:06:33Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NTc3OQ==", "bodyText": "I forgot to mention it, this formatting is on purpose. Ceckstyle complains if i format the lambda aligned to the other values, which seems wrong to me. [ant:checkstyle] [ERROR] /Users/mkleen/Code/crate/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java:357: 'lambda arguments' has incorrect indentation level 24, expected level should be 20. [Indentation]", "url": "https://github.com/crate/crate/pull/9624#discussion_r378095779", "createdAt": "2020-02-12T08:19:10Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExMTE5OQ==", "bodyText": "I think the following passes:\ndiff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 4001a79418..c9c1212316 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n@@ -347,13 +347,14 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n             returnvalues = returnGen.generateReturnValues(\n                 // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n                 // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n-                new Doc(-1,\n-                        indexShard.shardId().getIndexName(),\n-                        item.id(),\n-                        indexResult.getVersion(),\n-                        indexResult.getSeqNo(),\n-                        primaryTerm,\n-                        source,\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n                     () -> \"\"\n                 )\n             );", "url": "https://github.com/crate/crate/pull/9624#discussion_r378111199", "createdAt": "2020-02-12T08:52:39Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjYzODg5OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNzoxNVrOFoMj5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNzoxNVrOFoMj5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MzE1Nw==", "bodyText": "I think it would also be worth adding a comment about why the -1 is okay.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693157", "createdAt": "2020-02-11T15:07:15Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjY0MzcwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowODoyNFrOFoMm_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODo0NzoyMFrOFol60w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ==", "bodyText": "Nodes running 4.1 or earlier won't send this, so we need to add some BWC handling here.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693949", "createdAt": "2020-02-11T15:08:24Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA4OTYwOQ==", "bodyText": "Actually the whole block is already covered in a  if (in.getVersion().onOrAfter(Version.V_4_2_0)) statement.  Maybe this was not obvious from the change log. \n  \n    \n      crate/sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java\n    \n    \n         Line 121\n      in\n      720b84a\n    \n    \n    \n    \n\n        \n          \n           if (in.getVersion().onOrAfter(Version.V_4_2_0)) {", "url": "https://github.com/crate/crate/pull/9624#discussion_r378089609", "createdAt": "2020-02-12T08:03:01Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwODYyNw==", "bodyText": "Ah right, didn't see this in the diff.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378108627", "createdAt": "2020-02-12T08:47:20Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjY0OTYxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowOTo0OFrOFoMqsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoxNjoxOFrOFoo2BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA==", "bodyText": "What is the difference between returnValues and outputs? Isn't it redundant to have both?", "url": "https://github.com/crate/crate/pull/9624#discussion_r377694898", "createdAt": "2020-02-11T15:09:48Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5MTA5OQ==", "bodyText": "They are not the same. outputs are the types of result e.g. long for rowcount, while returnValues are the expression of the returning clause evaluated against the document.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378091099", "createdAt": "2020-02-12T08:07:08Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwODM1Mg==", "bodyText": "But if returnValues are present, then the outputs must match. (Or at least have matching types).\nI think this needs at least some clarification via comments how they relate to each other. Or maybe utilize the outputs for both and have some flag that indicates if it is a result set or a single rowcount.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378108352", "createdAt": "2020-02-12T08:46:49Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1NjU0OQ==", "bodyText": "I just tried your suggestion to use the outputs and a flag indicating what is the purpose of the outputs and it clearly does not make the code simpler, because now i have to treat outputs in different ways depending on the purpose. For now I added a comment with the relationship between output and returnvalues and will give it a second thought also related to updates. If we do this change we should probably do it also for update related datastructures to be consistent.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378156549", "createdAt": "2020-02-12T10:16:18Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjY3NDMxOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/planner/consumer/InsertFromSubQueryPlannerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNToxNTozM1rOFoM5wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODowNzoyNVrOFok2ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5ODc1NA==", "bodyText": "Maybe limit this to only the one table that is used in the tests.\nWastes some CPU cycles and makes it more difficult to have an overview what schemas are in use in this file.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377698754", "createdAt": "2020-02-11T15:15:33Z", "author": {"login": "mfussenegger"}, "path": "sql/src/test/java/io/crate/planner/consumer/InsertFromSubQueryPlannerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.consumer;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import io.crate.analyze.TableDefinitions;\n+import io.crate.exceptions.UnsupportedFeatureException;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.PartitionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.SQLExecutor;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.singletonList;\n+\n+public class InsertFromSubQueryPlannerTest extends CrateDummyClusterServiceUnitTest {\n+\n+    private SQLExecutor e;\n+    private TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext();\n+\n+    @Before\n+    public void prepare() throws IOException {\n+        e = buildExecutor(clusterService);\n+    }\n+\n+    private static SQLExecutor buildExecutor(ClusterService clusterService) throws IOException {\n+        return SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom())\n+            .enableDefaultTables()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5MTIwMw==", "bodyText": "Good point, thank you!", "url": "https://github.com/crate/crate/pull/9624#discussion_r378091203", "createdAt": "2020-02-12T08:07:25Z", "author": {"login": "mkleen"}, "path": "sql/src/test/java/io/crate/planner/consumer/InsertFromSubQueryPlannerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.consumer;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import io.crate.analyze.TableDefinitions;\n+import io.crate.exceptions.UnsupportedFeatureException;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.PartitionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.SQLExecutor;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.singletonList;\n+\n+public class InsertFromSubQueryPlannerTest extends CrateDummyClusterServiceUnitTest {\n+\n+    private SQLExecutor e;\n+    private TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext();\n+\n+    @Before\n+    public void prepare() throws IOException {\n+        e = buildExecutor(clusterService);\n+    }\n+\n+    private static SQLExecutor buildExecutor(ClusterService clusterService) throws IOException {\n+        return SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom())\n+            .enableDefaultTables()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5ODc1NA=="}, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTIwMDgzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODoyMjo0N1rOFolOiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODo1Mzo1N1rOFomHZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzI4OQ==", "bodyText": "Checkstyle lambda oddity again, see comment before.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378097289", "createdAt": "2020-02-12T08:22:47Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,108 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based.\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(fetchedDoc.docId(),\n+                        fetchedDoc.getIndex(),\n+                        fetchedDoc.getId(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        indexResult.getTerm(),\n+                        source,\n+                    () -> \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a411e5152b95add7f9ea58590e5823e1fbf4f5d1"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExMTg0Nw==", "bodyText": "See my comment further above, if each arg is on a newline checkstyle passes.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378111847", "createdAt": "2020-02-12T08:53:57Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,108 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based.\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(fetchedDoc.docId(),\n+                        fetchedDoc.getIndex(),\n+                        fetchedDoc.getId(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        indexResult.getTerm(),\n+                        source,\n+                    () -> \"\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzI4OQ=="}, "originalCommit": {"oid": "a411e5152b95add7f9ea58590e5823e1fbf4f5d1"}, "originalPosition": 188}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1048, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}