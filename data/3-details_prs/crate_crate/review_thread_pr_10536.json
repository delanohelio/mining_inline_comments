{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MTkzODE5", "number": 10536, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDowM1rOEj8HNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDowM1rOEj8HNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTIwNTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDowM1rOHSlO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzowNjoxMlrOHSv5Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ==", "bodyText": "\ud83d\udc4d I think doing the free mem accounting not on every batch iterator was also some issue to come into play or?", "url": "https://github.com/crate/crate/pull/10536#discussion_r489246455", "createdAt": "2020-09-16T08:10:03Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MzM2OA==", "bodyText": "If I'm not mistaken apply is only called once per ShardingUpsertExecutor instance.\nThe main motivation for moving it is to reduce the window between retrieving the free memory from the circuit breaker and accounting for the memory.\nI'm actually wondering if the logic now may lead to too many circuit breaker exceptions. If it ends up using the free memory from the circuit breaker because it's lower than the limit * 0.30, then with concurrent operations it may be likely that accounting for the free bytes would trip the breaker.\nShould we extend the circuitBreaker and have some functionality that allows us to say \"I want to reserve X bytes, if that's not available, reserve as much as possible and tell me how much I can use\"?", "url": "https://github.com/crate/crate/pull/10536#discussion_r489253368", "createdAt": "2020-09-16T08:21:38Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ=="}, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5MTE3MA==", "bodyText": "I'm not sure if I get you right.\n\nShould we extend the circuitBreaker and have some functionality that allows us to say \"I want to reserve X bytes, if that's not available, reserve as much as possible and tell me how much I can use\"?\n\nIsn't this exactly what the code is doing by using the free available mem  (limit - used) if the desired one (limit * 0.3) is not available?\nAs the CircuitBreaker's accounting is protected against concurrent issues, how could concurrent operations get wrong free memory and thus result more frequently in breaker exceptions?", "url": "https://github.com/crate/crate/pull/10536#discussion_r489291170", "createdAt": "2020-09-16T09:19:17Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ=="}, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5NTQ4Nw==", "bodyText": "Getting the free memory via limit - used and then calling addEstimateBytesAndMaybeBreak is not atomic. In-between the amount of free memory can change. The circuitBreakers concurrency gurantee's are only for the individual calls.", "url": "https://github.com/crate/crate/pull/10536#discussion_r489295487", "createdAt": "2020-09-16T09:25:54Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ=="}, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5ODI2Mg==", "bodyText": "I ok now I got it, +1 for moving this into the circuit breaker to make that atomic. I understood this wrong as I interpreted it that the suggestion would result in a different logic.", "url": "https://github.com/crate/crate/pull/10536#discussion_r489298262", "createdAt": "2020-09-16T09:30:12Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ=="}, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyMTA5NA==", "bodyText": "@seut pushed a fixup to make it atomic.", "url": "https://github.com/crate/crate/pull/10536#discussion_r489421094", "createdAt": "2020-09-16T13:06:12Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/indexing/ShardingUpsertExecutor.java", "diffHunk": "@@ -252,6 +254,7 @@ private boolean shouldPauseOnPartitionCreation(ShardedRequests<ShardUpsertReques\n \n     @Override\n     public CompletableFuture<? extends Iterable<Row>> apply(BatchIterator<Row> batchIterator) {\n+        var isUsedBytesOverThreshold = new IsUsedBytesOverThreshold(queryCircuitBreaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjQ1NQ=="}, "originalCommit": {"oid": "211bfa0aab194e4b872c258ad4b5ac60f70580ce"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1010, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}