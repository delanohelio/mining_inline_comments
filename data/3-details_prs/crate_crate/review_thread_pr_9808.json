{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MjE0Nzc3", "number": 9808, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOToxNzo0MFrODr-4JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOToyMzowOFrODr-_-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDQ1NTQwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOToxNzo0MFrOF8o3cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTozNzo1MlrOF8pkxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEyODQzNA==", "bodyText": "I'd prefer using this style for improved readability, but maybe thats more a personal preference:\nList<FuncResolver> resolvers = implementations.computeIfAbsent(functionName, new ArrayList<>());\nresolvers.add(udfService.buildFunctionResolver(udf));", "url": "https://github.com/crate/crate/pull/9808#discussion_r399128434", "createdAt": "2020-03-27T09:17:40Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java", "diffHunk": "@@ -195,22 +199,49 @@ UserDefinedFunctionsMetaData removeFunction(@Nullable UserDefinedFunctionsMetaDa\n         }\n     }\n \n-    public void updateImplementations(String schema, Stream<UserDefinedFunctionMetaData> userDefinedFunctions) {\n-        functions.registerUdfResolversForSchema(schema, constructScalarInstances(userDefinedFunctions));\n-    }\n \n-    private Map<FunctionIdent, FunctionImplementation> constructScalarInstances(Stream<UserDefinedFunctionMetaData> functions) {\n-        Iterator<UserDefinedFunctionMetaData> it = functions.iterator();\n-        Map<FunctionIdent, FunctionImplementation> implementationsByIdent = new HashMap<>();\n+    public void updateImplementations(String schema, Stream<UserDefinedFunctionMetaData> userDefinedFunctions) {\n+        final Map<FunctionName, List<FuncResolver>> implementations = new HashMap<>();\n+        Iterator<UserDefinedFunctionMetaData> it = userDefinedFunctions.iterator();\n         while (it.hasNext()) {\n-            UserDefinedFunctionMetaData udfMetaData = it.next();\n-            try {\n-                Scalar scalar = getLanguage(udfMetaData.language()).createFunctionImplementation(udfMetaData);\n-                implementationsByIdent.put(scalar.info().ident(), scalar);\n-            } catch (ScriptException | IllegalArgumentException e) {\n-                LOGGER.warn(\"Can't create user defined function: \" + udfMetaData.specificName(), e);\n+            UserDefinedFunctionMetaData udf = it.next();\n+            FuncResolver resolver = buildFunctionResolver(udf);\n+            if (resolver == null) {\n+                continue;\n             }\n+            implementations.compute(\n+                new FunctionName(udf.schema(), udf.name()),\n+                (key, resolvers) -> {\n+                    if (resolvers == null) {\n+                        resolvers = new ArrayList<>();\n+                    }\n+                    resolvers.add(resolver);\n+                    return resolvers;\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15cc833f76342cac920b7e688cbd1cc84271bf98"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MDAzOQ==", "bodyText": "I did it intentionally, with the reasoning that the compute is an atomic operation, etc. but actually it makes no sense such as everything anyways happens in the local scope of the method UserDefinedFunctionService#updateImplementations. I am fine with updating it to your suggestion as well.", "url": "https://github.com/crate/crate/pull/9808#discussion_r399140039", "createdAt": "2020-03-27T09:37:52Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java", "diffHunk": "@@ -195,22 +199,49 @@ UserDefinedFunctionsMetaData removeFunction(@Nullable UserDefinedFunctionsMetaDa\n         }\n     }\n \n-    public void updateImplementations(String schema, Stream<UserDefinedFunctionMetaData> userDefinedFunctions) {\n-        functions.registerUdfResolversForSchema(schema, constructScalarInstances(userDefinedFunctions));\n-    }\n \n-    private Map<FunctionIdent, FunctionImplementation> constructScalarInstances(Stream<UserDefinedFunctionMetaData> functions) {\n-        Iterator<UserDefinedFunctionMetaData> it = functions.iterator();\n-        Map<FunctionIdent, FunctionImplementation> implementationsByIdent = new HashMap<>();\n+    public void updateImplementations(String schema, Stream<UserDefinedFunctionMetaData> userDefinedFunctions) {\n+        final Map<FunctionName, List<FuncResolver>> implementations = new HashMap<>();\n+        Iterator<UserDefinedFunctionMetaData> it = userDefinedFunctions.iterator();\n         while (it.hasNext()) {\n-            UserDefinedFunctionMetaData udfMetaData = it.next();\n-            try {\n-                Scalar scalar = getLanguage(udfMetaData.language()).createFunctionImplementation(udfMetaData);\n-                implementationsByIdent.put(scalar.info().ident(), scalar);\n-            } catch (ScriptException | IllegalArgumentException e) {\n-                LOGGER.warn(\"Can't create user defined function: \" + udfMetaData.specificName(), e);\n+            UserDefinedFunctionMetaData udf = it.next();\n+            FuncResolver resolver = buildFunctionResolver(udf);\n+            if (resolver == null) {\n+                continue;\n             }\n+            implementations.compute(\n+                new FunctionName(udf.schema(), udf.name()),\n+                (key, resolvers) -> {\n+                    if (resolvers == null) {\n+                        resolvers = new ArrayList<>();\n+                    }\n+                    resolvers.add(resolver);\n+                    return resolvers;\n+                });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEyODQzNA=="}, "originalCommit": {"oid": "15cc833f76342cac920b7e688cbd1cc84271bf98"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDQ3NTQ1OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/integrationtests/SQLTransportIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOToyMzowOFrOF8pDsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOToyMzowOFrOF8pDsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEzMTU3MA==", "bodyText": "I thinks this is fine, but a comment here would be helpful.", "url": "https://github.com/crate/crate/pull/9808#discussion_r399131570", "createdAt": "2020-03-27T09:23:08Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/integrationtests/SQLTransportIntegrationTest.java", "diffHunk": "@@ -610,7 +612,9 @@ public void assertFunctionIsDeletedOnAll(String schema, String name, List<DataTy\n             Iterable<Functions> functions = internalCluster().getInstances(Functions.class);\n             for (Functions function : functions) {\n                 FunctionImplementation func = function.getQualified(new FunctionIdent(schema, name, argTypes));\n-                assertThat(func, Matchers.nullValue());\n+                if (func != null) {\n+                    assertThat(func.info().ident().argumentTypes(), not(contains(argTypes)));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15cc833f76342cac920b7e688cbd1cc84271bf98"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1552, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}