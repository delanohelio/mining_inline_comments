{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMjMyNzY2", "number": 10780, "title": "Ensure pg_proc.oid and pg_type.typreceive can be joined", "bodyText": "Summary of the changes / Why this improves CrateDB\nFixes a regression which led in npgsql to an error like this:\nThe CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\nPostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\nSELECT ns.nspname, typ_and_elem_type.*,\n  CASE\n      WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n      WHEN typtype = 'r' THEN 1                        -- Ranges after\n      WHEN typtype = 'c' THEN 2                        -- Composites after\n      WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n      WHEN typtype = 'a' THEN 4                        -- Arrays before\n      WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n    END AS ord\nFROM (\n    -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n    -- We first do this for the type (innerest-most subquery), and then for its element type\n    -- This also returns the array element, range subtype and domain base type as elemtypoid\n    SELECT\n        typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n        elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n        CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n    FROM (\n        SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n            CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n            CASE\n                WHEN proc.proname='array_recv' THEN typ.typelem\n                WHEN typ.typtype='r' THEN rngsubtype\n                WHEN typ.typtype='d' THEN typ.typbasetype\n            END AS elemtypoid\n        FROM pg_type AS typ\n        LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n        LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n        LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n    ) AS typ\n    LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n    LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n    LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n) AS typ_and_elem_type\nJOIN pg_namespace AS ns ON (ns.oid = typnamespace)\nWHERE\n    typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n    (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n    (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n    (typtype = 'a' AND (  -- Array of...\n        elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n        (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n        (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n    ))\nORDER BY ord;\n\nThe join LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive didn't\nmatch anymore after ae507cc because the\nfunction to generate the oid for pg_proc was changed without changing\nthe corresponding pg_type related entries.\nFixes #10776\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-11-18T14:40:04Z", "url": "https://github.com/crate/crate/pull/10780", "merged": true, "mergeCommit": {"oid": "cb6246bcf4f471585a332a9af37aa0a10bc28b8c"}, "closed": true, "closedAt": "2020-11-19T09:58:29Z", "author": {"login": "mfussenegger"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddvaetAFqTUzMzUyODA1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdd-qxIABqjQwMTQ2MTQ4NDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTI4MDUz", "url": "https://github.com/crate/crate/pull/10780#pullrequestreview-533528053", "createdAt": "2020-11-18T14:55:31Z", "commit": {"oid": "edc5bf6f4071659a5adfc539311c1c21be101baf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTI4MTYw", "url": "https://github.com/crate/crate/pull/10780#pullrequestreview-533528160", "createdAt": "2020-11-18T14:55:37Z", "commit": {"oid": "edc5bf6f4071659a5adfc539311c1c21be101baf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1NTozN1rOH1xr9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1NTozN1rOH1xr9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE1MDY0Ng==", "bodyText": "the signatures return types are now all undefined, is it because they are not used?", "url": "https://github.com/crate/crate/pull/10780#discussion_r526150646", "createdAt": "2020-11-18T14:55:37Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/collect/sources/InformationSchemaIterables.java", "diffHunk": "@@ -167,34 +166,16 @@ public InformationSchemaIterables(final Schemas schemas,\n             Stream.concat(\n                 sequentialStream(PGTypes.pgTypes())\n                     .filter(t -> t.typArray() != 0)\n-                    .map(InformationSchemaIterables::typeToSignature)\n+                    .map(x -> x.typReceive().asDummySignature())\n                     .map(PgProcTable.Entry::of),\n \n                 // Don't generate array_recv entry from pgTypes to avoid duplicate entries\n                 // (We want 1 array_recv entry, not one per array type)\n-                Stream.of(\n-                    PgProcTable.Entry.of(\n-                        Signature.scalar(\n-                            \"array_recv\",\n-                            DataTypes.INTEGER.getTypeSignature(),\n-                            new ArrayType<>(DataTypes.UNDEFINED).getTypeSignature()\n-                        )\n-                    )\n-                )\n+                Stream.of(PgProcTable.Entry.of(Regproc.of(\"array_recv\").asDummySignature()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc5bf6f4071659a5adfc539311c1c21be101baf"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTI4Mjc0", "url": "https://github.com/crate/crate/pull/10780#pullrequestreview-533528274", "createdAt": "2020-11-18T14:55:43Z", "commit": {"oid": "edc5bf6f4071659a5adfc539311c1c21be101baf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "committedDate": "2020-11-19T08:41:43Z", "message": "Ensure pg_proc.oid and pg_type.typreceive can be joined\n\nFixes a regression which led in npgsql to an error like this:\n\n    The CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\n    PostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\n\n    SELECT ns.nspname, typ_and_elem_type.*,\n      CASE\n          WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n          WHEN typtype = 'r' THEN 1                        -- Ranges after\n          WHEN typtype = 'c' THEN 2                        -- Composites after\n          WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n          WHEN typtype = 'a' THEN 4                        -- Arrays before\n          WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n        END AS ord\n    FROM (\n        -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n        -- We first do this for the type (innerest-most subquery), and then for its element type\n        -- This also returns the array element, range subtype and domain base type as elemtypoid\n        SELECT\n            typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n            elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n            CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n        FROM (\n            SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n                CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n                CASE\n                    WHEN proc.proname='array_recv' THEN typ.typelem\n                    WHEN typ.typtype='r' THEN rngsubtype\n                    WHEN typ.typtype='d' THEN typ.typbasetype\n                END AS elemtypoid\n            FROM pg_type AS typ\n            LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n            LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n            LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n        ) AS typ\n        LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n        LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n        LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n    ) AS typ_and_elem_type\n    JOIN pg_namespace AS ns ON (ns.oid = typnamespace)\n    WHERE\n        typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n        (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n        (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n        (typtype = 'a' AND (  -- Array of...\n            elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n            (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n            (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n        ))\n    ORDER BY ord;\n\nThe join `LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive` didn't\nmatch anymore after ae507cc46432064a019e3dc56b5a44d402d1d3b8 because the\nfunction to generate the oid for `pg_proc` was changed without changing\nthe corresponding `pg_type` related entries."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edc5bf6f4071659a5adfc539311c1c21be101baf", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/edc5bf6f4071659a5adfc539311c1c21be101baf", "committedDate": "2020-11-18T14:37:28Z", "message": "Ensure pg_proc.oid and pg_type.typreceive can be joined\n\nFixes a regression which led in npgsql to an error like this:\n\n    The CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\n    PostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\n\n    SELECT ns.nspname, typ_and_elem_type.*,\n      CASE\n          WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n          WHEN typtype = 'r' THEN 1                        -- Ranges after\n          WHEN typtype = 'c' THEN 2                        -- Composites after\n          WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n          WHEN typtype = 'a' THEN 4                        -- Arrays before\n          WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n        END AS ord\n    FROM (\n        -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n        -- We first do this for the type (innerest-most subquery), and then for its element type\n        -- This also returns the array element, range subtype and domain base type as elemtypoid\n        SELECT\n            typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n            elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n            CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n        FROM (\n            SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n                CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n                CASE\n                    WHEN proc.proname='array_recv' THEN typ.typelem\n                    WHEN typ.typtype='r' THEN rngsubtype\n                    WHEN typ.typtype='d' THEN typ.typbasetype\n                END AS elemtypoid\n            FROM pg_type AS typ\n            LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n            LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n            LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n        ) AS typ\n        LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n        LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n        LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n    ) AS typ_and_elem_type\n    JOIN pg_namespace AS ns ON (ns.oid = typnamespace)\n    WHERE\n        typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n        (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n        (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n        (typtype = 'a' AND (  -- Array of...\n            elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n            (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n            (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n        ))\n    ORDER BY ord;\n\nThe join `LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive` didn't\nmatch anymore after ae507cc46432064a019e3dc56b5a44d402d1d3b8 because the\nfunction to generate the oid for `pg_proc` was changed without changing\nthe corresponding `pg_type` related entries."}, "afterCommit": {"oid": "05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "committedDate": "2020-11-19T08:41:43Z", "message": "Ensure pg_proc.oid and pg_type.typreceive can be joined\n\nFixes a regression which led in npgsql to an error like this:\n\n    The CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\n    PostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\n\n    SELECT ns.nspname, typ_and_elem_type.*,\n      CASE\n          WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n          WHEN typtype = 'r' THEN 1                        -- Ranges after\n          WHEN typtype = 'c' THEN 2                        -- Composites after\n          WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n          WHEN typtype = 'a' THEN 4                        -- Arrays before\n          WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n        END AS ord\n    FROM (\n        -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n        -- We first do this for the type (innerest-most subquery), and then for its element type\n        -- This also returns the array element, range subtype and domain base type as elemtypoid\n        SELECT\n            typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n            elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n            CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n        FROM (\n            SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n                CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n                CASE\n                    WHEN proc.proname='array_recv' THEN typ.typelem\n                    WHEN typ.typtype='r' THEN rngsubtype\n                    WHEN typ.typtype='d' THEN typ.typbasetype\n                END AS elemtypoid\n            FROM pg_type AS typ\n            LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n            LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n            LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n        ) AS typ\n        LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n        LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n        LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n    ) AS typ_and_elem_type\n    JOIN pg_namespace AS ns ON (ns.oid = typnamespace)\n    WHERE\n        typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n        (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n        (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n        (typtype = 'a' AND (  -- Array of...\n            elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n            (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n            (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n        ))\n    ORDER BY ord;\n\nThe join `LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive` didn't\nmatch anymore after ae507cc46432064a019e3dc56b5a44d402d1d3b8 because the\nfunction to generate the oid for `pg_proc` was changed without changing\nthe corresponding `pg_type` related entries."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3644, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}