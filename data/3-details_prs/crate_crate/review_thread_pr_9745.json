{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NzQwMTMx", "number": 9745, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDoxNTowMlrODmUJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTo1ODozMFrODmvsjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTAyNjE5OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDoxNTowMlrOFzqXUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwOTowMTo0MFrOF0GKaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw==", "bodyText": "Would it be possible to define a class that extends DefaultTraversalSymbolVisitor in oder to visit all symbols from window function, such as we have exactly the same login in visitWindowFunction?", "url": "https://github.com/crate/crate/pull/9745#discussion_r389715793", "createdAt": "2020-03-09T14:15:02Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "diffHunk": "@@ -102,6 +104,43 @@ private WindowAgg(LogicalPlan source, WindowDefinition windowDefinition, List<Wi\n         this.standalone = standalone;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n+        toKeep.removeAll(windowFunctions);\n+        List<Symbol> newStandalone = List.copyOf(toKeep);\n+        for (WindowFunction windowFunction : windowFunctions) {\n+            toKeep.addAll(windowFunction.arguments());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1NzI4MQ==", "bodyText": "I think I now see a common pattern between the different operators.  Will try to extract some common logic to contain most of the complexity", "url": "https://github.com/crate/crate/pull/9745#discussion_r389757281", "createdAt": "2020-03-09T15:14:53Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "diffHunk": "@@ -102,6 +104,43 @@ private WindowAgg(LogicalPlan source, WindowDefinition windowDefinition, List<Wi\n         this.standalone = standalone;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n+        toKeep.removeAll(windowFunctions);\n+        List<Symbol> newStandalone = List.copyOf(toKeep);\n+        for (WindowFunction windowFunction : windowFunctions) {\n+            toKeep.addAll(windowFunction.arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMjc3NA==", "bodyText": "@kovrus pushed a fixup. Please let me know what you think.", "url": "https://github.com/crate/crate/pull/9745#discussion_r389812774", "createdAt": "2020-03-09T16:36:58Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "diffHunk": "@@ -102,6 +104,43 @@ private WindowAgg(LogicalPlan source, WindowDefinition windowDefinition, List<Wi\n         this.standalone = standalone;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n+        toKeep.removeAll(windowFunctions);\n+        List<Symbol> newStandalone = List.copyOf(toKeep);\n+        for (WindowFunction windowFunction : windowFunctions) {\n+            toKeep.addAll(windowFunction.arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE3MTI0MA==", "bodyText": "looks good \ud83d\udc4d", "url": "https://github.com/crate/crate/pull/9745#discussion_r390171240", "createdAt": "2020-03-10T09:01:40Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "diffHunk": "@@ -102,6 +104,43 @@ private WindowAgg(LogicalPlan source, WindowDefinition windowDefinition, List<Wi\n         this.standalone = standalone;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n+        toKeep.removeAll(windowFunctions);\n+        List<Symbol> newStandalone = List.copyOf(toKeep);\n+        for (WindowFunction windowFunction : windowFunctions) {\n+            toKeep.addAll(windowFunction.arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTE2Mzg4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDo0NTozNlrOFzrp5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo0ODozNFrOFzuUmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjkzMg==", "bodyText": "can you elaborate a bit here? if we use a ScopedSymbol instead of a subscript function, we basically do not need the logic in the loop bellow? how can a subscript function be mapped to scoped symbol?", "url": "https://github.com/crate/crate/pull/9745#discussion_r389736932", "createdAt": "2020-03-09T14:45:36Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "diffHunk": "@@ -80,6 +84,58 @@ public RelationName name() {\n         return outputs;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        ArrayList<Symbol> mappedToKeep = new ArrayList<>();\n+        /* outputsToKeep may be scalars on top of the Rename result or subscripts\n+         * Eval: x > 1, obj['x']\n+         *  \u2514 Rename[x, obj]\n+         *      \u2514 Collect [x, obj]\n+         *\n+         * TODO: `obj['x']` can be a ScopedSymbol instead of a subscript function. Can we change that?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MDYzMw==", "bodyText": "Yeah the comment is a bit vague because even if it is a subscript function it will be wrapped in a ScopedSymbol. The point is more about whether the path component of the ColumnIdent is used vs. having a real Function. In the latter case the FieldsVisitor approach would be enough and the getRoot() part further below wouldn't be necessary.\nI'll adapt the comment or figure out a better solution.", "url": "https://github.com/crate/crate/pull/9745#discussion_r389780633", "createdAt": "2020-03-09T15:48:34Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "diffHunk": "@@ -80,6 +84,58 @@ public RelationName name() {\n         return outputs;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        ArrayList<Symbol> mappedToKeep = new ArrayList<>();\n+        /* outputsToKeep may be scalars on top of the Rename result or subscripts\n+         * Eval: x > 1, obj['x']\n+         *  \u2514 Rename[x, obj]\n+         *      \u2514 Collect [x, obj]\n+         *\n+         * TODO: `obj['x']` can be a ScopedSymbol instead of a subscript function. Can we change that?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjkzMg=="}, "originalCommit": {"oid": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODM0Mzk2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDo1NjozNlrOF0KC_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDo1NjozNlrOF0KC_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzNDg3Ng==", "bodyText": "I'm not too happy about having to resort to identity here, but I don't really have a better idea.", "url": "https://github.com/crate/crate/pull/9745#discussion_r390234876", "createdAt": "2020-03-10T10:56:36Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "diffHunk": "@@ -80,6 +84,41 @@ public RelationName name() {\n         return outputs;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        /* In `SELECT * FROM (SELECT t1.*, t2.* FROM tbl AS t1, tbl AS t2) AS tjoin`\n+         * The `ScopedSymbol`s are ambiguous; To map them correctly this uses a IdentityHashMap\n+         */\n+        IdentityHashMap<Symbol, Symbol> parentToChildMap = new IdentityHashMap<>(outputs.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTM0MzU3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/symbol/SymbolVisitors.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNToxNzoyMlrOF0Trfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNToxOToyMVrOF0Txiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5MjcwMw==", "bodyText": "minor: was wondering whether it is really necessary to create an instance of IntersectionVisitor on each intersection method invocation and whether it makes sense to reuse a visitor context to pass haystack and needle (but it is probably the same coz the context has to be created..)?", "url": "https://github.com/crate/crate/pull/9745#discussion_r390392703", "createdAt": "2020-03-10T15:17:22Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/symbol/SymbolVisitors.java", "diffHunk": "@@ -42,6 +48,127 @@ public static boolean any(Predicate<? super Symbol> symbolPredicate, Symbol symb\n         return symbol.accept(ANY_VISITOR, symbolPredicate);\n     }\n \n+    /**\n+     * Calls the given `consumer` for all intersection points between `needle` and `haystack`.\n+     * For example, in:\n+     * <pre>\n+     *     needle: x > 20 AND y = 2\n+     *     haystack: [x, y = 2]\n+     * </pre>\n+     *\n+     * The `consumer` would be called for `x` and for `y = 2`\n+     */\n+    public static <T> void intersection(Symbol needle, Collection<T> haystack, Consumer<T> consumer) {\n+        needle.accept(new IntersectionVisitor<>(haystack, consumer), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NDI1MQ==", "bodyText": "but it is probably the same coz the context has to be created..\n\nYes, that was my reason for going for a visitor instance directly - to avoid having to introduce a context class.", "url": "https://github.com/crate/crate/pull/9745#discussion_r390394251", "createdAt": "2020-03-10T15:19:21Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/symbol/SymbolVisitors.java", "diffHunk": "@@ -42,6 +48,127 @@ public static boolean any(Predicate<? super Symbol> symbolPredicate, Symbol symb\n         return symbol.accept(ANY_VISITOR, symbolPredicate);\n     }\n \n+    /**\n+     * Calls the given `consumer` for all intersection points between `needle` and `haystack`.\n+     * For example, in:\n+     * <pre>\n+     *     needle: x > 20 AND y = 2\n+     *     haystack: [x, y = 2]\n+     * </pre>\n+     *\n+     * The `consumer` would be called for `x` and for `y = 2`\n+     */\n+    public static <T> void intersection(Symbol needle, Collection<T> haystack, Consumer<T> consumer) {\n+        needle.accept(new IntersectionVisitor<>(haystack, consumer), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5MjcwMw=="}, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTUwMzEyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTo1MDo0N1rOF0VPLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjoyODo1NFrOF0W7_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQxODIyMw==", "bodyText": "Why is this required? Or why not at AnalyzedView?", "url": "https://github.com/crate/crate/pull/9745#discussion_r390418223", "createdAt": "2020-03-10T15:50:47Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java", "diffHunk": "@@ -101,7 +108,7 @@ public RelationName relationName() {\n     @Nonnull\n     @Override\n     public List<Symbol> outputs() {\n-        return outputs;\n+        return List.copyOf(outputs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0NjA3OQ==", "bodyText": "It was required for an intermediate version I had. Reverted it now.", "url": "https://github.com/crate/crate/pull/9745#discussion_r390446079", "createdAt": "2020-03-10T16:28:54Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java", "diffHunk": "@@ -101,7 +108,7 @@ public RelationName relationName() {\n     @Nonnull\n     @Override\n     public List<Symbol> outputs() {\n-        return outputs;\n+        return List.copyOf(outputs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQxODIyMw=="}, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTUzOTM0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTo1ODozMFrOF0VmHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjoyODozMFrOF0W66w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyNDA5NQ==", "bodyText": "maybe worth adding the \"why\"", "url": "https://github.com/crate/crate/pull/9745#discussion_r390424095", "createdAt": "2020-03-10T15:58:30Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -112,6 +114,39 @@ default boolean preferShardProjections() {\n \n     LogicalPlan replaceSources(List<LogicalPlan> sources);\n \n+    /**\n+     * Request an operator to return a new version of itself with all outputs removed except the ones contained in `outputsToKeep`.\n+     * <p>\n+     *  Note that `outputsToKeep` can contain scalars on top of the outputs that the \"current\" operator outputs.\n+     *  This doesn't mean that the operator has to pull-down the scalar as well, but it means it has to provide all outputs\n+     *  that are required by the parent.\n+     *  Using {@link io.crate.expression.symbol.SymbolVisitors#intersection(Symbol, Collection, Consumer)} is an option\n+     *  To find the outputs required by the parent.\n+     * </p>\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     A: [substr(x, 0, 3), y]\n+     *     \u2514 B [x, y, z]              // Should provide `x` and `y` after the prune call.\n+     * </pre>\n+     *\n+     * <p>\n+     *   This must propagate down the tree:\n+     * </p>\n+     * <pre>\n+     *      root       A call to `root.pruneOutputsExcept(..)` must result in calls on all: A, B and C\n+     *       / \\\n+     *     A   C\n+     *     |\n+     *     B\n+     * </pre>\n+     * <p>\n+     *  If there are no outputs to prune and if the source also didn't change, `this` must be returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0NTgwMw==", "bodyText": "Extended it to explain why", "url": "https://github.com/crate/crate/pull/9745#discussion_r390445803", "createdAt": "2020-03-10T16:28:30Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -112,6 +114,39 @@ default boolean preferShardProjections() {\n \n     LogicalPlan replaceSources(List<LogicalPlan> sources);\n \n+    /**\n+     * Request an operator to return a new version of itself with all outputs removed except the ones contained in `outputsToKeep`.\n+     * <p>\n+     *  Note that `outputsToKeep` can contain scalars on top of the outputs that the \"current\" operator outputs.\n+     *  This doesn't mean that the operator has to pull-down the scalar as well, but it means it has to provide all outputs\n+     *  that are required by the parent.\n+     *  Using {@link io.crate.expression.symbol.SymbolVisitors#intersection(Symbol, Collection, Consumer)} is an option\n+     *  To find the outputs required by the parent.\n+     * </p>\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     A: [substr(x, 0, 3), y]\n+     *     \u2514 B [x, y, z]              // Should provide `x` and `y` after the prune call.\n+     * </pre>\n+     *\n+     * <p>\n+     *   This must propagate down the tree:\n+     * </p>\n+     * <pre>\n+     *      root       A call to `root.pruneOutputsExcept(..)` must result in calls on all: A, B and C\n+     *       / \\\n+     *     A   C\n+     *     |\n+     *     B\n+     * </pre>\n+     * <p>\n+     *  If there are no outputs to prune and if the source also didn't change, `this` must be returned.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyNDA5NQ=="}, "originalCommit": {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1634, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}