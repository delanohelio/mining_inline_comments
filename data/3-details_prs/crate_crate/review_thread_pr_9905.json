{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNjkxMDk3", "number": 9905, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoxNjoyMFrOD3nxHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoxOToyNVrOD3n2Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjQ5ODIyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/predicate/PredicateModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoxNjoyMFrOGN-RyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoyODozM1rOGN-y6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwNTAzMg==", "bodyText": "I extended the PredicateModule from AbstractFunctionModule or there was a reason why it wasn't done like that before?", "url": "https://github.com/crate/crate/pull/9905#discussion_r417305032", "createdAt": "2020-04-29T13:16:20Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/predicate/PredicateModule.java", "diffHunk": "@@ -21,34 +21,13 @@\n \n package io.crate.expression.predicate;\n \n-import io.crate.metadata.FunctionIdent;\n+import io.crate.expression.AbstractFunctionModule;\n import io.crate.metadata.FunctionImplementation;\n-import io.crate.metadata.FunctionName;\n-import io.crate.metadata.FunctionResolver;\n-import org.elasticsearch.common.inject.AbstractModule;\n-import org.elasticsearch.common.inject.multibindings.MapBinder;\n \n-public class PredicateModule extends AbstractModule {\n-\n-    private MapBinder<FunctionIdent, FunctionImplementation> functionBinder;\n-    private MapBinder<FunctionName, FunctionResolver> resolverBinder;\n-\n-    public void register(FunctionImplementation impl) {\n-        functionBinder.addBinding(impl.info().ident()).toInstance(impl);\n-    }\n-\n-    public void register(String name, FunctionResolver functionResolver) {\n-        register(new FunctionName(name), functionResolver);\n-    }\n-\n-    public void register(FunctionName qualifiedName, FunctionResolver functionResolver) {\n-        resolverBinder.addBinding(qualifiedName).toInstance(functionResolver);\n-    }\n+public class PredicateModule extends AbstractFunctionModule<FunctionImplementation> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3432a37bb95d238594cd7bc3e324759eaa0f8e9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMxMzUxNQ==", "bodyText": "I don't see any reasons why this was not extended. Maybe just never refactored...", "url": "https://github.com/crate/crate/pull/9905#discussion_r417313515", "createdAt": "2020-04-29T13:28:33Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/predicate/PredicateModule.java", "diffHunk": "@@ -21,34 +21,13 @@\n \n package io.crate.expression.predicate;\n \n-import io.crate.metadata.FunctionIdent;\n+import io.crate.expression.AbstractFunctionModule;\n import io.crate.metadata.FunctionImplementation;\n-import io.crate.metadata.FunctionName;\n-import io.crate.metadata.FunctionResolver;\n-import org.elasticsearch.common.inject.AbstractModule;\n-import org.elasticsearch.common.inject.multibindings.MapBinder;\n \n-public class PredicateModule extends AbstractModule {\n-\n-    private MapBinder<FunctionIdent, FunctionImplementation> functionBinder;\n-    private MapBinder<FunctionName, FunctionResolver> resolverBinder;\n-\n-    public void register(FunctionImplementation impl) {\n-        functionBinder.addBinding(impl.info().ident()).toInstance(impl);\n-    }\n-\n-    public void register(String name, FunctionResolver functionResolver) {\n-        register(new FunctionName(name), functionResolver);\n-    }\n-\n-    public void register(FunctionName qualifiedName, FunctionResolver functionResolver) {\n-        resolverBinder.addBinding(qualifiedName).toInstance(functionResolver);\n-    }\n+public class PredicateModule extends AbstractFunctionModule<FunctionImplementation> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwNTAzMg=="}, "originalCommit": {"oid": "e3432a37bb95d238594cd7bc3e324759eaa0f8e9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjUxMTAzOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/analyze/EvaluatingNormalizerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoxOToyNVrOGN-ZvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzoxOToyNVrOGN-ZvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwNzA2OQ==", "bodyText": "I had to adjust these tests for the operators as well and I went with an simpler approach. Just use this for functions with signatures:\n    private FunctionInfo functionInfo(Signature signature, DataType dataType) {\n        return functions.getQualified(signature, List.of(dataType, dataType)).info();\n    }", "url": "https://github.com/crate/crate/pull/9905#discussion_r417307069", "createdAt": "2020-04-29T13:19:25Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/analyze/EvaluatingNormalizerTest.java", "diffHunk": "@@ -123,17 +130,25 @@ public void testEvaluationClusterGranularity() {\n         assertThat(query, instanceOf(Function.class));\n     }\n \n-    private FunctionInfo functionInfo(String name, DataType dataType, boolean isPredicate) {\n-        ImmutableList<DataType> dataTypes;\n+    private FunctionInfo functionInfo(String name, DataType<?> dataType, boolean isPredicate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3432a37bb95d238594cd7bc3e324759eaa0f8e9"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1446, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}