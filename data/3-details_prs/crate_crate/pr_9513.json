{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDU0ODAx", "number": 9513, "title": "Add missing object casts in the insert from subquery cast projection ", "bodyText": "Summary of the changes / Why this improves CrateDB\nChanges signature of internal to_<data type> cast functions by extending the argument list with\nthe desired return type of the function which actually fixes the issue with the creation of the correct\nEvalProjection (cast projection) of the insert from subqueries plan.\nRelated #9528 #9522\nChecklist\n\n User relevant changes are recorded in CHANGES.txt\n Touched code is covered by tests\n Documentation has been updated if necessary\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-01-15T10:07:44Z", "url": "https://github.com/crate/crate/pull/9513", "merged": true, "mergeCommit": {"oid": "c641bed0932abbd814b95fc4dfaa26172d768b7a"}, "closed": true, "closedAt": "2020-01-21T11:21:00Z", "author": {"login": "kovrus"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6ivvJgBqjI5NTAyMTU0ODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8etBngBqjI5NjU2NzY5MzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95c720f790d518f781acf83c970b4c05cfc1a787", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/95c720f790d518f781acf83c970b4c05cfc1a787", "committedDate": "2020-01-15T10:07:22Z", "message": "Add missing to object castis in the insert from suqquery cast projection."}, "afterCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/3248dc69a003c1d363798533e7a286ca5997ea31", "committedDate": "2020-01-15T10:10:04Z", "message": "Add missing object casts in insert from suqquery cast projection."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTE1MjI1", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-343115225", "createdAt": "2020-01-15T10:19:02Z", "commit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxOTowMlrOFdzcIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxOTowMlrOFdzcIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ==", "bodyText": "Added this condition just for now, so we always generated cast to object... Do you think we have to have a proper equal and isConvertible for object types, by proper i mean taking into account inner types and considering cases with different fields, undefined types, etc. I am not sure how straightforward that can be, coz isConvertible depends on equals now, but that would be now the way to go for object types and we would need to have a special handling for it. Probably, we have to do that anyways, just want to get some input on it.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366795809", "createdAt": "2020-01-15T10:19:02Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTkxOTg1", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-343191985", "createdAt": "2020-01-15T12:45:00Z", "commit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0NTowMFrOFd3Fxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0OTowNVrOFd3MSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg==", "bodyText": "Would it make sense to always encode the return type into the cast function and generally remove the notion of having per type cast function names?\nSo that we don't have to treat object casts in a special way.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366855622", "createdAt": "2020-01-15T12:45:00Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NzI5MA==", "bodyText": "Can you elaborate on the isConvertible relationship to equals?\nI think we should override equals on ObjectType to take inner-types into consideration.", "url": "https://github.com/crate/crate/pull/9513#discussion_r366857290", "createdAt": "2020-01-15T12:49:05Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ=="}, "originalCommit": {"oid": "3248dc69a003c1d363798533e7a286ca5997ea31"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a96cd621cef8977275df5e4dcbf8cac15729351", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/4a96cd621cef8977275df5e4dcbf8cac15729351", "committedDate": "2020-01-15T14:42:31Z", "message": "fixup! Register a dedicated cast function for object types."}, "afterCommit": {"oid": "4d7dcc32ff86e7668a2821a5250379546d45e288", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/4d7dcc32ff86e7668a2821a5250379546d45e288", "committedDate": "2020-01-15T14:45:05Z", "message": "fixup! Register a dedicated cast function for object types."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d7dcc32ff86e7668a2821a5250379546d45e288", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/4d7dcc32ff86e7668a2821a5250379546d45e288", "committedDate": "2020-01-15T14:45:05Z", "message": "fixup! Register a dedicated cast function for object types."}, "afterCommit": {"oid": "f3ed6e3f814933b6f87605ace2efacbfa995977c", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f3ed6e3f814933b6f87605ace2efacbfa995977c", "committedDate": "2020-01-20T09:46:20Z", "message": "Add missing object casts in insert from suqquery cast projection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a01d11d050409da2d37eb985ab6daa4b6152ee9", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/9a01d11d050409da2d37eb985ab6daa4b6152ee9", "committedDate": "2020-01-20T15:47:46Z", "message": "Merge CastFunction and TryCastFunction classes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3ed6e3f814933b6f87605ace2efacbfa995977c", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f3ed6e3f814933b6f87605ace2efacbfa995977c", "committedDate": "2020-01-20T09:46:20Z", "message": "Add missing object casts in insert from suqquery cast projection."}, "afterCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/666827543d2cf6a488899832a91fe16d312e0b19", "committedDate": "2020-01-20T15:57:26Z", "message": "Add test for insert from subquery/values into the same partition."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDM1Mzg4", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-345435388", "createdAt": "2020-01-20T16:50:56Z", "commit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MDo1N1rOFfkYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNjo1MTo0M1rOFfkZrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0NjIxMQ==", "bodyText": "can you wrap this item to 79 chars? you can break apart literal blocks if they have spaces in them no problem", "url": "https://github.com/crate/crate/pull/9513#discussion_r368646211", "createdAt": "2020-01-20T16:50:57Z", "author": {"login": "norosa"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -57,6 +57,13 @@ None\n Fixes\n =====\n \n+- Fixed a bug that would lead to insertion of records via", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0NjU3Mw==", "bodyText": "can you add an empty line above this to start the new para. also wrap to 79 chars by breaking after timestamp if it fits", "url": "https://github.com/crate/crate/pull/9513#discussion_r368646573", "createdAt": "2020-01-20T16:51:43Z", "author": {"login": "norosa"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -57,6 +57,13 @@ None\n Fixes\n =====\n \n+- Fixed a bug that would lead to insertion of records via\n+  ``INSERT INTO ... (SELECT ... FROM ..)`` and\n+  ``INSERT INTO ... VALUES (...)``  into different partitions while using\n+  the same partition by value.\n+  This occurs only when the partition key is an object field of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19"}, "originalPosition": 8}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "666827543d2cf6a488899832a91fe16d312e0b19", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/666827543d2cf6a488899832a91fe16d312e0b19", "committedDate": "2020-01-20T15:57:26Z", "message": "Add test for insert from subquery/values into the same partition."}, "afterCommit": {"oid": "f95392fd33cd050d580f6920b50662d9f1bf2526", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f95392fd33cd050d580f6920b50662d9f1bf2526", "committedDate": "2020-01-20T22:12:42Z", "message": "Add test for insert from subquery/values into the same partition."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f95392fd33cd050d580f6920b50662d9f1bf2526", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f95392fd33cd050d580f6920b50662d9f1bf2526", "committedDate": "2020-01-20T22:12:42Z", "message": "Add test for insert from subquery/values into the same partition."}, "afterCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/cb399038aa6078b97df005d5a705d7af0ffac963", "committedDate": "2020-01-20T22:30:34Z", "message": "Add test for insert from subquery/values into the same partition."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Njk4MTcw", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-345698170", "createdAt": "2020-01-21T08:25:02Z", "commit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNTowM1rOFfxkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNToyNVrOFfxkrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjIyMg==", "bodyText": "isn't it always 1 or 2 arguments?", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862222", "createdAt": "2020-01-21T08:25:03Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjM4Mw==", "bodyText": "Same here, I think this should be limited to 1 or 2 arguments", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862383", "createdAt": "2020-01-21T08:25:25Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzE2MzIx", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-345716321", "createdAt": "2020-01-21T08:59:17Z", "commit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1OToxN1rOFfycUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1OToxN1rOFfycUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ==", "bodyText": "Do we still need the CAST_SIGNATURES in the current form? I thought we're going to remove the to_<typeName> notation. Or is it still required for BWC?", "url": "https://github.com/crate/crate/pull/9513#discussion_r368876625", "createdAt": "2020-01-21T08:59:17Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n+            this.name = name;\n         }\n \n         @Override\n         public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n-            checkPreconditions(dataTypes);\n-            return new CastFunction(new FunctionInfo(new FunctionIdent(name, dataTypes), targetType));\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n         }\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        for (Map.Entry<String, DataType> function : CastFunctionResolver.CAST_SIGNATURES.entrySet()) {\n-            module.register(function.getKey(), new Resolver(function.getValue(), function.getKey()));\n+        for (Map.Entry<String, DataType> function : CAST_SIGNATURES.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963"}, "originalPosition": 178}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a87af4cd49c9d7fde967f875d30c65e6d3c6ec0e", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/a87af4cd49c9d7fde967f875d30c65e6d3c6ec0e", "committedDate": "2020-01-21T09:32:38Z", "message": "fixup! Pass the return type info as a second argument of cast functions."}, "afterCommit": {"oid": "4459e5196875cf00672efe86729c136119ce634d", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/4459e5196875cf00672efe86729c136119ce634d", "committedDate": "2020-01-21T09:34:25Z", "message": "fixup! Pass the return type info as a second argument of cast functions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4459e5196875cf00672efe86729c136119ce634d", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/4459e5196875cf00672efe86729c136119ce634d", "committedDate": "2020-01-21T09:34:25Z", "message": "fixup! Pass the return type info as a second argument of cast functions."}, "afterCommit": {"oid": "5a242fadab4d74a5b5cce957778f311c8ee050ce", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/5a242fadab4d74a5b5cce957778f311c8ee050ce", "committedDate": "2020-01-21T09:39:30Z", "message": "fixup! Pass the return type info as a second argument of cast functions."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzQ5MDA5", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-345749009", "createdAt": "2020-01-21T09:51:58Z", "commit": {"oid": "5a242fadab4d74a5b5cce957778f311c8ee050ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzUzMjY0", "url": "https://github.com/crate/crate/pull/9513#pullrequestreview-345753264", "createdAt": "2020-01-21T09:58:09Z", "commit": {"oid": "5a242fadab4d74a5b5cce957778f311c8ee050ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7a528e3d774fbd11d2b1fa9a7ae9ce9356df8b0", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/d7a528e3d774fbd11d2b1fa9a7ae9ce9356df8b0", "committedDate": "2020-01-21T10:36:33Z", "message": "Pass the return type info as a second argument of cast functions.\n\nCurrently, it is not possible to resolve a function based on\nits return type. For instance, it won't be possible to generated\nan object cast function with the return type which inner types\nhave to be considered. Therefore, to bypass this limitation we\nencode the return type info as a second argument of a cast function\nand resolve the return type based on it."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f04eceada1129575042cba85f72d18169df0ee4a", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f04eceada1129575042cba85f72d18169df0ee4a", "committedDate": "2020-01-21T10:36:34Z", "message": "Add test for insert from subquery/values into the same partition."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a242fadab4d74a5b5cce957778f311c8ee050ce", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/5a242fadab4d74a5b5cce957778f311c8ee050ce", "committedDate": "2020-01-21T09:39:30Z", "message": "fixup! Pass the return type info as a second argument of cast functions."}, "afterCommit": {"oid": "f04eceada1129575042cba85f72d18169df0ee4a", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f04eceada1129575042cba85f72d18169df0ee4a", "committedDate": "2020-01-21T10:36:34Z", "message": "Add test for insert from subquery/values into the same partition."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3909, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}