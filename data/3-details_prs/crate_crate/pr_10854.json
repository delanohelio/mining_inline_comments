{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODQ3MDMx", "number": 10854, "title": "Add the numeric data type and numeric sum aggregation. ", "bodyText": "Summary of the changes / Why this improves CrateDB\nThis PR introduces the CrateDB numeric data type (backed by BigDecimal) and adds\nthe support for the sum aggregation on the numeric type. This change does not change the\nsemantic of the existing sum aggregation functions, e.g. sum(long_column) will still overflow\nif the sum exceeds the range of long. This change enables a mechanism to handle the overflow\nby casting the column to a numeric type with optional precision or/and scale parameters,\ne.g. sum(long_column::numeric) .\nRelated to #7373\nFollow-ups:\n\nNumericSumAggregation.DoubleSum and NumericSumAggregation.FloatSum apply a similar pattern\nas in NumericSumAggregation.LongSum, so the doc values aggregator sum optimization operates on primitives and once the overflow is detected it starts to use BigDecimal. Maybe combine it with Kahan sum.\nMaybe add avg aggregation with the numeric type?\n\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-12-07T17:58:06Z", "url": "https://github.com/crate/crate/pull/10854", "merged": true, "mergeCommit": {"oid": "34dec2401a1aad6ba9bfa108a5691ce8b4c141f0"}, "closed": true, "closedAt": "2021-01-11T12:01:06Z", "author": {"login": "kovrus"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkIRp7ABqjQwODQyNzE2MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvEzZTABqjQxOTAzMDM3MDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25bfeb77ff59a6797e9cd9d5b31931bcc9c95251", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/25bfeb77ff59a6797e9cd9d5b31931bcc9c95251", "committedDate": "2020-12-07T17:56:43Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}, "afterCommit": {"oid": "d75f842a0489e90c744dd2efd07483da3b00de5f", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/d75f842a0489e90c744dd2efd07483da3b00de5f", "committedDate": "2020-12-08T11:16:48Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d75f842a0489e90c744dd2efd07483da3b00de5f", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/d75f842a0489e90c744dd2efd07483da3b00de5f", "committedDate": "2020-12-08T11:16:48Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}, "afterCommit": {"oid": "aacd0285dc2245fe4e013997e631cdcf9c86d029", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/aacd0285dc2245fe4e013997e631cdcf9c86d029", "committedDate": "2020-12-08T14:20:10Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aacd0285dc2245fe4e013997e631cdcf9c86d029", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/aacd0285dc2245fe4e013997e631cdcf9c86d029", "committedDate": "2020-12-08T14:20:10Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}, "afterCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "committedDate": "2020-12-08T14:54:01Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Mzc0NDM3", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-547374437", "createdAt": "2020-12-08T15:56:52Z", "commit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1Njo1M1rOIBlV7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjoyMDowNlrOIBm9ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA==", "bodyText": "doesn't this fail if input is a InputColumn symbol?\nI also don't completely get why the changes in this class are related/needed...", "url": "https://github.com/crate/crate/pull/10854#discussion_r538531308", "createdAt": "2020-12-08T15:56:53Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesAggregates.java", "diffHunk": "@@ -134,20 +134,51 @@\n \n     @Nullable\n     private static MappedFieldType resolveInputToFieldType(FieldTypeLookup fieldTypeLookup,\n-                                                           List<Symbol> toCollect,\n                                                            Symbol input) {\n-        if (!(input instanceof InputColumn)) {\n+        MappedFieldType mappedFieldType = fieldTypeLookup.get(((Reference) input).column().fqn());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MDExNQ==", "bodyText": "why not calling .setScale on the original value?", "url": "https://github.com/crate/crate/pull/10854#discussion_r538540115", "createdAt": "2020-12-08T16:04:39Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MTYxNw==", "bodyText": "why is the intermediate BigInteger used here instead of passing the string directly?", "url": "https://github.com/crate/crate/pull/10854#discussion_r538541617", "createdAt": "2020-12-08T16:06:01Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String) {\n+            return new BigDecimal(\n+                new BigInteger((String) value),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1NjM5Mg==", "bodyText": "couldn't this be folded into the String branch?", "url": "https://github.com/crate/crate/pull/10854#discussion_r538556392", "createdAt": "2020-12-08T16:18:46Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String) {\n+            return new BigDecimal(\n+                new BigInteger((String) value),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Long\n+                   || value instanceof Byte\n+                   || value instanceof Integer\n+                   || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Float || value instanceof Double) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1NzgzNA==", "bodyText": "just adding 1L once should be enough and keeps this simpler", "url": "https://github.com/crate/crate/pull/10854#discussion_r538557834", "createdAt": "2020-12-08T16:20:06Z", "author": {"login": "seut"}, "path": "server/src/test/java/io/crate/execution/engine/aggregation/impl/OverflowAwareMutableLongTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertThat;\n+\n+public class OverflowAwareMutableLongTest {\n+\n+    @Test\n+    public void test_add_without_overflow_operates_on_primitive_long() {\n+        var value = new OverflowAwareMutableLong(5L);\n+        value.add(5L);\n+\n+        assertThat(value.hasValue(), is(true));\n+        assertThat(value.primitiveSum(), is(10L));\n+        assertThat(value.bigDecimalSum(), is(nullValue()));\n+        assertThat(value.value(), is(BigDecimal.TEN));\n+    }\n+\n+    @Test\n+    public void test_add_with_overflow_operates_on_big_decimal() {\n+        var value = new OverflowAwareMutableLong(Long.MAX_VALUE);\n+        value.add(5L);\n+        value.add(5L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTc0NTIy", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-548174522", "createdAt": "2020-12-09T13:21:06Z", "commit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzoyMTowNlrOICUQ_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzozNDo0NVrOICU2uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMDA5Mg==", "bodyText": "The length is internally calculated as\n        int byteLen = bitLength()/8 + 1;\n        byte[] byteArray = new byte[byteLen];\n\nCould we maybe use bitLength() / 8 + 1 directly? Creating the byteArray only to get the size seems overly expensive for the memory estimation.", "url": "https://github.com/crate/crate/pull/10854#discussion_r539300092", "createdAt": "2020-12-09T13:21:06Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/breaker/NumericSizeEstimator.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.breaker;\n+\n+import javax.annotation.Nullable;\n+import java.math.BigDecimal;\n+\n+public final class NumericSizeEstimator extends SizeEstimator<BigDecimal> {\n+\n+    public static final NumericSizeEstimator INSTANCE = new NumericSizeEstimator();\n+\n+    private NumericSizeEstimator() {\n+    }\n+\n+    @Override\n+    public long estimateSize(@Nullable BigDecimal value) {\n+        if (value == null) {\n+            return 8;\n+        }\n+        return value.unscaledValue().toByteArray().length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMTg1OA==", "bodyText": "Shouldn't the returnType default to numeric anyway because of the signature definition?\nNot sure I understand the reasoning here.\nIf we later on add supports for numeric type storage we shouldn't have to adjust aggregation functions.", "url": "https://github.com/crate/crate/pull/10854#discussion_r539301858", "createdAt": "2020-12-09T13:23:47Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMjYyNQ==", "bodyText": "See comment about avoiding toByteArray in the size estimator class", "url": "https://github.com/crate/crate/pull/10854#discussion_r539302625", "createdAt": "2020-12-09T13:24:47Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.\n+        var argumentType = boundSignature.getArgumentDataTypes().get(0);\n+        assert argumentType.id() == DataTypes.NUMERIC.id();\n+        //noinspection unchecked\n+        this.returnType = (DataType<BigDecimal>) argumentType;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BigDecimal newState(RamAccounting ramAccounting,\n+                               Version indexVersionCreated,\n+                               Version minNodeInCluster,\n+                               MemoryManager memoryManager) {\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal iterate(RamAccounting ramAccounting,\n+                              MemoryManager memoryManager,\n+                              BigDecimal state,\n+                              Input[] args) throws CircuitBreakingException {\n+        BigDecimal value = returnType.implicitCast(args[0].value());\n+        if (value != null) {\n+            if (state != null) {\n+                state = state.add(value);\n+            } else {\n+                state = value;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public BigDecimal reduce(RamAccounting ramAccounting,\n+                             BigDecimal state1,\n+                             BigDecimal state2) {\n+        if (state1 == null) {\n+            return state2;\n+        }\n+        if (state2 == null) {\n+            return state1;\n+        }\n+        return state1.add(state2);\n+    }\n+\n+    @Override\n+    public BigDecimal terminatePartial(RamAccounting ramAccounting, BigDecimal state) {\n+        if (state != null) {\n+            ramAccounting.addBytes(state.unscaledValue().toByteArray().length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMzU0Nw==", "bodyText": "Same here.\nI'm also not sure if partialResult is the right place for the accounting. partialResult is called at the end of the aggregation, long after the allocations and resizes already happened.\nI think doing this in initialState or as needed would be safer", "url": "https://github.com/crate/crate/pull/10854#discussion_r539303547", "createdAt": "2020-12-09T13:26:05Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.\n+        var argumentType = boundSignature.getArgumentDataTypes().get(0);\n+        assert argumentType.id() == DataTypes.NUMERIC.id();\n+        //noinspection unchecked\n+        this.returnType = (DataType<BigDecimal>) argumentType;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BigDecimal newState(RamAccounting ramAccounting,\n+                               Version indexVersionCreated,\n+                               Version minNodeInCluster,\n+                               MemoryManager memoryManager) {\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal iterate(RamAccounting ramAccounting,\n+                              MemoryManager memoryManager,\n+                              BigDecimal state,\n+                              Input[] args) throws CircuitBreakingException {\n+        BigDecimal value = returnType.implicitCast(args[0].value());\n+        if (value != null) {\n+            if (state != null) {\n+                state = state.add(value);\n+            } else {\n+                state = value;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public BigDecimal reduce(RamAccounting ramAccounting,\n+                             BigDecimal state1,\n+                             BigDecimal state2) {\n+        if (state1 == null) {\n+            return state2;\n+        }\n+        if (state2 == null) {\n+            return state1;\n+        }\n+        return state1.add(state2);\n+    }\n+\n+    @Override\n+    public BigDecimal terminatePartial(RamAccounting ramAccounting, BigDecimal state) {\n+        if (state != null) {\n+            ramAccounting.addBytes(state.unscaledValue().toByteArray().length);\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public DataType<?> partialType() {\n+        return returnType;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public boolean isRemovableCumulative() {\n+        return true;\n+    }\n+\n+    @Override\n+    public BigDecimal removeFromAggregatedState(RamAccounting ramAccounting,\n+                                                BigDecimal previousAggState,\n+                                                Input[] stateToRemove) {\n+        BigDecimal value = returnType.implicitCast(stateToRemove[0].value());\n+        if (value != null) {\n+            if (previousAggState != null) {\n+                return previousAggState.subtract(value);\n+            }\n+        }\n+        return previousAggState;\n+    }\n+\n+    @Override\n+    public DocValueAggregator<?> getDocValueAggregator(List<DataType<?>> argumentTypes,\n+                                                       List<MappedFieldType> fieldTypes) {\n+        return switch (argumentTypes.get(0).id()) {\n+            case ByteType.ID, ShortType.ID, IntegerType.ID, LongType.ID ->\n+                new SumLong(returnType, fieldTypes.get(0).name());\n+            case FloatType.ID -> new SumFloat(returnType, fieldTypes.get(0).name());\n+            case DoubleType.ID -> new SumDouble(returnType, fieldTypes.get(0).name());\n+            default -> null;\n+        };\n+    }\n+\n+    static class SumLong implements DocValueAggregator<OverflowAwareMutableLong> {\n+\n+        private final DataType<BigDecimal> returnType;\n+        private final String columnName;\n+        private SortedNumericDocValues values;\n+\n+        SumLong(DataType<BigDecimal> returnType, String columnName) {\n+            this.returnType = returnType;\n+            this.columnName = columnName;\n+        }\n+\n+        @Override\n+        public OverflowAwareMutableLong initialState(RamAccounting ramAccounting) {\n+            return new OverflowAwareMutableLong(0L);\n+        }\n+\n+        @Override\n+        public void loadDocValues(LeafReader reader) throws IOException {\n+            values = DocValues.getSortedNumeric(reader, columnName);\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting,\n+                          int doc,\n+                          OverflowAwareMutableLong state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                state.add(values.nextValue());\n+            }\n+        }\n+\n+        @Override\n+        public BigDecimal partialResult(RamAccounting ramAccounting,\n+                                        OverflowAwareMutableLong state) {\n+            if (state.hasValue()) {\n+                var partialResult = state.value();\n+                ramAccounting.addBytes(partialResult.unscaledValue().toByteArray().length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwNjM3Ng==", "bodyText": "Should we maybe add a test in crate-qa with asyncpg or so, to verify that this can be read? Or is this covered already somewhere?", "url": "https://github.com/crate/crate/pull/10854#discussion_r539306376", "createdAt": "2020-12-09T13:29:54Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/protocols/postgres/types/NumericType.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.nio.charset.StandardCharsets;\n+\n+class NumericType extends PGType<BigDecimal> {\n+\n+    static final int OID = 1700;\n+\n+    private static final int TYPE_LEN = -1;\n+    private static final int TYPE_MOD = -1;\n+\n+    public static final NumericType INSTANCE = new NumericType();\n+\n+    private NumericType() {\n+        super(OID, TYPE_LEN, TYPE_MOD, \"numeric\");\n+    }\n+\n+    @Override\n+    public int typArray() {\n+        return PGArray.NUMERIC_ARRAY.oid();\n+    }\n+\n+    @Override\n+    public String typeCategory() {\n+        return TypeCategory.NUMERIC.code();\n+    }\n+\n+    @Override\n+    public String type() {\n+        return Type.BASE.code();\n+    }\n+\n+    @Override\n+    public int writeAsBinary(ByteBuf buffer, @Nonnull BigDecimal value) {\n+        buffer.writeInt(TYPE_LEN);\n+\n+        buffer.writeInt(value.scale());\n+        buffer.writeInt(value.precision());\n+\n+        var unscaled = value.unscaledValue();\n+        byte[] bytes = unscaled.toByteArray();\n+        buffer.writeInt(bytes.length);\n+        buffer.writeBytes(bytes);\n+\n+        // unscaled (length) + unscaled (bytes) + precision and scale\n+        return INT32_BYTE_SIZE + bytes.length + INT32_BYTE_SIZE * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwOTc1Mg==", "bodyText": "There's  writeByteArray and readByteArray which could be used", "url": "https://github.com/crate/crate/pull/10854#discussion_r539309752", "createdAt": "2020-12-09T13:34:45Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Long\n+                   || value instanceof Byte\n+                   || value instanceof Integer\n+                   || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String\n+                   || value instanceof Float\n+                   || value instanceof Double) {\n+            return new BigDecimal(\n+                value.toString(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else {\n+            throw new ClassCastException(\"Can't cast '\" + value + \"' to \" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal sanitizeValue(Object value) {\n+        if (value == null) {\n+            return null;\n+        } else {\n+            return (BigDecimal) value;\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal valueForInsert(Object value) {\n+        throw new UnsupportedOperationException(\n+            getName() + \" type cannot be used in insert statements\");\n+    }\n+\n+    @VisibleForTesting\n+    Integer scale() {\n+        return scale;\n+    }\n+\n+    @VisibleForTesting\n+    Integer precision() {\n+        return precision;\n+    }\n+\n+    private MathContext mathContextOrDefault() {\n+        if (precision == null) {\n+            return MathContext.UNLIMITED;\n+        } else {\n+            return new MathContext(precision);\n+        }\n+    }\n+\n+    private int scaleOrDefault() {\n+        return Objects.requireNonNullElse(scale, 0);\n+    }\n+\n+    private boolean unscaled() {\n+        return precision == null;\n+    }\n+\n+    @Override\n+    public TypeSignature getTypeSignature() {\n+        if (unscaled()) {\n+            return super.getTypeSignature();\n+        } else {\n+            ArrayList<TypeSignature> parameters = new ArrayList<>();\n+            parameters.add(TypeSignature.of(precision));\n+            if (scale != null) {\n+                parameters.add(TypeSignature.of(scale));\n+            }\n+            return new TypeSignature(getName(), parameters);\n+        }\n+    }\n+\n+    @Override\n+    public List<DataType<?>> getTypeParameters() {\n+        if (unscaled()) {\n+            return List.of();\n+        } else {\n+            if (scale != null) {\n+                return List.of(DataTypes.INTEGER);\n+            } else {\n+                return List.of(DataTypes.INTEGER, DataTypes.INTEGER);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int compare(BigDecimal o1, BigDecimal o2) {\n+        return o1.compareTo(o2);\n+    }\n+\n+    @Override\n+    public BigDecimal readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            byte[] bytes = new byte[in.readVInt()];\n+            in.readBytes(bytes, 0, bytes.length);\n+            return new BigDecimal(\n+                new BigInteger(bytes),\n+                scaleOrDefault(),\n+                mathContextOrDefault()\n+            );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, BigDecimal v) throws IOException {\n+        if (v != null) {\n+            out.writeBoolean(true);\n+            var bytes = v.unscaledValue().toByteArray();\n+            out.writeVInt(bytes.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjA2MTkz", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-548206193", "createdAt": "2020-12-09T13:56:50Z", "commit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzo1Njo1MFrOICV3BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzo1Njo1MFrOICV3BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNjIxMg==", "bodyText": "Ah okay, now I get it.\nHow about something like this instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // usually the sum numeric aggregation function is going to be\n          \n          \n            \n                    // resolved after casting the sum parameter to the numeric type,\n          \n          \n            \n                    // e.g. sum(count::numeric(16, 2)). Having that, it\n          \n          \n            \n                    // is not possible to resolve the return type that will contain\n          \n          \n            \n                    // the precision and/or scale. Therefore, we infer the return\n          \n          \n            \n                    // type from the argument type.\n          \n          \n            \n                    // We want to preserve the scale and precision from the numeric argument type for the return type.\n          \n          \n            \n                    // So we use the incoming numeric type as return type instead of the return type from the signature  \n          \n          \n            \n                    // `sum(count::numeric(16, 2))` should return the type `numeric(16, 2)` not `numeric`", "url": "https://github.com/crate/crate/pull/10854#discussion_r539326212", "createdAt": "2020-12-09T13:56:50Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4Mjc1MjUy", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-548275252", "createdAt": "2020-12-09T15:03:54Z", "commit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNTowMzo1NFrOICZPAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNTowNTozMlrOICZUgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MTUwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the function argument to the :ref:` numeric type <numeric_type>` with an\n          \n          \n            \n            the function argument to the :ref:`numeric type <numeric_type>` with an", "url": "https://github.com/crate/crate/pull/10854#discussion_r539381504", "createdAt": "2020-12-09T15:03:54Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MjExMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The ``sum`` aggregation on the ``bigint`` column will result in the overflow\n          \n          \n            \n            The ``sum`` aggregation on the ``bigint`` column will result in an overflow", "url": "https://github.com/crate/crate/pull/10854#discussion_r539382112", "createdAt": "2020-12-09T15:04:37Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an\n+arbitrary precision.\n+\n+.. Hidden: create user visits table\n+\n+    cr> CREATE TABLE uservisits (id integer, count bigint)\n+    ... CLUSTERED INTO 1 SHARDS\n+    ... WITH (number_of_replicas = 0);\n+    CREATE OK, 1 row affected (... sec)\n+\n+.. Hidden: insert into uservisits table\n+\n+    cr> INSERT INTO uservisits VALUES (1, 9223372036854775807), (2, 10);\n+    INSERT OK, 2 rows affected  (... sec)\n+\n+.. Hidden: refresh uservisits table\n+\n+    cr> REFRESH TABLE uservisits;\n+    REFRESH OK, 1 row affected  (... sec)\n+\n+The ``sum`` aggregation on the ``bigint`` column will result in the overflow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MjkxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the aggregation column to the numeric data type::\n          \n          \n            \n            the aggregation column to the ``numeric`` data type::", "url": "https://github.com/crate/crate/pull/10854#discussion_r539382912", "createdAt": "2020-12-09T15:05:32Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an\n+arbitrary precision.\n+\n+.. Hidden: create user visits table\n+\n+    cr> CREATE TABLE uservisits (id integer, count bigint)\n+    ... CLUSTERED INTO 1 SHARDS\n+    ... WITH (number_of_replicas = 0);\n+    CREATE OK, 1 row affected (... sec)\n+\n+.. Hidden: insert into uservisits table\n+\n+    cr> INSERT INTO uservisits VALUES (1, 9223372036854775807), (2, 10);\n+    INSERT OK, 2 rows affected  (... sec)\n+\n+.. Hidden: refresh uservisits table\n+\n+    cr> REFRESH TABLE uservisits;\n+    REFRESH OK, 1 row affected  (... sec)\n+\n+The ``sum`` aggregation on the ``bigint`` column will result in the overflow\n+in the following aggregation query::\n+\n+    cr> SELECT sum(count)\n+    ... FROM uservisits;\n+    ArithmeticException[long overflow]\n+\n+To address the overflow of the sum aggregation on the given field, we cast\n+the aggregation column to the numeric data type::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "072c4a111d75fbe8137c751074c4e2aa3a164c8e", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/072c4a111d75fbe8137c751074c4e2aa3a164c8e", "committedDate": "2020-12-09T13:35:42Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}, "afterCommit": {"oid": "c26c0b4d93e038e911989955161863f8acb1d52f", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/c26c0b4d93e038e911989955161863f8acb1d52f", "committedDate": "2020-12-10T15:14:38Z", "message": "fixup! Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTc4MTE1", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-549978115", "createdAt": "2020-12-11T10:30:22Z", "commit": {"oid": "c26c0b4d93e038e911989955161863f8acb1d52f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozMDoyMlrOIDys5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozNDo1NVrOIDy4Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzMzNA==", "bodyText": "This will just account for the internal bits needed for the integers of the BigInteger. I think we should account all other fields of BigDecimal + BigInteger as well (see https://www.javamex.com/tutorials/memory/object_memory_usage.shtml + https://stackoverflow.com/questions/2501176/java-bigdecimal-memory-usage).", "url": "https://github.com/crate/crate/pull/10854#discussion_r540847334", "createdAt": "2020-12-11T10:30:22Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof Long\n+            || value instanceof Byte\n+            || value instanceof Integer\n+            || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String\n+                   || value instanceof Float\n+                   || value instanceof Double\n+                   || value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                value.toString(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else {\n+            throw new ClassCastException(\"Can't cast '\" + value + \"' to \" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal sanitizeValue(Object value) {\n+        if (value == null) {\n+            return null;\n+        } else {\n+            return (BigDecimal) value;\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal valueForInsert(Object value) {\n+        throw new UnsupportedOperationException(\n+            getName() + \" type cannot be used in insert statements\");\n+    }\n+\n+    public static long size(@Nonnull BigDecimal value) {\n+        return value.unscaledValue().bitLength() / 8 + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c26c0b4d93e038e911989955161863f8acb1d52f"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MDIxOA==", "bodyText": "Yes I think its important to account that at earliest as possible, meaning accounting for the min size at initialState and adjusting it on iterate.", "url": "https://github.com/crate/crate/pull/10854#discussion_r540850218", "createdAt": "2020-12-11T10:34:55Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.\n+        var argumentType = boundSignature.getArgumentDataTypes().get(0);\n+        assert argumentType.id() == DataTypes.NUMERIC.id();\n+        //noinspection unchecked\n+        this.returnType = (DataType<BigDecimal>) argumentType;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BigDecimal newState(RamAccounting ramAccounting,\n+                               Version indexVersionCreated,\n+                               Version minNodeInCluster,\n+                               MemoryManager memoryManager) {\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal iterate(RamAccounting ramAccounting,\n+                              MemoryManager memoryManager,\n+                              BigDecimal state,\n+                              Input[] args) throws CircuitBreakingException {\n+        BigDecimal value = returnType.implicitCast(args[0].value());\n+        if (value != null) {\n+            if (state != null) {\n+                state = state.add(value);\n+            } else {\n+                state = value;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public BigDecimal reduce(RamAccounting ramAccounting,\n+                             BigDecimal state1,\n+                             BigDecimal state2) {\n+        if (state1 == null) {\n+            return state2;\n+        }\n+        if (state2 == null) {\n+            return state1;\n+        }\n+        return state1.add(state2);\n+    }\n+\n+    @Override\n+    public BigDecimal terminatePartial(RamAccounting ramAccounting, BigDecimal state) {\n+        if (state != null) {\n+            ramAccounting.addBytes(state.unscaledValue().toByteArray().length);\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public DataType<?> partialType() {\n+        return returnType;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public boolean isRemovableCumulative() {\n+        return true;\n+    }\n+\n+    @Override\n+    public BigDecimal removeFromAggregatedState(RamAccounting ramAccounting,\n+                                                BigDecimal previousAggState,\n+                                                Input[] stateToRemove) {\n+        BigDecimal value = returnType.implicitCast(stateToRemove[0].value());\n+        if (value != null) {\n+            if (previousAggState != null) {\n+                return previousAggState.subtract(value);\n+            }\n+        }\n+        return previousAggState;\n+    }\n+\n+    @Override\n+    public DocValueAggregator<?> getDocValueAggregator(List<DataType<?>> argumentTypes,\n+                                                       List<MappedFieldType> fieldTypes) {\n+        return switch (argumentTypes.get(0).id()) {\n+            case ByteType.ID, ShortType.ID, IntegerType.ID, LongType.ID ->\n+                new SumLong(returnType, fieldTypes.get(0).name());\n+            case FloatType.ID -> new SumFloat(returnType, fieldTypes.get(0).name());\n+            case DoubleType.ID -> new SumDouble(returnType, fieldTypes.get(0).name());\n+            default -> null;\n+        };\n+    }\n+\n+    static class SumLong implements DocValueAggregator<OverflowAwareMutableLong> {\n+\n+        private final DataType<BigDecimal> returnType;\n+        private final String columnName;\n+        private SortedNumericDocValues values;\n+\n+        SumLong(DataType<BigDecimal> returnType, String columnName) {\n+            this.returnType = returnType;\n+            this.columnName = columnName;\n+        }\n+\n+        @Override\n+        public OverflowAwareMutableLong initialState(RamAccounting ramAccounting) {\n+            return new OverflowAwareMutableLong(0L);\n+        }\n+\n+        @Override\n+        public void loadDocValues(LeafReader reader) throws IOException {\n+            values = DocValues.getSortedNumeric(reader, columnName);\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting,\n+                          int doc,\n+                          OverflowAwareMutableLong state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                state.add(values.nextValue());\n+            }\n+        }\n+\n+        @Override\n+        public BigDecimal partialResult(RamAccounting ramAccounting,\n+                                        OverflowAwareMutableLong state) {\n+            if (state.hasValue()) {\n+                var partialResult = state.value();\n+                ramAccounting.addBytes(partialResult.unscaledValue().toByteArray().length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMzU0Nw=="}, "originalCommit": {"oid": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04"}, "originalPosition": 212}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTkwMjk0", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-549990294", "createdAt": "2020-12-11T10:47:16Z", "commit": {"oid": "c26c0b4d93e038e911989955161863f8acb1d52f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d7dada19676319c2ca5c61ac1be33ed13234864", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/0d7dada19676319c2ca5c61ac1be33ed13234864", "committedDate": "2020-12-11T12:25:23Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}, "afterCommit": {"oid": "6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "committedDate": "2020-12-11T12:27:29Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTA3NTM3", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-550107537", "createdAt": "2020-12-11T13:43:27Z", "commit": {"oid": "6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTA4NTMy", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-550108532", "createdAt": "2020-12-11T13:44:49Z", "commit": {"oid": "6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "committedDate": "2020-12-11T12:27:29Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}, "afterCommit": {"oid": "eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "committedDate": "2020-12-11T13:55:54Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "committedDate": "2020-12-11T13:55:54Z", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation."}, "afterCommit": {"oid": "70dad6d72492480a5aa500009d602fdb302d0473", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/70dad6d72492480a5aa500009d602fdb302d0473", "committedDate": "2020-12-11T14:35:47Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwOTYxMDA1", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-550961005", "createdAt": "2020-12-13T21:15:41Z", "commit": {"oid": "70dad6d72492480a5aa500009d602fdb302d0473"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMToxNTo0MVrOIE5frw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMToxNTo0MVrOIE5frw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNzIxNQ==", "bodyText": "@seut I couldn't finish this part on time, so such as I am not here, I am handling it over to you :(\nI've been trying to come up with some solution that would reflect the numeric_send method   https://github.com/postgres/postgres/blob/7538708394e7a70105a4e601e253adf80f47cca8/src/backend/utils/adt/numeric.c#L1030-L1049 but couldn't make it work (testing with asyncgpg). I've been writing num digits, weight, sign, scale and each digit as short (int16), but it seems that it is more complicated than that, see  https://github.com/cockroachdb/cockroach/blob/c2b4fff9ce4a0b80f74dd39a5e45eccd15c1b933/pkg/sql/pgwire/pgwirebase/encoding.go#L600-L637 and https://github.com/cockroachdb/cockroach/blob/c2b4fff9ce4a0b80f74dd39a5e45eccd15c1b933/pkg/sql/pgwire/pgwirebase/encoding.go#L550-L662", "url": "https://github.com/crate/crate/pull/10854#discussion_r542007215", "createdAt": "2020-12-13T21:15:41Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/protocols/postgres/types/NumericType.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.nio.charset.StandardCharsets;\n+\n+class NumericType extends PGType<BigDecimal> {\n+\n+    static final int OID = 1700;\n+\n+    private static final int TYPE_LEN = -1;\n+    private static final int TYPE_MOD = -1;\n+\n+    public static final NumericType INSTANCE = new NumericType();\n+\n+    private NumericType() {\n+        super(OID, TYPE_LEN, TYPE_MOD, \"numeric\");\n+    }\n+\n+    @Override\n+    public int typArray() {\n+        return PGArray.NUMERIC_ARRAY.oid();\n+    }\n+\n+    @Override\n+    public String typeCategory() {\n+        return TypeCategory.NUMERIC.code();\n+    }\n+\n+    @Override\n+    public String type() {\n+        return Type.BASE.code();\n+    }\n+\n+    @Override\n+    public int writeAsBinary(ByteBuf buffer, @Nonnull BigDecimal value) {\n+        buffer.writeInt(TYPE_LEN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70dad6d72492480a5aa500009d602fdb302d0473"}, "originalPosition": 63}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70dad6d72492480a5aa500009d602fdb302d0473", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/70dad6d72492480a5aa500009d602fdb302d0473", "committedDate": "2020-12-11T14:35:47Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}, "afterCommit": {"oid": "66fc34ef5193419148ec31e0667972a32b6cb558", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/66fc34ef5193419148ec31e0667972a32b6cb558", "committedDate": "2020-12-17T12:36:16Z", "message": "Add arithmetic support for numeric type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NjUwMzA3", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-554650307", "createdAt": "2020-12-17T14:23:58Z", "commit": {"oid": "72a75b2c20601d253664c3c9362d5ef3fabb9e0f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDoyMzo1OFrOIH3_BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDoyMzo1OFrOIH3_BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyODE5Ng==", "bodyText": "Thanks for your efforts. Can we also add testing some negative values here?", "url": "https://github.com/crate/crate/pull/10854#discussion_r545128196", "createdAt": "2020-12-17T14:23:58Z", "author": {"login": "amotl"}, "path": "server/src/test/java/io/crate/protocols/postgres/types/NumericTypeTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+public class NumericTypeTest extends BasePGTypeTest<BigDecimal> {\n+\n+    public NumericTypeTest() {\n+        super(NumericType.INSTANCE);\n+    }\n+\n+    @Test\n+    public void test_read_and_write_numeric_text_value() {\n+        var expected = new BigDecimal(\"12.123\", MathContext.DECIMAL64)\n+            .setScale(2, MathContext.DECIMAL64.getRoundingMode());\n+        ByteBuf buffer = Unpooled.buffer();\n+        try {\n+            //noinspection unchecked\n+            pgType.writeAsText(buffer, expected);\n+            var actual = pgType.readTextValue(buffer, buffer.readInt());\n+            assertThat(actual, is(expected));\n+            assertThat(actual.toString(), is(expected.toString()));\n+        } finally {\n+            buffer.release();\n+        }\n+    }\n+\n+    @Test\n+    public void test_read_and_write_numeric_binary_value() {\n+        ArrayList<BigDecimal> testNumbers = new ArrayList<>();\n+        testNumbers.add(new BigDecimal(\"00123\"));\n+        testNumbers.add(new BigDecimal(\"12345.1\"));\n+        testNumbers.add(new BigDecimal(\"12.123\").setScale(2, MathContext.DECIMAL64.getRoundingMode()));\n+        testNumbers.add(new BigDecimal(\"1234.0\"));\n+        testNumbers.add(new BigDecimal(\"1234.0000\").setScale(1, MathContext.DECIMAL64.getRoundingMode()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72a75b2c20601d253664c3c9362d5ef3fabb9e0f"}, "originalPosition": 64}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72a75b2c20601d253664c3c9362d5ef3fabb9e0f", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/72a75b2c20601d253664c3c9362d5ef3fabb9e0f", "committedDate": "2020-12-17T12:56:39Z", "message": "fixup! Fix pg numeric binary protocol support"}, "afterCommit": {"oid": "77b86e80465072ed48adbb486652a48c22c2783e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/77b86e80465072ed48adbb486652a48c22c2783e", "committedDate": "2020-12-17T20:24:33Z", "message": "Add arithmetic support for numeric type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "77b86e80465072ed48adbb486652a48c22c2783e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/77b86e80465072ed48adbb486652a48c22c2783e", "committedDate": "2020-12-17T20:24:33Z", "message": "Add arithmetic support for numeric type"}, "afterCommit": {"oid": "cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "committedDate": "2020-12-17T20:31:54Z", "message": "Add arithmetic support for numeric type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "committedDate": "2020-12-17T20:31:54Z", "message": "Add arithmetic support for numeric type"}, "afterCommit": {"oid": "87f9ab0ecdc27903db3b1aca73cea9e566adc9d1", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/87f9ab0ecdc27903db3b1aca73cea9e566adc9d1", "committedDate": "2020-12-17T21:06:49Z", "message": "fixup! Add precision and scale parameters to the numeric data type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07bf20ac1aeb0f7c0b9bc6e1b860ebc9464f9a1f", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/07bf20ac1aeb0f7c0b9bc6e1b860ebc9464f9a1f", "committedDate": "2021-01-08T10:51:24Z", "message": "Fix function matching based on numer of exact argument types\n\nThe function matching fallback logic to select the most specific\nfunction signature based on the numer of exact argument types wrongly\nused the bound signature instead of the declared one.\n\nThis also required some hardening on most subscript function signatures\nwhich were only working before by coincindence based on this mistake."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "634b3b3d8cd0d9cc8be54e7690b4fbd24d30e435", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/634b3b3d8cd0d9cc8be54e7690b4fbd24d30e435", "committedDate": "2021-01-08T10:51:24Z", "message": "Add the numeric data type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66a24fdaf4905176933064339191cfd60b888d9a", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/66a24fdaf4905176933064339191cfd60b888d9a", "committedDate": "2021-01-08T10:51:25Z", "message": "Add a size estimator for the numeric data type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31b6554c637475a8adf980dce1bd122f499152e1", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/31b6554c637475a8adf980dce1bd122f499152e1", "committedDate": "2021-01-08T10:51:25Z", "message": "Add the numeric type cast support for primitive numeric types."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4161073f71b083f36affc37630780d40e2b052e7", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/4161073f71b083f36affc37630780d40e2b052e7", "committedDate": "2020-12-17T21:15:43Z", "message": "fixup! Fix pg numeric binary protocol support"}, "afterCommit": {"oid": "ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "committedDate": "2021-01-08T10:51:26Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "committedDate": "2021-01-08T10:51:26Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown."}, "afterCommit": {"oid": "1f678a287799f481cb35f27e86712570d5f85693", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/1f678a287799f481cb35f27e86712570d5f85693", "committedDate": "2021-01-08T12:33:42Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjYzMDg3", "url": "https://github.com/crate/crate/pull/10854#pullrequestreview-565263087", "createdAt": "2021-01-11T11:19:43Z", "commit": {"oid": "1f678a287799f481cb35f27e86712570d5f85693"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a5f765da9d415ffb601f9b4d7d6840272fe82e2", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/6a5f765da9d415ffb601f9b4d7d6840272fe82e2", "committedDate": "2021-01-11T11:25:24Z", "message": "Add precision and scale parameters to the numeric data type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae0a1bfd074ce7a429cff95bf2e03bf94bbb8d28", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/ae0a1bfd074ce7a429cff95bf2e03bf94bbb8d28", "committedDate": "2021-01-11T11:25:28Z", "message": "Add the PG wire protocol support for the numeric data type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f0b23136a9c84e4bc36954e918ae459e9acd1b", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/05f0b23136a9c84e4bc36954e918ae459e9acd1b", "committedDate": "2021-01-11T11:26:55Z", "message": "Add support for the numeric data type in the sum aggregation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f25ea79196fed86a76426e03d84c84963c0dc02d", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/f25ea79196fed86a76426e03d84c84963c0dc02d", "committedDate": "2021-01-11T11:26:57Z", "message": "Add documentation for the numeric type and numeric sum aggreagtion."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d0c37063b118913ef9e0c5ecec08816e2f61715", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/8d0c37063b118913ef9e0c5ecec08816e2f61715", "committedDate": "2021-01-11T11:26:57Z", "message": "Fix pg numeric binary protocol support\n\nImplementation is validated locally by using a self-built version of\nPgJDBC master which includes binary support for numeric types.\nSee https://gist.github.com/seut/275e734c66b3f6b02d4e1cf9df5233ef,\nhttps://github.com/pgjdbc/pgjdbc/commit/c85b149d68c."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf7c13585f69eecdfe1d1c6c218fa5f0d780f6a3", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/bf7c13585f69eecdfe1d1c6c218fa5f0d780f6a3", "committedDate": "2021-01-11T11:26:57Z", "message": "Add arithmetic support for numeric type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ce43410da0ea5f78d08347ddb8180e5a016eabf", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/0ce43410da0ea5f78d08347ddb8180e5a016eabf", "committedDate": "2021-01-11T11:26:57Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range an exception must\nbe thrown."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f678a287799f481cb35f27e86712570d5f85693", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/1f678a287799f481cb35f27e86712570d5f85693", "committedDate": "2021-01-08T12:33:42Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown."}, "afterCommit": {"oid": "0ce43410da0ea5f78d08347ddb8180e5a016eabf", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/0ce43410da0ea5f78d08347ddb8180e5a016eabf", "committedDate": "2021-01-11T11:26:57Z", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range an exception must\nbe thrown."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3690, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}