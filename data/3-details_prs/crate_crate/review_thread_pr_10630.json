{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NDE4ODYw", "number": 10630, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMDoyMVrOEsmuQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyMjoxMVrOEsm9sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjA3MjM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMDoyMVrOHf8C2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMDoyMVrOHf8C2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1MTY3NA==", "bodyText": "Afaik this is only used as a Character\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final char NULL = '\\0';\n          \n          \n            \n                private static final Character NULL = '\\0';", "url": "https://github.com/crate/crate/pull/10630#discussion_r503251674", "createdAt": "2020-10-12T12:10:21Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();\n+    private static final char NULL = '\\0';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjA3NDc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMToxNFrOHf8EcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMToxNFrOHf8EcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1MjA4MQ==", "bodyText": "Don't think that this improve anything, I'd suggest to use DataTypes.STRING.getTypeSignature() directly below.", "url": "https://github.com/crate/crate/pull/10630#discussion_r503252081", "createdAt": "2020-10-12T12:11:14Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjA3NzA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMTo1N1rOHf8F5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxMTo1N1rOHf8F5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1MjQ1NQ==", "bodyText": "Looks like this should be private accessible only?", "url": "https://github.com/crate/crate/pull/10630#discussion_r503252455", "createdAt": "2020-10-12T12:11:57Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();\n+    private static final char NULL = '\\0';\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\"translate\", STRING, STRING, STRING, STRING),\n+            TranslateFunction::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final Map<Character, Character> tmap;\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature, Map<Character, Character> tmap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjA4OTU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxNTo1M1rOHf8NyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxNTo1M1rOHf8NyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1NDQ3Mg==", "bodyText": "Any reason to store this into a local var?", "url": "https://github.com/crate/crate/pull/10630#discussion_r503254472", "createdAt": "2020-10-12T12:15:53Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();\n+    private static final char NULL = '\\0';\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\"translate\", STRING, STRING, STRING, STRING),\n+            TranslateFunction::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final Map<Character, Character> tmap;\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature, Map<Character, Character> tmap) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.tmap = tmap;\n+    }\n+\n+    @Override\n+    public Scalar<String, String> compile(List<Symbol> args) {\n+        assert args.size() == 3 : \"translate takes exactly three arguments\";\n+\n+        Symbol from = args.get(1);\n+        if (!Literal.isLiteral(from, DataTypes.STRING)) {\n+            return this;\n+        }\n+        Symbol to = args.get(2);\n+        if (!Literal.isLiteral(to, DataTypes.STRING)) {\n+            return this;\n+        }\n+        String fromStr = ((Input<String>) from).value();\n+        String toStr = ((Input<String>) to).value();\n+        return new TranslateFunction(signature, boundSignature, computeMap(fromStr, toStr));\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<String>[] args) {\n+        assert args.length == 3 : \"translate takes exactly three arguments\";\n+        String source = args[0].value();\n+        String from = args[1].value();\n+        String to = args[2].value();\n+        if (source == null || from == null || to == null) {\n+            return null;\n+        }\n+        if (source.length() == 0 || from.length() == 0) {\n+            return source;\n+        }\n+        Map<Character, Character> tmap = this.tmap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjA5ODQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxODozMFrOHf8S4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxODozMFrOHf8S4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1NTc3OQ==", "bodyText": "this would avoid an additional by-key lookup which slightly improves on larger source text input according to my local benchmarks:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (tmap.containsKey(c)) {\n          \n          \n            \n                            char mc = tmap.get(c);\n          \n          \n            \n                            if (mc != NULL) {\n          \n          \n            \n                                result[resultCount++] = mc;\n          \n          \n            \n                            }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result[resultCount++] = c;\n          \n          \n            \n                        }\n          \n          \n            \n                        var mc = tmap.get(c);\n          \n          \n            \n                        if (mc == null) {\n          \n          \n            \n                            result[resultCount++] = c;\n          \n          \n            \n                        } else if (mc != NULL) {\n          \n          \n            \n                            result[resultCount++] = mc;\n          \n          \n            \n                        }", "url": "https://github.com/crate/crate/pull/10630#discussion_r503255779", "createdAt": "2020-10-12T12:18:30Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();\n+    private static final char NULL = '\\0';\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\"translate\", STRING, STRING, STRING, STRING),\n+            TranslateFunction::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final Map<Character, Character> tmap;\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature, Map<Character, Character> tmap) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.tmap = tmap;\n+    }\n+\n+    @Override\n+    public Scalar<String, String> compile(List<Symbol> args) {\n+        assert args.size() == 3 : \"translate takes exactly three arguments\";\n+\n+        Symbol from = args.get(1);\n+        if (!Literal.isLiteral(from, DataTypes.STRING)) {\n+            return this;\n+        }\n+        Symbol to = args.get(2);\n+        if (!Literal.isLiteral(to, DataTypes.STRING)) {\n+            return this;\n+        }\n+        String fromStr = ((Input<String>) from).value();\n+        String toStr = ((Input<String>) to).value();\n+        return new TranslateFunction(signature, boundSignature, computeMap(fromStr, toStr));\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<String>[] args) {\n+        assert args.length == 3 : \"translate takes exactly three arguments\";\n+        String source = args[0].value();\n+        String from = args[1].value();\n+        String to = args[2].value();\n+        if (source == null || from == null || to == null) {\n+            return null;\n+        }\n+        if (source.length() == 0 || from.length() == 0) {\n+            return source;\n+        }\n+        Map<Character, Character> tmap = this.tmap;\n+        if (tmap == null) {\n+            tmap = computeMap(from, to);\n+        }\n+        return translate(tmap, source);\n+    }\n+\n+    private static String translate(Map<Character, Character> tmap, String source) {\n+        int sourceLen = source.length();\n+        char[] result = new char[sourceLen];\n+        int resultCount = 0;\n+        for (int i = 0; i < sourceLen; i++) {\n+            char c = source.charAt(i);\n+            if (tmap.containsKey(c)) {\n+                char mc = tmap.get(c);\n+                if (mc != NULL) {\n+                    result[resultCount++] = mc;\n+                }\n+            } else {\n+                result[resultCount++] = c;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjEwNDE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyMDowMlrOHf8WNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyMDowMlrOHf8WNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1NjYzMQ==", "bodyText": "avoids boxing\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            char mc = NULL;\n          \n          \n            \n                            var mc = NULL;", "url": "https://github.com/crate/crate/pull/10630#discussion_r503256631", "createdAt": "2020-10-12T12:20:02Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/scalar/string/TranslateFunction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TranslateFunction extends Scalar<String, String> {\n+\n+    private static final TypeSignature STRING = DataTypes.STRING.getTypeSignature();\n+    private static final char NULL = '\\0';\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\"translate\", STRING, STRING, STRING, STRING),\n+            TranslateFunction::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final Map<Character, Character> tmap;\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    public TranslateFunction(Signature signature, Signature boundSignature, Map<Character, Character> tmap) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.tmap = tmap;\n+    }\n+\n+    @Override\n+    public Scalar<String, String> compile(List<Symbol> args) {\n+        assert args.size() == 3 : \"translate takes exactly three arguments\";\n+\n+        Symbol from = args.get(1);\n+        if (!Literal.isLiteral(from, DataTypes.STRING)) {\n+            return this;\n+        }\n+        Symbol to = args.get(2);\n+        if (!Literal.isLiteral(to, DataTypes.STRING)) {\n+            return this;\n+        }\n+        String fromStr = ((Input<String>) from).value();\n+        String toStr = ((Input<String>) to).value();\n+        return new TranslateFunction(signature, boundSignature, computeMap(fromStr, toStr));\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<String>[] args) {\n+        assert args.length == 3 : \"translate takes exactly three arguments\";\n+        String source = args[0].value();\n+        String from = args[1].value();\n+        String to = args[2].value();\n+        if (source == null || from == null || to == null) {\n+            return null;\n+        }\n+        if (source.length() == 0 || from.length() == 0) {\n+            return source;\n+        }\n+        Map<Character, Character> tmap = this.tmap;\n+        if (tmap == null) {\n+            tmap = computeMap(from, to);\n+        }\n+        return translate(tmap, source);\n+    }\n+\n+    private static String translate(Map<Character, Character> tmap, String source) {\n+        int sourceLen = source.length();\n+        char[] result = new char[sourceLen];\n+        int resultCount = 0;\n+        for (int i = 0; i < sourceLen; i++) {\n+            char c = source.charAt(i);\n+            if (tmap.containsKey(c)) {\n+                char mc = tmap.get(c);\n+                if (mc != NULL) {\n+                    result[resultCount++] = mc;\n+                }\n+            } else {\n+                result[resultCount++] = c;\n+            }\n+        }\n+        return String.valueOf(result, 0, resultCount);\n+    }\n+\n+    private static Map<Character, Character> computeMap(String from, String to) {\n+        Map<Character, Character> tmap = new HashMap<>();\n+        for (int i = 0; i < from.length(); i++) {\n+            char c = from.charAt(i);\n+            if (!tmap.containsKey(c)) {\n+                char mc = NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MjExMTg1OnYy", "diffSide": "RIGHT", "path": "benchmarks/src/test/java/io/crate/execution/StringTranslateTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyMjoxMVrOHf8aog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoyMjoxMVrOHf8aog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1Nzc2Mg==", "bodyText": "Thanks for that. I think this is only interesting for now but has no real benefit of keeping it, so I think we shouldn't commit it.", "url": "https://github.com/crate/crate/pull/10630#discussion_r503257762", "createdAt": "2020-10-12T12:22:11Z", "author": {"login": "seut"}, "path": "benchmarks/src/test/java/io/crate/execution/StringTranslateTest.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Timeout;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1)\n+@Measurement(iterations = 4)\n+@Timeout(time = 30_000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 2, time = 10_000, timeUnit = TimeUnit.MILLISECONDS)\n+public class StringTranslateTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43c927c8a345536c5ae726e95f8410b1dac9780"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 958, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}