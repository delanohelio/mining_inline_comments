{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NTU5MjE2", "number": 9615, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTowNDowNVrODfNklA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTozODo1NVrODfOeTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDU0ODA0OnYy", "diffSide": "RIGHT", "path": "docs/sql/statements/insert.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTowNDowNVrOFoyE6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNToxMjozOVrOFpHN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwNzgxNw==", "bodyText": "Are system columns not supported? Otherwise maybe add the same as here? 289d32d", "url": "https://github.com/crate/crate/pull/9615#discussion_r378307817", "createdAt": "2020-02-12T15:04:05Z", "author": {"login": "seut"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -119,14 +126,22 @@ Parameters\n ==========\n \n :table_ident:\n-  The identifier (optionally schema-qualified) of an existing table.\n+    The identifier (optionally schema-qualified) of an existing table.\n \n :column_ident:\n-  The name of a column or field in the table pointed to by *table_ident*.\n+    The name of a column or field in the table pointed to by *table_ident*.\n \n :expression:\n-  An expression or value to assign to the corresponding column.\n+    An expression or value to assign to the corresponding column.\n \n :query:\n-  A query (SELECT statement) that supplies the rows to be inserted.\n-  Refer to the ``SELECT`` statement for a description of the syntax.\n+    A query (``SELECT`` statement) that supplies the rows to be inserted.\n+    Refer to the ``SELECT`` statement for a description of the syntax.\n+\n+:output_expression:\n+    An expression to be computed and returned by the ``INSERT`` command\n+    after each row is updated. The expression can use any column names\n+    of the table or use ``*`` to return all columns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1NDE4OA==", "bodyText": "good catch, will do \ud83d\udc4d", "url": "https://github.com/crate/crate/pull/9615#discussion_r378654188", "createdAt": "2020-02-13T05:12:39Z", "author": {"login": "mkleen"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -119,14 +126,22 @@ Parameters\n ==========\n \n :table_ident:\n-  The identifier (optionally schema-qualified) of an existing table.\n+    The identifier (optionally schema-qualified) of an existing table.\n \n :column_ident:\n-  The name of a column or field in the table pointed to by *table_ident*.\n+    The name of a column or field in the table pointed to by *table_ident*.\n \n :expression:\n-  An expression or value to assign to the corresponding column.\n+    An expression or value to assign to the corresponding column.\n \n :query:\n-  A query (SELECT statement) that supplies the rows to be inserted.\n-  Refer to the ``SELECT`` statement for a description of the syntax.\n+    A query (``SELECT`` statement) that supplies the rows to be inserted.\n+    Refer to the ``SELECT`` statement for a description of the syntax.\n+\n+:output_expression:\n+    An expression to be computed and returned by the ``INSERT`` command\n+    after each row is updated. The expression can use any column names\n+    of the table or use ``*`` to return all columns.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwNzgxNw=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDU2MTI0OnYy", "diffSide": "RIGHT", "path": "docs/sql/statements/insert.rst", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTowNzoyM1rOFoyNLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMDowMjo0NlrOFpNrsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg==", "bodyText": "What does | relation.*  stand for, can you give me an example please? Maybe its just me ;)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378309932", "createdAt": "2020-02-12T15:07:23Z", "author": {"login": "seut"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1MTUzMQ==", "bodyText": "I'm a little out of my depth here, but:\nis the foo.* syntax valid EBNF? as a rule, I think our SQL syntax definitions in the docs should be formatted as syntactically correct EBNF\nif you generate EBNF directly from the Antlr definition, what would it look like for this bit?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378351531", "createdAt": "2020-02-12T16:08:19Z", "author": {"login": "norosa"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1NTQ4Mg==", "bodyText": "@seut relation.* means that you can use the following syntax insert into foo (id, name) values (1, 'bob') returning foo.* returning id and name as result and it is supported.", "url": "https://github.com/crate/crate/pull/9615#discussion_r378655482", "createdAt": "2020-02-13T05:18:57Z", "author": {"login": "mkleen"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1NTc5Mw==", "bodyText": "@Nomi sounds good. I think this is a bit inconsistent over the docs. Can you make a proposal how you would like to see it ?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378655793", "createdAt": "2020-02-13T05:20:20Z", "author": {"login": "mkleen"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc1MDQwNw==", "bodyText": "@mkleen it is inconsistent, yeah :( this is something I've been wanting to work on for a while. ideally, I want to generate the EBNF output into the docs (including railroad diagrams) directly from the Antlr definition\nbut until I get a chance to work on that, I don't know enough to have any preferences re how to format this. only that I think we should try to at least make sure of the following:\n\n\nthe SQL syntax definitions in the docs are kept up-to-date with our Antlr configuration (sounds obvious but I suspect there are a few cases where there's a slight mismatch)\n\n\nthe SQL syntax definitions are valid EBNF\n\n\nI don't know enough about EBNF at the moment to know whether foo.* is valid EBNF, and if it's not, what you would replace it with. sorry!\nmy guess, from this specific example, is that foo.* type expressions are already covered in this syntax definition by the output_expression parameter. so perhaps instead of adding | relation.* you could clarify in the text that output_expression supports single column names as well as globbed column names? not sure", "url": "https://github.com/crate/crate/pull/9615#discussion_r378750407", "createdAt": "2020-02-13T09:44:39Z", "author": {"login": "norosa"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc1NTIyMg==", "bodyText": "@mechanomi  Originally we put relation.*  in update to the returning clause documentation https://github.com/crate/crate/blob/master/docs/sql/statements/update.rst\nAt the moment i would like to keep it consistent with the returning clause in update, and this pr is about insert. So maybe lets do another pr after cleaning up update and insert together ? Would that be ok for you ?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378755222", "createdAt": "2020-02-13T09:53:54Z", "author": {"login": "mkleen"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MDExNA==", "bodyText": "yup sure ok", "url": "https://github.com/crate/crate/pull/9615#discussion_r378760114", "createdAt": "2020-02-13T10:02:46Z", "author": {"login": "norosa"}, "path": "docs/sql/statements/insert.rst", "diffHunk": "@@ -24,24 +24,31 @@ Synopsis\n       { VALUES ( expression [, ...] ) [, ...] | ( query ) | query }\n       [ ON CONFLICT (column_ident [, ...]) DO UPDATE SET { column_ident = expression [, ...] } |\n         ON CONFLICT [ ( column_ident [, ...] ) ] DO NOTHING ]\n+      [ RETURNING { * | output_expression [ [ AS ] output_name ] | relation.* } [, ...] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTkzMg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDU4MDI2OnYy", "diffSide": "RIGHT", "path": "sql-parser/src/main/java/io/crate/sql/SqlFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToxMTo0MVrOFoyYmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzozMTo0MVrOFpJcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxMjg1Nw==", "bodyText": "isn't onConflict still missing here?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378312857", "createdAt": "2020-02-12T15:11:41Z", "author": {"login": "seut"}, "path": "sql-parser/src/main/java/io/crate/sql/SqlFormatter.java", "diffHunk": "@@ -205,6 +206,41 @@ protected Void visitExplain(Explain node, Integer indent) {\n             return null;\n         }\n \n+        @Override\n+        public Void visitInsert(Insert<?> node, Integer indent) {\n+            append(indent, \"INSERT\");\n+            builder.append(' ');\n+            append(indent, \"INTO\");\n+            builder.append(' ');\n+            node.table().accept(this, indent);\n+            builder.append(' ');\n+            var columns = node.columns().iterator();\n+            if (columns.hasNext()) {\n+                builder.append('(');\n+                while (columns.hasNext()) {\n+                    builder.append(columns.next());\n+                    if (columns.hasNext()) {\n+                        builder.append(\", \");\n+                    }\n+                }\n+                builder.append(')');\n+            }\n+            builder.append(' ');\n+            node.insertSource().accept(this, indent);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5MDY1Nw==", "bodyText": "True, It is missing, although it was added in the \n  \n    \n      crate/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java\n    \n    \n         Line 1050\n      in\n      208553a\n    \n    \n    \n    \n\n        \n          \n           printStatement(\"insert into t (a, b) values (1, 2) on conflict do nothing\"); \n        \n    \n  \n\n\nbut not failing. I think the TestStatementBuilder is not testing as i would expected it. I will add it. I thought it is part of the insert source since it was passing right away.", "url": "https://github.com/crate/crate/pull/9615#discussion_r378690657", "createdAt": "2020-02-13T07:31:41Z", "author": {"login": "mkleen"}, "path": "sql-parser/src/main/java/io/crate/sql/SqlFormatter.java", "diffHunk": "@@ -205,6 +206,41 @@ protected Void visitExplain(Explain node, Integer indent) {\n             return null;\n         }\n \n+        @Override\n+        public Void visitInsert(Insert<?> node, Integer indent) {\n+            append(indent, \"INSERT\");\n+            builder.append(' ');\n+            append(indent, \"INTO\");\n+            builder.append(' ');\n+            node.table().accept(this, indent);\n+            builder.append(' ');\n+            var columns = node.columns().iterator();\n+            if (columns.hasNext()) {\n+                builder.append('(');\n+                while (columns.hasNext()) {\n+                    builder.append(columns.next());\n+                    if (columns.hasNext()) {\n+                        builder.append(\", \");\n+                    }\n+                }\n+                builder.append(')');\n+            }\n+            builder.append(' ');\n+            node.insertSource().accept(this, indent);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxMjg1Nw=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDYwNzAyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToxODowM1rOFoypJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNToyNzo0MlrOFpHaZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzA5Mw==", "bodyText": "Please remove Nullable annotation as it is expected to not be null by next assertion", "url": "https://github.com/crate/crate/pull/9615#discussion_r378317093", "createdAt": "2020-02-12T15:18:03Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1NzM4MA==", "bodyText": "You are right, I had a different (wrong) understanding of what Nullable means.", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657380", "createdAt": "2020-02-13T05:27:42Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzA5Mw=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDYzNTkwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToyNTowMlrOFoy7QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNTozMDo0NFrOFpHdEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMTcyOA==", "bodyText": "shouldn't this be indexResult.getTerm()?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378321728", "createdAt": "2020-02-12T15:25:02Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1ODA2Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/crate/crate/pull/9615#discussion_r378658066", "createdAt": "2020-02-13T05:30:44Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMTcyOA=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDY0MzgxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToyNzowMFrOFozASA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjozNTozMVrOFpIbeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzAxNg==", "bodyText": "why not passing in the rawSource here as well? don't we want to support _raw as returning for performance reasons? If this was already discussed, sorry. If so a reasoning comment would be helpful ;)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323016", "createdAt": "2020-02-12T15:27:00Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3NDA0MQ==", "bodyText": "Yes, lets do it!", "url": "https://github.com/crate/crate/pull/9615#discussion_r378674041", "createdAt": "2020-02-13T06:35:31Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzAxNg=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDY0NTY1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToyNzoyOFrOFozBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNToyNzoyOFrOFozBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzMyOA==", "bodyText": "same here, no _raw support wanted?", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323328", "createdAt": "2020-02-12T15:27:28Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(\n+                    fetchedDoc.docId(),\n+                    fetchedDoc.getIndex(),\n+                    fetchedDoc.getId(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    indexResult.getTerm(),\n+                    source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDY4NzQ0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTozNjo0M1rOFozbCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNToyOTo1NlrOFpHcUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyOTg2NQ==", "bodyText": "very minor:  Isn't toArray(new Object[0]) still faster, safer than toArray(new Object[])? (see https://shipilev.net/blog/2016/arrays-wisdom-ancients/)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378329865", "createdAt": "2020-02-12T15:36:43Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java", "diffHunk": "@@ -94,20 +96,31 @@ public ColumnIndexWriterProjector(ClusterService clusterService,\n             updateColumnNames = convert.targetNames();\n             assignments = convert.sources();\n         }\n+\n+        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[]{});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1Nzg3Mw==", "bodyText": "Good point i was not aware of this. (btw, great link)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657873", "createdAt": "2020-02-13T05:29:56Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java", "diffHunk": "@@ -94,20 +96,31 @@ public ColumnIndexWriterProjector(ClusterService clusterService,\n             updateColumnNames = convert.targetNames();\n             assignments = convert.sources();\n         }\n+\n+        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[]{});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyOTg2NQ=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDY5NTgxOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTozODo1NVrOFozgog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNTozMDoyNVrOFpHcxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzMTI5OA==", "bodyText": "format: indent issue (also @Test annotation missing)", "url": "https://github.com/crate/crate/pull/9615#discussion_r378331298", "createdAt": "2020-02-12T15:38:55Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java", "diffHunk": "@@ -1458,4 +1458,133 @@ public void testInsertDefaultExpressions() {\n                \"5| cr8\\n\")\n         );\n     }\n+\n+    @Test\n+    public void test_insert_with_id_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.rows()[0][0], is(1));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_multiple_values_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id, owner\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.cols()[1], is(\"owner\"));\n+        assertThat(response.rows()[0][0], is(1));\n+        assertThat(response.rows()[0][1], is(\"crate\"));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_function_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id + 1 as bar\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"bar\"));\n+        assertThat(response.rows()[0][0], is(2));\n+\n+    }\n+\n+\n+    @Test\n+    public void test_insert_with_seq_no_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning _seq_no as seq\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"seq\"));\n+        assertThat(response.rows()[0][0], is(0L));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_owner_renamed_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning owner as name\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"name\"));\n+        assertThat(response.rows()[0][0], is(\"crate\"));\n+\n+    }\n+\n+        public void test_insert_from_subquery_with_id_field_in_returning_clause() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1Nzk4OA==", "bodyText": "Good catch, thank you!", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657988", "createdAt": "2020-02-13T05:30:25Z", "author": {"login": "mkleen"}, "path": "sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java", "diffHunk": "@@ -1458,4 +1458,133 @@ public void testInsertDefaultExpressions() {\n                \"5| cr8\\n\")\n         );\n     }\n+\n+    @Test\n+    public void test_insert_with_id_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.rows()[0][0], is(1));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_multiple_values_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id, owner\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.cols()[1], is(\"owner\"));\n+        assertThat(response.rows()[0][0], is(1));\n+        assertThat(response.rows()[0][1], is(\"crate\"));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_function_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id + 1 as bar\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"bar\"));\n+        assertThat(response.rows()[0][0], is(2));\n+\n+    }\n+\n+\n+    @Test\n+    public void test_insert_with_seq_no_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning _seq_no as seq\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"seq\"));\n+        assertThat(response.rows()[0][0], is(0L));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_owner_renamed_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning owner as name\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"name\"));\n+        assertThat(response.rows()[0][0], is(\"crate\"));\n+\n+    }\n+\n+        public void test_insert_from_subquery_with_id_field_in_returning_clause() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzMTI5OA=="}, "originalCommit": {"oid": "108071f87108760beec4976bd2883282e29b108b"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1041, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}