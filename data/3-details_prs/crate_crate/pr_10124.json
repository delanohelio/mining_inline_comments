{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NTk5NTEw", "number": 10124, "title": "Delay writes on channel until execute is finished", "bodyText": "Summary of the changes / Why this improves CrateDB\nWe must make sure that the client receives the rows and the\ncommandComplete message before it receives a parseComplete for a\nsecond query that the client may have sent as well.\nWe send the query results and the commandComplete from the SEARCH\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\nThis fixes #10068\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-06-23T14:12:44Z", "url": "https://github.com/crate/crate/pull/10124", "merged": true, "mergeCommit": {"oid": "aa1beca0ec5ec1e2d2f564268f91b6855f71f3db"}, "closed": true, "closedAt": "2020-06-23T16:38:29Z", "author": {"login": "mfussenegger"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuGUrggFqTQzNTgzNjE4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuHoIVABqjM0NzM2NzI3NzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODM2MTgy", "url": "https://github.com/crate/crate/pull/10124#pullrequestreview-435836182", "createdAt": "2020-06-23T14:23:55Z", "commit": {"oid": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNDoyMzo1NlrOGnrvdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNDoyODowOVrOGnr8uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NDMwOA==", "bodyText": "shouldn't this be at least volatile?", "url": "https://github.com/crate/crate/pull/10124#discussion_r444264308", "createdAt": "2020-06-23T14:23:56Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/protocols/postgres/DelayableWriteChannel.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres;\n+\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.concurrent.CompletableFuture;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelId;\n+import io.netty.channel.ChannelMetadata;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelProgressivePromise;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoop;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Channel implementation that allows to delay writes with `blockWritesUntil`\n+ **/\n+public class DelayableWriteChannel implements Channel {\n+\n+    private final Channel delegate;\n+    private DelayedWrites delay;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NjQ2Nw==", "bodyText": "As ArrayDeque isn't thread-safe, don't we have to ensure thread-safety here or on the caller side?\n(same on the below delayed.poll())", "url": "https://github.com/crate/crate/pull/10124#discussion_r444266467", "createdAt": "2020-06-23T14:26:45Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/protocols/postgres/DelayableWriteChannel.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres;\n+\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.concurrent.CompletableFuture;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelId;\n+import io.netty.channel.ChannelMetadata;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelProgressivePromise;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoop;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Channel implementation that allows to delay writes with `blockWritesUntil`\n+ **/\n+public class DelayableWriteChannel implements Channel {\n+\n+    private final Channel delegate;\n+    private DelayedWrites delay;\n+\n+    public DelayableWriteChannel(Channel channel) {\n+        this.delegate = channel;\n+    }\n+\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        return delegate.attr(key);\n+    }\n+\n+    @Override\n+    public <T> boolean hasAttr(AttributeKey<T> key) {\n+        return delegate.hasAttr(key);\n+    }\n+\n+    @Override\n+    public ChannelFuture bind(SocketAddress localAddress) {\n+        return delegate.bind(localAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress) {\n+        return delegate.connect(remoteAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {\n+        return delegate.connect(remoteAddress, localAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture disconnect() {\n+        return delegate.disconnect();\n+    }\n+\n+    @Override\n+    public ChannelFuture close() {\n+        return delegate.close();\n+    }\n+\n+    @Override\n+    public ChannelFuture deregister() {\n+        return delegate.deregister();\n+    }\n+\n+    @Override\n+    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {\n+        return delegate.bind(localAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {\n+        return delegate.connect(remoteAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        return delegate.connect(remoteAddress, localAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture disconnect(ChannelPromise promise) {\n+        return delegate.disconnect(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture close(ChannelPromise promise) {\n+        return delegate.close(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture deregister(ChannelPromise promise) {\n+        return delegate.deregister(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture write(Object msg) {\n+        if (delay != null) {\n+            ChannelPromise newPromise = newPromise();\n+            delay.add(() -> delegate.write(msg, newPromise));\n+            return newPromise;\n+        }\n+        return delegate.write(msg);\n+    }\n+\n+    @Override\n+    public ChannelFuture write(Object msg, ChannelPromise promise) {\n+        if (delay != null) {\n+            delay.add(() -> delegate.write(msg, promise));\n+            return promise;\n+        }\n+        return delegate.write(msg, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {\n+        if (delay != null) {\n+            delay.add(() -> delegate.writeAndFlush(msg, promise));\n+        }\n+        return delegate.writeAndFlush(msg, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeAndFlush(Object msg) {\n+        if (delay != null) {\n+            ChannelPromise promise = newPromise();\n+            delay.add(() -> delegate.writeAndFlush(msg, promise));\n+            return promise;\n+        }\n+        return delegate.writeAndFlush(msg);\n+    }\n+\n+    @Override\n+    public ChannelPromise newPromise() {\n+        return delegate.newPromise();\n+    }\n+\n+    @Override\n+    public ChannelProgressivePromise newProgressivePromise() {\n+        return delegate.newProgressivePromise();\n+    }\n+\n+    @Override\n+    public ChannelFuture newSucceededFuture() {\n+        return delegate.newSucceededFuture();\n+    }\n+\n+    @Override\n+    public ChannelFuture newFailedFuture(Throwable cause) {\n+        return delegate.newFailedFuture(cause);\n+    }\n+\n+    @Override\n+    public ChannelPromise voidPromise() {\n+        return delegate.voidPromise();\n+    }\n+\n+    @Override\n+    public int compareTo(Channel o) {\n+        return delegate.compareTo(o);\n+    }\n+\n+    @Override\n+    public ChannelId id() {\n+        return delegate.id();\n+    }\n+\n+    @Override\n+    public EventLoop eventLoop() {\n+        return delegate.eventLoop();\n+    }\n+\n+    @Override\n+    public Channel parent() {\n+        return delegate.parent();\n+    }\n+\n+    @Override\n+    public ChannelConfig config() {\n+        return delegate.config();\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return delegate.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isRegistered() {\n+        return delegate.isRegistered();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return delegate.isActive();\n+    }\n+\n+    @Override\n+    public ChannelMetadata metadata() {\n+        return delegate.metadata();\n+    }\n+\n+    @Override\n+    public SocketAddress localAddress() {\n+        return delegate.localAddress();\n+    }\n+\n+    @Override\n+    public SocketAddress remoteAddress() {\n+        return delegate.remoteAddress();\n+    }\n+\n+    @Override\n+    public ChannelFuture closeFuture() {\n+        return delegate.closeFuture();\n+    }\n+\n+    @Override\n+    public boolean isWritable() {\n+        return delegate.isWritable();\n+    }\n+\n+    @Override\n+    public long bytesBeforeUnwritable() {\n+        return delegate.bytesBeforeUnwritable();\n+    }\n+\n+    @Override\n+    public long bytesBeforeWritable() {\n+        return delegate.bytesBeforeWritable();\n+    }\n+\n+    @Override\n+    public Unsafe unsafe() {\n+        return delegate.unsafe();\n+    }\n+\n+    @Override\n+    public ChannelPipeline pipeline() {\n+        return delegate.pipeline();\n+    }\n+\n+    @Override\n+    public ByteBufAllocator alloc() {\n+        return delegate.alloc();\n+    }\n+\n+    @Override\n+    public Channel read() {\n+        return delegate.read();\n+    }\n+\n+    @Override\n+    public Channel flush() {\n+        return delegate.flush();\n+    }\n+\n+    public Channel bypassDelay() {\n+        return delegate;\n+    }\n+\n+    public void delayWritesUntil(CompletableFuture<?> future) {\n+        DelayedWrites delayedWrites;\n+        if (delay == null) {\n+            delayedWrites = new DelayedWrites(future);\n+        } else {\n+            delayedWrites = new DelayedWrites(delay.future.thenCompose(ignored -> future));\n+        }\n+        this.delay = delayedWrites;\n+        future.whenComplete((res, err) -> {\n+            delayedWrites.runDelayed();\n+            if (delay == delayedWrites) {\n+                delay = null;\n+            }\n+        });\n+    }\n+\n+    static class DelayedWrites {\n+\n+        private final ArrayDeque<Runnable> delayed = new ArrayDeque<>();\n+        private final CompletableFuture<?> future;\n+\n+        public DelayedWrites(CompletableFuture<?> future) {\n+            this.future = future;\n+        }\n+\n+        public void add(Runnable runnable) {\n+            delayed.add(runnable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NzcwNQ==", "bodyText": "could be annotated with @Nullable", "url": "https://github.com/crate/crate/pull/10124#discussion_r444267705", "createdAt": "2020-06-23T14:28:09Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/action/sql/Session.java", "diffHunk": "@@ -353,7 +353,7 @@ public DescribeResult describe(char type, String portalOrStatement) {\n         }\n     }\n \n-    public void execute(String portalName, int maxRows, ResultReceiver<?> resultReceiver) {\n+    public CompletableFuture<?> execute(String portalName, int maxRows, ResultReceiver<?> resultReceiver) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODcwMDg0", "url": "https://github.com/crate/crate/pull/10124#pullrequestreview-435870084", "createdAt": "2020-06-23T14:56:47Z", "commit": {"oid": "f076aad4ed97edae0171c27dfc1984b61dac48f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODg0MTUx", "url": "https://github.com/crate/crate/pull/10124#pullrequestreview-435884151", "createdAt": "2020-06-23T15:11:11Z", "commit": {"oid": "f076aad4ed97edae0171c27dfc1984b61dac48f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f076aad4ed97edae0171c27dfc1984b61dac48f1", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/f076aad4ed97edae0171c27dfc1984b61dac48f1", "committedDate": "2020-06-23T14:54:07Z", "message": "fixup! fixup! Delay writes on channel until execute is finished"}, "afterCommit": {"oid": "95cdb268a49b434e38151b247f2ba447cbf9c136", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/95cdb268a49b434e38151b247f2ba447cbf9c136", "committedDate": "2020-06-23T15:15:16Z", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3a458eeca39f2733b002538e9c0f656d9505c10", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/c3a458eeca39f2733b002538e9c0f656d9505c10", "committedDate": "2020-06-23T15:59:25Z", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95cdb268a49b434e38151b247f2ba447cbf9c136", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/95cdb268a49b434e38151b247f2ba447cbf9c136", "committedDate": "2020-06-23T15:15:16Z", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068"}, "afterCommit": {"oid": "c3a458eeca39f2733b002538e9c0f656d9505c10", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/c3a458eeca39f2733b002538e9c0f656d9505c10", "committedDate": "2020-06-23T15:59:25Z", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3145, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}