{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5Nzk1NDQy", "number": 10866, "title": "Improvement: Overhaul arrays and objects DQL docs", "bodyText": "Summary of the changes / Why this improves CrateDB\nparent issue: #10110\nI am leaving the commit history on this PR as-is in case it helps with the review. once I have feedback, I will update the branch and squash the commits\nnot sure how the commits should be squashed before merging. two options come to mind:\n\nsquash the whole thing into one commit\nsquash the changes to selects.html (along with other RST files and test data) as an update to the docs, and then squash the DepricationWarning fix (and any other related changes that might be necessary) into a separate commit as an update to the build system\n\nmaybe there are other ways of doing this? open to suggestions!\nall of the changes on this PR result directly from my attempts to improve the arrays and objects SQL examples (and explanatory text) in selects.html\nthe changes on this PR do the following:\n\n\nfix a DepricationWarning output by test_docs.py (see 6bda89c, a905e06, 1cd25a2) -- encountered while trying to fix the itests Gradle task\n\n\nrenames the locations column race to inhabitants (rationale here: #10110 (comment)) -- appears in the SQL examples. fixing this necessitated small changes in other files to reflect the rename\n\n\nfixes the test data's handling of ID values by removing the double quotes (see locations.json, locations_import_summary1.json, locations_import_summary2.json). inserting values as strings works, but it results in string sorting (as opposed to numerical sorting) when used in the examples. the previous sort order results in examples that list \"1\" followed by \"10\" (sort by id limit 2). with this change, the same example lists \"1\" followed by \"2\" (which I think is easier to understand, and is more in line with other test data)\n\n\nalters the interests of two places in the locations test data (see locations.json) and adds a landmarks column (see test_docs.py) so that example queries in the ANY section more clearly demonstrate what is being shown\n\n\nupdates a reference in table-functions.rst to reflect some slight re-working of the sections in selects.html (plus zaps some trailing whitespaces -- an automatic thing my editor does. this is good style, so I left it in. but can remove, here and elsewhere, if requested)\n\n\nupdates any RST files that need updating to reflect the new locations test data (information-schema.rst, http.rst, value-expressions.rst)\n\n\nfor selects.html\n\nrework the opening info (see line 7 onwards)\nupdates examples to match the test data in the introduction section (line 27)\nrewraps some paras to fit 79 chars (line 67 and elsewhere)\nchanges the example output integer column formatting to right-align the value (to match the actual output) (line 191 and elsewhere)\nmoves link lists to the bottom of the file per the RST style guide (line 306)\nremoves a redundant example (line 494)\nre-orders the section so that concepts are introduced gradually and each explanation builds upon the previous one. the new order: Arrays, Objects, Arrays within objects, Object within arrays, ANY (array), and Negating ANY -- NOTE: I adopted the phrases \"arrays within objects\" and \"objects within arrays\" because, in English, \"object arrays\" is ambiguous and could mean \"arrays that belong to an object\" or \"arrays of objects\". this ambiguity significantly adds to the confusion of the existing text\nin the sections that cover arrays and objects, I reworked the examples so the reader is first shown the data and then shown how to operate on it in successively complex ways. this directly addresses @proddata's observation on #10110 that \"it is not clear if [the] information [being operated on] is an object or array\"\nmoved some info to admonition blocks and added new admonitions to clarify various points (as necessary)\nchanged the example queries to insert more places from the Hitchhikers Guide to the Galaxy universe (in keeping with the theme already established by the test data). as it was, inserting European placenames into this data set produced results that mix two different themes (which adds a small amount of confusion to an already confusing topic)\ndid my best to disambiguate what is happening when the examples query nested arrays and objects. I went through a bunch of iterations on this. it is difficult to explain without making someone dizzy. I think the approach I settled on works though. basically: be deliberate and verbose (e.g., the use of \"child\" and \"parent\")\nadded new admonitions (line 697) explaining that the child array index n must come before the parent object property name (e.g., my_column[n]['property']). this is so unintuitive that I was tempted to add a title to this admonition saying something like \"SQL syntax Gotcha\", but decided against it. I ended up trying to find out if it has been documented before in some sort of PostgreSQL \"gotchas\" list (e.g., https://sql-info.de/postgresql/postgres-gotchas.html). I couldn't find anything. I am also not clear why we do it this way. is it for compatibility with PostgreSQL? does PostgreSQL not support the inverse syntax? (I do not explain why we do it this way in the text. but if it is useful to do so, I can add that)\nadded notes about the fact that the my_column[n]['property'] syntax is polymorphic. at least, this is my understanding of it based on my experimentation. it is not mentioned in our docs, and I was unable to find anything useful on the web that would help me explain this. I am not sure polymorphic is the technically correct term to use here, but it seems to fit\nadded a note about the my_column['property']::text[][1] syntax mentioned by @jordi in #10110 (comment) -- this is a candidate for removal, imo. not sure if it's necessary or useful to add this or whether it just adds more complexity to one of the most complex sections in this document\nreworked the examples in ANY and Negating ANY so that the examples better illustrate the purpose of the syntax being demonstrated\n\n\n\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-12-14T20:59:26Z", "url": "https://github.com/crate/crate/pull/10866", "merged": true, "mergeCommit": {"oid": "a043eca82d557532ffdb7598e0a70952b6c04471"}, "closed": true, "closedAt": "2021-01-13T19:27:03Z", "author": {"login": "norosa"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmNPZ8gBqjQxMTE1NzYzNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdv0XEOABqjQyMDI3MjAyMjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6745143d06e1d84d687a48127f60fc6271fb4b7b", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/6745143d06e1d84d687a48127f60fc6271fb4b7b", "committedDate": "2020-12-14T20:57:08Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}, "afterCommit": {"oid": "18142761b57818c7535763f3f29160d1a9a9ce67", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/18142761b57818c7535763f3f29160d1a9a9ce67", "committedDate": "2020-12-14T22:11:48Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18142761b57818c7535763f3f29160d1a9a9ce67", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/18142761b57818c7535763f3f29160d1a9a9ce67", "committedDate": "2020-12-14T22:11:48Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}, "afterCommit": {"oid": "ca543835467f3947aa9d8c486eda803fe61260cb", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/ca543835467f3947aa9d8c486eda803fe61260cb", "committedDate": "2020-12-14T22:15:04Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NTc5NzU5", "url": "https://github.com/crate/crate/pull/10866#pullrequestreview-554579759", "createdAt": "2020-12-17T12:59:22Z", "commit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMjo1OToyMlrOIH0gIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMjo1OToyMlrOIH0gIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA3MTEzOA==", "bodyText": "lint: should be \"table's\"", "url": "https://github.com/crate/crate/pull/10866#discussion_r545071138", "createdAt": "2020-12-17T12:59:22Z", "author": {"login": "justien"}, "path": "docs/general/information-schema.rst", "diffHunk": "@@ -288,24 +288,25 @@ table::\n     +-------------------+--------------------------------+-----+--------------------------+\n     | locations         | date                           |   3 | timestamp with time zone |\n     | locations         | description                    |   6 | text                     |\n-    | locations         | id                             |   1 | text                     |\n+    | locations         | id                             |   1 | integer                  |\n     | locations         | information                    |  11 | object_array             |\n     | locations         | information['evolution_level'] |  12 | smallint                 |\n     | locations         | information['population']      |  13 | bigint                   |\n+    | locations         | inhabitants                    |   7 | object                   |\n+    | locations         | inhabitants['description']     |   8 | text                     |\n+    | locations         | inhabitants['interests']       |   9 | text_array               |\n+    | locations         | inhabitants['name']            |  10 | text                     |\n     | locations         | kind                           |   4 | text                     |\n+    | locations         | landmarks                      |  14 | text_array               |\n     | locations         | name                           |   2 | text                     |\n     | locations         | position                       |   5 | integer                  |\n-    | locations         | race                           |   7 | object                   |\n-    | locations         | race['description']            |   8 | text                     |\n-    | locations         | race['interests']              |   9 | text_array               |\n-    | locations         | race['name']                   |  10 | text                     |\n     | partitioned_table | date                           |   3 | timestamp with time zone |\n     | partitioned_table | id                             |   1 | bigint                   |\n     | partitioned_table | title                          |   2 | text                     |\n     | quotes            | id                             |   1 | integer                  |\n     | quotes            | quote                          |   2 | text                     |\n     +-------------------+--------------------------------+-----+--------------------------+\n-    SELECT 18 rows in set (... sec)\n+    SELECT 19 rows in set (... sec)\n \n You can even query this tables' own columns (attention: this might lead to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NzY4MTcx", "url": "https://github.com/crate/crate/pull/10866#pullrequestreview-554768171", "createdAt": "2020-12-17T16:23:43Z", "commit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjoyMzo0M1rOIH9rfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjo0NDo0NVrOIH-pyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMTUwMw==", "bodyText": "Can we keep truncating the result table? I think without, readability gets worse.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545221503", "createdAt": "2020-12-17T16:23:43Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -5,40 +5,46 @@\n Selecting data\n ==============\n \n-Selecting (i.e. retrieving) data from CrateDB is done by using a SQL ``SELECT``\n-statement. The response to a ``SELECT`` query contains the column names of the\n-result, the actual result rows as a two-dimensional array of values, the row\n-count and the duration.\n+Selecting (i.e., retrieving) data from CrateDB can be done by using an SQL\n+``SELECT`` statement. The response to a ``SELECT`` query includes the column\n+names of the result, the result rows as a two-dimensional array of values, the\n+row count, and the execution time.\n+\n+.. SEEALSO::\n+\n+    :ref:`SELECT syntax <sql_reference_select>`\n \n .. rubric:: Table of contents\n \n .. contents::\n    :local:\n \n+\n Introduction\n ============\n \n A simple select::\n \n-    cr> select name, position from locations order by id limit 2;\n-    +-------------------+----------+\n-    | name              | position |\n-    +-------------------+----------+\n-    | North West Ripple | 1        |\n-    | Arkintoofle Minor | 3        |\n-    +-------------------+----------+\n+    cr> select id, name from locations order by id limit 2;\n+    +----+-------------------+\n+    | id | name              |\n+    +----+-------------------+\n+    |  1 | North West Ripple |\n+    |  2 | Outer Eastern Rim |\n+    +----+-------------------+\n     SELECT 2 rows in set (... sec)\n \n If the '*' operator is used, all columns defined in the schema are returned for\n each row::\n \n-    cr> select * from locations order by id limit 1 offset 1;\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    | id | name              |         date | kind   | position | description | race      | information |\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    | 10 | Arkintoofle Minor | 308534400000 | Planet |        3 | Motivate... | {\"desc... |        NULL |\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    SELECT 1 row in set (... sec)\n+    cr> select * from locations order by id limit 2;\n+    +----+-------------------+--------------+--------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------------------------------------------------------------------------------------+-----------+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMjI1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or another ``SELECT`` statement.\n          \n          \n            \n            or another ref:`SELECT <sql_reference_select>` statement.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545222257", "createdAt": "2020-12-17T16:24:42Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -59,8 +65,7 @@ Aliases can be used to change the output name of the columns::\n \n The ``FROM`` clause is used to reference the relation this select query is\n based upon. Can be a single table, many tables, a view, a :ref:`JOIN <sql_joins>`\n-or another ``SELECT`` statement. See :ref:`SELECT Reference\n-<sql_reference_select>`\n+or another ``SELECT`` statement.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNDcxOQ==", "bodyText": "The sections before were about comparison operators, how does a general Arrays section fit here?", "url": "https://github.com/crate/crate/pull/10866#discussion_r545224719", "createdAt": "2020-12-17T16:27:55Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNjgzNg==", "bodyText": "No, you can not nest arrays with in arrays. Defining a columns as array(array(text)) is not supported.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545226836", "createdAt": "2020-12-17T16:30:43Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyOTUxOA==", "bodyText": "See my comment above, arrays of arrays are not supported.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545229518", "createdAt": "2020-12-17T16:34:24Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNDA0OA==", "bodyText": "Mentioning that this is still possible by my_column[1]['property']::text[][1] is maybe useful?", "url": "https://github.com/crate/crate/pull/10866#discussion_r545234048", "createdAt": "2020-12-17T16:40:23Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 482}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNTE0Ng==", "bodyText": "No, see comment above.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545235146", "createdAt": "2020-12-17T16:41:44Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 594}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNjU5NQ==", "bodyText": "Also see my comment above.\nThe whole Object inside arrays section looks like the repeated version of Arrays inside objects. Does this really makes sense like this? Couldn't we fold this together or just highlight important differences and otherwise link to the previous explanations?", "url": "https://github.com/crate/crate/pull/10866#discussion_r545236595", "createdAt": "2020-12-17T16:43:38Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNzQ0OQ==", "bodyText": "I'd suggest to move the general array/object handling description outside of the comparison operator list.\nOr we could change the header level and move array comparison operator beneath general array and object description.", "url": "https://github.com/crate/crate/pull/10866#discussion_r545237449", "createdAt": "2020-12-17T16:44:45Z", "author": {"login": "seut"}, "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_any_array:\n+\n+``ANY (array)``\n+===============", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9183582de62081389adb864f48dfc3819ea7fb6c"}, "originalPosition": 603}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ce0d3dbe7933a5e54466abaab23f806bd6da9ee", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/4ce0d3dbe7933a5e54466abaab23f806bd6da9ee", "committedDate": "2020-12-18T12:43:32Z", "message": "move ANY and negating ANY sections, per feedback\n\nalso add some refs to the array section that appears after as these sections\nconcern arrays"}, "afterCommit": {"oid": "2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "committedDate": "2021-01-05T13:01:06Z", "message": "Correction: Add clarification and cross-reference for object literals syntax (fixes crate/tech-writing-domain#201)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "committedDate": "2021-01-05T13:01:06Z", "message": "Correction: Add clarification and cross-reference for object literals syntax (fixes crate/tech-writing-domain#201)"}, "afterCommit": {"oid": "f725e09fc28e80c2701efa831a62e12b7879e9c4", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/f725e09fc28e80c2701efa831a62e12b7879e9c4", "committedDate": "2021-01-05T13:06:12Z", "message": "restructuring"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f725e09fc28e80c2701efa831a62e12b7879e9c4", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/f725e09fc28e80c2701efa831a62e12b7879e9c4", "committedDate": "2021-01-05T13:06:12Z", "message": "restructuring"}, "afterCommit": {"oid": "256dddd94bbc5289678e50690a6da2dd3be85e1f", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/256dddd94bbc5289678e50690a6da2dd3be85e1f", "committedDate": "2021-01-11T23:26:38Z", "message": "fixup! make tests pass"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "256dddd94bbc5289678e50690a6da2dd3be85e1f", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/256dddd94bbc5289678e50690a6da2dd3be85e1f", "committedDate": "2021-01-11T23:26:38Z", "message": "fixup! make tests pass"}, "afterCommit": {"oid": "a3231e769f01112a167d45dbe880b9b328bd0cd8", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/a3231e769f01112a167d45dbe880b9b328bd0cd8", "committedDate": "2021-01-11T23:30:37Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3231e769f01112a167d45dbe880b9b328bd0cd8", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/a3231e769f01112a167d45dbe880b9b328bd0cd8", "committedDate": "2021-01-11T23:30:37Z", "message": "Improvement: Overhaul arrays and objects DQL docs"}, "afterCommit": {"oid": "0561b2e647543adfff52400ec076ddb5375812f2", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/0561b2e647543adfff52400ec076ddb5375812f2", "committedDate": "2021-01-11T23:31:49Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0561b2e647543adfff52400ec076ddb5375812f2", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/0561b2e647543adfff52400ec076ddb5375812f2", "committedDate": "2021-01-11T23:31:49Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}, "afterCommit": {"oid": "dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "committedDate": "2021-01-12T00:14:01Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "committedDate": "2021-01-12T00:14:01Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}, "afterCommit": {"oid": "ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "committedDate": "2021-01-12T00:15:00Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "committedDate": "2021-01-12T00:15:00Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}, "afterCommit": {"oid": "237b86bc2107b8e722a84e09bb80af28df20e7e6", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/237b86bc2107b8e722a84e09bb80af28df20e7e6", "committedDate": "2021-01-12T00:22:58Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "237b86bc2107b8e722a84e09bb80af28df20e7e6", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/237b86bc2107b8e722a84e09bb80af28df20e7e6", "committedDate": "2021-01-12T00:22:58Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}, "afterCommit": {"oid": "6265084f9db95e54d8390a1e114976c80e7802a4", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/6265084f9db95e54d8390a1e114976c80e7802a4", "committedDate": "2021-01-12T00:59:03Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDg1NjM0", "url": "https://github.com/crate/crate/pull/10866#pullrequestreview-567085634", "createdAt": "2021-01-13T10:29:11Z", "commit": {"oid": "f15ad44d121311ae186c00027b28399418d66b51"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b7c9d16f5b5762b7b7777e61687ed049345322e", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/9b7c9d16f5b5762b7b7777e61687ed049345322e", "committedDate": "2021-01-13T18:51:47Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8ffe7541a785d6defd83e926da1c5f7f2c2f27e", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/a8ffe7541a785d6defd83e926da1c5f7f2c2f27e", "committedDate": "2021-01-13T18:51:13Z", "message": "Merge branch 'master' into nomi/arr-obj"}, "afterCommit": {"oid": "9b7c9d16f5b5762b7b7777e61687ed049345322e", "author": {"user": {"login": "norosa", "name": "Naomi Rose"}}, "url": "https://github.com/crate/crate/commit/9b7c9d16f5b5762b7b7777e61687ed049345322e", "committedDate": "2021-01-13T18:51:47Z", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3593, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}