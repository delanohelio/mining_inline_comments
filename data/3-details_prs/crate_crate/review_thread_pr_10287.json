{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3ODUwOTQ4", "number": 10287, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODoxNzoyMlrOETJW2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODoxNzoyMlrOETJW2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTExNzA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/jobs/SharedShardContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODoxNzoyMlrOG4tr7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODoxNzoyMlrOG4tr7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyMTk2Nw==", "bodyText": "The searchers are already ref-counted inside the engine. So it shouldn't be necessary to add another ref-counting layer on top.", "url": "https://github.com/crate/crate/pull/10287#discussion_r462121967", "createdAt": "2020-07-29T08:17:22Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/jobs/SharedShardContext.java", "diffHunk": "@@ -22,46 +22,40 @@\n \n package io.crate.execution.jobs;\n \n-import org.apache.lucene.search.IndexSearcher;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n import org.elasticsearch.index.IndexNotFoundException;\n import org.elasticsearch.index.IndexService;\n import org.elasticsearch.index.engine.Engine;\n import org.elasticsearch.index.shard.IndexShard;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.indices.IndicesService;\n \n-import javax.annotation.concurrent.NotThreadSafe;\n-import java.util.function.UnaryOperator;\n-\n @NotThreadSafe\n public class SharedShardContext {\n \n     private final IndicesService indicesService;\n     private final ShardId shardId;\n     private final int readerId;\n-    private final UnaryOperator<IndexSearcher> wrapSearcher;\n+    private final UnaryOperator<Engine.Searcher> wrapSearcher;\n \n-    private RefCountSearcher searcher;\n     private IndexService indexService;\n     private IndexShard indexShard;\n \n     SharedShardContext(IndicesService indicesService,\n                        ShardId shardId,\n                        int readerId,\n-                       UnaryOperator<IndexSearcher> wrapSearcher) {\n+                       UnaryOperator<Engine.Searcher> wrapSearcher) {\n         this.indicesService = indicesService;\n         this.shardId = shardId;\n         this.readerId = readerId;\n         this.wrapSearcher = wrapSearcher;\n     }\n \n     public Engine.Searcher acquireSearcher(String source) throws IndexNotFoundException {\n-        if (searcher == null) {\n-            Engine.Searcher searcher = indexShard().acquireSearcher(source);\n-            this.searcher = new RefCountSearcher(shardId, searcher, wrapSearcher.apply(searcher.searcher()));\n-        }\n-        searcher.inc();\n-        return searcher;\n+        return wrapSearcher.apply(indexShard().acquireSearcher(source));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12a88093ab5db9f5953d62282af55a5e33db59fb"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1239, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}