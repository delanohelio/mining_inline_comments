{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3ODE1ODMx", "number": 9763, "title": "Add new signature based function registry ", "bodyText": "Our current function registry does not provide the information needed by a proper pg_proc table implementation. Also the current implementation has other known limitations or even bugs.\nSignatures can be defined with type variables constraints to support constraints across given argument types, e.g. a array(E), array(E) signature requires all E types to either have a common super type or being convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted, this should be re-implemented decoupled later on (Relates #9652).\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures (Relates #9567).\nThis concept is heavily inspired by https://prestodb.io/.", "createdAt": "2020-03-13T14:46:42Z", "url": "https://github.com/crate/crate/pull/9763", "merged": true, "mergeCommit": {"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f"}, "closed": true, "closedAt": "2020-03-24T10:40:11Z", "author": {"login": "seut"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNRtHrABqjMxMjcwODU2NTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQv_EnABqjMxNTg5MjExNTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55fcc69ceb8ce55c02e299716218664eb06c6052", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/55fcc69ceb8ce55c02e299716218664eb06c6052", "committedDate": "2020-03-13T14:35:50Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [] Support iteration over registered function incl. all info\u2019s required by `pg_proc`\n - [x] Use type precendence and cast if needed\n - [] Move (down-)cast lucene optimization to a rule"}, "afterCommit": {"oid": "e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "committedDate": "2020-03-13T15:04:26Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [] Support iteration over registered function incl. all info\u2019s required by `pg_proc`\n - [x] Use type precendence and cast if needed\n - [] Move (down-)cast lucene optimization to a rule"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzY3ODg4", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-374367888", "createdAt": "2020-03-13T14:57:26Z", "commit": {"oid": "55fcc69ceb8ce55c02e299716218664eb06c6052"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo1NzoyNlrOF2G3NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo1OTo1MlrOF2G9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA==", "bodyText": "I think we output this in information_schema tables, so this may be a breaking change. If we do need to change it, maybe we  could go with innerType.getName() + '[]' for improved PostgreSQL compatibility?", "url": "https://github.com/crate/crate/pull/9763#discussion_r392279860", "createdAt": "2020-03-13T14:57:26Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/ArrayType.java", "diffHunk": "@@ -83,7 +93,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n     @Override\n     public String getName() {\n-        return innerType.getName() + \"_\" + NAME;\n+        return NAME + \"(\" + innerType.getName() + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55fcc69ceb8ce55c02e299716218664eb06c6052"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg==", "bodyText": "What do you think of going for module.register(signature, types -> impl), and omit the FuncResolver from the register API?", "url": "https://github.com/crate/crate/pull/9763#discussion_r392281372", "createdAt": "2020-03-13T14:59:52Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java", "diffHunk": "@@ -21,36 +21,81 @@\n \n package io.crate.expression.scalar;\n \n-import com.google.common.base.Preconditions;\n import io.crate.data.Input;\n-import io.crate.exceptions.ConversionException;\n-import io.crate.expression.symbol.FuncArg;\n import io.crate.expression.symbol.Function;\n import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.FuncResolver;\n import io.crate.metadata.FunctionIdent;\n-import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.FunctionName;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n-import io.crate.metadata.functions.params.FuncParams;\n-import io.crate.metadata.functions.params.Param;\n-import io.crate.types.ArrayType;\n-import io.crate.types.DataType;\n+import io.crate.metadata.functions.Signature;\n import io.crate.types.DataTypes;\n \n-import javax.annotation.Nullable;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n \n public abstract class ConcatFunction extends Scalar<String, String> {\n \n     public static final String NAME = \"concat\";\n     private FunctionInfo functionInfo;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        FunctionName name = new FunctionName(null, NAME);\n+\n+        module.register(\n+            new FuncResolver(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55fcc69ceb8ce55c02e299716218664eb06c6052"}, "originalPosition": 44}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "committedDate": "2020-03-13T15:04:26Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [] Support iteration over registered function incl. all info\u2019s required by `pg_proc`\n - [x] Use type precendence and cast if needed\n - [] Move (down-)cast lucene optimization to a rule"}, "afterCommit": {"oid": "a40611b8f14b1a4784ce0e26461ce5effffef895", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/a40611b8f14b1a4784ce0e26461ce5effffef895", "committedDate": "2020-03-16T21:31:02Z", "message": "fixup! WIP: refactor function registration and resolving"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a40611b8f14b1a4784ce0e26461ce5effffef895", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/a40611b8f14b1a4784ce0e26461ce5effffef895", "committedDate": "2020-03-16T21:31:02Z", "message": "fixup! WIP: refactor function registration and resolving"}, "afterCommit": {"oid": "9a7922b487370f2b3c300b8d2b34104445ac3241", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/9a7922b487370f2b3c300b8d2b34104445ac3241", "committedDate": "2020-03-16T21:33:28Z", "message": "fixup! WIP: refactor function registration and resolving"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a7922b487370f2b3c300b8d2b34104445ac3241", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/9a7922b487370f2b3c300b8d2b34104445ac3241", "committedDate": "2020-03-16T21:33:28Z", "message": "fixup! WIP: refactor function registration and resolving"}, "afterCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/93edb2cb269dd2510ffe9de10ccc94961994a0c2", "committedDate": "2020-03-20T13:27:53Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDg3ODMw", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-378487830", "createdAt": "2020-03-20T13:37:11Z", "commit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozNzoxMVrOF5T99w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozNzoxMVrOF5T99w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ==", "bodyText": "This is not really correct, depending on the argument types it will change to object(text, V, text, V2, ...) where V and V2 may be bound to different types.\nCurrently the return type is not used so it won't matter, but will be later used for information of all registered functions (pg_proc).\nNot sure, shall we define it as object() (undefined inner types)? We could also discuss/change it when adding the signature information to pg_proc.", "url": "https://github.com/crate/crate/pull/9763#discussion_r395640311", "createdAt": "2020-03-20T13:37:11Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java", "diffHunk": "@@ -90,7 +78,17 @@ public final Object evaluate(TransactionContext txnCtx, Input<Object>... args) {\n         return m;\n     }\n \n-    public static void register(ScalarFunctionModule scalarFunctionModule) {\n-        scalarFunctionModule.register(NAME, RESOLVER);\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.builder()\n+                .name(new FunctionName(null, NAME))\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n+                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                .returnType(parseTypeSignature(\"object(text, V)\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDg4OTY1", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-378488965", "createdAt": "2020-03-20T13:38:39Z", "commit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODozOVrOF5UBeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODozOVrOF5UBeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTIwOQ==", "bodyText": "This class will supersede the FunctionResolver class once all functions are changed to the new signature based registration.", "url": "https://github.com/crate/crate/pull/9763#discussion_r395641209", "createdAt": "2020-03-20T13:38:39Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/metadata/FuncResolver.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata;\n+\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class FuncResolver implements Function<List<DataType>, FunctionImplementation> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDg5Njc2", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-378489676", "createdAt": "2020-03-20T13:39:29Z", "commit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozOToyOVrOF5UDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozOToyOVrOF5UDlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ==", "bodyText": "This class just acts a Map holder, we could also use the map directly and remove this class. I tend to keep it mainly for readability reasons inside the SignatureBinder. Any input?", "url": "https://github.com/crate/crate/pull/9763#discussion_r395641751", "createdAt": "2020-03-20T13:39:29Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/metadata/functions/BoundVariables.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.types.DataType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class BoundVariables {\n+\n+    private final Map<String, DataType<?>> typeVariables;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/93edb2cb269dd2510ffe9de10ccc94961994a0c2", "committedDate": "2020-03-20T13:27:53Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed"}, "afterCommit": {"oid": "046cc3051132bb213b51dc22a8097c824d9129e4", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/046cc3051132bb213b51dc22a8097c824d9129e4", "committedDate": "2020-03-20T13:40:11Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "046cc3051132bb213b51dc22a8097c824d9129e4", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/046cc3051132bb213b51dc22a8097c824d9129e4", "committedDate": "2020-03-20T13:40:11Z", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed"}, "afterCommit": {"oid": "856c4ce868244694941c78ac38b2369da550943c", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/856c4ce868244694941c78ac38b2369da550943c", "committedDate": "2020-03-20T14:13:51Z", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or \nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted, \nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MjM4NzMz", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-379238733", "createdAt": "2020-03-23T09:05:09Z", "commit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTowNTowOVrOF58L7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOToxMjozM1rOF58bjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5OTI0Nw==", "bodyText": "Would it make sense to have this method in TypeSignature ? signature.createType() or something like that?", "url": "https://github.com/crate/crate/pull/9763#discussion_r396299247", "createdAt": "2020-03-23T09:05:09Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMDE0OQ==", "bodyText": "I'd inline this. It's a shallow method that adds no additional meaning.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396300149", "createdAt": "2020-03-23T09:06:48Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMjg4MA==", "bodyText": "Maybe make this top-level. I think if we move the getType into TypeSignature we could get rid of the TypeSignatures \"utils\" style class and expose the getCommonSuperType as part of the (then top-level) TypeCompatibility class. This would make the responsibility imho a bit clearer.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396302880", "createdAt": "2020-03-23T09:11:48Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMzI0NQ==", "bodyText": "Is the cyclic dependency here really needed (TypeSignatureParameter has a reference to TypeSignature, TypeSignature has references to TypeSignatureParameter)", "url": "https://github.com/crate/crate/pull/9763#discussion_r396303245", "createdAt": "2020-03-23T09:12:33Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatureParameter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.Objects;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TypeSignatureParameter {\n+\n+    private final TypeSignature value;\n+\n+    public static TypeSignatureParameter of(TypeSignature typeSignature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MjQ5MjEy", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-379249212", "createdAt": "2020-03-23T09:19:57Z", "commit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOToxOTo1N1rOF58sCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo0MjowMVrOF59gqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNzQ2NQ==", "bodyText": "Maybe clarify that base is (part of) the type name.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396307465", "createdAt": "2020-03-23T09:19:57Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignatureParameter> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(format(Locale.ENGLISH, \"Bad type signature: '%s'\", signature));\n+    }\n+\n+    private static TypeSignatureParameter parseTypeSignatureParameter(String signature, int begin, int end) {\n+        String parameterName = signature.substring(begin, end).trim();\n+        return TypeSignatureParameter.of(parseTypeSignature(parameterName));\n+    }\n+\n+    private final String base;\n+    private final List<TypeSignatureParameter> parameters;\n+\n+    public TypeSignature(String base) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwODQ3Nw==", "bodyText": "Could you add a comment somewhere that explains why we \"default\" to covariant?  (This is not configurable so far as part of the Signature building, right?)", "url": "https://github.com/crate/crate/pull/9763#discussion_r396308477", "createdAt": "2020-03-23T09:21:49Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMDg0OA==", "bodyText": "I'm not sure if superType is the right term, as we have no type hierarchies (?). So far in other places we used targetType - not sure if that's better.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396310848", "createdAt": "2020-03-23T09:25:43Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMjc1Mw==", "bodyText": "Would it make sense to have the getBase()  directly in DataType ? E.g. type.getBaseName(). Would make sure that we don't construct the TypeSignature multiple times.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396312753", "createdAt": "2020-03-23T09:28:42Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDU3Nw==", "bodyText": "I think a \"why\" comment would be more useful here. Explain why the commonSuperType logic above can fail and which cases are enabled here.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314577", "createdAt": "2020-03-23T09:31:49Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDg1Nw==", "bodyText": "This could probably be a singleton.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314857", "createdAt": "2020-03-23T09:32:18Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {\n+        @Nullable\n+        private final DataType<?> commonSuperType;\n+        private final boolean coercible;\n+\n+        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n+            this.commonSuperType = commonSuperType;\n+            this.coercible = coercible;\n+        }\n+\n+        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+            return new TypeCompatibility(commonSuperType, coercible);\n+        }\n+\n+        private static TypeCompatibility incompatible() {\n+            return new TypeCompatibility(null, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTk0Ng==", "bodyText": "Do you think it would make sense to have a shortcut for the common case?\nLike Signature.scalar(NAME, DataType<?> ... types) where the last type is the return type.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396315946", "createdAt": "2020-03-23T09:33:55Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java", "diffHunk": "@@ -53,7 +54,17 @@ public static FunctionInfo createInfo(List<DataType> types) {\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        module.register(\n+            Signature.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNzYzNQ==", "bodyText": "I think the signature here should be documented. For example that array and object is treated in a special way is important (via TypeSignatures.getType).", "url": "https://github.com/crate/crate/pull/9763#discussion_r396317635", "createdAt": "2020-03-23T09:36:45Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxODczMQ==", "bodyText": "Not sure how to deal with this, but maybe meanwhile add a comment inline to point this out.", "url": "https://github.com/crate/crate/pull/9763#discussion_r396318731", "createdAt": "2020-03-23T09:38:23Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java", "diffHunk": "@@ -90,7 +78,17 @@ public final Object evaluate(TransactionContext txnCtx, Input<Object>... args) {\n         return m;\n     }\n \n-    public static void register(ScalarFunctionModule scalarFunctionModule) {\n-        scalarFunctionModule.register(NAME, RESOLVER);\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.builder()\n+                .name(new FunctionName(null, NAME))\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n+                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                .returnType(parseTypeSignature(\"object(text, V)\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ=="}, "originalCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTA4NA==", "bodyText": "Can this TODO be resolved?", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319084", "createdAt": "2020-03-23T09:38:58Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -169,13 +193,51 @@ private FunctionImplementation getBuiltin(FunctionName functionName, List<DataTy\n     private FunctionImplementation getBuiltinByArgs(FunctionName functionName,\n                                                     List<? extends FuncArg> argumentsTypes,\n                                                     SearchPath searchPath) {\n+        // V2\n+        FunctionImplementation impl = resolveFunctionBySignature(\n+            functionName,\n+            Lists2.map(argumentsTypes, FuncArg::valueType),\n+            searchPath\n+        );\n+        if (impl != null) {\n+            return impl;\n+        }\n+\n         FunctionResolver resolver = lookupFunctionResolver(functionName, searchPath, functionResolvers::get);\n         if (resolver == null) {\n             return null;\n         }\n         return resolveFunctionForArgumentTypes(argumentsTypes, resolver);\n     }\n \n+    @Nullable\n+    private FunctionImplementation resolveFunctionBySignature(FunctionName name,\n+                                                              List<DataType> arguments,\n+                                                              SearchPath searchPath) {\n+        var candidates = functionImplementations.get(name);\n+        if (candidates == null && name.schema() == null) {\n+            for (String pathSchema : searchPath) {\n+                FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());\n+                candidates = functionImplementations.get(searchPathFunctionName);\n+                if (candidates != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (candidates != null) {\n+            for (FuncResolver candidate : candidates) {\n+                Signature boundSignature = new SignatureBinder(candidate.getSignature(), true)\n+                    .bind(arguments);\n+                if (boundSignature != null) {\n+                    // TODO: check for more specific function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTYzMQ==", "bodyText": "I think it is okay to keep it, but if so it should fully encapsulate typeVariables. Currently it also leaks the map via  public Map<String, DataType<?>> getTypeVariables() {", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319631", "createdAt": "2020-03-23T09:39:50Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/functions/BoundVariables.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.types.DataType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class BoundVariables {\n+\n+    private final Map<String, DataType<?>> typeVariables;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ=="}, "originalCommit": {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDQzMQ==", "bodyText": "Can you add some assertions that make sure all required properties are set? (name, kind, argument types..)", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320431", "createdAt": "2020-03-23T09:41:08Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDkzNg==", "bodyText": "No need to change but fyi: I recently added a Lists2.joinOn", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320936", "createdAt": "2020-03-23T09:42:01Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(\n+                name,\n+                kind,\n+                typeVariableConstraints,\n+                argumentTypes,\n+                returnType,\n+                variableArityGroup,\n+                variableArity);\n+        }\n+    }\n+\n+\n+    private final FunctionName name;\n+    private final FunctionInfo.Type kind;\n+    private final List<TypeSignature> argumentTypes;\n+    private final TypeSignature returnType;\n+    private final List<TypeVariableConstraint> typeVariableConstraints;\n+    private final List<TypeSignature> variableArityGroup;\n+    private final boolean variableArity;\n+\n+    private Signature(FunctionName name,\n+                      FunctionInfo.Type kind,\n+                      List<TypeVariableConstraint> typeVariableConstraints,\n+                      List<TypeSignature> argumentTypes,\n+                      TypeSignature returnType,\n+                      List<TypeSignature> variableArityGroup,\n+                      boolean variableArity) {\n+        this.name = name;\n+        this.kind = kind;\n+        this.argumentTypes = argumentTypes;\n+        this.typeVariableConstraints = typeVariableConstraints;\n+        this.returnType = returnType;\n+        this.variableArityGroup = variableArityGroup;\n+        this.variableArity = variableArity;\n+    }\n+\n+    public FunctionName getName() {\n+        return name;\n+    }\n+\n+    public FunctionInfo.Type getKind() {\n+        return kind;\n+    }\n+\n+    public List<TypeSignature> getArgumentTypes() {\n+        return argumentTypes;\n+    }\n+\n+    public TypeSignature getReturnType() {\n+        return returnType;\n+    }\n+\n+    public List<TypeVariableConstraint> getTypeVariableConstraints() {\n+        return typeVariableConstraints;\n+    }\n+\n+    public List<TypeSignature> getVariableArityGroup() {\n+        return variableArityGroup;\n+    }\n+\n+    public boolean isVariableArity() {\n+        return variableArity;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n+\n+        return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n+               \"(\" + String.join(\",\", Lists2.map(argumentTypes, TypeSignature::toString)) + \"):\" + returnType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MzU1Njgy", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-379355682", "createdAt": "2020-03-23T11:49:08Z", "commit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMTo0OTowOFrOF6B7SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNToxMTo1NlrOF6J9vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM5MzI4OQ==", "bodyText": "Given that there are already static constructors for both cases I think this overload could be removed", "url": "https://github.com/crate/crate/pull/9763#discussion_r396393289", "createdAt": "2020-03-23T11:49:08Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import java.util.Objects;\n+\n+public class TypeVariableConstraint {\n+\n+    public static TypeVariableConstraint typeVariable(String name) {\n+        return new TypeVariableConstraint(name);\n+    }\n+\n+    public static TypeVariableConstraint typeVariableOfAnyType(String name) {\n+        return new TypeVariableConstraint(name, true);\n+    }\n+\n+    private final String name;\n+    private final boolean anyAllowed;\n+\n+    private TypeVariableConstraint(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjA2NA==", "bodyText": "Shouldn't this be compatible?", "url": "https://github.com/crate/crate/pull/9763#discussion_r396516064", "createdAt": "2020-03-23T15:00:00Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonType();\n+    }\n+\n+    private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+        return new TypeCompatibility(commonSuperType, coercible);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(fromType, false);\n+        }\n+\n+        String fromTypeBaseName = fromType.getTypeSignature().getBaseTypeName();\n+        String toTypeBaseName = toType.getTypeSignature().getBaseTypeName();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+            if (!fromType.getTypeParameters().isEmpty() || !toType.getTypeParameters().isEmpty()) {\n+                return typeCompatibilityForParametrizedType(fromType, toType);\n+            }\n+            return compatible(fromType, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db3a746648da697fda8b505be150876822d39d5f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODQ0NQ==", "bodyText": "Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation  could be avoided (if types match,  undefined  case,  maybe even the \"by precedence\" case)", "url": "https://github.com/crate/crate/pull/9763#discussion_r396518445", "createdAt": "2020-03-23T15:03:06Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db3a746648da697fda8b505be150876822d39d5f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTM1MQ==", "bodyText": "Does/ should this work for nested cases?", "url": "https://github.com/crate/crate/pull/9763#discussion_r396521351", "createdAt": "2020-03-23T15:07:14Z", "author": {"login": "mfussenegger"}, "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    /**\n+     * Creates a type signature out of the given signature string.\n+     * A signature type string may contain parameters inside parenthesis:\n+     * <p>\n+     *   base_type_name(parameter [, parameter])\n+     * </p>\n+     *\n+     * Custom parameterized type handling must also be supported by {@link #createType()}.\n+     *\n+     * Some examples:\n+     * <p>\n+     *      integer\n+     *      array(integer)\n+     *      array(E)\n+     *      object(text, integer)\n+     *      object(text, V)\n+     * <p>\n+     */\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignature> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db3a746648da697fda8b505be150876822d39d5f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyNDk5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:\n          \n          \n            \n                    // The logic can be summarized as finding the right most item (based on the list below) seen so far:", "url": "https://github.com/crate/crate/pull/9763#discussion_r396524990", "createdAt": "2020-03-23T15:11:56Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.types.DataType;\n+import io.crate.types.TypeSignature;\n+import io.crate.types.UndefinedType;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.logging.Loggers;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariableOfAnyType;\n+import static io.crate.types.TypeCompatibility.getCommonType;\n+import static java.lang.String.format;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+\n+/**\n+ * Determines whether, and how, a callsite matches a generic function signature.\n+ * Which is equivalent to finding assignments for the variables in the generic signature,\n+ * such that all of the function's declared parameters are super types of the corresponding\n+ * arguments, and also satisfy the declared constraints (such as a given type parameter must\n+ * be of the same type or not)\n+ */\n+public class SignatureBinder {\n+    // 4 is chosen arbitrarily here. This limit is set to avoid having infinite loops in iterative solving.\n+    private static final int SOLVE_ITERATION_LIMIT = 4;\n+\n+    private static final Logger LOGGER = Loggers.getLogger(SignatureBinder.class);\n+\n+    private final Signature declaredSignature;\n+    private final boolean allowCoercion;\n+    private final Map<String, TypeVariableConstraint> typeVariableConstraints;\n+\n+    public SignatureBinder(Signature declaredSignature, boolean allowCoercion) {\n+        this.declaredSignature = declaredSignature;\n+        this.allowCoercion = allowCoercion;\n+        this.typeVariableConstraints = declaredSignature.getTypeVariableConstraints().stream()\n+            .collect(toMap(TypeVariableConstraint::getName, identity()));\n+    }\n+\n+    @Nullable\n+    public Signature bind(List<DataType> actualArgumentTypes) {\n+        BoundVariables boundVariables = bindVariables(Lists2.map(actualArgumentTypes, DataType::getTypeSignature));\n+        if (boundVariables == null) {\n+            return null;\n+        }\n+        return applyBoundVariables(declaredSignature, boundVariables, typeVariableConstraints, actualArgumentTypes.size());\n+    }\n+\n+    @Nullable\n+    BoundVariables bindVariables(List<TypeSignature> actualArgumentTypes) {\n+        ArrayList<TypeConstraintSolver> constraintSolvers = new ArrayList<>();\n+        if (!appendConstraintSolversForArguments(constraintSolvers, actualArgumentTypes)) {\n+            return null;\n+        }\n+\n+        return iterativeSolve(Collections.unmodifiableList(constraintSolvers));\n+    }\n+\n+    private static Signature applyBoundVariables(Signature signature,\n+                                                 BoundVariables boundVariables,\n+                                                 Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                 int arity) {\n+        List<TypeSignature> argumentSignatures;\n+        if (signature.isVariableArity()) {\n+            argumentSignatures = expandVarargFormalTypeSignature(\n+                signature.getArgumentTypes(),\n+                signature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                arity);\n+            if (argumentSignatures == null) {\n+                throw new IllegalArgumentException(\n+                    \"Size of argument types does not match a multiple of the defined variable arguments\");\n+            }\n+        } else {\n+            if (signature.getArgumentTypes().size() != arity) {\n+                throw new IllegalArgumentException(\"Size of argument types does not match given arity\");\n+            }\n+            argumentSignatures = signature.getArgumentTypes();\n+        }\n+        List<TypeSignature> boundArgumentSignatures = applyBoundVariables(argumentSignatures, boundVariables);\n+        TypeSignature boundReturnTypeSignature = applyBoundVariables(signature.getReturnType(), boundVariables);\n+\n+        return Signature.builder()\n+            .name(signature.getName())\n+            .kind(signature.getKind())\n+            .argumentTypes(boundArgumentSignatures)\n+            .returnType(boundReturnTypeSignature)\n+            .setVariableArity(false)\n+            .build();\n+    }\n+\n+    private static List<TypeSignature> applyBoundVariables(List<TypeSignature> typeSignatures,\n+                                                           BoundVariables boundVariables) {\n+        ArrayList<TypeSignature> builder = new ArrayList<>();\n+        for (TypeSignature typeSignature : typeSignatures) {\n+            builder.add(applyBoundVariables(typeSignature, boundVariables));\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static TypeSignature applyBoundVariables(TypeSignature typeSignature, BoundVariables boundVariables) {\n+        String baseType = typeSignature.getBaseTypeName();\n+        if (boundVariables.containsTypeVariable(baseType)) {\n+            if (typeSignature.getParameters().isEmpty() == false) {\n+                throw new IllegalStateException(\"Type parameters cannot have parameters\");\n+            }\n+            return boundVariables.getTypeVariable(baseType).getTypeSignature();\n+        }\n+\n+        List<TypeSignature> parameters = Lists2.map(\n+            typeSignature.getParameters(),\n+            typeSignatureParameter -> applyBoundVariables(typeSignatureParameter, boundVariables));\n+\n+        return new TypeSignature(baseType, parameters);\n+    }\n+\n+    private boolean appendConstraintSolversForArguments(List<TypeConstraintSolver> resultBuilder,\n+                                                        List<TypeSignature> actualTypeSignatures) {\n+        boolean variableArity = declaredSignature.isVariableArity();\n+        List<TypeSignature> formalTypeSignatures = declaredSignature.getArgumentTypes();\n+        if (variableArity) {\n+            int variableGroupCount = declaredSignature.getVariableArityGroup().size();\n+            int variableArgumentCount = variableGroupCount > 0 ? variableGroupCount : 1;\n+            if (actualTypeSignatures.size() < formalTypeSignatures.size() - variableArgumentCount) {\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\n+                        \"Given signature size {} is not smaller than minimum variableArity of formal signature size {}\",\n+                        actualTypeSignatures.size(),\n+                        formalTypeSignatures.size() - variableArgumentCount);\n+                }\n+                return false;\n+            }\n+            formalTypeSignatures = expandVarargFormalTypeSignature(\n+                formalTypeSignatures,\n+                declaredSignature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                actualTypeSignatures.size());\n+            if (formalTypeSignatures == null) {\n+                // var args expanding detected a no-match\n+                return false;\n+            }\n+        }\n+\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            appendTypeRelationshipConstraintSolver(resultBuilder,\n+                                                   formalTypeSignatures.get(i),\n+                                                   actualTypeSignatures.get(i),\n+                                                   allowCoercion);\n+        }\n+\n+        return appendConstraintSolvers(resultBuilder, formalTypeSignatures, actualTypeSignatures, allowCoercion);\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            List<? extends TypeSignature> formalTypeSignatures,\n+                                            List<TypeSignature> actualTypeSignatures,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            if (!appendConstraintSolvers(resultBuilder,\n+                                         formalTypeSignatures.get(i),\n+                                         actualTypeSignatures.get(i),\n+                                         allowCoercion)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            TypeSignature formalTypeSignature,\n+                                            TypeSignature actualTypeSignature,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignature.getParameters().isEmpty()) {\n+            TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(formalTypeSignature.getBaseTypeName());\n+            if (typeVariableConstraint == null) {\n+                return true;\n+            }\n+            resultBuilder.add(new TypeParameterSolver(formalTypeSignature.getBaseTypeName(), actualTypeSignature.createType()));\n+            return true;\n+        }\n+\n+        DataType<?> actualType = actualTypeSignature.createType();\n+\n+        List<TypeSignature> actualTypeParametersTypeSignatureProvider;\n+        if (UndefinedType.ID == actualType.id()) {\n+            actualTypeParametersTypeSignatureProvider = Collections.nCopies(formalTypeSignature.getParameters().size(),\n+                                                                            UndefinedType.INSTANCE.getTypeSignature());\n+        } else {\n+            actualTypeParametersTypeSignatureProvider = Lists2.map(\n+                actualType.getTypeParameters(),\n+                DataType::getTypeSignature\n+            );\n+        }\n+\n+        return appendConstraintSolvers(\n+            resultBuilder,\n+            Collections.unmodifiableList(formalTypeSignature.getParameters()),\n+            actualTypeParametersTypeSignatureProvider,\n+            allowCoercion);\n+    }\n+\n+    private void appendTypeRelationshipConstraintSolver(List<TypeConstraintSolver> resultBuilder,\n+                                                        TypeSignature formalTypeSignature,\n+                                                        TypeSignature actualTypeSignature,\n+                                                        boolean allowCoercion) {\n+        Set<String> typeVariables = typeVariablesOf(formalTypeSignature);\n+        resultBuilder.add(new TypeRelationshipConstraintSolver(\n+            formalTypeSignature,\n+            typeVariables,\n+            actualTypeSignature.createType(),\n+            allowCoercion));\n+    }\n+\n+    private Set<String> typeVariablesOf(TypeSignature typeSignature) {\n+        if (typeVariableConstraints.containsKey(typeSignature.getBaseTypeName())) {\n+            return Set.of(typeSignature.getBaseTypeName());\n+        }\n+        HashSet<String> variables = new HashSet<>();\n+        for (TypeSignature parameter : typeSignature.getParameters()) {\n+            variables.addAll(typeVariablesOf(parameter));\n+        }\n+\n+        return variables;\n+    }\n+\n+    @Nullable\n+    private BoundVariables iterativeSolve(List<TypeConstraintSolver> constraints) {\n+        BoundVariables.Builder boundVariablesBuilder = BoundVariables.builder();\n+        for (int i = 0; true; i++) {\n+            if (i == SOLVE_ITERATION_LIMIT) {\n+                throw new IllegalStateException(format(\n+                    Locale.ENGLISH,\n+                    \"SignatureBinder.iterativeSolve does not converge after %d iterations.\",\n+                    SOLVE_ITERATION_LIMIT));\n+            }\n+            SolverReturnStatusMerger statusMerger = new SolverReturnStatusMerger();\n+            for (TypeConstraintSolver constraint : constraints) {\n+                var constraintStatus = constraint.update(boundVariablesBuilder);\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\"Status after updating constraint={}: {}\", constraint, constraintStatus);\n+                }\n+                statusMerger.add(constraintStatus);\n+                if (statusMerger.getCurrent() == SolverReturnStatus.UNSOLVABLE) {\n+                    if (LOGGER.isTraceEnabled()) {\n+                        LOGGER.trace(\"Status merger resulted in UNSOLVABLE state\");\n+                    }\n+                    return null;\n+                }\n+            }\n+            switch (statusMerger.getCurrent()) {\n+                case UNCHANGED_SATISFIED:\n+                    break;\n+                case UNCHANGED_NOT_SATISFIED:\n+                    return null;\n+                case CHANGED:\n+                    continue;\n+                default:\n+                case UNSOLVABLE:\n+                    throw new UnsupportedOperationException(\"Signature binding unsolvable\");\n+            }\n+            break;\n+        }\n+\n+        BoundVariables boundVariables = boundVariablesBuilder.build();\n+        if (!allTypeVariablesBound(boundVariables)) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Not all variables are bound. Defined variables={}, bound={}\",\n+                             typeVariableConstraints,\n+                             boundVariables);\n+            }\n+            return null;\n+        }\n+        return boundVariables;\n+    }\n+\n+    private boolean allTypeVariablesBound(BoundVariables boundVariables) {\n+        return boundVariables.getTypeVariableNames().equals(typeVariableConstraints.keySet());\n+    }\n+\n+    @Nullable\n+    private static List<TypeSignature> expandVarargFormalTypeSignature(List<TypeSignature> formalTypeSignatures,\n+                                                                       List<TypeSignature> variableArityGroup,\n+                                                                       Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                                       int actualArity) {\n+        int variableArityGroupCount = variableArityGroup.size();\n+        if (variableArityGroupCount > 0 && actualArity % variableArityGroupCount != 0) {\n+            // no match\n+            return null;\n+        }\n+        int arityCountIncludedInsideFormalSignature = variableArityGroupCount == 0 ? 1 : variableArityGroupCount;\n+        int variableArityArgumentsCount = actualArity - formalTypeSignatures.size() + arityCountIncludedInsideFormalSignature;\n+        if (variableArityArgumentsCount == 0) {\n+            return formalTypeSignatures.subList(0, formalTypeSignatures.size() - arityCountIncludedInsideFormalSignature);\n+        }\n+        if (variableArityArgumentsCount == arityCountIncludedInsideFormalSignature) {\n+            return formalTypeSignatures;\n+        }\n+        if (variableArityArgumentsCount > arityCountIncludedInsideFormalSignature && formalTypeSignatures.isEmpty()) {\n+            throw new IllegalArgumentException(\"Found variable argument(s) but list of formal type signatures is empty\");\n+        }\n+\n+        ArrayList<TypeSignature> builder = new ArrayList<>(formalTypeSignatures);\n+        if (variableArityGroup.isEmpty()) {\n+            TypeSignature lastTypeSignature = formalTypeSignatures.get(formalTypeSignatures.size() - 1);\n+            for (int i = 1; i < variableArityArgumentsCount; i++) {\n+                addVarArgTypeSignature(lastTypeSignature, typeVariableConstraints, builder, i);\n+            }\n+        } else {\n+            for (int i = 0; i < variableArityArgumentsCount - formalTypeSignatures.size(); ) {\n+                i += variableArityGroupCount;\n+                for (var typeSignature : variableArityGroup) {\n+                    addVarArgTypeSignature(typeSignature, typeVariableConstraints, builder, i);\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static void addVarArgTypeSignature(TypeSignature typeSignature,\n+                                               Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                               List<TypeSignature> builder,\n+                                               int actualArity) {\n+        TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(typeSignature.getBaseTypeName());\n+        if (typeVariableConstraint != null && typeVariableConstraint.isAnyAllowed()) {\n+            // Type variables defaults to be bound to the same type.\n+            // To support independent variable type arguments, each vararg must be bound to a dedicated type variable.\n+            String constraintName = \"_generated_\" + typeSignature.getBaseTypeName() + actualArity;\n+            TypeSignature newTypeSignature = new TypeSignature(constraintName);\n+            typeVariableConstraints.put(constraintName, typeVariableOfAnyType(constraintName));\n+            builder.add(newTypeSignature);\n+        } else {\n+            builder.add(typeSignature);\n+        }\n+\n+    }\n+\n+    private static boolean satisfiesCoercion(boolean allowCoercion,\n+                                             DataType<?> fromType,\n+                                             TypeSignature toTypeSignature) {\n+        if (allowCoercion) {\n+            return fromType.isConvertableTo(toTypeSignature.createType());\n+        } else {\n+            return fromType.getTypeSignature().equals(toTypeSignature);\n+        }\n+    }\n+\n+    private interface TypeConstraintSolver {\n+        SolverReturnStatus update(BoundVariables.Builder bindings);\n+    }\n+\n+    private enum SolverReturnStatus {\n+        UNCHANGED_SATISFIED,\n+        UNCHANGED_NOT_SATISFIED,\n+        CHANGED,\n+        UNSOLVABLE,\n+    }\n+\n+    private static class SolverReturnStatusMerger {\n+        // This class gives the overall status when multiple status are seen from different parts.\n+        // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db3a746648da697fda8b505be150876822d39d5f"}, "originalPosition": 407}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjU5ODc4", "url": "https://github.com/crate/crate/pull/9763#pullrequestreview-379659878", "createdAt": "2020-03-23T17:29:54Z", "commit": {"oid": "b0346f3eecfcef419b37b1e821267bf28a80e317"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0346f3eecfcef419b37b1e821267bf28a80e317", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/b0346f3eecfcef419b37b1e821267bf28a80e317", "committedDate": "2020-03-23T16:37:35Z", "message": "fixup! Implement new signature based function registry"}, "afterCommit": {"oid": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "committedDate": "2020-03-24T08:31:46Z", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "committedDate": "2020-03-24T10:02:45Z", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "committedDate": "2020-03-24T08:31:46Z", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures."}, "afterCommit": {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "author": {"user": {"login": "seut", "name": "Sebastian Utz"}}, "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "committedDate": "2020-03-24T10:02:45Z", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3579, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}