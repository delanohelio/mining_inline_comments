{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3Nzc1MzY2", "number": 9880, "title": "Use the new func registry for the generate_series function.", "bodyText": "Summary of the changes / Why this improves CrateDB\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-04-23T08:54:41Z", "url": "https://github.com/crate/crate/pull/9880", "merged": true, "mergeCommit": {"oid": "a39f14e6fcba7c99cc11474a08ae17f1fcce6db1"}, "closed": true, "closedAt": "2020-04-24T09:30:34Z", "author": {"login": "kovrus"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcacR3RABqjMyNjQ4OTQzNDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcatnjxgH2gAyNDA3Nzc1MzY2OjAxODhmNTNmMGM3NzY5ZjZlZDFlNDA0NGNjODI4YWNmNGFmMjc4MmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6249639b558038d43429b5185591e5f4dac02ad", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/d6249639b558038d43429b5185591e5f4dac02ad", "committedDate": "2020-04-23T08:52:10Z", "message": "Use the new func registry for the generate_series function."}, "afterCommit": {"oid": "1aed97bff743ea8f74b7310cdea86f20ea12f4e3", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/1aed97bff743ea8f74b7310cdea86f20ea12f4e3", "committedDate": "2020-04-23T12:44:41Z", "message": "Use the new func registry for the generate_series function."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1aed97bff743ea8f74b7310cdea86f20ea12f4e3", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/1aed97bff743ea8f74b7310cdea86f20ea12f4e3", "committedDate": "2020-04-23T12:44:41Z", "message": "Use the new func registry for the generate_series function."}, "afterCommit": {"oid": "ac0390c67e474834bd36db79fd822ece147df5e0", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/ac0390c67e474834bd36db79fd822ece147df5e0", "committedDate": "2020-04-23T14:11:33Z", "message": "Use the new func registry for the generate_series function."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTM3MDI1", "url": "https://github.com/crate/crate/pull/9880#pullrequestreview-399137025", "createdAt": "2020-04-23T14:11:05Z", "commit": {"oid": "1aed97bff743ea8f74b7310cdea86f20ea12f4e3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDoxMTowNVrOGKqHfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDoxMjozOFrOGKqM1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyODk4OQ==", "bodyText": "hm shall we really catch unsupported argument types here instead of just letting it throw an unsupported function exception? I wouldn't introduce (or take further) such a special pattern, we don't do that anywhere else afaik.", "url": "https://github.com/crate/crate/pull/9880#discussion_r413828989", "createdAt": "2020-04-23T14:11:05Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/tablefunctions/GenerateSeries.java", "diffHunk": "@@ -71,69 +65,104 @@\n public final class GenerateSeries<T extends Number> extends TableFunctionImplementation<T> {\n \n     public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_series\");\n-    private final FunctionInfo info;\n-    private final T defaultStep;\n-    private final BinaryOperator<T> minus;\n-    private final BinaryOperator<T> plus;\n-    private final BinaryOperator<T> divide;\n-    private final Comparator<T> comparator;\n-    private final RowType returnType;\n \n     public static void register(TableFunctionModule module) {\n-        Param startAndEnd = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP);\n-        Param stepType = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.INTERVAL);\n-        FuncParams.Builder paramsBuilder = FuncParams\n-            .builder(startAndEnd, startAndEnd)\n-            .withVarArgs(stepType)\n-            .limitVarArgOccurrences(1);\n-        module.register(NAME, new BaseFunctionResolver(paramsBuilder.build()) {\n-            @Override\n-            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n-                DataType<?> startType = types.get(0);\n-                DataType<?> stopType = types.get(1);\n-                assert startType.equals(stopType) : \"Start and stop type must be the same, got: \" + startType + \" and \" + stopType;\n-                if (types.size() == 2 && !startType.equals(DataTypes.INTEGER) && !startType.equals(DataTypes.LONG)) {\n+        // without step\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                new RowType(List.of(DataTypes.LONG)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1L, (x, y) -> x - y, Long::sum, (x, y) -> x / y, Long::compare)\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                new RowType(List.of(DataTypes.INTEGER)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1, (x, y) -> x - y, Integer::sum, (x, y) -> x / y, Integer::compare)\n+        );\n+\n+        // with step\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                new RowType(List.of(DataTypes.LONG)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1L, (x, y) -> x - y, Long::sum, (x, y) -> x / y, Long::compare)\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                new RowType(List.of(DataTypes.INTEGER)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1, (x, y) -> x - y, Integer::sum, (x, y) -> x / y, Integer::compare)\n+        );\n+\n+        // generate_series(ts, ts, interval)\n+        for (var supportedType : List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ)) {\n+            module.register(\n+                Signature.table(\n+                    NAME,\n+                    supportedType.getTypeSignature(),\n+                    supportedType.getTypeSignature(),\n+                    DataTypes.INTERVAL.getTypeSignature(),\n+                    new RowType(List.of(supportedType)).getTypeSignature()),\n+                GenerateSeriesIntervals::new\n+            );\n+            module.register(\n+                Signature.table(\n+                    NAME,\n+                    supportedType.getTypeSignature(),\n+                    supportedType.getTypeSignature(),\n+                    new RowType(List.of(supportedType)).getTypeSignature()),\n+                (signature, argTypes) -> {\n                     throw new IllegalArgumentException(\n-                        \"generate_series(start, stop) has type `\" + startType.getName() +\n+                        \"generate_series(start, stop) has type `\" + argTypes.get(0).getName() +\n                         \"` for start, but requires long/int values for start and stop, \" +\n                         \"or if used with timestamps, it requires a third argument for the step (interval)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aed97bff743ea8f74b7310cdea86f20ea12f4e3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzMDM1OQ==", "bodyText": "minor: I'd prefer having each argument in a dedicated line for improved readability (also related to the other registrations below).", "url": "https://github.com/crate/crate/pull/9880#discussion_r413830359", "createdAt": "2020-04-23T14:12:38Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/tablefunctions/GenerateSeries.java", "diffHunk": "@@ -71,69 +65,104 @@\n public final class GenerateSeries<T extends Number> extends TableFunctionImplementation<T> {\n \n     public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_series\");\n-    private final FunctionInfo info;\n-    private final T defaultStep;\n-    private final BinaryOperator<T> minus;\n-    private final BinaryOperator<T> plus;\n-    private final BinaryOperator<T> divide;\n-    private final Comparator<T> comparator;\n-    private final RowType returnType;\n \n     public static void register(TableFunctionModule module) {\n-        Param startAndEnd = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP);\n-        Param stepType = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.INTERVAL);\n-        FuncParams.Builder paramsBuilder = FuncParams\n-            .builder(startAndEnd, startAndEnd)\n-            .withVarArgs(stepType)\n-            .limitVarArgOccurrences(1);\n-        module.register(NAME, new BaseFunctionResolver(paramsBuilder.build()) {\n-            @Override\n-            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n-                DataType<?> startType = types.get(0);\n-                DataType<?> stopType = types.get(1);\n-                assert startType.equals(stopType) : \"Start and stop type must be the same, got: \" + startType + \" and \" + stopType;\n-                if (types.size() == 2 && !startType.equals(DataTypes.INTEGER) && !startType.equals(DataTypes.LONG)) {\n+        // without step\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                new RowType(List.of(DataTypes.LONG)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1L, (x, y) -> x - y, Long::sum, (x, y) -> x / y, Long::compare)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0390c67e474834bd36db79fd822ece147df5e0"}, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac0390c67e474834bd36db79fd822ece147df5e0", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/ac0390c67e474834bd36db79fd822ece147df5e0", "committedDate": "2020-04-23T14:11:33Z", "message": "Use the new func registry for the generate_series function."}, "afterCommit": {"oid": "370f72c22171e2ae3a0d60064b3b5a373e780f4c", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/370f72c22171e2ae3a0d60064b3b5a373e780f4c", "committedDate": "2020-04-23T14:20:49Z", "message": "Use the new func registry for the generate_series function."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTgwNTUw", "url": "https://github.com/crate/crate/pull/9880#pullrequestreview-399180550", "createdAt": "2020-04-23T14:53:12Z", "commit": {"oid": "370f72c22171e2ae3a0d60064b3b5a373e780f4c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1MzoxMlrOGKsYXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1MzoxMlrOGKsYXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2NjA3Ng==", "bodyText": "Ah right, thx for the info.\nPitty, so we are missing a possibility to forbid coercion from a specific type. I wouldn't implement that now but will keep it in mind for maybe future adjustments.", "url": "https://github.com/crate/crate/pull/9880#discussion_r413866076", "createdAt": "2020-04-23T14:53:12Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/tablefunctions/GenerateSeries.java", "diffHunk": "@@ -71,69 +65,104 @@\n public final class GenerateSeries<T extends Number> extends TableFunctionImplementation<T> {\n \n     public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_series\");\n-    private final FunctionInfo info;\n-    private final T defaultStep;\n-    private final BinaryOperator<T> minus;\n-    private final BinaryOperator<T> plus;\n-    private final BinaryOperator<T> divide;\n-    private final Comparator<T> comparator;\n-    private final RowType returnType;\n \n     public static void register(TableFunctionModule module) {\n-        Param startAndEnd = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP);\n-        Param stepType = Param.of(DataTypes.LONG, DataTypes.INTEGER, DataTypes.INTERVAL);\n-        FuncParams.Builder paramsBuilder = FuncParams\n-            .builder(startAndEnd, startAndEnd)\n-            .withVarArgs(stepType)\n-            .limitVarArgOccurrences(1);\n-        module.register(NAME, new BaseFunctionResolver(paramsBuilder.build()) {\n-            @Override\n-            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n-                DataType<?> startType = types.get(0);\n-                DataType<?> stopType = types.get(1);\n-                assert startType.equals(stopType) : \"Start and stop type must be the same, got: \" + startType + \" and \" + stopType;\n-                if (types.size() == 2 && !startType.equals(DataTypes.INTEGER) && !startType.equals(DataTypes.LONG)) {\n+        // without step\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                new RowType(List.of(DataTypes.LONG)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1L, (x, y) -> x - y, Long::sum, (x, y) -> x / y, Long::compare)\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                new RowType(List.of(DataTypes.INTEGER)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1, (x, y) -> x - y, Integer::sum, (x, y) -> x / y, Integer::compare)\n+        );\n+\n+        // with step\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                DataTypes.LONG.getTypeSignature(),\n+                new RowType(List.of(DataTypes.LONG)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1L, (x, y) -> x - y, Long::sum, (x, y) -> x / y, Long::compare)\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                new RowType(List.of(DataTypes.INTEGER)).getTypeSignature()),\n+            (signature, argTypes) -> new GenerateSeries<>(\n+                signature, argTypes, 1, (x, y) -> x - y, Integer::sum, (x, y) -> x / y, Integer::compare)\n+        );\n+\n+        // generate_series(ts, ts, interval)\n+        for (var supportedType : List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ)) {\n+            module.register(\n+                Signature.table(\n+                    NAME,\n+                    supportedType.getTypeSignature(),\n+                    supportedType.getTypeSignature(),\n+                    DataTypes.INTERVAL.getTypeSignature(),\n+                    new RowType(List.of(supportedType)).getTypeSignature()),\n+                GenerateSeriesIntervals::new\n+            );\n+            module.register(\n+                Signature.table(\n+                    NAME,\n+                    supportedType.getTypeSignature(),\n+                    supportedType.getTypeSignature(),\n+                    new RowType(List.of(supportedType)).getTypeSignature()),\n+                (signature, argTypes) -> {\n                     throw new IllegalArgumentException(\n-                        \"generate_series(start, stop) has type `\" + startType.getName() +\n+                        \"generate_series(start, stop) has type `\" + argTypes.get(0).getName() +\n                         \"` for start, but requires long/int values for start and stop, \" +\n                         \"or if used with timestamps, it requires a third argument for the step (interval)\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyODk4OQ=="}, "originalCommit": {"oid": "1aed97bff743ea8f74b7310cdea86f20ea12f4e3"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ae10ee16ab7312703004368a67fa8a204afdc6d", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/2ae10ee16ab7312703004368a67fa8a204afdc6d", "committedDate": "2020-04-24T07:48:03Z", "message": "Use the new func registry for the generate_series function."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f41b8f985e4b932347ff00bb304c58a5566c5756", "author": {"user": {"login": "mergify[bot]", "name": null}}, "url": "https://github.com/crate/crate/commit/f41b8f985e4b932347ff00bb304c58a5566c5756", "committedDate": "2020-04-24T07:45:02Z", "message": "Merge branch 'master' into r/generate-series-reg"}, "afterCommit": {"oid": "2ae10ee16ab7312703004368a67fa8a204afdc6d", "author": {"user": {"login": "kovrus", "name": "Ruslan Kovalov"}}, "url": "https://github.com/crate/crate/commit/2ae10ee16ab7312703004368a67fa8a204afdc6d", "committedDate": "2020-04-24T07:48:03Z", "message": "Use the new func registry for the generate_series function."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdeb2c97287230bf794384e3c736b60654371bd7", "author": {"user": {"login": "mergify[bot]", "name": null}}, "url": "https://github.com/crate/crate/commit/fdeb2c97287230bf794384e3c736b60654371bd7", "committedDate": "2020-04-24T08:24:08Z", "message": "Merge branch 'master' into r/generate-series-reg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0188f53f0c7769f6ed1e4044cc828acf4af2782b", "author": {"user": {"login": "mergify[bot]", "name": null}}, "url": "https://github.com/crate/crate/commit/0188f53f0c7769f6ed1e4044cc828acf4af2782b", "committedDate": "2020-04-24T08:57:03Z", "message": "Merge branch 'master' into r/generate-series-reg"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3297, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}