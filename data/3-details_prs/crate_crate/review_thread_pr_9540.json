{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDQ2ODUy", "number": 9540, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjoxNDoxMFrODZeG5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzozMToyOFrODa4Ivw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDM0Mjc4OnYy", "diffSide": "RIGHT", "path": "blob/src/main/java/io/crate/common/Hex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjoxNDoxMFrOFf36fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjoxNDoxMFrOFf36fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2NjI3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a string with the leasing hexadecimal flag removed.\n          \n          \n            \n                 * Returns a string with the leading hexadecimal flag removed.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368966271", "createdAt": "2020-01-21T12:14:10Z", "author": {"login": "seut"}, "path": "blob/src/main/java/io/crate/common/Hex.java", "diffHunk": "@@ -33,6 +38,37 @@\n      */\n     private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n \n+    /**\n+     * Returns true if the argument is in the \"bytea\" hex format.\n+     */\n+    public static boolean isHexFormat(String data) {\n+        return data.startsWith(HEX_FLAG);\n+    }\n+\n+    /**\n+     * Returns a string with the leasing hexadecimal flag removed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDM1NDM4OnYy", "diffSide": "RIGHT", "path": "blob/src/main/java/io/crate/common/Octal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjoxODo0MVrOFf4Bmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjoxODo0MVrOFf4Bmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2ODA5MA==", "bodyText": "We should move this class and the existing Hex one into the shared subproject, this new class is not used inside blob at all and it contains generic logic anyway.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368968090", "createdAt": "2020-01-21T12:18:41Z", "author": {"login": "seut"}, "path": "blob/src/main/java/io/crate/common/Octal.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.common;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+/**\n+ * Encodes and decodes binary strings into the \"bytea\" escape format.\n+ * Unprintable bytes, outside of the 32..126 range are represented with an octal number \"\\nnn\", and backslashes\n+ * are doubled.\n+ */\n+public class Octal {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDM5Mjc1OnYy", "diffSide": "RIGHT", "path": "docs/appendices/release-notes/unreleased.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozMjo1NlrOFf4Yhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozMjo1NlrOFf4Yhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3Mzk1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Add encode and decode string functions.\n          \n          \n            \n            - Added the :ref:`encode` and :ref:`decode` string functions.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368973958", "createdAt": "2020-01-21T12:32:56Z", "author": {"login": "seut"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -52,7 +52,7 @@ None\n Changes\n =======\n \n-None\n+- Add encode and decode string functions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQwODA1OnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozODo1MFrOFf4hpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozODo1MFrOFf4hpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NjI5Mg==", "bodyText": "All examples which uses the cr> prefix are executed and tested when running our itest  gradle task.\nI think this will fail as the output SELECT 1 row in set (... sec) is missing.\nAnother minor: all lines should be intended by 4 spaces.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368976292", "createdAt": "2020-01-21T12:38:50Z", "author": {"login": "seut"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -508,6 +508,49 @@ Example::\n    In both cases, the scalar functions lpad and rpad, do now accept a len\n    greater than 50000.\n \n+.. _scalar-encode:\n+\n+``encode(bytea, format)``\n+-------------------------\n+\n+Encode takes a binary string in hex format and returns a textual representation\n+into the specified format. Supported formats are base64, hex, and escape. The\n+escape format represents unprintable characters with an octal sequence `\\nnn`.\n+\n+Synopsis::\n+\n+    encode(string1, format)\n+\n+Example::\n+\n+   cr> select encode(E'123\\b\\t56', 'base64');\n+   +----------------------------------------+\n+   | select encode(E'123\\b\\t56', 'base64'); |\n+   +----------------------------------------+\n+   | MTIzCAk1Ng==                           |\n+   +----------------------------------------+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQwODgxOnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozOTowOVrOFf4iGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjozOTowOVrOFf4iGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NjQxMQ==", "bodyText": "Same issues here as well.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368976411", "createdAt": "2020-01-21T12:39:09Z", "author": {"login": "seut"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -508,6 +508,49 @@ Example::\n    In both cases, the scalar functions lpad and rpad, do now accept a len\n    greater than 50000.\n \n+.. _scalar-encode:\n+\n+``encode(bytea, format)``\n+-------------------------\n+\n+Encode takes a binary string in hex format and returns a textual representation\n+into the specified format. Supported formats are base64, hex, and escape. The\n+escape format represents unprintable characters with an octal sequence `\\nnn`.\n+\n+Synopsis::\n+\n+    encode(string1, format)\n+\n+Example::\n+\n+   cr> select encode(E'123\\b\\t56', 'base64');\n+   +----------------------------------------+\n+   | select encode(E'123\\b\\t56', 'base64'); |\n+   +----------------------------------------+\n+   | MTIzCAk1Ng==                           |\n+   +----------------------------------------+\n+\n+.. _scalar-decode:\n+\n+``decode(text, format)``\n+-------------------------\n+\n+Decodes text encoded in the given format, which are listed in the `encode`\n+documentation. Returns a binary string in the hex format.\n+\n+Synopsis::\n+\n+    decode(text1, format)\n+\n+Example::\n+\n+   cr> select decode('T\\214', 'escape');\n+   +-----------------------------------+\n+   | select decode('T\\214', 'escape'); |\n+   +-----------------------------------+\n+   | \\x548c                            |\n+   +-----------------------------------+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQxNjc2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0MTo1MlrOFf4mxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0MTo1MlrOFf4mxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NzYwNw==", "bodyText": "By defining a encode and decode function to the Format enum itself, this switch statement can be eliminated which improves performance.\nAlso the error handling should be improved, like e.g. catching the not-found enum.valueOf exception and turn it into a user friendly \"Format 'foo' not supported\" exception.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368977607", "createdAt": "2020-01-21T12:41:52Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQyMDg4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0MzoyNFrOFf4pNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0MzoyNFrOFf4pNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODIyOQ==", "bodyText": "I think using string concatenation is faster and cheaper here than using the string format.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978229", "createdAt": "2020-01-21T12:43:24Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Takes a string encoded into the given format and returns its hexadecimal representation.\n+     */\n+    private static class Decode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String text, String format) {\n+            final byte[] value;\n+\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    value = Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8));\n+                    break;\n+                case HEX:\n+                    // text is already in hex format\n+                    return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.validateHex(text));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQyMjE3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0Mzo1MFrOFf4p6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0Mzo1MFrOFf4p6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODQxMA==", "bodyText": "Also here, string concatenation should be faster and cheaper.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978410", "createdAt": "2020-01-21T12:43:50Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Takes a string encoded into the given format and returns its hexadecimal representation.\n+     */\n+    private static class Decode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String text, String format) {\n+            final byte[] value;\n+\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    value = Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8));\n+                    break;\n+                case HEX:\n+                    // text is already in hex format\n+                    return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.validateHex(text));\n+                case ESCAPE:\n+                    value = Octal.decode(text);\n+                    break;\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+            assert value != null;\n+            return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.encodeHexString(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQyMzgzOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0NDozNVrOFf4rAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0NDozNVrOFf4rAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODY4OQ==", "bodyText": "I suggest to use the expectedException rule everywhere inside this suite to also test for a user-friendly error message.", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978689", "createdAt": "2020-01-21T12:44:35Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQyODY3OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0NjoxM1rOFf4t_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwODoyNzowM1rOFgTv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTQ1Mg==", "bodyText": "please use expectedException rule here instead (don't use System.out anyway, it will bypass any logging/output suppression inside the test runner)", "url": "https://github.com/crate/crate/pull/9540#discussion_r368979452", "createdAt": "2020-01-21T12:46:13Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToHex() {\n+        assertEvaluate(\"encode('\\\\xfh', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToEscape() {\n+        assertEvaluate(\"encode('\\\\xfh', 'escape')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex1() {\n+        assertEvaluate(\"decode('\\\\xff', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex2() {\n+        assertEvaluate(\"decode('ffa', 'hex')\", null);\n+    }\n+\n+    @Test\n+    public void testUnknownFormat() {\n+        try {\n+            assertEvaluate(\"encode('\\\\xff', 'bad')\", null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyMjMxMw==", "bodyText": "My bad, the sysout was not meant to be commited.", "url": "https://github.com/crate/crate/pull/9540#discussion_r369422313", "createdAt": "2020-01-22T08:27:03Z", "author": {"login": "scampi"}, "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToHex() {\n+        assertEvaluate(\"encode('\\\\xfh', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToEscape() {\n+        assertEvaluate(\"encode('\\\\xfh', 'escape')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex1() {\n+        assertEvaluate(\"decode('\\\\xff', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex2() {\n+        assertEvaluate(\"decode('ffa', 'hex')\", null);\n+    }\n+\n+    @Test\n+    public void testUnknownFormat() {\n+        try {\n+            assertEvaluate(\"encode('\\\\xff', 'bad')\", null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTQ1Mg=="}, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDQzMTA1OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0NzowNVrOFf4vhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMjo0NzowNVrOFf4vhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTg0NA==", "bodyText": "I think we should add a encode/decode test for NULL values", "url": "https://github.com/crate/crate/pull/9540#discussion_r368979844", "createdAt": "2020-01-21T12:47:05Z", "author": {"login": "seut"}, "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToHex() {\n+        assertEvaluate(\"encode('\\\\xfh', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToEscape() {\n+        assertEvaluate(\"encode('\\\\xfh', 'escape')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex1() {\n+        assertEvaluate(\"decode('\\\\xff', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex2() {\n+        assertEvaluate(\"decode('ffa', 'hex')\", null);\n+    }\n+\n+    @Test\n+    public void testUnknownFormat() {\n+        try {\n+            assertEvaluate(\"encode('\\\\xff', 'bad')\", null);\n+            fail(\"Should fail on unknown format\");\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"e = \" + e);\n+        }\n+        try {\n+            assertEvaluate(\"decode('FA==', 'bad')\", null);\n+            fail(\"Should fail on unknown format\");\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"e = \" + e);\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeFuncBase64() {\n+        // input in hex format\n+        final Literal<Object> name = Literal.of(DataTypes.STRING, \"\\\\x3132330001\");\n+        assertEvaluate(\"encode('\\\\x3132330001', 'base64')\", \"MTIzAAE=\");\n+        assertEvaluate(\"encode(name, 'Base64')\", \"MTIzAAE=\", name);\n+        // input in escape format\n+        assertEvaluate(\"encode('123\\\\000\\\\001', 'base64')\", \"MTIzAAE=\");\n+        assertEvaluate(\"encode('123', 'base64')\", \"MTIz\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncBase64() {\n+        final Literal<Object> name = Literal.of(DataTypes.STRING, \"MTIzAAE=\");\n+        assertEvaluate(\"decode('MTIzAAE=', 'base64')\", \"\\\\x3132330001\");\n+        assertEvaluate(\"decode('MTIzAAE=', 'BASE64')\", \"\\\\x3132330001\");\n+        assertEvaluate(\"decode(name, 'base64')\", \"\\\\x3132330001\", name);\n+    }\n+\n+    @Test\n+    public void testEncodeFuncHex() {\n+        assertEvaluate(\"encode('\\\\x3132330001', 'hex')\", \"3132330001\");\n+        assertEvaluate(\"encode('123\\\\000\\\\001', 'hex')\", \"3132330001\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncHex() {\n+        assertEvaluate(\"decode('3132330001', 'hex')\", \"\\\\x3132330001\");\n+    }\n+\n+    @Test\n+    public void testEncodeEmpties() {\n+        assertEvaluate(\"encode('', 'base64')\", \"\");\n+        assertEvaluate(\"encode('', 'hex')\", \"\");\n+        assertEvaluate(\"encode('', 'escape')\", \"\");\n+    }\n+\n+    @Test\n+    public void testEncodeFuncEscape() {\n+        assertEvaluate(\"encode('a\\bb\\\\c', 'escape')\", \"a\\\\010b\\\\\\\\c\");\n+        assertEvaluate(\"encode('\\\\x6108625c63', 'escape')\", \"a\\\\010b\\\\\\\\c\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncEscape() {\n+        assertEvaluate(\"decode('a\\\\010b\\\\\\\\c', 'escape')\", \"\\\\x6108625c63\");\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTA5MzExOnYy", "diffSide": "RIGHT", "path": "docs/appendices/release-notes/unreleased.rst", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzozMToyOFrOFiCsqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToxOToxNlrOFiOZ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MDEwNw==", "bodyText": "minor nitpick: new changes should be put in top in the related sections. also we use a 80 char line limit in rst files.", "url": "https://github.com/crate/crate/pull/9540#discussion_r371240107", "createdAt": "2020-01-27T13:31:28Z", "author": {"login": "seut"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -58,6 +58,8 @@ Changes\n - Introduced new optional ``RETURNING`` clause for :ref:`Update <ref-update>` to\n   return specified values from each row updated.\n \n+- Added the :ref:`encode(bytea, format) <scalar-encode>` and :ref:`decode(text, format) <scalar-decode>` string functions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5794deaf824534e8d9d38fda3254e7da90c1f787"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMTkxOA==", "bodyText": "Fixed in the latest commit I squashed.", "url": "https://github.com/crate/crate/pull/9540#discussion_r371431918", "createdAt": "2020-01-27T19:19:16Z", "author": {"login": "scampi"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -58,6 +58,8 @@ Changes\n - Introduced new optional ``RETURNING`` clause for :ref:`Update <ref-update>` to\n   return specified values from each row updated.\n \n+- Added the :ref:`encode(bytea, format) <scalar-encode>` and :ref:`decode(text, format) <scalar-decode>` string functions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MDEwNw=="}, "originalCommit": {"oid": "5794deaf824534e8d9d38fda3254e7da90c1f787"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1131, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}