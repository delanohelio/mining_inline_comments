{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNjA4OTgw", "number": 10708, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo1NDowMVrOEzrvTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowNzo0MFrOE0RMTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjI5NDU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo1NDowMVrOHrEYWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo1NDowMVrOHrEYWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyMjU4NA==", "bodyText": "This isn't streamed and looking at the usages I think being able to change the granularity is currently also not really necessary?", "url": "https://github.com/crate/crate/pull/10708#discussion_r514922584", "createdAt": "2020-10-30T07:54:01Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java", "diffHunk": "@@ -41,6 +42,7 @@\n public class EvalProjection extends Projection {\n \n     private final List<Symbol> outputs;\n+    private RowGranularity requiredGranularity = RowGranularity.CLUSTER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjMxODExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODowMjoxMVrOHrElwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODowMjoxMVrOHrElwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjAxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Symbol> boundOutputs = Lists2.map(\n          \n          \n            \n                        outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n          \n          \n            \n                    var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n          \n          \n            \n                    var binder = new SubQueryAndParamBinder(params, subQueryResults);\n          \n          \n            \n                    List<Symbol> boundOutputs = Lists2.map(outputs, binder)\n          \n          \n            \n                    var boundQuery = binder.convert(query);\n          \n      \n    \n    \n  \n\nAvoids creating 2 SubQueryAndParamBinder instances", "url": "https://github.com/crate/crate/pull/10708#discussion_r514926016", "createdAt": "2020-10-30T08:02:11Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjMxOTc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODowMjo1MFrOHrEmyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTo1MDoyNlrOHrVP4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjI4Mw==", "bodyText": "In which case can ref.ident().tableIdent().equals(tableRelation.relationName()) be false here?", "url": "https://github.com/crate/crate/pull/10708#discussion_r514926283", "createdAt": "2020-10-30T08:02:50Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5ODk0NQ==", "bodyText": "Should, not happen, I'll remove this.", "url": "https://github.com/crate/crate/pull/10708#discussion_r515198945", "createdAt": "2020-10-30T15:50:26Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjI4Mw=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjMzNDUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODowODowNVrOHrEvZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMDozNlrOHr5z-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ==", "bodyText": "I also don't quite understand why this check is necessary. toCollect is a set, so duplicates won't be added anyways?\nIs this under the assumption that the symbol might not be needed because it is only used in the docKeys part? I'm not sure if that assertion is safe. Couldn't the query still use columns from docKeyColumns ?", "url": "https://github.com/crate/crate/pull/10708#discussion_r514928485", "createdAt": "2020-10-30T08:08:05Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NTM2MQ==", "bodyText": "Maybe it would make sense to use something like SymbolVisitors.intersection(query, allPossibleTableOutputs, toCollect::add); ?\nI think that would handle functions better. If you have a SELECT substr(x, ...) WHERE .. (pk = 1 AND substr(x, ..) it wouldn't add x to the outputs I think.", "url": "https://github.com/crate/crate/pull/10708#discussion_r514945361", "createdAt": "2020-10-30T08:44:11Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwMDE2MQ==", "bodyText": "Yep right, good catch. This logic which is intended to only add a filter projection when needed (other columns than DocKeys are part of the query) was not correct. I'll push a new safe logic.", "url": "https://github.com/crate/crate/pull/10708#discussion_r515200161", "createdAt": "2020-10-30T15:52:09Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIyOTg4NQ==", "bodyText": "Pushed a fixup before I saw your recent suggestion with the intersection. If you still think I should go in this direction instead, please shout.", "url": "https://github.com/crate/crate/pull/10708#discussion_r515229885", "createdAt": "2020-10-30T16:40:09Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMzE0Mw==", "bodyText": "And related to WHERE .. (pk = 1 AND substr(x, ..), as the RevVisitor traverses the tree x will be added to the outputs. This query works as expected. Do I miss anything?", "url": "https://github.com/crate/crate/pull/10708#discussion_r515303143", "createdAt": "2020-10-30T18:34:39Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5ODAwOQ==", "bodyText": "I thought something along the lines of\ncreate table tbl (id int primary key, x int);\nselect x from tbl where id = 1 and (_seq_no = 1 or x = 1)\n\nBut that is forbidden.\nOr\nselect x from tbl where id = 1 and (id = 3 or x = 1);\n\nbut that works. So all good \ud83d\udc4d", "url": "https://github.com/crate/crate/pull/10708#discussion_r515798009", "createdAt": "2020-11-02T08:10:36Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjM0MzgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/statement/DeletePlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxMToxOVrOHrE0ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxMToxOVrOHrE0ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyOTg1MA==", "bodyText": "Would it be possible to use the existing SymbolVisitors.any or Symbols.containsColumn  for this?", "url": "https://github.com/crate/crate/pull/10708#discussion_r514929850", "createdAt": "2020-10-30T08:11:19Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/statement/DeletePlanner.java", "diffHunk": "@@ -193,4 +203,32 @@ private static ExecutionPlan deleteByQuery(DocTableRelation table, PlannerContex\n         Collect collect = new Collect(collectPhase, TopN.NO_LIMIT, 0, 1, 1, null);\n         return Merge.ensureOnHandler(collect, context, Collections.singletonList(MergeCountProjection.INSTANCE));\n     }\n+\n+    private static class NonPartitionReferenceDetector extends SymbolVisitor<List<Reference>, Boolean> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjM0ODY2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxMjo1NVrOHrE3lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxMjo1NVrOHrE3lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkzMDU4Mw==", "bodyText": "Isn't this already tested in testUpdateUsingSeqNoRequiresPk (UpdatePlannerTest) ?", "url": "https://github.com/crate/crate/pull/10708#discussion_r514930583", "createdAt": "2020-10-30T08:12:55Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java", "diffHunk": "@@ -126,4 +126,26 @@ public void testSelectWhereSeqNoAndPTWithoutPrimaryKey() throws Exception {\n                                 HttpResponseStatus.BAD_REQUEST,\n                                 4000));\n     }\n+\n+    @Test\n+    public void test_update_where_id_and_seq_missing_primary_term() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjM1MzIxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxNDoyOVrOHrE6SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODoxNDoyOVrOHrE6SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkzMTI3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 2\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(0L));\n          \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 2\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(0L));\n          \n          \n            \n            \n          \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 1\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(1L));\n          \n      \n    \n    \n  \n\nTo have the \"pk lookup matches and query matches\" part covered too.", "url": "https://github.com/crate/crate/pull/10708#discussion_r514931273", "createdAt": "2020-10-30T08:14:29Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java", "diffHunk": "@@ -304,7 +304,14 @@ public void testDeleteByQueryCommaRouting() throws Exception {\n \n         execute(\"select * from explicit_routing\");\n         assertThat(response.rowCount(), is(2L));\n+    }\n \n+    @Test\n+    public void test_select_where_pk_and_additional_filter() {\n+        execute(\"create table t1 (id int primary key, x int) with (refresh_interval=0)\");\n+        execute(\"insert into t1 (id, x) values (1, 1)\");\n+        execute(\"select id from t1 where id = 1 and x = 2\");\n+        assertThat(response.rowCount(), is(0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQzMDg2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/testing/Asserts.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowNzo0MFrOHr5vKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoyMDo0NFrOHr6GfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA==", "bodyText": "Isn't this the same as org.junit.jupiter.api.Assertions.assertThrows ?", "url": "https://github.com/crate/crate/pull/10708#discussion_r515796778", "createdAt": "2020-11-02T08:07:40Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/testing/Asserts.java", "diffHunk": "@@ -40,4 +42,14 @@ public static void assertThrows(Executable executable, Matcher<? super Throwable\n             assertThat(t, matcher);\n         }\n     }\n+\n+    public static void assertThrows(Executable executable, Class<? extends Throwable> type, String subString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eda372b47d75ef09fb7018cf6ff771c1147b5bb4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5OTYzOA==", "bodyText": "On the methods I know of/found, the given message is used as a prefix for a failure output instead of matching the thrown exception message. Or do other assertThrows implementation exists which I'm not aware of?", "url": "https://github.com/crate/crate/pull/10708#discussion_r515799638", "createdAt": "2020-11-02T08:14:17Z", "author": {"login": "seut"}, "path": "server/src/test/java/io/crate/testing/Asserts.java", "diffHunk": "@@ -40,4 +42,14 @@ public static void assertThrows(Executable executable, Matcher<? super Throwable\n             assertThat(t, matcher);\n         }\n     }\n+\n+    public static void assertThrows(Executable executable, Class<? extends Throwable> type, String subString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA=="}, "originalCommit": {"oid": "eda372b47d75ef09fb7018cf6ff771c1147b5bb4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwMjc0OA==", "bodyText": "Oh right \ud83d\udc4d", "url": "https://github.com/crate/crate/pull/10708#discussion_r515802748", "createdAt": "2020-11-02T08:20:44Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/testing/Asserts.java", "diffHunk": "@@ -40,4 +42,14 @@ public static void assertThrows(Executable executable, Matcher<? super Throwable\n             assertThat(t, matcher);\n         }\n     }\n+\n+    public static void assertThrows(Executable executable, Class<? extends Throwable> type, String subString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA=="}, "originalCommit": {"oid": "eda372b47d75ef09fb7018cf6ff771c1147b5bb4"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 989, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}