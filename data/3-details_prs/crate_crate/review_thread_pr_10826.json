{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MTc2MzUw", "number": 10826, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMzozMVrOE9t3QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMDoxNlrOE_GdcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTUwMDE2OnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMzozMVrOH6jbMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMzozMVrOH6jbMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTg1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The ``to_char`` function converts a timestamp, interval or numeric value to\n          \n          \n            \n            The ``to_char`` function converts a timestamp, interval, or numeric value to", "url": "https://github.com/crate/crate/pull/10826#discussion_r531159856", "createdAt": "2020-11-26T17:23:31Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1086,6 +1086,181 @@ It has two variants depending on the type of ``timestamp``:\n     +--------------+------------------+\n     SELECT 1 row in set (... sec)\n \n+\n+``to_char(expression, format_string)``\n+--------------------------------------\n+\n+The ``to_char`` function converts a timestamp, interval or numeric value to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTUwMTIzOnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMzo0NlrOH6jbtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMzo0NlrOH6jbtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTk5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            a timezone), ``interval`` or a ``numeric`` type.\n          \n          \n            \n            a timezone), ``interval``, or a ``numeric`` type.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531159990", "createdAt": "2020-11-26T17:23:46Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1086,6 +1086,181 @@ It has two variants depending on the type of ``timestamp``:\n     +--------------+------------------+\n     SELECT 1 row in set (... sec)\n \n+\n+``to_char(expression, format_string)``\n+--------------------------------------\n+\n+The ``to_char`` function converts a timestamp, interval or numeric value to\n+a string, based on a given format string.\n+\n+Returns: ``text``\n+\n+Synopsis\n+........\n+\n+::\n+\n+    TO_CHAR( expression, format_string )\n+\n+``expression`` can be any value with the type of ``timestamp`` (with or without\n+a timezone), ``interval`` or a ``numeric`` type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTUwMzYzOnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDoyNVrOH6jc6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDoyNVrOH6jc6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2MDI5OA==", "bodyText": "it might be a good idea to mark up all the tokens as literals here?", "url": "https://github.com/crate/crate/pull/10826#discussion_r531160298", "createdAt": "2020-11-26T17:24:25Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1086,6 +1086,181 @@ It has two variants depending on the type of ``timestamp``:\n     +--------------+------------------+\n     SELECT 1 row in set (... sec)\n \n+\n+``to_char(expression, format_string)``\n+--------------------------------------\n+\n+The ``to_char`` function converts a timestamp, interval or numeric value to\n+a string, based on a given format string.\n+\n+Returns: ``text``\n+\n+Synopsis\n+........\n+\n+::\n+\n+    TO_CHAR( expression, format_string )\n+\n+``expression`` can be any value with the type of ``timestamp`` (with or without\n+a timezone), ``interval`` or a ``numeric`` type.\n+\n+Format\n+......\n+\n+The syntax for the ``format_string`` differs based the type of the expression.\n+For ``timestamp`` expressions, the syntax follows that of the `Java DateTimeFormatter`_.\n+For reference, the table of permitted tokens is replicated below:\n+\n++-------+------------------------------+------------------------------------------------+\n+| Token | Meaning                      | Examples                                       |\n++=======+==============================+================================================+\n+| G     | Era                          | AD; Anno Domini; A                             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTUwNDI5OnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDozOVrOH6jdRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDozOVrOH6jdRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2MDM4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For documentation on how to achieve the short, full and narrow forms of the\n          \n          \n            \n            For documentation on how to achieve the short, full, and narrow forms of the", "url": "https://github.com/crate/crate/pull/10826#discussion_r531160388", "createdAt": "2020-11-26T17:24:39Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1086,6 +1086,181 @@ It has two variants depending on the type of ``timestamp``:\n     +--------------+------------------+\n     SELECT 1 row in set (... sec)\n \n+\n+``to_char(expression, format_string)``\n+--------------------------------------\n+\n+The ``to_char`` function converts a timestamp, interval or numeric value to\n+a string, based on a given format string.\n+\n+Returns: ``text``\n+\n+Synopsis\n+........\n+\n+::\n+\n+    TO_CHAR( expression, format_string )\n+\n+``expression`` can be any value with the type of ``timestamp`` (with or without\n+a timezone), ``interval`` or a ``numeric`` type.\n+\n+Format\n+......\n+\n+The syntax for the ``format_string`` differs based the type of the expression.\n+For ``timestamp`` expressions, the syntax follows that of the `Java DateTimeFormatter`_.\n+For reference, the table of permitted tokens is replicated below:\n+\n++-------+------------------------------+------------------------------------------------+\n+| Token | Meaning                      | Examples                                       |\n++=======+==============================+================================================+\n+| G     | Era                          | AD; Anno Domini; A                             |\n++-------+------------------------------+------------------------------------------------+\n+| u     | Year                         | 2020; 20                                       |\n++-------+------------------------------+------------------------------------------------+\n+| y     | Year of Era                  | 2020; 20                                       |\n++-------+------------------------------+------------------------------------------------+\n+| D     | Day of Year                  | 201                                            |\n++-------+------------------------------+------------------------------------------------+\n+| M     | Month of Year (Numeric/Text) | 6; 06; Jul; July                               |\n++-------+------------------------------+------------------------------------------------+\n+| L     | Month of Year (Narrow Text)  | J                                              |\n++-------+------------------------------+------------------------------------------------+\n+| d     | Day of Month                 | 20                                             |\n++-------+------------------------------+------------------------------------------------+\n+| Q     | Quarter of Year (Numeric)    | 2; 02                                          |\n++-------+------------------------------+------------------------------------------------+\n+| q     | Quarter of Year (Text)       | Q2; 2nd quarter                                |\n++-------+------------------------------+------------------------------------------------+\n+| Y     | Week Based Year              | 1996; 96                                       |\n++-------+------------------------------+------------------------------------------------+\n+| w     | Week of Week Based Year      | 27                                             |\n++-------+------------------------------+------------------------------------------------+\n+| W     | Week of Month                | 3                                              |\n++-------+------------------------------+------------------------------------------------+\n+| E     | Day of Week                  | Tue; Tuesday; T                                |\n++-------+------------------------------+------------------------------------------------+\n+| e     | Day of Week (Numeric)        | 2; 02                                          |\n++-------+------------------------------+------------------------------------------------+\n+| F     | Week of Month                | 3                                              |\n++-------+------------------------------+------------------------------------------------+\n+| a     | AM/PM of Day                 | PM                                             |\n++-------+------------------------------+------------------------------------------------+\n+| h     | Clock Hour (1-12)            | 11                                             |\n++-------+------------------------------+------------------------------------------------+\n+| K     | Hour (0-11)                  | 0                                              |\n++-------+------------------------------+------------------------------------------------+\n+| k     | Clock Hour (1-24)            | 23                                             |\n++-------+------------------------------+------------------------------------------------+\n+| H     | Hour of Day (0-23)           | 14                                             |\n++-------+------------------------------+------------------------------------------------+\n+| m     | Minute of Hour               | 30                                             |\n++-------+------------------------------+------------------------------------------------+\n+| s     | Second of Minute             | 55                                             |\n++-------+------------------------------+------------------------------------------------+\n+| S     | Fraction of Second           | 978                                            |\n++-------+------------------------------+------------------------------------------------+\n+| A     | Millisecond of Day           | 1234                                           |\n++-------+------------------------------+------------------------------------------------+\n+| n     | Nanosecond of Second         | 987654321                                      |\n++-------+------------------------------+------------------------------------------------+\n+| N     | Nanosecond of Day            | 1234000000                                     |\n++-------+------------------------------+------------------------------------------------+\n+| V     | Timezone ID                  | America/Los_Angeles; Z; -08:30                 |\n++-------+------------------------------+------------------------------------------------+\n+| z     | Timezone Name                | Pacific Standard Time: PST                     |\n++-------+------------------------------+------------------------------------------------+\n+| O     | Localized Zone-Offset        | GMT+8; GMT+08:00; UTC-08:00;                   |\n++-------+------------------------------+------------------------------------------------+\n+| X     | Zone Offset (Z for zero)     | Z; -08; -0830; -08:30; -083015; -08:30:15;     |\n++-------+------------------------------+------------------------------------------------+\n+| x     | Zone Offset                  | +0000; -08; -0830; -08:30; -083015; -08:30:15; |\n++-------+------------------------------+------------------------------------------------+\n+| Z     | Zone Offset                  | +0000; -0800; -08:00;                          |\n++-------+------------------------------+------------------------------------------------+\n+| p     | Pad Next                     | 1                                              |\n++-------+------------------------------+------------------------------------------------+\n+| '     | Escape for Text              |                                                |\n++-------+------------------------------+------------------------------------------------+\n+| ''    | Single Quote                 | '                                              |\n++-------+------------------------------+------------------------------------------------+\n+| [     | Begin Optional Section       |                                                |\n++-------+------------------------------+------------------------------------------------+\n+| ]     | End Optional Section         |                                                |\n++-------+------------------------------+------------------------------------------------+\n+\n+For documentation on how to achieve the short, full and narrow forms of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTUwNTMwOnYy", "diffSide": "RIGHT", "path": "docs/general/builtins/scalar.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDo1OFrOH6jd1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyNDo1OFrOH6jd1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2MDUzNA==", "bodyText": "same comment as above re marking up symbols as literals", "url": "https://github.com/crate/crate/pull/10826#discussion_r531160534", "createdAt": "2020-11-26T17:24:58Z", "author": {"login": "norosa"}, "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1086,6 +1086,181 @@ It has two variants depending on the type of ``timestamp``:\n     +--------------+------------------+\n     SELECT 1 row in set (... sec)\n \n+\n+``to_char(expression, format_string)``\n+--------------------------------------\n+\n+The ``to_char`` function converts a timestamp, interval or numeric value to\n+a string, based on a given format string.\n+\n+Returns: ``text``\n+\n+Synopsis\n+........\n+\n+::\n+\n+    TO_CHAR( expression, format_string )\n+\n+``expression`` can be any value with the type of ``timestamp`` (with or without\n+a timezone), ``interval`` or a ``numeric`` type.\n+\n+Format\n+......\n+\n+The syntax for the ``format_string`` differs based the type of the expression.\n+For ``timestamp`` expressions, the syntax follows that of the `Java DateTimeFormatter`_.\n+For reference, the table of permitted tokens is replicated below:\n+\n++-------+------------------------------+------------------------------------------------+\n+| Token | Meaning                      | Examples                                       |\n++=======+==============================+================================================+\n+| G     | Era                          | AD; Anno Domini; A                             |\n++-------+------------------------------+------------------------------------------------+\n+| u     | Year                         | 2020; 20                                       |\n++-------+------------------------------+------------------------------------------------+\n+| y     | Year of Era                  | 2020; 20                                       |\n++-------+------------------------------+------------------------------------------------+\n+| D     | Day of Year                  | 201                                            |\n++-------+------------------------------+------------------------------------------------+\n+| M     | Month of Year (Numeric/Text) | 6; 06; Jul; July                               |\n++-------+------------------------------+------------------------------------------------+\n+| L     | Month of Year (Narrow Text)  | J                                              |\n++-------+------------------------------+------------------------------------------------+\n+| d     | Day of Month                 | 20                                             |\n++-------+------------------------------+------------------------------------------------+\n+| Q     | Quarter of Year (Numeric)    | 2; 02                                          |\n++-------+------------------------------+------------------------------------------------+\n+| q     | Quarter of Year (Text)       | Q2; 2nd quarter                                |\n++-------+------------------------------+------------------------------------------------+\n+| Y     | Week Based Year              | 1996; 96                                       |\n++-------+------------------------------+------------------------------------------------+\n+| w     | Week of Week Based Year      | 27                                             |\n++-------+------------------------------+------------------------------------------------+\n+| W     | Week of Month                | 3                                              |\n++-------+------------------------------+------------------------------------------------+\n+| E     | Day of Week                  | Tue; Tuesday; T                                |\n++-------+------------------------------+------------------------------------------------+\n+| e     | Day of Week (Numeric)        | 2; 02                                          |\n++-------+------------------------------+------------------------------------------------+\n+| F     | Week of Month                | 3                                              |\n++-------+------------------------------+------------------------------------------------+\n+| a     | AM/PM of Day                 | PM                                             |\n++-------+------------------------------+------------------------------------------------+\n+| h     | Clock Hour (1-12)            | 11                                             |\n++-------+------------------------------+------------------------------------------------+\n+| K     | Hour (0-11)                  | 0                                              |\n++-------+------------------------------+------------------------------------------------+\n+| k     | Clock Hour (1-24)            | 23                                             |\n++-------+------------------------------+------------------------------------------------+\n+| H     | Hour of Day (0-23)           | 14                                             |\n++-------+------------------------------+------------------------------------------------+\n+| m     | Minute of Hour               | 30                                             |\n++-------+------------------------------+------------------------------------------------+\n+| s     | Second of Minute             | 55                                             |\n++-------+------------------------------+------------------------------------------------+\n+| S     | Fraction of Second           | 978                                            |\n++-------+------------------------------+------------------------------------------------+\n+| A     | Millisecond of Day           | 1234                                           |\n++-------+------------------------------+------------------------------------------------+\n+| n     | Nanosecond of Second         | 987654321                                      |\n++-------+------------------------------+------------------------------------------------+\n+| N     | Nanosecond of Day            | 1234000000                                     |\n++-------+------------------------------+------------------------------------------------+\n+| V     | Timezone ID                  | America/Los_Angeles; Z; -08:30                 |\n++-------+------------------------------+------------------------------------------------+\n+| z     | Timezone Name                | Pacific Standard Time: PST                     |\n++-------+------------------------------+------------------------------------------------+\n+| O     | Localized Zone-Offset        | GMT+8; GMT+08:00; UTC-08:00;                   |\n++-------+------------------------------+------------------------------------------------+\n+| X     | Zone Offset (Z for zero)     | Z; -08; -0830; -08:30; -083015; -08:30:15;     |\n++-------+------------------------------+------------------------------------------------+\n+| x     | Zone Offset                  | +0000; -08; -0830; -08:30; -083015; -08:30:15; |\n++-------+------------------------------+------------------------------------------------+\n+| Z     | Zone Offset                  | +0000; -0800; -08:00;                          |\n++-------+------------------------------+------------------------------------------------+\n+| p     | Pad Next                     | 1                                              |\n++-------+------------------------------+------------------------------------------------+\n+| '     | Escape for Text              |                                                |\n++-------+------------------------------+------------------------------------------------+\n+| ''    | Single Quote                 | '                                              |\n++-------+------------------------------+------------------------------------------------+\n+| [     | Begin Optional Section       |                                                |\n++-------+------------------------------+------------------------------------------------+\n+| ]     | End Optional Section         |                                                |\n++-------+------------------------------+------------------------------------------------+\n+\n+For documentation on how to achieve the short, full and narrow forms of the\n+token outputs, please consult the `Java DateTimeFormatter`_ documentation.\n+\n+::\n+\n+    cr> select to_char(timestamp '1970-01-01T17:31:12', 'EEEE, LLLL d - h:m a uuuu G') as ts;\n+    +---------------------------------------+\n+    | ts                                    |\n+    +---------------------------------------+\n+    | Thursday, January 1 - 5:31 PM 1970 AD |\n+    +---------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+For ``interval`` expressions, the formatting string is discard and the interval\n+is returned in a standard form:\n+\n+::\n+\n+    cr> select to_char(interval '1-2 3 4:5:6', '') as interval;\n+    +------------------------------------------------------------+\n+    | interval                                                   |\n+    +------------------------------------------------------------+\n+    | 1 year, 2 months, 3 days, 4 hours, 5 minutes and 6 seconds |\n+    +------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+For ``numeric`` expressions, the syntax follows that of the `Java DecimalFormat`_.\n+For reference, the table of permitted tokens is replicated below:\n+\n++--------+---------------------+----------------------------------------------------------------------+\n+| Symbol | Location            | Meaning                                                              |\n++========+=====================+======================================================================+\n+| 0      | Number              | Digit                                                                |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzcyMTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOTo1MTowNVrOH63uyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDo0NDo0N1rOH7AyDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg==", "bodyText": "is it absolutely necessary to use joda time? I think we were actually moving away from it in favour of java time.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531492552", "createdAt": "2020-11-27T09:51:05Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyNTE5Ng==", "bodyText": "I wasn't sure - I was following what we've used in other scalar functions that involve intervals such as IntervalArithmeticScalar and IntervalTimestampArithmeticScalar. Totally happy to change it though", "url": "https://github.com/crate/crate/pull/10826#discussion_r531525196", "createdAt": "2020-11-27T10:47:23Z", "author": {"login": "autophagy"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4OTg2Nw==", "bodyText": "Yes, it was used there because it seems that it was hard to go with java time in that case, but in I think the general rule we follow is going with java time if it is possible.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531589867", "createdAt": "2020-11-27T13:03:26Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY0MDg0NA==", "bodyText": "Just looking into it a bit further - would it be okay to use Joda for the time being here? IntervalType.sanitizeValue() itself returns a Joda period, and as far as I can tell converting between a Joda Period and a Java Period isn't super straightforward. Given we also use the Joda PeriodFormat here, maybe it makes sense to stick with Joda in this instance?", "url": "https://github.com/crate/crate/pull/10826#discussion_r531640844", "createdAt": "2020-11-27T14:44:47Z", "author": {"login": "autophagy"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzczNzA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOTo1NToxOVrOH634Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMDoxNDowOVrOH64hjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NDkzMQ==", "bodyText": "What do you think of using BinaryScalar and keeping the evaluate logic a bit more separated instead of having a generic function and then check for the type in the evaluate each time when it is executed? See CoordinateFunction or RoundFunction.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531494931", "createdAt": "2020-11-27T09:55:19Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import io.crate.types.TimestampType;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        Stream.of(DataTypes.NUMERIC_PRIMITIVE_TYPES, List.of(DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP, DataTypes.INTERVAL))\n+            .flatMap(Collection::stream)\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ), ToCharFunction::new\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<Object>... args) {\n+        Literal expression = (Literal) args[0];\n+        int dataType = expression.valueType().id();\n+        if (TimestampType.ID_WITH_TZ == dataType) {\n+            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(String.valueOf(args[1].value()),\n+                                                                      Locale.ENGLISH);\n+            Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(args[0].value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNTU0OA==", "bodyText": "Aha! Yeah, I was just about to push a fixup where the evaluation logic was part of the registration step, rather than the evaluation step for every row. Thanks for the heads up \ud83d\ude42", "url": "https://github.com/crate/crate/pull/10826#discussion_r531505548", "createdAt": "2020-11-27T10:14:09Z", "author": {"login": "autophagy"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import io.crate.types.TimestampType;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        Stream.of(DataTypes.NUMERIC_PRIMITIVE_TYPES, List.of(DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP, DataTypes.INTERVAL))\n+            .flatMap(Collection::stream)\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ), ToCharFunction::new\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<Object>... args) {\n+        Literal expression = (Literal) args[0];\n+        int dataType = expression.valueType().id();\n+        if (TimestampType.ID_WITH_TZ == dataType) {\n+            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(String.valueOf(args[1].value()),\n+                                                                      Locale.ENGLISH);\n+            Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(args[0].value());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NDkzMQ=="}, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzc0MjE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOTo1NjozNFrOH637JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOTo1NjozNFrOH637JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NTcxNw==", "bodyText": "it can result in NPE. You would have to do the null check yourself or if you use BinaryScalar, this case will be already taken care of.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531495717", "createdAt": "2020-11-27T09:56:34Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import io.crate.types.TimestampType;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        Stream.of(DataTypes.NUMERIC_PRIMITIVE_TYPES, List.of(DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP, DataTypes.INTERVAL))\n+            .flatMap(Collection::stream)\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ), ToCharFunction::new\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<Object>... args) {\n+        Literal expression = (Literal) args[0];\n+        int dataType = expression.valueType().id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608b67d42fdffcabfe1e399338d69c86427c0e69"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDM0NDQ0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/expression/scalar/ToCharFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzowMDoxNVrOH69lig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzowMDoxNVrOH69lig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4ODQ5MA==", "bodyText": "maybe we can add some tests for the corner cases, like null handling, etc.", "url": "https://github.com/crate/crate/pull/10826#discussion_r531588490", "createdAt": "2020-11-27T13:00:15Z", "author": {"login": "kovrus"}, "path": "server/src/test/java/io/crate/expression/scalar/ToCharFunctionTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import org.junit.Test;\n+\n+\n+public class ToCharFunctionTest extends AbstractScalarFunctionsTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82758a538ff1f330fc1f1a928b866ce761e8b164"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTIzMTA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzowNTozNFrOH76OYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzowNTozNFrOH76OYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MTk4NQ==", "bodyText": "you do not really have to pass the argument type explicitly, you can already get it from the bound signature.\nassert boundSignature.getArgumentDataTypes().size() == 1\nboundSignature.getArgumentDataTypes().get(0)", "url": "https://github.com/crate/crate/pull/10826#discussion_r532581985", "createdAt": "2020-11-30T13:05:34Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTIzNTg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzowNjo0OVrOH76RNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDo1Nzo1NlrOH8nRsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ==", "bodyText": "maybe we can reuse an instance of PeriodFormatter instead of initializing it on each function call.", "url": "https://github.com/crate/crate/pull/10826#discussion_r532582711", "createdAt": "2020-11-30T13:06:49Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;\n+        this.evaluatorFunc = evaluatorFunc;\n+    }\n+\n+    private static String evaluateTimestamp(Object timestamp, String pattern) {\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern,\n+                                                                  Locale.ENGLISH);\n+        Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(timestamp);\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts),\n+                                                         TimeZone.getTimeZone(\"UTC\").toZoneId());\n+        return formatter.format(dateTime);\n+    }\n+\n+    private static String evaluateInterval(Object interval, String pattern) {\n+        PeriodFormatter formatter = PeriodFormat.getDefault();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIxMDQyOQ==", "bodyText": "That would prevent the function from being static, right?", "url": "https://github.com/crate/crate/pull/10826#discussion_r533210429", "createdAt": "2020-12-01T09:25:18Z", "author": {"login": "autophagy"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;\n+        this.evaluatorFunc = evaluatorFunc;\n+    }\n+\n+    private static String evaluateTimestamp(Object timestamp, String pattern) {\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern,\n+                                                                  Locale.ENGLISH);\n+        Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(timestamp);\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts),\n+                                                         TimeZone.getTimeZone(\"UTC\").toZoneId());\n+        return formatter.format(dateTime);\n+    }\n+\n+    private static String evaluateInterval(Object interval, String pattern) {\n+        PeriodFormatter formatter = PeriodFormat.getDefault();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}, "originalCommit": {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxNzA5Ng==", "bodyText": "not really, you would have to do smth like:\nprivate static final PeriodFormatter PERIOD_FORMATTER = PeriodFormat.getDefault();", "url": "https://github.com/crate/crate/pull/10826#discussion_r533317096", "createdAt": "2020-12-01T10:52:59Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;\n+        this.evaluatorFunc = evaluatorFunc;\n+    }\n+\n+    private static String evaluateTimestamp(Object timestamp, String pattern) {\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern,\n+                                                                  Locale.ENGLISH);\n+        Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(timestamp);\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts),\n+                                                         TimeZone.getTimeZone(\"UTC\").toZoneId());\n+        return formatter.format(dateTime);\n+    }\n+\n+    private static String evaluateInterval(Object interval, String pattern) {\n+        PeriodFormatter formatter = PeriodFormat.getDefault();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}, "originalCommit": {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyMDExNQ==", "bodyText": "Ah, of course \ud83e\udd26\u200d\u2640\ufe0f", "url": "https://github.com/crate/crate/pull/10826#discussion_r533320115", "createdAt": "2020-12-01T10:57:56Z", "author": {"login": "autophagy"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;\n+        this.evaluatorFunc = evaluatorFunc;\n+    }\n+\n+    private static String evaluateTimestamp(Object timestamp, String pattern) {\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern,\n+                                                                  Locale.ENGLISH);\n+        Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(timestamp);\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts),\n+                                                         TimeZone.getTimeZone(\"UTC\").toZoneId());\n+        return formatter.format(dateTime);\n+    }\n+\n+    private static String evaluateInterval(Object interval, String pattern) {\n+        PeriodFormatter formatter = PeriodFormat.getDefault();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}, "originalCommit": {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjAxNTg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMDoxNlrOH8nthQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMDoxNlrOH8nthQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNzIzNw==", "bodyText": "maybe add a message to the assertion, otherwise ack", "url": "https://github.com/crate/crate/pull/10826#discussion_r533327237", "createdAt": "2020-12-01T11:10:16Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    private static final PeriodFormatter PERIOD_FORMATTER = PeriodFormat.getDefault();\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        assert boundSignature.getArgumentDataTypes().size() == 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30297ccccde26a4641aadf9675c472e1d37eaaa1"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 937, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}