{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3ODU4NTc4", "number": 10481, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMzo1NjowM1rOEg8gAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0NDoxN1rOEhGnUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTgxMTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMzo1NjowM1rOHOAQkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMTowMToyMFrOHOHkWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NjM1NA==", "bodyText": "I wonder if we have a potential double-close issue here. I think after the collectTask.addSearcher(sharedShardContext.readerId(), searcher); call the searcher will be closed as part of the collectTask.\nThis is probably also the case in the other places where we have the same setup pattern - so may not be exclusively to this PR now and we can also follow up on it later.", "url": "https://github.com/crate/crate/pull/10481#discussion_r484446354", "createdAt": "2020-09-07T13:56:03Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {\n+            var keyColumnRef = (Reference) DocReferences.inverseSourceLookup(keyRef);\n+            MappedFieldType keyFieldType = fieldTypeLookup.get(keyRef.column().fqn());\n+            if (keyFieldType == null || !keyFieldType.hasDocValues()) {\n+                return null;\n+            } else {\n+                columnKeyRefs.add(keyColumnRef);\n+            }\n+        }\n+\n+        //noinspection rawtypes\n+        List<DocValueAggregator> aggregators = DocValuesAggregates.createAggregators(\n+            functions,\n+            groupProjection.values(),\n+            fieldTypeLookup,\n+            collectPhase.toCollect(),\n+            collectTask.txnCtx().sessionSettings().searchPath()\n+        );\n+        if (aggregators == null) {\n+            return null;\n+        }\n+\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)\n+            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {\n+            return null;\n+        }\n+\n+        ShardId shardId = indexShard.shardId();\n+        SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);\n+        Engine.Searcher searcher = sharedShardContext.acquireSearcher(formatSource(collectPhase));\n+\n+        try {\n+            QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();\n+            collectTask.addSearcher(sharedShardContext.readerId(), searcher);\n+\n+            InputFactory.Context<? extends LuceneCollectorExpression<?>> docCtx\n+                = docInputFactory.getCtx(collectTask.txnCtx());\n+            docCtx.add(columnKeyRefs);\n+            List<? extends LuceneCollectorExpression<?>> keyExpressions = docCtx.expressions();\n+\n+            LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(\n+                collectPhase.where(),\n+                collectTask.txnCtx(),\n+                indexShard.mapperService(),\n+                indexShard.shardId().getIndexName(),\n+                queryShardContext,\n+                table,\n+                sharedShardContext.indexService().cache()\n+            );\n+\n+            var ramAccounting = collectTask.getRamAccounting();\n+            if (columnKeyRefs.size() == 1) {\n+                return GroupByIterator.forSingleKey(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs.get(0),\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            } else {\n+                return GroupByIterator.forManyKeys(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs,\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            }\n+        } catch (Throwable t) {\n+            searcher.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NjEwNA==", "bodyText": "\ud83d\udc4d added it into the follow-up list. i'll check it later.", "url": "https://github.com/crate/crate/pull/10481#discussion_r484566104", "createdAt": "2020-09-07T21:01:20Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {\n+            var keyColumnRef = (Reference) DocReferences.inverseSourceLookup(keyRef);\n+            MappedFieldType keyFieldType = fieldTypeLookup.get(keyRef.column().fqn());\n+            if (keyFieldType == null || !keyFieldType.hasDocValues()) {\n+                return null;\n+            } else {\n+                columnKeyRefs.add(keyColumnRef);\n+            }\n+        }\n+\n+        //noinspection rawtypes\n+        List<DocValueAggregator> aggregators = DocValuesAggregates.createAggregators(\n+            functions,\n+            groupProjection.values(),\n+            fieldTypeLookup,\n+            collectPhase.toCollect(),\n+            collectTask.txnCtx().sessionSettings().searchPath()\n+        );\n+        if (aggregators == null) {\n+            return null;\n+        }\n+\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)\n+            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {\n+            return null;\n+        }\n+\n+        ShardId shardId = indexShard.shardId();\n+        SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);\n+        Engine.Searcher searcher = sharedShardContext.acquireSearcher(formatSource(collectPhase));\n+\n+        try {\n+            QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();\n+            collectTask.addSearcher(sharedShardContext.readerId(), searcher);\n+\n+            InputFactory.Context<? extends LuceneCollectorExpression<?>> docCtx\n+                = docInputFactory.getCtx(collectTask.txnCtx());\n+            docCtx.add(columnKeyRefs);\n+            List<? extends LuceneCollectorExpression<?>> keyExpressions = docCtx.expressions();\n+\n+            LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(\n+                collectPhase.where(),\n+                collectTask.txnCtx(),\n+                indexShard.mapperService(),\n+                indexShard.shardId().getIndexName(),\n+                queryShardContext,\n+                table,\n+                sharedShardContext.indexService().cache()\n+            );\n+\n+            var ramAccounting = collectTask.getRamAccounting();\n+            if (columnKeyRefs.size() == 1) {\n+                return GroupByIterator.forSingleKey(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs.get(0),\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            } else {\n+                return GroupByIterator.forManyKeys(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs,\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            }\n+        } catch (Throwable t) {\n+            searcher.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NjM1NA=="}, "originalCommit": {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTgxNjQyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIteratorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMzo1NzoyN1rOHOAThw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMzo1NzoyN1rOHOAThw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NzExMQ==", "bodyText": "there are already pretty many group by integrations tests already.", "url": "https://github.com/crate/crate/pull/10481#discussion_r484447111", "createdAt": "2020-09-07T13:57:27Z", "author": {"login": "kovrus"}, "path": "server/src/test/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIteratorTest.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.Row;\n+import io.crate.execution.engine.aggregation.impl.SumAggregation;\n+import io.crate.expression.reference.doc.lucene.BytesRefColumnReference;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LongColumnReference;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.ReferenceIdent;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.RowGranularity;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.TestingRowConsumer;\n+import io.crate.types.DataTypes;\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.NumericDocValuesField;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.ByteBuffersDirectory;\n+import org.elasticsearch.common.lucene.BytesRefs;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static io.crate.testing.TestingHelpers.createNodeContext;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class DocValuesGroupByOptimizedIteratorTest extends CrateDummyClusterServiceUnitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDA3MDc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNToxMjowM1rOHOCs6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNToxMjowM1rOHOCs6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NjM3OA==", "bodyText": "this could be merged-into the loop below and thus would eliminate the docKeyRefs list and would avoid another loop.", "url": "https://github.com/crate/crate/pull/10481#discussion_r484486378", "createdAt": "2020-09-07T15:12:03Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDA3NTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNToxMzo0MVrOHOCvvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNToxMzo0MVrOHOCvvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NzEwMg==", "bodyText": "I think this could be checked at the very first to avoid unnecessary logic", "url": "https://github.com/crate/crate/pull/10481#discussion_r484487102", "createdAt": "2020-09-07T15:13:41Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {\n+            var keyColumnRef = (Reference) DocReferences.inverseSourceLookup(keyRef);\n+            MappedFieldType keyFieldType = fieldTypeLookup.get(keyRef.column().fqn());\n+            if (keyFieldType == null || !keyFieldType.hasDocValues()) {\n+                return null;\n+            } else {\n+                columnKeyRefs.add(keyColumnRef);\n+            }\n+        }\n+\n+        //noinspection rawtypes\n+        List<DocValueAggregator> aggregators = DocValuesAggregates.createAggregators(\n+            functions,\n+            groupProjection.values(),\n+            fieldTypeLookup,\n+            collectPhase.toCollect(),\n+            collectTask.txnCtx().sessionSettings().searchPath()\n+        );\n+        if (aggregators == null) {\n+            return null;\n+        }\n+\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)\n+            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ2ODMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0NDoxN1rOHOO2dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzozNToxOVrOHOQcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTQzMQ==", "bodyText": "why not as the very first check even before checking for shard projections?", "url": "https://github.com/crate/crate/pull/10481#discussion_r484685431", "createdAt": "2020-09-08T06:44:17Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -98,24 +97,23 @@\n             return null;\n         }\n \n-        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n-        for (var key : groupProjection.keys()) {\n-            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n-            if (keyRef == null) {\n-                return null; // group by on non-reference\n-            } else {\n-                docKeyRefs.add(keyRef);\n-            }\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cf692f5cb2a8fbd82e5d2c4368f33e167a8f34"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMTUyMQ==", "bodyText": "ah true, changed it and squashed the fixup", "url": "https://github.com/crate/crate/pull/10481#discussion_r484711521", "createdAt": "2020-09-08T07:35:19Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -98,24 +97,23 @@\n             return null;\n         }\n \n-        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n-        for (var key : groupProjection.keys()) {\n-            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n-            if (keyRef == null) {\n-                return null; // group by on non-reference\n-            } else {\n-                docKeyRefs.add(keyRef);\n-            }\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTQzMQ=="}, "originalCommit": {"oid": "76cf692f5cb2a8fbd82e5d2c4368f33e167a8f34"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1199, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}