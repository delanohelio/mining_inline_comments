{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Mjg3MTQ4", "number": 9833, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjozMzo0MFrODtFj_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjozMzo0MFrODtFj_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NjAzNjQ2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/engine/collect/PKLookupOperation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjozMzo0MFrOF-Thow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjo0MDo0NVrOF-Tywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NTkzOQ==", "bodyText": "isn't projectors.wrap(...) missing here?", "url": "https://github.com/crate/crate/pull/9833#discussion_r400875939", "createdAt": "2020-03-31T12:33:40Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/engine/collect/PKLookupOperation.java", "diffHunk": "@@ -177,60 +135,46 @@ public void runWithShardProjections(UUID jobId,\n                 }\n                 throw new ShardNotFoundException(shardId);\n             }\n-            try {\n-                shardAndIdsList.add(\n-                    new ShardAndIds(\n-                        shard,\n-                        shardCollectSource.getProjectorFactory(shardId),\n-                        idsByShardEntry.getValue()\n-                    ));\n-            } catch (ShardNotFoundException e) {\n-                if (ignoreMissing) {\n-                    continue;\n-                }\n-                throw e;\n-            }\n-        }\n-        ArrayList<BatchIterator<Row>> iterators = new ArrayList<>(shardAndIdsList.size());\n-        for (ShardAndIds shardAndIds : shardAndIdsList) {\n-            Stream<Row> rowStream = shardAndIds.value.stream()\n-                .map(pkAndVersion -> lookupDoc(shardAndIds.shard,\n-                                               pkAndVersion.id(),\n-                                               pkAndVersion.version(),\n-                                               pkAndVersion.seqNo(),\n-                                               pkAndVersion.primaryTerm()))\n+            Stream<Row> rowStream = idsByShardEntry.getValue().stream()\n+                .map(pkAndVersion -> lookupDoc(\n+                    shard,\n+                    pkAndVersion.id(),\n+                    pkAndVersion.version(),\n+                    VersionType.EXTERNAL,\n+                    pkAndVersion.seqNo(),\n+                    pkAndVersion.primaryTerm()))\n+                .filter(Objects::nonNull)\n                 .map(resultToRow);\n \n-            Projectors projectors = new Projectors(\n-                projections,\n-                jobId,\n-                txnCtx,\n-                ramAccountingSupplier.get(),\n-                memoryManagerSupplier.get(),\n-                shardAndIds.projectorFactory);\n-            final Iterable<Row> rowIterable;\n-            if (nodeConsumer.requiresScroll() && !projectors.providesIndependentScroll()) {\n-                rowIterable = rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList());\n+            if (projections.isEmpty()) {\n+                final Iterable<Row> rowIterable = requiresScroll\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));\n             } else {\n-                rowIterable = rowStream::iterator;\n+                ProjectorFactory projectorFactory;\n+                try {\n+                    projectorFactory = shardCollectSource.getProjectorFactory(shardId);\n+                } catch (ShardNotFoundException e) {\n+                    if (ignoreMissing) {\n+                        continue;\n+                    }\n+                    throw e;\n+                }\n+                Projectors projectors = new Projectors(\n+                    projections,\n+                    jobId,\n+                    txnCtx,\n+                    ramAccountingSupplier.get(),\n+                    memoryManagerSupplier.get(),\n+                    projectorFactory);\n+                final Iterable<Row> rowIterable = requiresScroll && !projectors.providesIndependentScroll()\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3cd47440ef75d363e53faf3405f8eb2ab449bc"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4MDMyMg==", "bodyText": "Right. Too much back & forth. I'll also append some changes that this code is actually used again.", "url": "https://github.com/crate/crate/pull/9833#discussion_r400880322", "createdAt": "2020-03-31T12:40:45Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/engine/collect/PKLookupOperation.java", "diffHunk": "@@ -177,60 +135,46 @@ public void runWithShardProjections(UUID jobId,\n                 }\n                 throw new ShardNotFoundException(shardId);\n             }\n-            try {\n-                shardAndIdsList.add(\n-                    new ShardAndIds(\n-                        shard,\n-                        shardCollectSource.getProjectorFactory(shardId),\n-                        idsByShardEntry.getValue()\n-                    ));\n-            } catch (ShardNotFoundException e) {\n-                if (ignoreMissing) {\n-                    continue;\n-                }\n-                throw e;\n-            }\n-        }\n-        ArrayList<BatchIterator<Row>> iterators = new ArrayList<>(shardAndIdsList.size());\n-        for (ShardAndIds shardAndIds : shardAndIdsList) {\n-            Stream<Row> rowStream = shardAndIds.value.stream()\n-                .map(pkAndVersion -> lookupDoc(shardAndIds.shard,\n-                                               pkAndVersion.id(),\n-                                               pkAndVersion.version(),\n-                                               pkAndVersion.seqNo(),\n-                                               pkAndVersion.primaryTerm()))\n+            Stream<Row> rowStream = idsByShardEntry.getValue().stream()\n+                .map(pkAndVersion -> lookupDoc(\n+                    shard,\n+                    pkAndVersion.id(),\n+                    pkAndVersion.version(),\n+                    VersionType.EXTERNAL,\n+                    pkAndVersion.seqNo(),\n+                    pkAndVersion.primaryTerm()))\n+                .filter(Objects::nonNull)\n                 .map(resultToRow);\n \n-            Projectors projectors = new Projectors(\n-                projections,\n-                jobId,\n-                txnCtx,\n-                ramAccountingSupplier.get(),\n-                memoryManagerSupplier.get(),\n-                shardAndIds.projectorFactory);\n-            final Iterable<Row> rowIterable;\n-            if (nodeConsumer.requiresScroll() && !projectors.providesIndependentScroll()) {\n-                rowIterable = rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList());\n+            if (projections.isEmpty()) {\n+                final Iterable<Row> rowIterable = requiresScroll\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));\n             } else {\n-                rowIterable = rowStream::iterator;\n+                ProjectorFactory projectorFactory;\n+                try {\n+                    projectorFactory = shardCollectSource.getProjectorFactory(shardId);\n+                } catch (ShardNotFoundException e) {\n+                    if (ignoreMissing) {\n+                        continue;\n+                    }\n+                    throw e;\n+                }\n+                Projectors projectors = new Projectors(\n+                    projections,\n+                    jobId,\n+                    txnCtx,\n+                    ramAccountingSupplier.get(),\n+                    memoryManagerSupplier.get(),\n+                    projectorFactory);\n+                final Iterable<Row> rowIterable = requiresScroll && !projectors.providesIndependentScroll()\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NTkzOQ=="}, "originalCommit": {"oid": "ae3cd47440ef75d363e53faf3405f8eb2ab449bc"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1573, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}