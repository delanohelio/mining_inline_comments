{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMTc0OTQ0", "number": 10076, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MjoyNFrOEEw89g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMjozODoyN1rOEFhLMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDMxNzk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/operators/Collect.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MjoyNFrOGil2Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MjoyNFrOGil2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNDg0Nw==", "bodyText": "I wonder if we should trigger it inside the WhereClauseOptimizer instead to avoid to trigger it in 3 (select/update/delete) plans.", "url": "https://github.com/crate/crate/pull/10076#discussion_r438924847", "createdAt": "2020-06-11T16:42:24Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/Collect.java", "diffHunk": "@@ -258,7 +260,7 @@ private RoutedCollectPhase createPhase(PlannerContext plannerContext, java.util.\n                 ? Lists2.map(boundOutputs, DocReferences::toSourceLookup)\n                 : boundOutputs,\n             Collections.emptyList(),\n-            where.queryOrFallback(),\n+            Optimizer.optimizeQuery(plannerContext, where.queryOrFallback()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTE5NjY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNDoyNFrOGiutIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNDoyNFrOGiutIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2OTk4NQ==", "bodyText": "Maybe we could create a new symbol or expression package within optimizer.\nThis stuff isn't necessarily reserved for the collect pieces.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439069985", "createdAt": "2020-06-11T21:04:24Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTE5OTcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNTozN1rOGiuvFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMToxNzo0MFrOGjAa-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDQ4Nw==", "bodyText": "() -> Version.CURRENT isn't the minNodeVersionInCluster. Is this correct?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439070487", "createdAt": "2020-06-11T21:05:37Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.analyze.expressions.ExpressionAnalyzer;\n+import io.crate.common.collections.Lists2;\n+import io.crate.exceptions.ConversionException;\n+import io.crate.expression.symbol.FunctionCopyVisitor;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.PlannerContext;\n+import io.crate.planner.optimizer.collect.rule.MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveSubscriptOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Match;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class Optimizer {\n+\n+    public static Symbol optimizeQuery(PlannerContext plannerContext, Symbol query) {\n+        Optimizer optimizer = new Optimizer(\n+            plannerContext.functions(),\n+            plannerContext.transactionContext(),\n+            () -> Version.CURRENT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MDI0OA==", "bodyText": "Yep, good catch.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439360248", "createdAt": "2020-06-12T11:17:40Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.analyze.expressions.ExpressionAnalyzer;\n+import io.crate.common.collections.Lists2;\n+import io.crate.exceptions.ConversionException;\n+import io.crate.expression.symbol.FunctionCopyVisitor;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.PlannerContext;\n+import io.crate.planner.optimizer.collect.rule.MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveSubscriptOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Match;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class Optimizer {\n+\n+    public static Symbol optimizeQuery(PlannerContext plannerContext, Symbol query) {\n+        Optimizer optimizer = new Optimizer(\n+            plannerContext.functions(),\n+            plannerContext.transactionContext(),\n+            () -> Version.CURRENT,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDQ4Nw=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTIwMzAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNjo0OVrOGiuxLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNjo0OVrOGiuxLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MTAyMQ==", "bodyText": "Based on the types and name it is hard to guess what String and List<Symbol>, Symbol here are referring to. Maybe it would be worth to introduce a named specific interface?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439071021", "createdAt": "2020-06-11T21:06:49Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.analyze.expressions.ExpressionAnalyzer;\n+import io.crate.common.collections.Lists2;\n+import io.crate.exceptions.ConversionException;\n+import io.crate.expression.symbol.FunctionCopyVisitor;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.PlannerContext;\n+import io.crate.planner.optimizer.collect.rule.MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveSubscriptOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Match;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class Optimizer {\n+\n+    public static Symbol optimizeQuery(PlannerContext plannerContext, Symbol query) {\n+        Optimizer optimizer = new Optimizer(\n+            plannerContext.functions(),\n+            plannerContext.transactionContext(),\n+            () -> Version.CURRENT,\n+            List.of(\n+                MoveReferenceCastToLiteralCastInsideOperators::new,\n+                MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference::new,\n+                MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference::new,\n+                MoveSubscriptOnReferenceCastToLiteralCastInsideOperators::new,\n+                MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators::new\n+            )\n+        );\n+        return optimizer.optimize(query);\n+    }\n+\n+    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n+\n+    private final List<Rule<?>> rules;\n+    private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n+    private final Visitor visitor = new Visitor();\n+\n+    public Optimizer(Functions functions,\n+                     CoordinatorTxnCtx coordinatorTxnCtx,\n+                     Supplier<Version> minNodeVersionInCluster,\n+                     List<Function<BiFunction<String, List<Symbol>, Symbol>, Rule<?>>> rules) {\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTIxNDE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/collect/rule/MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToxMTowN1rOGiu4Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODo1MzoxM1rOGjpDQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA==", "bodyText": "Should we try to create some \"matcher\" functions, similar to how isFunction(name, argMatcher...) works that we use in the tests?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439072834", "createdAt": "2020-06-11T21:11:07Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/rule/MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect.rule;\n+\n+import io.crate.expression.scalar.ArrayUpperFunction;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.collect.Rule;\n+import io.crate.planner.optimizer.matcher.Capture;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+\n+import static io.crate.expression.operator.Operators.COMPARISON_OPERATORS;\n+import static io.crate.expression.scalar.cast.CastFunctionResolver.CAST_FUNCTION_NAMES;\n+import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n+\n+\n+public class MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators implements Rule<Function> {\n+\n+    private final Capture<Function> castCapture;\n+    private final Pattern<Function> pattern;\n+    private final BiFunction<String, List<Symbol>, Symbol> functionResolver;\n+    private volatile boolean enabled = true;\n+\n+    public MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators(\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver\n+    ) {\n+        this.functionResolver = functionResolver;\n+        this.castCapture = new Capture<>();\n+        this.pattern = typeOf(Function.class)\n+            .with(f -> COMPARISON_OPERATORS.contains(f.info().ident().name()))\n+            .with(f -> f.arguments().get(1).symbolType() == SymbolType.LITERAL)\n+            .with(f -> Optional.of(f.arguments().get(0)), typeOf(Function.class).capturedAs(castCapture)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMyMDc4NA==", "bodyText": "Good idea, will try.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439320784", "createdAt": "2020-06-12T09:48:59Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/rule/MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect.rule;\n+\n+import io.crate.expression.scalar.ArrayUpperFunction;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.collect.Rule;\n+import io.crate.planner.optimizer.matcher.Capture;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+\n+import static io.crate.expression.operator.Operators.COMPARISON_OPERATORS;\n+import static io.crate.expression.scalar.cast.CastFunctionResolver.CAST_FUNCTION_NAMES;\n+import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n+\n+\n+public class MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators implements Rule<Function> {\n+\n+    private final Capture<Function> castCapture;\n+    private final Pattern<Function> pattern;\n+    private final BiFunction<String, List<Symbol>, Symbol> functionResolver;\n+    private volatile boolean enabled = true;\n+\n+    public MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators(\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver\n+    ) {\n+        this.functionResolver = functionResolver;\n+        this.castCapture = new Capture<>();\n+        this.pattern = typeOf(Function.class)\n+            .with(f -> COMPARISON_OPERATORS.contains(f.info().ident().name()))\n+            .with(f -> f.arguments().get(1).symbolType() == SymbolType.LITERAL)\n+            .with(f -> Optional.of(f.arguments().get(0)), typeOf(Function.class).capturedAs(castCapture)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNTkyMA==", "bodyText": "I'd suggest to do this as a follow up so we first could get this functionality merged in and finish up the complete function registry overhaul (move missing functions, afaik only operators left).", "url": "https://github.com/crate/crate/pull/10076#discussion_r440025920", "createdAt": "2020-06-15T08:53:13Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/rule/MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect.rule;\n+\n+import io.crate.expression.scalar.ArrayUpperFunction;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.collect.Rule;\n+import io.crate.planner.optimizer.matcher.Capture;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+\n+import static io.crate.expression.operator.Operators.COMPARISON_OPERATORS;\n+import static io.crate.expression.scalar.cast.CastFunctionResolver.CAST_FUNCTION_NAMES;\n+import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n+\n+\n+public class MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators implements Rule<Function> {\n+\n+    private final Capture<Function> castCapture;\n+    private final Pattern<Function> pattern;\n+    private final BiFunction<String, List<Symbol>, Symbol> functionResolver;\n+    private volatile boolean enabled = true;\n+\n+    public MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators(\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver\n+    ) {\n+        this.functionResolver = functionResolver;\n+        this.castCapture = new Capture<>();\n+        this.pattern = typeOf(Function.class)\n+            .with(f -> COMPARISON_OPERATORS.contains(f.info().ident().name()))\n+            .with(f -> f.arguments().get(1).symbolType() == SymbolType.LITERAL)\n+            .with(f -> Optional.of(f.arguments().get(0)), typeOf(Function.class).capturedAs(castCapture)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTIzMTk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToxODoxM1rOGivDuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowOToyOVrOGjngrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ==", "bodyText": "Is this to assign the name with the predicate? (Just to make sure I understand why this is being changed)\nI'm not sure I see the benefit of doing this in this new way?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439075771", "createdAt": "2020-06-11T21:18:13Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxMDEyNA==", "bodyText": "We need to match inside the rule predicates again a list of all full-qualified internal operator names. (https://github.com/crate/crate/pull/10076/files#diff-cc8e036acde8edb2dfa2dd74f78d3336R40)\nAlso by doing it this way we just can loop over the enum to register the operators.\nWe could also do this in a concrete way (like it was before) and additionally store a list of the operator names. I guess this is a bit of personal preference, no strong opinion here.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439310124", "createdAt": "2020-06-12T09:26:15Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMDY4Ng==", "bodyText": "We need to match inside the rule predicates again a list of all full-qualified internal operator names\n\nAh I missed that.\nCould we now also remove the Names class and refer to the enum directly instead?", "url": "https://github.com/crate/crate/pull/10076#discussion_r440000686", "createdAt": "2020-06-15T08:09:29Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI0MTc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyMjowNFrOGivKBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyMjowNFrOGivKBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NzM4MQ==", "bodyText": "Looks like this is only used in tests. Maybe annotate with @VisibleForTesting", "url": "https://github.com/crate/crate/pull/10076#discussion_r439077381", "createdAt": "2020-06-11T21:22:04Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {\n+        EQ(ComparisonExpression.Type.EQUAL, result -> result == 0),\n+        NEQ(ComparisonExpression.Type.NOT_EQUAL, result -> result != 0),\n+        GTE(ComparisonExpression.Type.GREATER_THAN_OR_EQUAL, result -> result >= 0),\n+        GT(ComparisonExpression.Type.GREATER_THAN, result -> result > 0),\n+        LTE(ComparisonExpression.Type.LESS_THAN_OR_EQUAL, result -> result <= 0),\n+        LT(ComparisonExpression.Type.LESS_THAN, result -> result < 0);\n+\n+        final String fullQualifiedName;\n+        final String name;\n+        final IntPredicate cmp;\n+\n+        Type(ComparisonExpression.Type type, IntPredicate cmp) {\n+            this.fullQualifiedName = OPERATOR_PREFIX + type.getValue();\n+            this.name = type.getValue();\n+            this.cmp = cmp;\n+        }\n+\n+        public static List<String> fullQualifiedNames() {\n+            return Lists2.map(Arrays.asList(values()), t -> t.fullQualifiedName);\n+        }\n+\n+        public static List<String> operatorSymbols() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI1MTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/expression/symbol/Symbols.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyNTozOVrOGivP9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODoxMDoxNlrOGjnigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg==", "bodyText": "Looks like in the call-sites of this we're now creating comparisons where the types don't match. Shouldn't they still be adjusted somehow?\nI'm afraid that this might bite us later if we don't do that.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439078902", "createdAt": "2020-06-11T21:25:39Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/expression/symbol/Symbols.java", "diffHunk": "@@ -170,6 +172,14 @@ public static String format(String messageTmpl, Symbol... symbols) {\n         return String.format(Locale.ENGLISH, messageTmpl, formattedSymbols);\n     }\n \n+    public static Symbol unwrapReferenceFromCast(Symbol symbol) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMwNzIyNw==", "bodyText": "It is only used to extract primary key columns or columns which generated column expressions are including/targeting to expand queries with the generated column. So the symbol tree will not be changed, the expanded generated column will still take the original comparison into account. Do I maybe miss something?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439307227", "createdAt": "2020-06-12T09:19:54Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/expression/symbol/Symbols.java", "diffHunk": "@@ -170,6 +172,14 @@ public static String format(String messageTmpl, Symbol... symbols) {\n         return String.format(Locale.ENGLISH, messageTmpl, formattedSymbols);\n     }\n \n+    public static Symbol unwrapReferenceFromCast(Symbol symbol) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTE1Mw==", "bodyText": "Do I maybe miss something?\n\nNo, thanks for the clarification - I misunderstood what's happening.", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001153", "createdAt": "2020-06-15T08:10:16Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/expression/symbol/Symbols.java", "diffHunk": "@@ -170,6 +172,14 @@ public static String format(String messageTmpl, Symbol... symbols) {\n         return String.format(Locale.ENGLISH, messageTmpl, formattedSymbols);\n     }\n \n+    public static Symbol unwrapReferenceFromCast(Symbol symbol) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI1NjQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Rule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyNzoyOVrOGivTFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODoxMDo1MVrOGjnjyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA==", "bodyText": "Looks like this is not used yet. Should we remove this + isEnabled altogether for now?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439079700", "createdAt": "2020-06-11T21:27:29Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Rule.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import org.elasticsearch.Version;\n+\n+public interface Rule<T> {\n+\n+    Pattern<T> pattern();\n+\n+    boolean isEnabled();\n+\n+    void setEnabled(boolean enabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5MjcxOQ==", "bodyText": "Right. Maybe we should group all cast rules and expose one session setting to enable/disable all?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439292719", "createdAt": "2020-06-12T08:50:38Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Rule.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import org.elasticsearch.Version;\n+\n+public interface Rule<T> {\n+\n+    Pattern<T> pattern();\n+\n+    boolean isEnabled();\n+\n+    void setEnabled(boolean enabled);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTQ4Mg==", "bodyText": "Right. Maybe we should group all cast rules and expose one session setting to enable/disable all?\n\nNot sure. I'd leave it out and postpone the decision how to handle this for later.", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001482", "createdAt": "2020-06-15T08:10:51Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/collect/Rule.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import org.elasticsearch.Version;\n+\n+public interface Rule<T> {\n+\n+    Pattern<T> pattern();\n+\n+    boolean isEnabled();\n+\n+    void setEnabled(boolean enabled);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTI2MTIyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyOToyOVrOGivWJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODoxMToxMFrOGjnkaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ==", "bodyText": "Would date be casted to long without the explicit timestamp cast?\nHow would something like date >= '2019-01-01' behave?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439080485", "createdAt": "2020-06-11T21:29:29Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5NDA3OA==", "bodyText": "Would date be casted to long without the explicit timestamp cast?\n\nYes. But the cast optimizer rules would change the cast to 1395874800000::timestamp eventually. I just wanted to avoid changing the assertions in that analyzer test.\n\nHow would something like date >= '2019-01-01' behave?\n\nThe same, cast on date will be replaced afterwards by the cast optimizer rules.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439294078", "createdAt": "2020-06-12T08:53:23Z", "author": {"login": "seut"}, "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5ODQwNw==", "bodyText": "I think date::text >= '2019-01-01' has different semantics than date >= '2019-01-01'::timestamp has.\nIf we \"restore\" the later semantics only by the optimization, it's no longer only a performance optimization, but will be required for correct behavior - which I think is bad. We should be able to turn off all optimizations and every query should still return the same results as with the optimizations on.\nFor the numeric cases x::int = 1 or x = 1::long have the same behavior, so I think there it doesn't matter and is okay.\nMaybe we should add additional timestamp, text overloads for the comparison operators?", "url": "https://github.com/crate/crate/pull/10076#discussion_r439298407", "createdAt": "2020-06-12T09:01:28Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxNDYzOA==", "bodyText": "I think date::text >= '2019-01-01' has different semantics than date >= '2019-01-01'::timestamp has.\n\nYeah right, good point.\n\nMaybe we should add additional timestamp, text overloads for the comparison operators?\n\nYes good idea. Could we then postpone this until the operators are refactored to use the new signature based function registry which easily allow overloads?\nI think adding this overload to the existing (old/deprecated) function resolver maybe tricky.", "url": "https://github.com/crate/crate/pull/10076#discussion_r439314638", "createdAt": "2020-06-12T09:36:03Z", "author": {"login": "seut"}, "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTY0MQ==", "bodyText": "Could we then postpone this until the operators are refactored to use the new signature based function registry which easily allow overloads?\n\nyep", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001641", "createdAt": "2020-06-15T08:11:10Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, "originalCommit": {"oid": "3efa9b457e875100a2dbf2534202086f68c29177"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MjIxODcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/optimizer/symbol/FunctionSymbolResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMjozODoyN1rOGjwU4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzozNjo0MVrOGjyeYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NTEyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Symbol apply(String bame, List<Symbol> arguments);\n          \n          \n            \n                Symbol apply(String name, List<Symbol> arguments);\n          \n      \n    \n    \n  \n\ntypo?", "url": "https://github.com/crate/crate/pull/10076#discussion_r440145120", "createdAt": "2020-06-15T12:38:27Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/optimizer/symbol/FunctionSymbolResolver.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.symbol;\n+\n+import io.crate.expression.symbol.Symbol;\n+\n+import java.util.List;\n+\n+public interface FunctionSymbolResolver {\n+\n+    Symbol apply(String bame, List<Symbol> arguments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597ff9fa442dc639cffd76d3e6f88949086b371b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MDMyMQ==", "bodyText": "\ud83d\udc4d thx", "url": "https://github.com/crate/crate/pull/10076#discussion_r440180321", "createdAt": "2020-06-15T13:36:41Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/optimizer/symbol/FunctionSymbolResolver.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.symbol;\n+\n+import io.crate.expression.symbol.Symbol;\n+\n+import java.util.List;\n+\n+public interface FunctionSymbolResolver {\n+\n+    Symbol apply(String bame, List<Symbol> arguments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NTEyMA=="}, "originalCommit": {"oid": "597ff9fa442dc639cffd76d3e6f88949086b371b"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1405, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}