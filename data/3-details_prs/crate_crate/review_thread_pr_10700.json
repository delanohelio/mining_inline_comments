{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MjkzODk0", "number": 10700, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMDoxNToyN1rOEyRjmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNDowMTo0OVrOFbZFJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMTUxODk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/CreateTableAsAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMDoxNToyN1rOHo0hhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToyNTozMFrOHpCJRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NTYzNw==", "bodyText": "I think this logic here may break if the query isn't a simple select ... from tbl because it assumes there is a QuerySpecification and that the relations are Table instances.\nI think to support all kinds of query it would be possible to use the RelationAnalyzer to analyze the query, and then to create the required table elements from the outputs of the AnalyzedRelation.", "url": "https://github.com/crate/crate/pull/10700#discussion_r512565637", "createdAt": "2020-10-27T10:15:27Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/CreateTableAsAnalyzer.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.RelationAnalyzer;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.metadata.table.Operation;\n+import io.crate.sql.tree.AllColumns;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.CreateTable;\n+import io.crate.sql.tree.CreateTableAs;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.GenericProperties;\n+import io.crate.sql.tree.Insert;\n+import io.crate.sql.tree.QualifiedName;\n+import io.crate.sql.tree.QualifiedNameReference;\n+import io.crate.sql.tree.Query;\n+import io.crate.sql.tree.QuerySpecification;\n+import io.crate.sql.tree.Relation;\n+import io.crate.sql.tree.SelectItem;\n+import io.crate.sql.tree.SingleColumn;\n+import io.crate.sql.tree.Table;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public final class CreateTableAsAnalyzer {\n+\n+    private final CreateTableStatementAnalyzer createTableStatementAnalyzer;\n+    private final InsertAnalyzer insertAnalyzer;\n+    private final RelationAnalyzer relationAnalyzer;\n+    private final Schemas schemas;\n+\n+    public CreateTableAsAnalyzer(CreateTableStatementAnalyzer createTableStatementAnalyzer,\n+                                 InsertAnalyzer insertAnalyzer,\n+                                 RelationAnalyzer relationAnalyzer,\n+                                 Schemas schemas) {\n+        this.createTableStatementAnalyzer = createTableStatementAnalyzer;\n+        this.insertAnalyzer = insertAnalyzer;\n+        this.relationAnalyzer = relationAnalyzer;\n+        this.schemas = schemas;\n+    }\n+\n+    public AnalyzedCreateTableAs analyze(CreateTableAs createTableAs,\n+                                         ParamTypeHints paramTypeHints,\n+                                         CoordinatorTxnCtx txnCtx) {\n+        RelationName relationName = RelationName.of(\n+            createTableAs.name().getName(), txnCtx.sessionContext().searchPath().currentSchema()\n+        );\n+        relationName.ensureValidForRelationCreation();\n+\n+        List<TableElement<Expression>> tableElements = getTableElementsFromSourceQuery(\n+            createTableAs.query(), txnCtx\n+        );\n+        CreateTable<Expression> createTable = new CreateTable<Expression>(\n+            createTableAs.name(),\n+            tableElements,\n+            Optional.empty(),\n+            Optional.empty(),\n+            GenericProperties.empty(),\n+            false\n+        );\n+\n+        //postponing the analysis of the insert statement, since the table has not been created yet.\n+        Supplier<AnalyzedInsertStatement> postponedInsertAnalysis = () -> {\n+                Insert<Expression> insert = new Insert<>(\n+                    createTableAs.name(),\n+                    createTableAs.query(),\n+                    Collections.emptyList(),\n+                    Collections.emptyList(),\n+                    Insert.DuplicateKeyContext.none()\n+                );\n+                return insertAnalyzer.analyze(insert, paramTypeHints, txnCtx);\n+            };\n+\n+        return new AnalyzedCreateTableAs(\n+            createTableStatementAnalyzer.analyze(createTable, paramTypeHints, txnCtx),\n+            postponedInsertAnalysis\n+        );\n+    }\n+\n+    private DocTableInfo resolveTableInfo(Table table,\n+                             CoordinatorTxnCtx txnCtx) {\n+        return (DocTableInfo) schemas.resolveTableInfo(\n+            table.getName(),\n+            Operation.INSERT,\n+            txnCtx.sessionContext().sessionUser(),\n+            txnCtx.sessionContext().searchPath()\n+        );\n+    }\n+\n+    private List<TableElement<Expression>> getTableElementsFromSourceQuery (Query sourceQuery,\n+                                                                            CoordinatorTxnCtx txnCtx) {\n+        var querySpec = (QuerySpecification) sourceQuery.getQueryBody();\n+        List<Relation> relations = querySpec.getFrom();\n+        List<SelectItem> selectItems = querySpec.getSelect().getSelectItems();\n+\n+        List<TableElement<Expression>> allTableElements = relations.stream()\n+            .map(relation -> (Table)relation)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a710cf7fc738b1693dd666a63e3de49a00e6d872"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4ODgwNA==", "bodyText": "thanks for reviewing and suggestions! will move on", "url": "https://github.com/crate/crate/pull/10700#discussion_r512788804", "createdAt": "2020-10-27T15:25:30Z", "author": {"login": "jeeminso"}, "path": "server/src/main/java/io/crate/analyze/CreateTableAsAnalyzer.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.RelationAnalyzer;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.metadata.table.Operation;\n+import io.crate.sql.tree.AllColumns;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.CreateTable;\n+import io.crate.sql.tree.CreateTableAs;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.GenericProperties;\n+import io.crate.sql.tree.Insert;\n+import io.crate.sql.tree.QualifiedName;\n+import io.crate.sql.tree.QualifiedNameReference;\n+import io.crate.sql.tree.Query;\n+import io.crate.sql.tree.QuerySpecification;\n+import io.crate.sql.tree.Relation;\n+import io.crate.sql.tree.SelectItem;\n+import io.crate.sql.tree.SingleColumn;\n+import io.crate.sql.tree.Table;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public final class CreateTableAsAnalyzer {\n+\n+    private final CreateTableStatementAnalyzer createTableStatementAnalyzer;\n+    private final InsertAnalyzer insertAnalyzer;\n+    private final RelationAnalyzer relationAnalyzer;\n+    private final Schemas schemas;\n+\n+    public CreateTableAsAnalyzer(CreateTableStatementAnalyzer createTableStatementAnalyzer,\n+                                 InsertAnalyzer insertAnalyzer,\n+                                 RelationAnalyzer relationAnalyzer,\n+                                 Schemas schemas) {\n+        this.createTableStatementAnalyzer = createTableStatementAnalyzer;\n+        this.insertAnalyzer = insertAnalyzer;\n+        this.relationAnalyzer = relationAnalyzer;\n+        this.schemas = schemas;\n+    }\n+\n+    public AnalyzedCreateTableAs analyze(CreateTableAs createTableAs,\n+                                         ParamTypeHints paramTypeHints,\n+                                         CoordinatorTxnCtx txnCtx) {\n+        RelationName relationName = RelationName.of(\n+            createTableAs.name().getName(), txnCtx.sessionContext().searchPath().currentSchema()\n+        );\n+        relationName.ensureValidForRelationCreation();\n+\n+        List<TableElement<Expression>> tableElements = getTableElementsFromSourceQuery(\n+            createTableAs.query(), txnCtx\n+        );\n+        CreateTable<Expression> createTable = new CreateTable<Expression>(\n+            createTableAs.name(),\n+            tableElements,\n+            Optional.empty(),\n+            Optional.empty(),\n+            GenericProperties.empty(),\n+            false\n+        );\n+\n+        //postponing the analysis of the insert statement, since the table has not been created yet.\n+        Supplier<AnalyzedInsertStatement> postponedInsertAnalysis = () -> {\n+                Insert<Expression> insert = new Insert<>(\n+                    createTableAs.name(),\n+                    createTableAs.query(),\n+                    Collections.emptyList(),\n+                    Collections.emptyList(),\n+                    Insert.DuplicateKeyContext.none()\n+                );\n+                return insertAnalyzer.analyze(insert, paramTypeHints, txnCtx);\n+            };\n+\n+        return new AnalyzedCreateTableAs(\n+            createTableStatementAnalyzer.analyze(createTable, paramTypeHints, txnCtx),\n+            postponedInsertAnalysis\n+        );\n+    }\n+\n+    private DocTableInfo resolveTableInfo(Table table,\n+                             CoordinatorTxnCtx txnCtx) {\n+        return (DocTableInfo) schemas.resolveTableInfo(\n+            table.getName(),\n+            Operation.INSERT,\n+            txnCtx.sessionContext().sessionUser(),\n+            txnCtx.sessionContext().searchPath()\n+        );\n+    }\n+\n+    private List<TableElement<Expression>> getTableElementsFromSourceQuery (Query sourceQuery,\n+                                                                            CoordinatorTxnCtx txnCtx) {\n+        var querySpec = (QuerySpecification) sourceQuery.getQueryBody();\n+        List<Relation> relations = querySpec.getFrom();\n+        List<SelectItem> selectItems = querySpec.getSelect().getSelectItems();\n+\n+        List<TableElement<Expression>> allTableElements = relations.stream()\n+            .map(relation -> (Table)relation)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NTYzNw=="}, "originalCommit": {"oid": "a710cf7fc738b1693dd666a63e3de49a00e6d872"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDI0NTE1OnYy", "diffSide": "RIGHT", "path": "libs/sql-parser/src/main/antlr/SqlBase.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDoyMzo1NFrOH441wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDo1MDoxMlrOH46xvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxMzU2OQ==", "bodyText": "The \"Compatibility\" section of the respective PostgreSQL documentation about \"CREATE TABLE AS\" says [1]:\n\nCREATE TABLE AS conforms to the SQL standard. The following are nonstandard extensions:\n\nThe standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.\n\n\nAccording to @seut, this can be implemented like\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                | CREATE TABLE table AS '(' query ')'                                            #createTableAs\n          \n          \n            \n                | CREATE TABLE table AS insertSource                                             #createTableAs\n          \n      \n    \n    \n  \n\nCan you adjust this bit here?\n[1] https://www.postgresql.org/docs/current/sql-createtableas.html#id-1.9.3.86.9", "url": "https://github.com/crate/crate/pull/10700#discussion_r529413569", "createdAt": "2020-11-24T10:23:54Z", "author": {"login": "amotl"}, "path": "libs/sql-parser/src/main/antlr/SqlBase.g4", "diffHunk": "@@ -478,6 +478,7 @@ createStmt\n     : CREATE TABLE (IF NOT EXISTS)? table\n         '(' tableElement (',' tableElement)* ')'\n          partitionedByOrClusteredInto withProperties?                                #createTable\n+    | CREATE TABLE table AS '(' query ')'                                            #createTableAs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "726f3f48e5d463ed4f188337b1dfbdfe07b2570d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ0NTMwOA==", "bodyText": "@amotl Thank you Andreas, will fix this", "url": "https://github.com/crate/crate/pull/10700#discussion_r529445308", "createdAt": "2020-11-24T10:50:12Z", "author": {"login": "jeeminso"}, "path": "libs/sql-parser/src/main/antlr/SqlBase.g4", "diffHunk": "@@ -478,6 +478,7 @@ createStmt\n     : CREATE TABLE (IF NOT EXISTS)? table\n         '(' tableElement (',' tableElement)* ')'\n          partitionedByOrClusteredInto withProperties?                                #createTable\n+    | CREATE TABLE table AS '(' query ')'                                            #createTableAs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxMzU2OQ=="}, "originalCommit": {"oid": "726f3f48e5d463ed4f188337b1dfbdfe07b2570d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDI1NDA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDoyNDo1OVrOH447gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1NDowMVrOH55trg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA==", "bodyText": "I think I don't really understand why the visiting of the relations is necessary.\nWouldn't it be sufficient to do something like this:\nreturn Lists2.map(analyzedRelation.outputs(), this::outputToColumnDefinition)\nAnd outputToColumnDefinition would look something like this:\npublic static ColumnDefinition<Expression> outputToColumnDefinition(Symbol symbol) {\n    ColumnIdent column = Symbols.pathFromSymbol(symbol);\n\n    var type = MetadataToASTNodeResolver.dataTypeToColumnType(...);\n    return new ColumnDefinition<>(\n      column.name(),\n      null,       // default expression is always null\n      null,       // generated expression is always null\n      type,\n      List.of()   // constraints are always empty\n    )\n}\nIt looks like constraints are never copied from the source, so the above should be sufficient to handle all source relations in a generic way.\nPostgreSQL:\npsql=# create table tbl (x int default 10);\nTime: 16.267 ms\npsql=# create table copy as (select * from tbl);\nTime: 3.355 ms\npsql=# \\d copy\n                Table \"public.copy\"\n Column |  Type   | Collation | Nullable | Default\n--------+---------+-----------+----------+---------\n x      | integer |           |          |", "url": "https://github.com/crate/crate/pull/10700#discussion_r529415040", "createdAt": "2020-11-24T10:24:59Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzMjcxOA==", "bodyText": "FWIW, the optional like_option clauses to the general CREATE TABLE statement [1] will allow users to specify which additional properties of the original table to copy.\nThe SO article at [2] outlines this a bit more and gives some examples.\n-- Apply all properties from the source table.\nCREATE TABLE IF NOT EXISTS <ClonedTableName> (LIKE <OriginalTableName> INCLUDING ALL);\n\n-- Apply specific properties from the source table.\nCREATE TABLE <ClonedTableName> (LIKE <OriginalTableName> INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES);\n[1] https://www.postgresql.org/docs/current/sql-createtable.html\n[2] https://stackoverflow.com/questions/11176383/create-table-as-with-primary-key-in-one-statement-postgresql\n\nSo, would the visiting of the relations as implemented by @jeeminso be suitable to reuse for implementing the CREATE TABLE LIKE feature instead?", "url": "https://github.com/crate/crate/pull/10700#discussion_r529432718", "createdAt": "2020-11-24T10:39:43Z", "author": {"login": "amotl"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ0NTkxNw==", "bodyText": "So, would the visiting of the relations as implemented by @jeeminso be suitable to reuse for implementing the CREATE TABLE LIKE feature instead?\n\nI think it requires a different implementation. LIKE is restricted to a table name, not an arbitrary relation, so it won't be necessary to handle different concrete AnalyzedRelation implementations\nAlso: I think for a first version it's okay to not support the LIKE clause. We can extend that later in separate PRs. Otherwise this one will become rather big.", "url": "https://github.com/crate/crate/pull/10700#discussion_r529445917", "createdAt": "2020-11-24T10:50:39Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ1Mjg3MQ==", "bodyText": "It looks like constraints are never copied from the source, so the above should be sufficient to handle all source relations in a generic way.\n\nYes, if constraints are not required, outputToColumnDefinition() should be sufficient.\nOne question, I tried it on MySQL and observed the constraints copied, does CrateDB references Postgres documents only?\nmysql> create table tbl (x int default 10);\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql> show create table tbl;\n+-------+----------------------------------------------------------------------------------------+\n| Table | Create Table                                                                           |\n+-------+----------------------------------------------------------------------------------------+\n| tbl   | CREATE TABLE `tbl` (\n  `x` int(11) DEFAULT '10'\n) ENGINE=InnoDB DEFAULT CHARSET=latin1 |\n+-------+----------------------------------------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> create table copy as (select * from tbl);\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> show create table copy;\n+-------+-----------------------------------------------------------------------------------------+\n| Table | Create Table                                                                            |\n+-------+-----------------------------------------------------------------------------------------+\n| copy  | CREATE TABLE `copy` (\n  `x` int(11) DEFAULT '10'\n) ENGINE=InnoDB DEFAULT CHARSET=latin1 |\n+-------+-----------------------------------------------------------------------------------------+\n1 row in set (0.00 sec)", "url": "https://github.com/crate/crate/pull/10700#discussion_r529452871", "createdAt": "2020-11-24T10:56:29Z", "author": {"login": "jeeminso"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ1ODY0MA==", "bodyText": "does CrateDB references Postgres documents only?\n\nyes, we try to follow the SQL Standard and if there are behaviour extensions we try to mimic PostgreSQL.", "url": "https://github.com/crate/crate/pull/10700#discussion_r529458640", "createdAt": "2020-11-24T11:02:25Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDQzNg==", "bodyText": "thanks for clarification, will drop the 'visiting relations' logic and proceed.", "url": "https://github.com/crate/crate/pull/10700#discussion_r529474436", "createdAt": "2020-11-24T11:28:48Z", "author": {"login": "jeeminso"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3Nzk3NQ==", "bodyText": "Also: I think for a first version it's okay to not support the LIKE clause. We can extend that later in separate PRs. Otherwise this one will become rather big.\n\nSure. I didn't want to argue otherwise and just wanted to support this conversation by giving a perspective into the other syntax which supports transferring table properties. Thanks for sorting this out, @jeeminso and @mfussenegger!", "url": "https://github.com/crate/crate/pull/10700#discussion_r529477975", "createdAt": "2020-11-24T11:34:58Z", "author": {"login": "amotl"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEzMjU0NA==", "bodyText": "I have spent some time on this and encountered one issue. If one of the outputs (from the analyzedQuery) is a type of ScopedSymbol with its dataType being an ObjectType, its ColumnPolicy cannot be recovered without 'visiting relations'. Please help clarify whether recovering ColumnPolicy is required.\nI have tried to find Postgres equivalent of ObjectType and it seems that CompositeType is the closest but does not have ColumnPolicy feature.\nCurrently, I assigned ColumnPolicy.STRICT which should be default for ObjectTypes.\nAttached below the code snippet, in case you are interested. (almost all of the changes since the last changeset)\n    private List<TableElement<Expression>> getTableElementsFromSourceQuery(Query sourceQuery,\n                                                                           ParamTypeHints paramTypeHints,\n                                                                           CoordinatorTxnCtx txnCtx) {\n\n        AnalyzedRelation analyzedSourceQuery = relationAnalyzer.analyze(\n            sourceQuery,\n            new StatementAnalysisContext(paramTypeHints, Operation.READ, txnCtx));\n\n        return Lists2.map(analyzedSourceQuery.outputs(), CreateTableAsAnalyzer::outputToColumnDefinition);\n    }\n\n    private static ColumnDefinition<Expression> outputToColumnDefinition(Symbol symbol) {\n\n        final ColumnIdent column = Symbols.pathFromSymbol(symbol);\n        final ColumnPolicy columnPolicy = ColumnPolicy.STRICT;\n        final DataType<?> dataType = symbol.valueType();\n        var columnType = dataTypeToColumnType(dataType, columnPolicy);\n\n        return new ColumnDefinition<>(\n            column.name(),\n            null,\n            null,\n            columnType,\n            List.of()\n        );\n    }\n\n    //The original version from MetadataToASTNodeResolver depends on its private Extractor \n    // that makes use of extractColumnDefinitions() and DocTableInfo\n    private static ColumnType<Expression> dataTypeToColumnType(DataType<?> type,\n                                                               ColumnPolicy columnPolicy) {\n\n        if (type.id() == ObjectType.ID) {\n            List<ColumnDefinition<Expression>> childColumns = new ArrayList<>();\n            ((ObjectType) type).innerTypes().forEach(\n                (childName, childDataType) -> {\n                    childColumns.add(\n                        new ColumnDefinition<>(\n                            childName,\n                            null,\n                            null,\n                            dataTypeToColumnType(childDataType, columnPolicy),\n                            List.of())\n                    );\n                }\n            );\n            return new ObjectColumnType<>(columnPolicy.name(), childColumns);\n        } else if (type.id() == ArrayType.ID) {\n            DataType<?> innerType = ((ArrayType<?>) type).innerType();\n            return new CollectionColumnType<>(dataTypeToColumnType(\n                innerType,\n                columnPolicy\n            ));\n        } else if (type.id() == StringType.ID) {\n            StringType stringType = (StringType) type;\n            if (stringType.unbound()) {\n                return new ColumnType<>(type.getName());\n            } else {\n                return new ColumnType<>(\"VARCHAR\", List.of(stringType.lengthLimit()));\n            }\n        } else {\n            return new ColumnType<>(type.getName());\n        }\n    }", "url": "https://github.com/crate/crate/pull/10700#discussion_r530132544", "createdAt": "2020-11-25T06:23:13Z", "author": {"login": "jeeminso"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NjQ2Mg==", "bodyText": "I think for now it is okay to proceed with defaulting to ColumnPolicy.STRICT.\nWe may have to refactor the structures later to expose the column policy as part of the object-type, but we can follow up on that at a later point.", "url": "https://github.com/crate/crate/pull/10700#discussion_r530476462", "createdAt": "2020-11-25T15:54:01Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, "originalCommit": {"oid": "fbb0ee1906f5e0b9de1e64defca7bf883064e814"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MzM2MjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTozMzoyNVrOIRNdJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTozMzoyNVrOIRNdJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxNzE1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ColumnDefinition<Expression> convert(Symbol symbol) {\n          \n          \n            \n                    return symbolToColumnDefinition(symbol);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nI think going with just symbolToColumnDefinition directly should be good enough?", "url": "https://github.com/crate/crate/pull/10700#discussion_r554917159", "createdAt": "2021-01-11T09:33:25Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.ColumnIdent;\n+import io.crate.sql.tree.CollectionColumnType;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnPolicy;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.ObjectColumnType;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.ObjectType;\n+import io.crate.types.StringType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SymbolToColumnDefinitionConverter {\n+\n+    private static final ColumnPolicy OBJECT_TYPE_DEFAULT_COLUMN_POLICY = ColumnPolicy.STRICT;\n+\n+    public static ColumnDefinition<Expression> convert(Symbol symbol) {\n+        return symbolToColumnDefinition(symbol);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MzM4MTA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTozODoxNVrOIRNn2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwMTowNDo1NlrOISbh7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxOTg5OQ==", "bodyText": "Would it be possible to adapt the code in MetadataToASTNodeResolver to use a shared version?", "url": "https://github.com/crate/crate/pull/10700#discussion_r554919899", "createdAt": "2021-01-11T09:38:15Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.ColumnIdent;\n+import io.crate.sql.tree.CollectionColumnType;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnPolicy;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.ObjectColumnType;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.ObjectType;\n+import io.crate.types.StringType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SymbolToColumnDefinitionConverter {\n+\n+    private static final ColumnPolicy OBJECT_TYPE_DEFAULT_COLUMN_POLICY = ColumnPolicy.STRICT;\n+\n+    public static ColumnDefinition<Expression> convert(Symbol symbol) {\n+        return symbolToColumnDefinition(symbol);\n+    }\n+\n+    private static ColumnDefinition<Expression> symbolToColumnDefinition(Symbol symbol) {\n+\n+        final ColumnIdent column = Symbols.pathFromSymbol(symbol);\n+        final DataType<?> dataType = symbol.valueType();\n+        var columnType = dataTypeToColumnType(dataType);\n+\n+        //handles the case when an ObjectType's field is to be re-constructed.\n+        String columnName = (column.path().isEmpty()) ? column.name() : column.path().get(column.path().size() - 1);\n+\n+        return new ColumnDefinition<>(\n+            columnName,\n+            null,\n+            null,\n+            columnType,\n+            List.of());\n+    }\n+\n+    //The original version from MetadataToASTNodeResolver depends on its private Extractor\n+    // that makes use of extractColumnDefinitions() and DocTableInfo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE5NjMzMg==", "bodyText": "ok thanks, will look into it.\nare you referring to the commented code in the testcase? it was just for me to use as a reference, will remove that, for non-draft PR. Thank you", "url": "https://github.com/crate/crate/pull/10700#discussion_r556196332", "createdAt": "2021-01-13T01:04:56Z", "author": {"login": "jeeminso"}, "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.ColumnIdent;\n+import io.crate.sql.tree.CollectionColumnType;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnPolicy;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.ObjectColumnType;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.ObjectType;\n+import io.crate.types.StringType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SymbolToColumnDefinitionConverter {\n+\n+    private static final ColumnPolicy OBJECT_TYPE_DEFAULT_COLUMN_POLICY = ColumnPolicy.STRICT;\n+\n+    public static ColumnDefinition<Expression> convert(Symbol symbol) {\n+        return symbolToColumnDefinition(symbol);\n+    }\n+\n+    private static ColumnDefinition<Expression> symbolToColumnDefinition(Symbol symbol) {\n+\n+        final ColumnIdent column = Symbols.pathFromSymbol(symbol);\n+        final DataType<?> dataType = symbol.valueType();\n+        var columnType = dataTypeToColumnType(dataType);\n+\n+        //handles the case when an ObjectType's field is to be re-constructed.\n+        String columnName = (column.path().isEmpty()) ? column.name() : column.path().get(column.path().size() - 1);\n+\n+        return new ColumnDefinition<>(\n+            columnName,\n+            null,\n+            null,\n+            columnType,\n+            List.of());\n+    }\n+\n+    //The original version from MetadataToASTNodeResolver depends on its private Extractor\n+    // that makes use of extractColumnDefinitions() and DocTableInfo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxOTg5OQ=="}, "originalCommit": {"oid": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjcyODMxOnYy", "diffSide": "RIGHT", "path": "resolv.conf", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMDozNVrOIah6ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMDozNVrOIah6ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY4OTU5NA==", "bodyText": "Looks like this file as added by accident. Could you remove it?", "url": "https://github.com/crate/crate/pull/10700#discussion_r564689594", "createdAt": "2021-01-26T17:20:35Z", "author": {"login": "mfussenegger"}, "path": "resolv.conf", "diffHunk": "@@ -0,0 +1 @@\n+../run/systemd/resolve/resolv.conf", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0914192b5f46550ca2b26aba9745aebebfd9500b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjczNjI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMjoyNFrOIah_rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMjoyNFrOIah_rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MDg2Mw==", "bodyText": "Why did this change to lowercase?", "url": "https://github.com/crate/crate/pull/10700#discussion_r564690863", "createdAt": "2021-01-26T17:22:24Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -109,7 +124,7 @@ public static Expression expressionFromColumn(ColumnIdent ident) {\n             if (stringType.unbound()) {\n                 return new ColumnType<>(type.getName());\n             } else {\n-                return new ColumnType<>(\"VARCHAR\", List.of(stringType.lengthLimit()));\n+                return new ColumnType<>(\"varchar\", List.of(stringType.lengthLimit()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0914192b5f46550ca2b26aba9745aebebfd9500b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjczOTcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMzowNFrOIaiBwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMzowNFrOIaiBwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MTM5NA==", "bodyText": "Could you revert the unrelated formatting changes here?", "url": "https://github.com/crate/crate/pull/10700#discussion_r564691394", "createdAt": "2021-01-26T17:23:04Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -283,9 +313,9 @@ public Extractor(DocTableInfo tableInfo) {\n             GenericProperties<Expression> properties = new GenericProperties<>();\n             Expression numReplicas = new StringLiteral(tableInfo.numberOfReplicas());\n             properties.add(new GenericProperty<>(\n-                TableParameters.NUMBER_OF_REPLICAS.getKey(),\n-                numReplicas\n-                )\n+                               TableParameters.NUMBER_OF_REPLICAS.getKey(),\n+                               numReplicas\n+                           )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0914192b5f46550ca2b26aba9745aebebfd9500b"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1Njc0MDEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMzoxMVrOIaiCAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNzoyMzoxMVrOIaiCAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MTQ1OA==", "bodyText": "Same here", "url": "https://github.com/crate/crate/pull/10700#discussion_r564691458", "createdAt": "2021-01-26T17:23:11Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -294,9 +324,9 @@ public Extractor(DocTableInfo tableInfo) {\n             );\n             for (Map.Entry<String, Object> entry : tableParameters.entrySet()) {\n                 properties.add(new GenericProperty<>(\n-                        TableParameters.stripIndexPrefix(entry.getKey()),\n-                        Literal.fromObject(entry.getValue())\n-                    )\n+                                   TableParameters.stripIndexPrefix(entry.getKey()),\n+                                   Literal.fromObject(entry.getValue())\n+                               )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0914192b5f46550ca2b26aba9745aebebfd9500b"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0MjY2NzkwOnYy", "diffSide": "RIGHT", "path": "docs/appendices/release-notes/unreleased.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNDowMTo0OVrOIm399Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNDowMTo0OVrOIm399Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzMzc4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - added support for handling create-table-as statement.\n          \n          \n            \n            - Added support for the :ref:`CREATE TABLE AS <ref-create-table-as>` statement.", "url": "https://github.com/crate/crate/pull/10700#discussion_r577633781", "createdAt": "2021-02-17T14:01:49Z", "author": {"login": "mfussenegger"}, "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -53,7 +53,7 @@ None\n Changes\n =======\n \n-None\n+- added support for handling create-table-as statement.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546a0f62549909f289c1914e6374e2dc3517fdd0"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 979, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}