{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMTg3Mjgw", "number": 9641, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoxMTo0MlrODeg28g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoxNjozMFrODeg-qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzIyMjI2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/tablefunctions/PgExpandArray.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoxMTo0MlrOFnsF_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoyMzoxMlrOFnsjSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2MTIxNA==", "bodyText": "Aren't these assertions already ensured by the FuncParams definition?", "url": "https://github.com/crate/crate/pull/9641#discussion_r377161214", "createdAt": "2020-02-10T16:11:42Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/tablefunctions/PgExpandArray.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.metadata.information.InformationSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+public final class PgExpandArray extends TableFunctionImplementation<List<Object>> {\n+\n+    private static final String NAME = \"_pg_expandarray\";\n+    private static final FunctionName FUNCTION_NAME = new FunctionName(InformationSchemaInfo.NAME, NAME);\n+    private static final RelationName REL_NAME = new RelationName(InformationSchemaInfo.NAME, NAME);\n+    private final RowType resultType;\n+    private final FunctionInfo info;\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            FUNCTION_NAME,\n+            new BaseFunctionResolver(FuncParams.builder(Param.ANY_ARRAY).build()) {\n+                @Override\n+                public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                    assert types.size() == 1 : \"_pg_expandarray must have a single argument due to funcParams\";\n+                    DataType<?> dataType = types.get(0);\n+                    assert dataType instanceof ArrayType : \"Argument to _pg_expandarray must be an array\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56f1761e1ca6880c02f0a4627544c8be3060df01"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2ODcxNA==", "bodyText": "Yes they are, the assertion message earlier also says so: \"_pg_expandarray must have a single argument due to funcParams\";\nI like to add those to clarify that there is some kind of contract in place.", "url": "https://github.com/crate/crate/pull/9641#discussion_r377168714", "createdAt": "2020-02-10T16:23:12Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/tablefunctions/PgExpandArray.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.metadata.information.InformationSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+public final class PgExpandArray extends TableFunctionImplementation<List<Object>> {\n+\n+    private static final String NAME = \"_pg_expandarray\";\n+    private static final FunctionName FUNCTION_NAME = new FunctionName(InformationSchemaInfo.NAME, NAME);\n+    private static final RelationName REL_NAME = new RelationName(InformationSchemaInfo.NAME, NAME);\n+    private final RowType resultType;\n+    private final FunctionInfo info;\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            FUNCTION_NAME,\n+            new BaseFunctionResolver(FuncParams.builder(Param.ANY_ARRAY).build()) {\n+                @Override\n+                public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                    assert types.size() == 1 : \"_pg_expandarray must have a single argument due to funcParams\";\n+                    DataType<?> dataType = types.get(0);\n+                    assert dataType instanceof ArrayType : \"Argument to _pg_expandarray must be an array\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2MTIxNA=="}, "originalCommit": {"oid": "56f1761e1ca6880c02f0a4627544c8be3060df01"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzI0MjAzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/SubscriptFunctions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoxNjozMVrOFnsSaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjoyMzozM1rOFnskQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2NDM5NQ==", "bodyText": "Is this covered by any test already?", "url": "https://github.com/crate/crate/pull/9641#discussion_r377164395", "createdAt": "2020-02-10T16:16:31Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/SubscriptFunctions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.ObjectType;\n+import io.crate.types.RowType;\n+\n+public final class SubscriptFunctions {\n+\n+    @Nullable\n+    public static Function tryCreateSubscript(Symbol baseSymbol, List<String> path) {\n+        assert !path.isEmpty() : \"Path must not be empty to create subscript function\";\n+\n+        var baseType = baseSymbol.valueType();\n+        switch (baseType.id()) {\n+            case ObjectType.ID: {\n+                List<Symbol> arguments = Lists2.mapTail(baseSymbol, path, Literal::of);\n+                DataType<?> returnType = ((ObjectType) baseType).resolveInnerType(path);\n+                return new Function(\n+                    new FunctionInfo(new FunctionIdent(SubscriptObjectFunction.NAME, Symbols.typeView(arguments)), returnType),\n+                    arguments\n+                );\n+            }\n+\n+            case RowType.ID: {\n+                String child = path.get(0);\n+                RowType rowType = (RowType) baseType;\n+                int idx = rowType.fieldNames().indexOf(child);\n+                if (idx < 0) {\n+                    return null;\n+                }\n+                Function recordSubscript = new Function(\n+                    new FunctionInfo(\n+                        new FunctionIdent(SubscriptRecordFunction.NAME, List.of(baseType, DataTypes.STRING)),\n+                        rowType.getFieldType(idx)\n+                    ),\n+                    List.of(baseSymbol, Literal.of(child))\n+                );\n+                if (path.size() > 1) {\n+                    return tryCreateSubscript(recordSubscript, path.subList(1, path.size() - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1c4e7b770d8b76df1e0b720d7f966989e24ad61"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2ODk2MQ==", "bodyText": "No. Good point, I'll add some.", "url": "https://github.com/crate/crate/pull/9641#discussion_r377168961", "createdAt": "2020-02-10T16:23:33Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/SubscriptFunctions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.ObjectType;\n+import io.crate.types.RowType;\n+\n+public final class SubscriptFunctions {\n+\n+    @Nullable\n+    public static Function tryCreateSubscript(Symbol baseSymbol, List<String> path) {\n+        assert !path.isEmpty() : \"Path must not be empty to create subscript function\";\n+\n+        var baseType = baseSymbol.valueType();\n+        switch (baseType.id()) {\n+            case ObjectType.ID: {\n+                List<Symbol> arguments = Lists2.mapTail(baseSymbol, path, Literal::of);\n+                DataType<?> returnType = ((ObjectType) baseType).resolveInnerType(path);\n+                return new Function(\n+                    new FunctionInfo(new FunctionIdent(SubscriptObjectFunction.NAME, Symbols.typeView(arguments)), returnType),\n+                    arguments\n+                );\n+            }\n+\n+            case RowType.ID: {\n+                String child = path.get(0);\n+                RowType rowType = (RowType) baseType;\n+                int idx = rowType.fieldNames().indexOf(child);\n+                if (idx < 0) {\n+                    return null;\n+                }\n+                Function recordSubscript = new Function(\n+                    new FunctionInfo(\n+                        new FunctionIdent(SubscriptRecordFunction.NAME, List.of(baseType, DataTypes.STRING)),\n+                        rowType.getFieldType(idx)\n+                    ),\n+                    List.of(baseSymbol, Literal.of(child))\n+                );\n+                if (path.size() > 1) {\n+                    return tryCreateSubscript(recordSubscript, path.subList(1, path.size() - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2NDM5NQ=="}, "originalCommit": {"oid": "b1c4e7b770d8b76df1e0b720d7f966989e24ad61"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1062, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}