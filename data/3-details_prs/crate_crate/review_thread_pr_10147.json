{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMzgyODgz", "number": 10147, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNDozOFrOEJpifg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNzoxNVrOEJpm5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTUzMjE0OnYy", "diffSide": "LEFT", "path": "server/src/main/java/io/crate/metadata/pgcatalog/PgTypeTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNDozOFrOGqP8UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzoxNjoyM1rOGqQa7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NDU3Ng==", "bodyText": "Are you sure about all the types? I've added this check coz some types, like any (maybe it is actually the only type) don't have typreceive,  typoutput, and typinput. See\ntemplate1=# select typreceive from pg_type where oid = 2276;\n typreceive\n------------\n -\n(1 row)", "url": "https://github.com/crate/crate/pull/10147#discussion_r446954576", "createdAt": "2020-06-29T13:04:38Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/metadata/pgcatalog/PgTypeTable.java", "diffHunk": "@@ -64,31 +62,10 @@\n             .add(\"typtypmod\", INTEGER, c -> -1)\n             .add(\"typnamespace\", INTEGER, c -> TYPE_NAMESPACE_OID)\n             .add(\"typarray\", INTEGER, PGType::typArray)\n-            .add(\"typinput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_in\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_in\");\n-                }\n-            })\n-            .add(\"typoutput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_out\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_out\");\n-                }\n-            })\n-            .add(\"typreceive\", REGPROC, t -> regprocForMetaFunction(t, \"recv\"))\n+            .add(\"typinput\", REGPROC, PGType::typInput)\n+            .add(\"typoutput\", REGPROC, PGType::typOutput)\n+            .add(\"typreceive\", REGPROC, PGType::typReceive)\n             .add(\"typnotnull\", BOOLEAN, c -> false)\n             .build();\n     }\n-\n-    private static Regproc regprocForMetaFunction(PGType<?> type,\n-                                                  String suffix) {\n-        if (PGTypes.fromOID(type.oid()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "badccd716ca7dffd249e02fff2f5d684a291488c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk2MjQxNA==", "bodyText": "Good point. I added a fixup.", "url": "https://github.com/crate/crate/pull/10147#discussion_r446962414", "createdAt": "2020-06-29T13:16:23Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/metadata/pgcatalog/PgTypeTable.java", "diffHunk": "@@ -64,31 +62,10 @@\n             .add(\"typtypmod\", INTEGER, c -> -1)\n             .add(\"typnamespace\", INTEGER, c -> TYPE_NAMESPACE_OID)\n             .add(\"typarray\", INTEGER, PGType::typArray)\n-            .add(\"typinput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_in\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_in\");\n-                }\n-            })\n-            .add(\"typoutput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_out\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_out\");\n-                }\n-            })\n-            .add(\"typreceive\", REGPROC, t -> regprocForMetaFunction(t, \"recv\"))\n+            .add(\"typinput\", REGPROC, PGType::typInput)\n+            .add(\"typoutput\", REGPROC, PGType::typOutput)\n+            .add(\"typreceive\", REGPROC, PGType::typReceive)\n             .add(\"typnotnull\", BOOLEAN, c -> false)\n             .build();\n     }\n-\n-    private static Regproc regprocForMetaFunction(PGType<?> type,\n-                                                  String suffix) {\n-        if (PGTypes.fromOID(type.oid()) != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NDU3Ng=="}, "originalCommit": {"oid": "badccd716ca7dffd249e02fff2f5d684a291488c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTU0MzQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/collect/sources/InformationSchemaIterables.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNzoxNVrOGqQC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNzoxNVrOGqQC7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NjI2OQ==", "bodyText": "\ud83d\udc4d\nlgtm", "url": "https://github.com/crate/crate/pull/10147#discussion_r446956269", "createdAt": "2020-06-29T13:07:15Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/collect/sources/InformationSchemaIterables.java", "diffHunk": "@@ -160,21 +162,40 @@ public InformationSchemaIterables(final Schemas schemas,\n             .flatMap(List::stream)\n             .map(this::pgProc)\n             .iterator();\n-        pgTypeReceiveFunctions = () -> sequentialStream(PGTypes.pgTypes())\n-            .filter(pgType -> PGTypes.fromOID(pgType.oid()) != null)\n-            .map(\n-                type -> Signature.scalar(\n-                    type.typName() + \"recv\",\n-                    Objects.requireNonNullElse(\n-                        PGTypes.fromOID(type.oid()),\n-                        DataTypes.UNDEFINED\n-                    ).getTypeSignature()\n+\n+        pgTypeReceiveFunctions = () ->\n+            Stream.concat(\n+                sequentialStream(PGTypes.pgTypes())\n+                    .filter(t -> t.typArray() != 0)\n+                    .map(InformationSchemaIterables::typeToSignature)\n+                    .map(PgProcTable.Entry::of),\n+\n+                // Don't generate array_recv entry from pgTypes to avoid duplicate entries\n+                // (We want 1 array_recv entry, not one per array type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2912c278436d1a974a822532615097b2452d80"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1309, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}