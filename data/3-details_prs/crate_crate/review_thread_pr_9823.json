{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NjU1NTI1", "number": 9823, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzo1NTowMlrODsrz6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzo1OToyMFrODsr8IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MTgxNzM2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/geo/DistanceFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzo1NTowMlrOF9q6Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzo1NTowMlrOF9q6Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMDUwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    DataTypes.STRING, DataTypes.GEO_POINT, new ArrayType<>(DataTypes.DOUBLE));\n          \n          \n            \n                    DataTypes.STRING, DataTypes.GEO_POINT, DataTypes.DOUBLE_ARRAY);", "url": "https://github.com/crate/crate/pull/9823#discussion_r400210507", "createdAt": "2020-03-30T13:55:02Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/DistanceFunction.java", "diffHunk": "@@ -44,22 +40,30 @@\n import java.util.Arrays;\n import java.util.List;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public class DistanceFunction extends Scalar<Double, Point> {\n \n     public static final String NAME = \"distance\";\n-    private static final Param ALLOWED_PARAM = Param.of(\n-        DataTypes.STRING, DataTypes.GEO_POINT, new ArrayType(DataTypes.DOUBLE));\n+    private static final List<DataType<?>> SUPPORTED_TYPES = List.of(\n+        DataTypes.STRING, DataTypes.GEO_POINT, new ArrayType<>(DataTypes.DOUBLE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MTgzODQwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzo1OToyMFrOF9rHjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNDo0OTo0MFrOF9tgTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ==", "bodyText": "what is the preferable way of defining the signature\nparseTypeSignature(\"double precision\")\n\nor\nDataTypes.DOUBLE.getTypeSignature()\n\n?", "url": "https://github.com/crate/crate/pull/9823#discussion_r400213901", "createdAt": "2020-03-30T13:59:20Z", "author": {"login": "kovrus"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxOTU2Ng==", "bodyText": "No strict preference, both is valid. I prefer parseTypeSignature(\"double precision\") as I think is more readable, but may be just a personal preference.", "url": "https://github.com/crate/crate/pull/9823#discussion_r400219566", "createdAt": "2020-03-30T14:07:07Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ=="}, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzMTMzNg==", "bodyText": "Wouldn't the second variant be safer, since the type name must be valid to create the DataType instance later on?", "url": "https://github.com/crate/crate/pull/9823#discussion_r400231336", "createdAt": "2020-03-30T14:22:26Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ=="}, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTgzOQ==", "bodyText": "parseTypeSignature() will also fail on invalid types as it will call DataTypes.ofName() eventually.", "url": "https://github.com/crate/crate/pull/9823#discussion_r400235839", "createdAt": "2020-03-30T14:27:58Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ=="}, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI0MTQ1NA==", "bodyText": "parseTypeSignature() will also fail on invalid types as it will call DataTypes.ofName() eventually.\n\nGood point, although I think DataTypes.DOUBLE.getTypeSignature()  or parseTypeSignature(DataTypes.DOUBLE.getName())  would make the relationship clearer and make refactorings easier.\nProbably not worth going through all open PRs again, but maybe going forward?", "url": "https://github.com/crate/crate/pull/9823#discussion_r400241454", "createdAt": "2020-03-30T14:35:00Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ=="}, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI1MzAwNg==", "bodyText": "Refactoring is a good point although I really like the literal variant. But yes lets use then DataTypes.DOUBLE.getTypeSignature() in future.", "url": "https://github.com/crate/crate/pull/9823#discussion_r400253006", "createdAt": "2020-03-30T14:49:40Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/expression/scalar/geo/CoordinateFunction.java", "diffHunk": "@@ -31,13 +30,20 @@\n import java.util.List;\n import java.util.function.Function;\n \n+import static io.crate.metadata.functions.Signature.scalar;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n public final class CoordinateFunction {\n \n-    private static final List<DataType> SUPPORTED_INPUT_TYPES = ImmutableList.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n+    private static final List<DataType<?>> SUPPORTED_INPUT_TYPES =\n+        List.of(DataTypes.GEO_POINT, DataTypes.STRING, DataTypes.DOUBLE_ARRAY, DataTypes.UNDEFINED);\n \n     private static void register(ScalarFunctionModule module, String name, Function<Object, Double> func) {\n-        for (DataType inputType : SUPPORTED_INPUT_TYPES) {\n-            module.register(new UnaryScalar<>(name, inputType, DataTypes.DOUBLE, func));\n+        for (DataType<?> inputType : SUPPORTED_INPUT_TYPES) {\n+            module.register(\n+                scalar(name, inputType.getTypeSignature(), parseTypeSignature(\"double precision\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIxMzkwMQ=="}, "originalCommit": {"oid": "f3f8abb54460f320f0ae06cfd6dcba6c4f8866af"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1562, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}