{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NDg3MDc4", "number": 9479, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMToxOTozN1rODf26uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNDoxNDozOFrODf5wLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzMyMjE3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMToxOTozN1rOFpzeLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMToxOTozN1rOFpzeLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3OTI0Ng==", "bodyText": "We could also decide if we should account inside the NodeFetchResponse only if (numReaders > 0) https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56.", "url": "https://github.com/crate/crate/pull/9479#discussion_r379379246", "createdAt": "2020-02-14T11:19:37Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java", "diffHunk": "@@ -64,8 +68,22 @@ public TransportFetchOperation(TransportFetchNodeAction transportFetchNodeAction\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccounting,\n+            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96169dbef760e8dc3ab699656f04e472f3aa4869"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzcxMDAwOnYy", "diffSide": "RIGHT", "path": "es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzo1MDo0MlrOFp3IDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzo1MDo0MlrOFp3IDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTExOQ==", "bodyText": "The when in-time when sounds weird. Maybe re-phrase to by the time the teardown runs\nOr re-phrase completely to something like the following, omitting the second part completely.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when\n          \n          \n            \n                            // RamAccouting-release operations can run asynchronous after clients already received results.", "url": "https://github.com/crate/crate/pull/9479#discussion_r379439119", "createdAt": "2020-02-14T13:50:42Z", "author": {"login": "mfussenegger"}, "path": "es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "diffHunk": "@@ -2210,6 +2210,21 @@ public void ensureEstimatedStats() {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n+\n+                // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzcyMTkzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzo1NDo0NlrOFp3PrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNDowNDowMVrOFp3iNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ==", "bodyText": "Do we need the ConcurrentRamAccounting here? I think the SingleBucketBuilder isn't used concurrently. (Yes, threads may change, but there is no concurrent use by multiple threads)", "url": "https://github.com/crate/crate/pull/9479#discussion_r379441069", "createdAt": "2020-02-14T13:54:46Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -278,9 +279,16 @@ private void registerContextPhases(Iterable<? extends NodeOperation> nodeOperati\n             }\n             if (ExecutionPhases.hasDirectResponseDownstream(nodeOperation.downstreamNodes())) {\n                 var executionPhase = nodeOperation.executionPhase();\n-                var ramAccounting = RamAccountingContext.forExecutionPhase(breaker(), executionPhase);\n+                CircuitBreaker breaker = breaker();\n+                int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                    breaker.getLimit(),\n+                    1\n+                );\n+                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NTgxMg==", "bodyText": "right, good catch", "url": "https://github.com/crate/crate/pull/9479#discussion_r379445812", "createdAt": "2020-02-14T14:04:01Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -278,9 +279,16 @@ private void registerContextPhases(Iterable<? extends NodeOperation> nodeOperati\n             }\n             if (ExecutionPhases.hasDirectResponseDownstream(nodeOperation.downstreamNodes())) {\n                 var executionPhase = nodeOperation.executionPhase();\n-                var ramAccounting = RamAccountingContext.forExecutionPhase(breaker(), executionPhase);\n+                CircuitBreaker breaker = breaker();\n+                int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                    breaker.getLimit(),\n+                    1\n+                );\n+                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ=="}, "originalCommit": {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzczMDg3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzo1NzozNlrOFp3VHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzo1NzozNlrOFp3VHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MjQ2Mg==", "bodyText": "Do we need multiple MemoryManager instances here?\nI think if the ramAccounting instance is thread-safe, the MemoryManager instances inherit that thread-safety. So we could probably get away with using one.", "url": "https://github.com/crate/crate/pull/9479#discussion_r379442462", "createdAt": "2020-02-14T13:57:36Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -803,34 +847,33 @@ public Boolean visitFetchPhase(final FetchPhase phase, final Context context) {\n \n         @Override\n         public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n-\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Nzc4NjcxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNDoxNDozOFrOFp33PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzozNzoyN1rOFqapjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw==", "bodyText": "Same here regarding the MemoryManager instances. Sorry I had only pointed it out once as I wasn't sure if I'm missing something.", "url": "https://github.com/crate/crate/pull/9479#discussion_r379451197", "createdAt": "2020-02-14T14:14:38Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -886,33 +924,33 @@ public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n \n         @Override\n         public Boolean visitHashJoinPhase(HashJoinPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2564653f664b8caeda79b744602f3edfd7382ad9"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyMTEzNA==", "bodyText": "ah thanks!", "url": "https://github.com/crate/crate/pull/9479#discussion_r380021134", "createdAt": "2020-02-17T07:37:27Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -886,33 +924,33 @@ public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n \n         @Override\n         public Boolean visitHashJoinPhase(HashJoinPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw=="}, "originalCommit": {"oid": "2564653f664b8caeda79b744602f3edfd7382ad9"}, "originalPosition": 327}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1165, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}