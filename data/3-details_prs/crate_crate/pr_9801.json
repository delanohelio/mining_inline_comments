{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNTY3NTY2", "number": 9801, "title": "Enable query-then-fetch for more cases", "bodyText": "Summary of the changes / Why this improves CrateDB\nSee commits\nThe approach taken is similar to how the fetch planning worked before its\nremoval (#9669) with 2 important\ndifferences.\n\n\nThe trigger is still a rule, and only the sub-tree where the rule matched\nwill be rewritten.\n\n\nInstead of doing pointer chasing to get the Reference items, they're now\nbubbled up as part of the rewrite via a FetchRewrite result with\nFetchStub symbols.\n\n\nRough outline how it works:\nA rule triggers on any Limit operator. The rule invokes\nsource.rewriteFetch(usedOutputs) to trigger a rewrite of the sub-tree.\nusedOutputs is used the same as before, it indicates intermediately used\ncolumns.\nThe result of rewriteFetch is a FetchRewrite that contains:\n\nThe rewritten LogicalPlan operator\nreplacedOutputs, which is a mapping from \"previousOutput\" to \"what-the\nfetch operation needs to fetch to get the value for the original symbol\".\nSemantically both keys and values of the replacedOutputs represent the\noutputs of an operator before the rewrite. The values contain FetchStub\nsymbols which are used by Fetch to know what to fetch.\n\nChecklist\n\n Added an entry in CHANGES.txt for user facing changes\n Updated documentation & sql_features table for user facing changes\n Touched code is covered by tests\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-03-25T12:46:58Z", "url": "https://github.com/crate/crate/pull/9801", "merged": true, "mergeCommit": {"oid": "72309e9d401eb5c2de00f8a236174d31ed98346e"}, "closed": true, "closedAt": "2020-03-25T16:49:27Z", "author": {"login": "mfussenegger"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRImjqgBqjMxNjQyODU1MDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRJ3z3ABqjMxNjQ2ODkzMzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd535712c5ba71c795e296db718b1afb9abb6971", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/fd535712c5ba71c795e296db718b1afb9abb6971", "committedDate": "2020-03-25T14:31:04Z", "message": "Support fetch rewrite for NestedLoopJoin"}, "afterCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/c9710624c4683d11e3d24774beb174fbd8617d76", "committedDate": "2020-03-25T14:44:01Z", "message": "Support fetch rewrite for NestedLoopJoin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMjIwMTg5", "url": "https://github.com/crate/crate/pull/9801#pullrequestreview-381220189", "createdAt": "2020-03-25T14:47:14Z", "commit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NzoxNFrOF7erBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NzoxNFrOF7erBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjgzNw==", "bodyText": "I think we can move this in a follow up into either fetchRewrite itself or some utils or make it top-level, because we will need this for other operators as well.", "url": "https://github.com/crate/crate/pull/9801#discussion_r397912837", "createdAt": "2020-03-25T14:47:14Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Order.java", "diffHunk": "@@ -83,6 +88,50 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         return replaceSources(List.of(newSource));\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        HashSet<Symbol> allUsedColumns = new HashSet<>(usedColumns);\n+        allUsedColumns.addAll(orderBy.orderBySymbols());\n+        FetchRewrite fetchRewrite = source.rewriteToFetch(allUsedColumns);\n+        if (fetchRewrite == null) {\n+            return null;\n+        }\n+        LogicalPlan newSource = fetchRewrite.newPlan();\n+        Order newOrderBy = new Order(newSource, orderBy);\n+        Map<Symbol, Symbol> replacedOutputs = fetchRewrite.replacedOutputs();\n+        if (newOrderBy.outputs.size() > newSource.outputs().size()) {\n+            // This is the case if the `orderBy` contains computations on top of the source outputs.\n+            // e.g. OrderBy [x + y] where the source provides [x, y]\n+            // We need to extend replacedOutputs in this case because it must always contain entries for all outputs\n+            LinkedHashMap<Symbol, Symbol> newReplacedOutputs = new LinkedHashMap<>(replacedOutputs);\n+            FunctionCopyVisitor<Void> mapToFetchStubs = new FunctionCopyVisitor<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0e838f511943b32b5631245b26f39a388d04048", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/e0e838f511943b32b5631245b26f39a388d04048", "committedDate": "2020-03-25T14:48:21Z", "message": "Make fetch rewrite rule propagate through the whole sub-tree"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMjQ2ODg5", "url": "https://github.com/crate/crate/pull/9801#pullrequestreview-381246889", "createdAt": "2020-03-25T15:13:13Z", "commit": {"oid": "e11f6d9b6ae42fe0864c9d985280552e9a948a79"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMzoxM1rOF7f8og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo1N1rOF7ga9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzMzczMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * We can in a first phase fetch the values for [_fetchid, a],\n          \n          \n            \n             * In a first phase we can fetch the values for [_fetchid, a],", "url": "https://github.com/crate/crate/pull/9801#discussion_r397933730", "createdAt": "2020-03-25T15:13:13Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/Fetch.java", "diffHunk": "@@ -48,6 +48,35 @@\n import java.util.Map;\n import java.util.function.Function;\n \n+/**\n+ * <p>\n+ *   The fetch operator represents a 2 phase execution that is used to reduce value look-ups.\n+ * </p>\n+ *\n+ * For example:\n+ *\n+ * <pre>\n+ *     Limit[10]\n+ *      \u2514 OrderBy [a]\n+ *        \u2514 Collect [a, b, c]\n+ * </pre>\n+ *\n+ * Would fetch the values for all columns ([a, b, c]) {@code 10 * num_nodes} times.\n+ * With the fetch operator:\n+ *\n+ * <pre>\n+ *     Fetch [a, b, c]\n+ *      \u2514 Limit [10]\n+ *        \u2514 OrderBy [a]\n+ *          \u2514 Collect [_fetchid, a]\n+ * </pre>\n+ *\n+ * We can in a first phase fetch the values for [_fetchid, a],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e11f6d9b6ae42fe0864c9d985280552e9a948a79"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzNDk5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * because `HashAggregate` needs all columns produce its result.\n          \n          \n            \n                 * because `HashAggregate` needs all columns to produce its result.", "url": "https://github.com/crate/crate/pull/9801#discussion_r397934991", "createdAt": "2020-03-25T15:14:45Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -149,6 +149,40 @@ default boolean preferShardProjections() {\n      */\n     LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep);\n \n+    /**\n+     * Rewrite an operator and its children to utilize a \"query-then-fetch\" approach.\n+     * See {@link Fetch} for an explanation of query-then-fetch.\n+     * <pre>\n+     * This must propagate if possible. Example:\n+     *\n+     *     Limit[10]            // calls source.rewriteToFetch\n+     *      \u2514 Order [a ASC]     // should call source.rewriteToFetch\n+     *        \u2514 Collect [x, a, b]\n+     *\n+     * This results in:\n+     *\n+     *      Fetch[x, a, b]\n+     *       \u2514 Limit[10]\n+     *         \u2514 Order [a ASC]\n+     *           \u2514 Collect [_fetchid, a]\n+     *\n+     * Note that propagation only needs to happen if all operators can forward the `_fetchid`. Consider the following:\n+     *\n+     *      Limit[10]\n+     *        \u2514 HashAggregate[min(x), min(y)]\n+     *          \u2514 Limit[5]\n+     *            \u2514 Collect [x, y]\n+     *\n+     * In this case a call on `HashAggregate.rewriteToFetch` can return `null` to indicate that there is nothing to fetch,\n+     * because `HashAggregate` needs all columns produce its result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e11f6d9b6ae42fe0864c9d985280552e9a948a79"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzODU5NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/crate/crate/pull/9801#discussion_r397938594", "createdAt": "2020-03-25T15:19:23Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java", "diffHunk": "@@ -486,8 +486,27 @@ public static NodeOperationTree getNodeOperationTree(LogicalPlan logicalPlan,\n                                                          PlannerContext plannerContext,\n                                                          Row params,\n                                                          SubQueryResults subQueryResults) {\n-        ExecutionPlan executionPlan = logicalPlan.build(\n-            plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        ExecutionPlan executionPlan;\n+        try {\n+            executionPlan = logicalPlan.build(\n+                plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        } catch (Exception e) {\n+            // This should really only happen if there are planner bugs,\n+            // so the additional costs of creating a more informative exception shouldn't matter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTQ5NQ==", "bodyText": "Looks like there is no LogicalPlan test for this optimization, maybe worth creating one?", "url": "https://github.com/crate/crate/pull/9801#discussion_r397941495", "createdAt": "2020-03-25T15:22:57Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java", "diffHunk": "@@ -284,6 +284,42 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         );\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        ArrayList<Symbol> usedFromLeft = new ArrayList<>();\n+        ArrayList<Symbol> usedFromRight = new ArrayList<>();\n+        for (Symbol usedColumn : usedColumns) {\n+            SymbolVisitors.intersection(usedColumn, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(usedColumn, rhs.outputs(), usedFromRight::add);\n+        }\n+        if (joinCondition != null) {\n+            SymbolVisitors.intersection(joinCondition, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(joinCondition, rhs.outputs(), usedFromRight::add);\n+        }\n+        FetchRewrite lhsFetchRewrite = lhs.rewriteToFetch(usedFromLeft);\n+        if (lhsFetchRewrite == null) {\n+            return null;\n+        }\n+        FetchRewrite rhsFetchRewrite = rhs.rewriteToFetch(usedFromRight);\n+        if (rhsFetchRewrite == null) {\n+            return null;\n+        }\n+        return new FetchRewrite(\n+            Maps.concat(lhsFetchRewrite.replacedOutputs(), rhsFetchRewrite.replacedOutputs()),\n+            new NestedLoopJoin(\n+                lhsFetchRewrite.newPlan(),\n+                rhsFetchRewrite.newPlan(),\n+                joinType,\n+                joinCondition,\n+                isFiltered,\n+                topMostLeftRelation,\n+                orderByWasPushedDown,\n+                rewriteFilterOnOuterJoinToInnerJoinDone\n+            )\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/a1e987fd6b256ca0766ddeab906b7e996cc0b411", "committedDate": "2020-03-25T15:57:17Z", "message": "Enable query-then-fetch for Limit \u2192 Order \u2192 Collect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "committedDate": "2020-03-25T16:01:33Z", "message": "Support fetch rewrite for NestedLoopJoin"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/c9710624c4683d11e3d24774beb174fbd8617d76", "committedDate": "2020-03-25T14:44:01Z", "message": "Support fetch rewrite for NestedLoopJoin"}, "afterCommit": {"oid": "443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "author": {"user": {"login": "mfussenegger", "name": "Mathias Fu\u00dfenegger"}}, "url": "https://github.com/crate/crate/commit/443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "committedDate": "2020-03-25T16:01:33Z", "message": "Support fetch rewrite for NestedLoopJoin"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3449, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}