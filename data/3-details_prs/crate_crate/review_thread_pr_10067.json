{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMzM2ODI4", "number": 10067, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwOTo0OTo0NFrOEEOU2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoyMjoyM1rOEERQsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODY0NDcyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/io/crate/planner/operators/LogicalPlannerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwOTo0OTo0NFrOGhteiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwOTo0OTo0NFrOGhteiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAwMTI4OQ==", "bodyText": "testSelectCountStarIsOptimizedInsideRelations failed with:\njava.lang.AssertionError: \nExpected: a value less than or equal to <8388608L>\n     but: <24224152L> was greater than <8388608L>\n\tat __randomizedtesting.SeedInfo.seed([A1199D5560FEB506:3485992BF20EF71E]:0)\n\tat org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:18)\n\tat org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6)\n\tat io.crate.testing.MemoryLimits.assertMaxBytesAllocated(MemoryLimits.java:46)\n\tat io.crate.planner.operators.LogicalPlannerTest.plan(LogicalPlannerTest.java:69)\n\tat io.crate.planner.operators.LogicalPlannerTest.testSelectCountStarIsOptimizedInsideRelations(LogicalPlannerTest.java:221)\n\nNot sure why this increased in that particular case, because that isn't even affected by the other changes in this PR. Will follow up on this separately.", "url": "https://github.com/crate/crate/pull/10067#discussion_r438001289", "createdAt": "2020-06-10T09:49:44Z", "author": {"login": "mfussenegger"}, "path": "server/src/test/java/io/crate/planner/operators/LogicalPlannerTest.java", "diffHunk": "@@ -66,7 +66,7 @@ public void prepare() throws IOException {\n     }\n \n     private LogicalPlan plan(String statement) {\n-        return assertMaxBytesAllocated(ByteSizeUnit.MB.toBytes(8), () -> sqlExecutor.logicalPlan(statement));\n+        return assertMaxBytesAllocated(ByteSizeUnit.MB.toBytes(25), () -> sqlExecutor.logicalPlan(statement));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8df34b1b24c5b72ab7532b94e2e94d57578f54b2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTEyNTYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/planner/operators/TopNDistinct.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoyMjoyM1rOGhyObw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjo1NzoxNlrOGhzgLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3OTA4Nw==", "bodyText": "shouldn't be limit = limit + offset here also?", "url": "https://github.com/crate/crate/pull/10067#discussion_r438079087", "createdAt": "2020-06-10T12:22:23Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/TopNDistinct.java", "diffHunk": "@@ -101,31 +105,50 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 subQueryResults\n             )\n         );\n+        int offset = DataTypes.INTEGER.value(\n+            evaluate(\n+                plannerContext.transactionContext(),\n+                plannerContext.functions(),\n+                this.offset,\n+                params,\n+                subQueryResults\n+            )\n+        );\n         var inputColOutputs = InputColumn.mapToInputColumns(outputs);\n         executionPlan.addProjection(\n             new TopNDistinctProjection(\n-                limit,\n+                limit + offset,\n                 inputColOutputs,\n                 source.preferShardProjections() ? RowGranularity.SHARD : RowGranularity.CLUSTER\n             )\n         );\n         boolean onHandler = ExecutionPhases.executesOnHandler(\n             plannerContext.handlerNode(), executionPlan.resultDescription().nodeIds());\n-        if (!onHandler) {\n-            executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n-        } else if (source.preferShardProjections()) {\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n+        if (!onHandler || source.preferShardProjections()) {\n+            if (!onHandler) {\n+                executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n+            }\n+            TopNDistinctProjection topNDistinct = new TopNDistinctProjection(\n+                limit + offset,\n+                inputColOutputs,\n+                RowGranularity.CLUSTER\n+            );\n+            executionPlan.addProjection(topNDistinct);\n+            if (offset > 0) {\n+                // TopNDistinctProjection outputs a distinct result-set,\n+                // That allows us to use the TopNProjection to apply the offset\n+                executionPlan.addProjection(\n+                    new TopNProjection(limit, offset, Symbols.typeView(topNDistinct.outputs()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "128c1b6b0b503c9e2097fee50370771f0bf47715"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4MTIwNw==", "bodyText": "No, this is the final projection on the coordinator that needs to apply the final limit", "url": "https://github.com/crate/crate/pull/10067#discussion_r438081207", "createdAt": "2020-06-10T12:26:16Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/TopNDistinct.java", "diffHunk": "@@ -101,31 +105,50 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 subQueryResults\n             )\n         );\n+        int offset = DataTypes.INTEGER.value(\n+            evaluate(\n+                plannerContext.transactionContext(),\n+                plannerContext.functions(),\n+                this.offset,\n+                params,\n+                subQueryResults\n+            )\n+        );\n         var inputColOutputs = InputColumn.mapToInputColumns(outputs);\n         executionPlan.addProjection(\n             new TopNDistinctProjection(\n-                limit,\n+                limit + offset,\n                 inputColOutputs,\n                 source.preferShardProjections() ? RowGranularity.SHARD : RowGranularity.CLUSTER\n             )\n         );\n         boolean onHandler = ExecutionPhases.executesOnHandler(\n             plannerContext.handlerNode(), executionPlan.resultDescription().nodeIds());\n-        if (!onHandler) {\n-            executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n-        } else if (source.preferShardProjections()) {\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n+        if (!onHandler || source.preferShardProjections()) {\n+            if (!onHandler) {\n+                executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n+            }\n+            TopNDistinctProjection topNDistinct = new TopNDistinctProjection(\n+                limit + offset,\n+                inputColOutputs,\n+                RowGranularity.CLUSTER\n+            );\n+            executionPlan.addProjection(topNDistinct);\n+            if (offset > 0) {\n+                // TopNDistinctProjection outputs a distinct result-set,\n+                // That allows us to use the TopNProjection to apply the offset\n+                executionPlan.addProjection(\n+                    new TopNProjection(limit, offset, Symbols.typeView(topNDistinct.outputs()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3OTA4Nw=="}, "originalCommit": {"oid": "128c1b6b0b503c9e2097fee50370771f0bf47715"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4MjIxNg==", "bodyText": "ah right, thx.", "url": "https://github.com/crate/crate/pull/10067#discussion_r438082216", "createdAt": "2020-06-10T12:27:53Z", "author": {"login": "seut"}, "path": "server/src/main/java/io/crate/planner/operators/TopNDistinct.java", "diffHunk": "@@ -101,31 +105,50 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 subQueryResults\n             )\n         );\n+        int offset = DataTypes.INTEGER.value(\n+            evaluate(\n+                plannerContext.transactionContext(),\n+                plannerContext.functions(),\n+                this.offset,\n+                params,\n+                subQueryResults\n+            )\n+        );\n         var inputColOutputs = InputColumn.mapToInputColumns(outputs);\n         executionPlan.addProjection(\n             new TopNDistinctProjection(\n-                limit,\n+                limit + offset,\n                 inputColOutputs,\n                 source.preferShardProjections() ? RowGranularity.SHARD : RowGranularity.CLUSTER\n             )\n         );\n         boolean onHandler = ExecutionPhases.executesOnHandler(\n             plannerContext.handlerNode(), executionPlan.resultDescription().nodeIds());\n-        if (!onHandler) {\n-            executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n-        } else if (source.preferShardProjections()) {\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n+        if (!onHandler || source.preferShardProjections()) {\n+            if (!onHandler) {\n+                executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n+            }\n+            TopNDistinctProjection topNDistinct = new TopNDistinctProjection(\n+                limit + offset,\n+                inputColOutputs,\n+                RowGranularity.CLUSTER\n+            );\n+            executionPlan.addProjection(topNDistinct);\n+            if (offset > 0) {\n+                // TopNDistinctProjection outputs a distinct result-set,\n+                // That allows us to use the TopNProjection to apply the offset\n+                executionPlan.addProjection(\n+                    new TopNProjection(limit, offset, Symbols.typeView(topNDistinct.outputs()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3OTA4Nw=="}, "originalCommit": {"oid": "128c1b6b0b503c9e2097fee50370771f0bf47715"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwMDAxMw==", "bodyText": "Ah, but it should actually be outside of the block - otherwise it won't work for queries on sys tables or virtual tables.. Will add a fixup", "url": "https://github.com/crate/crate/pull/10067#discussion_r438100013", "createdAt": "2020-06-10T12:57:16Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/planner/operators/TopNDistinct.java", "diffHunk": "@@ -101,31 +105,50 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 subQueryResults\n             )\n         );\n+        int offset = DataTypes.INTEGER.value(\n+            evaluate(\n+                plannerContext.transactionContext(),\n+                plannerContext.functions(),\n+                this.offset,\n+                params,\n+                subQueryResults\n+            )\n+        );\n         var inputColOutputs = InputColumn.mapToInputColumns(outputs);\n         executionPlan.addProjection(\n             new TopNDistinctProjection(\n-                limit,\n+                limit + offset,\n                 inputColOutputs,\n                 source.preferShardProjections() ? RowGranularity.SHARD : RowGranularity.CLUSTER\n             )\n         );\n         boolean onHandler = ExecutionPhases.executesOnHandler(\n             plannerContext.handlerNode(), executionPlan.resultDescription().nodeIds());\n-        if (!onHandler) {\n-            executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n-        } else if (source.preferShardProjections()) {\n-            executionPlan.addProjection(\n-                new TopNDistinctProjection(limit, inputColOutputs, RowGranularity.CLUSTER));\n+        if (!onHandler || source.preferShardProjections()) {\n+            if (!onHandler) {\n+                executionPlan = Merge.ensureOnHandler(executionPlan, plannerContext);\n+            }\n+            TopNDistinctProjection topNDistinct = new TopNDistinctProjection(\n+                limit + offset,\n+                inputColOutputs,\n+                RowGranularity.CLUSTER\n+            );\n+            executionPlan.addProjection(topNDistinct);\n+            if (offset > 0) {\n+                // TopNDistinctProjection outputs a distinct result-set,\n+                // That allows us to use the TopNProjection to apply the offset\n+                executionPlan.addProjection(\n+                    new TopNProjection(limit, offset, Symbols.typeView(topNDistinct.outputs()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3OTA4Nw=="}, "originalCommit": {"oid": "128c1b6b0b503c9e2097fee50370771f0bf47715"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1396, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}