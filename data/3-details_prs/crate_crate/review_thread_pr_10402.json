{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMTU3Mzg3", "number": 10402, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoxODo1MFrOEZ_-bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoxODo1MFrOEZ_-bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Njk4MDMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoxODo1MFrOHDJnJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToxMDo0MVrOHDL_1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA==", "bodyText": "Shouldn't we do this in apply instead, to account the used bytes earlier? Or does that make the abstractions more complex?", "url": "https://github.com/crate/crate/pull/10402#discussion_r473065254", "createdAt": "2020-08-19T14:18:50Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97e90192158ffa5f0c5021487e8113c470f61503"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MDgyNA==", "bodyText": "Yes, forgot that it is called only once. I will just override the apply then and account for memory there.", "url": "https://github.com/crate/crate/pull/10402#discussion_r473070824", "createdAt": "2020-08-19T14:25:54Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, "originalCommit": {"oid": "97e90192158ffa5f0c5021487e8113c470f61503"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4NzUxOA==", "bodyText": "Hm it makes it a bit hard, it is not possible to reuse the abstraction, and extending it does not make sense. We need to have 4 different separate implementations for this case :/", "url": "https://github.com/crate/crate/pull/10402#discussion_r473087518", "createdAt": "2020-08-19T14:47:43Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, "originalCommit": {"oid": "97e90192158ffa5f0c5021487e8113c470f61503"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDQxNA==", "bodyText": "I'm a bit worried for the GROUP BY cases if we delay the accounting to partialResult. For aggregations it doesn't matter as it is only 1 row anyways. But afaik in the GROUP BY case the partial calls would happen at the very end, so we could have unique_key_values * num_arbitrary_aggregation aggregation states un-accounted for in-memory during the initial grouping phase, before any arbitrary state is accounted for.", "url": "https://github.com/crate/crate/pull/10402#discussion_r473090414", "createdAt": "2020-08-19T14:51:42Z", "author": {"login": "mfussenegger"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, "originalCommit": {"oid": "97e90192158ffa5f0c5021487e8113c470f61503"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDM0MQ==", "bodyText": "I see, let me look a bit more at it, but think for the arbitrary that's only the way to go with separate implementations or have smth like ThreeConsumer :)", "url": "https://github.com/crate/crate/pull/10402#discussion_r473104341", "createdAt": "2020-08-19T15:10:41Z", "author": {"login": "kovrus"}, "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, "originalCommit": {"oid": "97e90192158ffa5f0c5021487e8113c470f61503"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1172, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}