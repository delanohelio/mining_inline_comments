{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNTY3NTY2", "number": 9801, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NzoxNFrODrP2qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo1NlrODrQ7Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Njc1MTE1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/Order.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NzoxNFrOF7erBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NzoxNFrOF7erBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjgzNw==", "bodyText": "I think we can move this in a follow up into either fetchRewrite itself or some utils or make it top-level, because we will need this for other operators as well.", "url": "https://github.com/crate/crate/pull/9801#discussion_r397912837", "createdAt": "2020-03-25T14:47:14Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Order.java", "diffHunk": "@@ -83,6 +88,50 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         return replaceSources(List.of(newSource));\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        HashSet<Symbol> allUsedColumns = new HashSet<>(usedColumns);\n+        allUsedColumns.addAll(orderBy.orderBySymbols());\n+        FetchRewrite fetchRewrite = source.rewriteToFetch(allUsedColumns);\n+        if (fetchRewrite == null) {\n+            return null;\n+        }\n+        LogicalPlan newSource = fetchRewrite.newPlan();\n+        Order newOrderBy = new Order(newSource, orderBy);\n+        Map<Symbol, Symbol> replacedOutputs = fetchRewrite.replacedOutputs();\n+        if (newOrderBy.outputs.size() > newSource.outputs().size()) {\n+            // This is the case if the `orderBy` contains computations on top of the source outputs.\n+            // e.g. OrderBy [x + y] where the source provides [x, y]\n+            // We need to extend replacedOutputs in this case because it must always contain entries for all outputs\n+            LinkedHashMap<Symbol, Symbol> newReplacedOutputs = new LinkedHashMap<>(replacedOutputs);\n+            FunctionCopyVisitor<Void> mapToFetchStubs = new FunctionCopyVisitor<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Njg3ODQ4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/Fetch.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMzoxM1rOF7f8og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMzoxM1rOF7f8og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzMzczMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * We can in a first phase fetch the values for [_fetchid, a],\n          \n          \n            \n             * In a first phase we can fetch the values for [_fetchid, a],", "url": "https://github.com/crate/crate/pull/9801#discussion_r397933730", "createdAt": "2020-03-25T15:13:13Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/Fetch.java", "diffHunk": "@@ -48,6 +48,35 @@\n import java.util.Map;\n import java.util.function.Function;\n \n+/**\n+ * <p>\n+ *   The fetch operator represents a 2 phase execution that is used to reduce value look-ups.\n+ * </p>\n+ *\n+ * For example:\n+ *\n+ * <pre>\n+ *     Limit[10]\n+ *      \u2514 OrderBy [a]\n+ *        \u2514 Collect [a, b, c]\n+ * </pre>\n+ *\n+ * Would fetch the values for all columns ([a, b, c]) {@code 10 * num_nodes} times.\n+ * With the fetch operator:\n+ *\n+ * <pre>\n+ *     Fetch [a, b, c]\n+ *      \u2514 Limit [10]\n+ *        \u2514 OrderBy [a]\n+ *          \u2514 Collect [_fetchid, a]\n+ * </pre>\n+ *\n+ * We can in a first phase fetch the values for [_fetchid, a],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e11f6d9b6ae42fe0864c9d985280552e9a948a79"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Njg4NjIwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxNDo0NVrOF7gBjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxNDo0NVrOF7gBjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzNDk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * because `HashAggregate` needs all columns produce its result.\n          \n          \n            \n                 * because `HashAggregate` needs all columns to produce its result.", "url": "https://github.com/crate/crate/pull/9801#discussion_r397934991", "createdAt": "2020-03-25T15:14:45Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -149,6 +149,40 @@ default boolean preferShardProjections() {\n      */\n     LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep);\n \n+    /**\n+     * Rewrite an operator and its children to utilize a \"query-then-fetch\" approach.\n+     * See {@link Fetch} for an explanation of query-then-fetch.\n+     * <pre>\n+     * This must propagate if possible. Example:\n+     *\n+     *     Limit[10]            // calls source.rewriteToFetch\n+     *      \u2514 Order [a ASC]     // should call source.rewriteToFetch\n+     *        \u2514 Collect [x, a, b]\n+     *\n+     * This results in:\n+     *\n+     *      Fetch[x, a, b]\n+     *       \u2514 Limit[10]\n+     *         \u2514 Order [a ASC]\n+     *           \u2514 Collect [_fetchid, a]\n+     *\n+     * Note that propagation only needs to happen if all operators can forward the `_fetchid`. Consider the following:\n+     *\n+     *      Limit[10]\n+     *        \u2514 HashAggregate[min(x), min(y)]\n+     *          \u2514 Limit[5]\n+     *            \u2514 Collect [x, y]\n+     *\n+     * In this case a call on `HashAggregate.rewriteToFetch` can return `null` to indicate that there is nothing to fetch,\n+     * because `HashAggregate` needs all columns produce its result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e11f6d9b6ae42fe0864c9d985280552e9a948a79"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NjkwODU1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxOToyM1rOF7gPog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxOToyM1rOF7gPog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzODU5NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/crate/crate/pull/9801#discussion_r397938594", "createdAt": "2020-03-25T15:19:23Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java", "diffHunk": "@@ -486,8 +486,27 @@ public static NodeOperationTree getNodeOperationTree(LogicalPlan logicalPlan,\n                                                          PlannerContext plannerContext,\n                                                          Row params,\n                                                          SubQueryResults subQueryResults) {\n-        ExecutionPlan executionPlan = logicalPlan.build(\n-            plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        ExecutionPlan executionPlan;\n+        try {\n+            executionPlan = logicalPlan.build(\n+                plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        } catch (Exception e) {\n+            // This should really only happen if there are planner bugs,\n+            // so the additional costs of creating a more informative exception shouldn't matter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NjkyNjU1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo1N1rOF7ga9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo1N1rOF7ga9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTQ5NQ==", "bodyText": "Looks like there is no LogicalPlan test for this optimization, maybe worth creating one?", "url": "https://github.com/crate/crate/pull/9801#discussion_r397941495", "createdAt": "2020-03-25T15:22:57Z", "author": {"login": "seut"}, "path": "sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java", "diffHunk": "@@ -284,6 +284,42 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         );\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        ArrayList<Symbol> usedFromLeft = new ArrayList<>();\n+        ArrayList<Symbol> usedFromRight = new ArrayList<>();\n+        for (Symbol usedColumn : usedColumns) {\n+            SymbolVisitors.intersection(usedColumn, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(usedColumn, rhs.outputs(), usedFromRight::add);\n+        }\n+        if (joinCondition != null) {\n+            SymbolVisitors.intersection(joinCondition, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(joinCondition, rhs.outputs(), usedFromRight::add);\n+        }\n+        FetchRewrite lhsFetchRewrite = lhs.rewriteToFetch(usedFromLeft);\n+        if (lhsFetchRewrite == null) {\n+            return null;\n+        }\n+        FetchRewrite rhsFetchRewrite = rhs.rewriteToFetch(usedFromRight);\n+        if (rhsFetchRewrite == null) {\n+            return null;\n+        }\n+        return new FetchRewrite(\n+            Maps.concat(lhsFetchRewrite.replacedOutputs(), rhsFetchRewrite.replacedOutputs()),\n+            new NestedLoopJoin(\n+                lhsFetchRewrite.newPlan(),\n+                rhsFetchRewrite.newPlan(),\n+                joinType,\n+                joinCondition,\n+                isFiltered,\n+                topMostLeftRelation,\n+                orderByWasPushedDown,\n+                rewriteFilterOnOuterJoinToInnerJoinDone\n+            )\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9710624c4683d11e3d24774beb174fbd8617d76"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1551, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}