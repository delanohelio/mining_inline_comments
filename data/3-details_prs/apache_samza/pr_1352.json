{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4Nzk4NTk2", "number": 1352, "title": "SAMZA-2516: Migrate BaseKeyValueStorageEngineFactory to be an abstract class instead of trait", "bodyText": "Issues:\n\nIf using Scala 2.11, there is a compile error when trying to use a Java class extend a Scala trait with implemented methods. BaseKeyValueStorageEngineFactory can be considered part of the Samza API, but it is a Scala trait with an implemented method, so that restricts extension.\nIt would be good to migrate away from Scala code in general, for consistency with other new Samza code.\n\nChanges:\n\nBaseKeyValueStorageEngineFactory is now an abstract class written in Java.\nAdded some unit tests for BaseKeyValueStorageEngineFactory.\nThe functionality is intended to stay the same.\n\nTests:\n\nAdded unit tests\nSome tests in samza-test use in-memory key-value storage, and those tests pass.\nDeployed job with \"drop.large.messages\" enabled and verified that messages get dropped\nDeployed job with \"disallow.large.messages\" enabled and verified that exception is thrown\nDeployed job with changelog enabled and verified that changelog was being written to\n\nAPI changes:\nBaseKeyValueStorageEngineFactory is no longer a Scala trait, so that could potentially impact existing inheritors:\n\nAny existing Scala classes which uses the with syntax to mix in BaseKeyValueStorageEngineFactory will need to be updated to use BaseKeyValueStorageEngineFactory as an abstract class instead. If an existing Scala class used extends BaseKeyValueStorageEngineFactory (such as how InMemoryKeyValueStorageEngineFactory and RocksDbKeyValueStorageEngineFactory uses BaseKeyValueStorageEngineFactory), then it should not need to change.\nScala 2.12 compiles traits into interfaces with default methods, so a Java class built against the Scala 2.12 version of BaseKeyValueStorageEngineFactory won't be able to use it as an interface. A Java class will need to use BaseKeyValueStorageEngineFactory as an abstract class. I suppose BaseKeyValueStorageEngineFactory could work as an interface with a default implementation for getStorageEngine, but it seems like abstract class fits the pattern better, since getKVStore shouldn't be a public method.\n\nUpgrade instructions:\nAny custom implementation of BaseKeyValueStorageEngineFactory needs to treat it as an abstract class, not a trait/interface. If it is necessary to make changes, only class inheritance structure should need to be changed. The functionality/signature of getStorageEngine and the usage of the getKVStore abstract method are the same, so those pieces should stay the same.", "createdAt": "2020-04-24T22:52:39Z", "url": "https://github.com/apache/samza/pull/1352", "merged": true, "mergeCommit": {"oid": "a5f7a66cfde97ab0aa3bfcf662d827a4aeb324e1"}, "closed": true, "closedAt": "2020-06-15T22:40:14Z", "author": {"login": "cameronlee314"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABca4y6-gH2gAyNDA4Nzk4NTk2OmU1NmExYTZmNTkzYWM4NWRmOGYxMTE5MWY5ZDZlNmVjMGIwYjM1YzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrmJ2xgFqTQzMDk0NTkyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "committedDate": "2020-04-24T21:58:25Z", "message": "SAMZA-2516: Migrate BaseKeyValueStorageEngineFactory to be an abstract class instead of trait"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjA3Nzcx", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-402207771", "createdAt": "2020-04-28T21:00:24Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTowMDoyNFrOGNmuVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyMDoxMlrOGNnYSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxOTEyNA==", "bodyText": "Is there a difference here between the order of wrapping each store between disallowing large messages vs. allowing? Ie. in the if statement, you first create the maybeCachedStore first and then the LargeMessageSafeStore, then the SerializedStore vs in the else statement, you first create the LargeMessageSafeStore, the SerializedStore, then the maybeCachedStore?\nAlso if there isn't a difference in order, couldn't we refactor this section of the code into a function that is passed  the getDisallowLargeMessages as a param to return the final store?", "url": "https://github.com/apache/samza/pull/1352#discussion_r416919124", "createdAt": "2020-04-28T21:00:24Z", "author": {"login": "PanTheMan"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,\n+      String storeName,\n+      MetricsRegistry registry,\n+      StoreProperties.StorePropertiesBuilder storePropertiesBuilder,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      MessageCollector changelogCollector) {\n+    if (changelogSSP == null) {\n+      return storeToWrap;\n+    } else {\n+      LoggedStoreMetrics loggedStoreMetrics = new LoggedStoreMetrics(storeName, registry);\n+      storePropertiesBuilder.setLoggedStore(true);\n+      return new LoggedStore<>(storeToWrap, changelogSSP, changelogCollector, loggedStoreMetrics);\n+    }\n+  }\n+\n+  private static <T, U> KeyValueStore<T, U> applyLargeMessageHandling(String storeName,\n+      MetricsRegistry registry,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      StorageConfig storageConfig,\n+      int cacheSize,\n+      int batchSize,\n+      Serde<T> keySerde,\n+      Serde<U> msgSerde) {\n+    int maxMessageSize = storageConfig.getChangelogMaxMsgSizeBytes(storeName);\n+    if (storageConfig.getDisallowLargeMessages(storeName)) {\n+      /*\n+       * If large messages are disallowed in config, then this creates a LargeMessageSafeKeyValueStore that throws a\n+       * RecordTooLargeException when a large message is encountered.\n+       */\n+      KeyValueStore<byte[], byte[]> maybeCachedStore =\n+          buildMaybeCachedStore(storeName, registry, storeToWrap, cacheSize, batchSize);\n+      LargeMessageSafeStore largeMessageSafeKeyValueStore =\n+          new LargeMessageSafeStore(maybeCachedStore, storeName, false, maxMessageSize);\n+      return buildSerializedStore(storeName, registry, largeMessageSafeKeyValueStore, keySerde, msgSerde);\n+    } else {\n+      KeyValueStore<byte[], byte[]> toBeSerializedStore;\n+      if (storageConfig.getDropLargeMessages(storeName)) {\n+        toBeSerializedStore = new LargeMessageSafeStore(storeToWrap, storeName, true, maxMessageSize);\n+      } else {\n+        toBeSerializedStore = storeToWrap;\n+      }\n+      KeyValueStore<T, U> serializedStore =\n+          buildSerializedStore(storeName, registry, toBeSerializedStore, keySerde, msgSerde);\n+      return buildMaybeCachedStore(storeName, registry, serializedStore, cacheSize, batchSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTg2NQ==", "bodyText": "Is there a need to add a unit test if keySerde or msgSerde is missing?", "url": "https://github.com/apache/samza/pull/1352#discussion_r416929865", "createdAt": "2020-04-28T21:20:12Z", "author": {"login": "PanTheMan"}, "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStoreWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(nullSafeKeyValueStore.getStore(), CachedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(cachedStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDisallowLargeMessages() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, DISALLOW_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDisallowLargeMessagesWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG, DISALLOW_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(largeMessageSafeStore.getStore(), CachedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, cachedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDropLargeMessages() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, DROP_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDropLargeMessagesWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG, DROP_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(nullSafeKeyValueStore.getStore(), CachedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(cachedStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testAccessLogStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, ACCESS_LOG_ENABLED);\n+    // AccessLoggedStore requires a changelog SSP\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    AccessLoggedStore<?, ?> accessLoggedStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), AccessLoggedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(accessLoggedStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  private static <T extends KeyValueStore<?, ?>> T assertAndCast(KeyValueStore<?, ?> keyValueStore, Class<T> clazz) {\n+    assertTrue(\"Expected type \" + clazz.getName(), clazz.isInstance(keyValueStore));\n+    return clazz.cast(keyValueStore);\n+  }\n+\n+  private KeyValueStorageEngine<?, ?> baseStorageEngineValidation(StorageEngine storageEngine) {\n+    assertTrue(storageEngine instanceof KeyValueStorageEngine);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = (KeyValueStorageEngine<?, ?>) storageEngine;\n+    assertEquals(this.rawKeyValueStore, keyValueStorageEngine.getRawStore());\n+    return keyValueStorageEngine;\n+  }\n+\n+  private static void assertStoreProperties(StoreProperties storeProperties, boolean expectedPersistedToDisk,\n+      boolean expectedLoggedStore) {\n+    assertEquals(expectedPersistedToDisk, storeProperties.isPersistedToDisk());\n+    assertEquals(expectedLoggedStore, storeProperties.isLoggedStore());\n+  }\n+\n+  /**\n+   * @param changelogSSP if non-null, then enables logged store\n+   */\n+  private StorageEngine callGetStorageEngine(Config config, SystemStreamPartition changelogSSP) {\n+    when(this.jobContext.getConfig()).thenReturn(config);\n+    return new MockKeyValueStorageEngineFactory(this.rawKeyValueStore).getStorageEngine(STORE_NAME, this.storeDir,\n+        this.keySerde, this.msgSerde, this.changelogCollector, this.metricsRegistry, changelogSSP, this.jobContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 270}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5ODA5NDUy", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-409809452", "createdAt": "2020-05-12T08:22:41Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODoyMjo0MVrOGT7hBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODoyNTowN1rOGT7nFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MTIzNg==", "bodyText": "What is this needed for? Can we remove this log line?", "url": "https://github.com/apache/samza/pull/1352#discussion_r423551236", "createdAt": "2020-05-12T08:22:41Z", "author": {"login": "PawasChhokra"}, "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1Mjc5MA==", "bodyText": "Can we change the name of this function to something like testWithLoggedAndCachedStore()?", "url": "https://github.com/apache/samza/pull/1352#discussion_r423552790", "createdAt": "2020-05-12T08:25:07Z", "author": {"login": "PawasChhokra"}, "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStoreWithCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTMxOTg2", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418531986", "createdAt": "2020-05-26T17:43:38Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0MzozOFrOGapUQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0MzozOFrOGapUQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5MzA4OA==", "bodyText": "Would it help to add the storeName in the error-message, so the user known which store he has not defined the factory for?", "url": "https://github.com/apache/samza/pull/1352#discussion_r430593088", "createdAt": "2020-05-26T17:43:38Z", "author": {"login": "rmatharu"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTMyODc4", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418532878", "createdAt": "2020-05-26T17:44:54Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NDo1NFrOGapW7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NDo1NFrOGapW7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5Mzc3NQ==", "bodyText": "Should we have variables for DEFAULT_BATCH_SIZE and DEFAULT_CACHE_SIZE?", "url": "https://github.com/apache/samza/pull/1352#discussion_r430593775", "createdAt": "2020-05-26T17:44:54Z", "author": {"login": "rmatharu"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTMzMTI1", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418533125", "createdAt": "2020-05-26T17:45:12Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NToxMlrOGapX2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NToxMlrOGapX2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NDAwOA==", "bodyText": "Same as above, might help to have storeName in the error message", "url": "https://github.com/apache/samza/pull/1352#discussion_r430594008", "createdAt": "2020-05-26T17:45:12Z", "author": {"login": "rmatharu"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTMzOTc5", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418533979", "createdAt": "2020-05-26T17:46:24Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NjoyNFrOGapamw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0NjoyNFrOGapamw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NDcxNQ==", "bodyText": "/**\nWraps given store into a LoggedStore if a changeLog for the store is defined, otherwise skips wrapping.\n*/", "url": "https://github.com/apache/samza/pull/1352#discussion_r430594715", "createdAt": "2020-05-26T17:46:24Z", "author": {"login": "rmatharu"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTM1OTA5", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418535909", "createdAt": "2020-05-26T17:49:03Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0OTowM1rOGapg1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0OTowM1rOGapg1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NjMwOA==", "bodyText": "nit: buildStoreWithLargeMessageHandling?", "url": "https://github.com/apache/samza/pull/1352#discussion_r430596308", "createdAt": "2020-05-26T17:49:03Z", "author": {"login": "rmatharu"}, "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,\n+      String storeName,\n+      MetricsRegistry registry,\n+      StoreProperties.StorePropertiesBuilder storePropertiesBuilder,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      MessageCollector changelogCollector) {\n+    if (changelogSSP == null) {\n+      return storeToWrap;\n+    } else {\n+      LoggedStoreMetrics loggedStoreMetrics = new LoggedStoreMetrics(storeName, registry);\n+      storePropertiesBuilder.setLoggedStore(true);\n+      return new LoggedStore<>(storeToWrap, changelogSSP, changelogCollector, loggedStoreMetrics);\n+    }\n+  }\n+\n+  private static <T, U> KeyValueStore<T, U> applyLargeMessageHandling(String storeName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTM3MTAx", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-418537101", "createdAt": "2020-05-26T17:50:41Z", "commit": {"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76859a95b2eb566d88b14d4023521d90ecc6588d", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/76859a95b2eb566d88b14d4023521d90ecc6588d", "committedDate": "2020-05-28T01:21:23Z", "message": "added javadocs, extract constants, improve exception messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c67db5d38d0a5c344974313594ac2fe7f3eaabd", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/5c67db5d38d0a5c344974313594ac2fe7f3eaabd", "committedDate": "2020-05-28T17:21:23Z", "message": "Merge branch 'master' into base_kv_engine_scala"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTk3OTE0", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-421197914", "createdAt": "2020-05-29T18:39:55Z", "commit": {"oid": "5c67db5d38d0a5c344974313594ac2fe7f3eaabd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzc1Mzcz", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-421375373", "createdAt": "2020-05-30T03:57:14Z", "commit": {"oid": "5c67db5d38d0a5c344974313594ac2fe7f3eaabd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a805be9889a57e87070cfc088f18024aab6f381", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/1a805be9889a57e87070cfc088f18024aab6f381", "committedDate": "2020-06-12T16:43:23Z", "message": "Merge branch 'master' into base_kv_engine_scala"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTQ1OTIz", "url": "https://github.com/apache/samza/pull/1352#pullrequestreview-430945923", "createdAt": "2020-06-15T19:51:59Z", "commit": {"oid": "1a805be9889a57e87070cfc088f18024aab6f381"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4580, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}