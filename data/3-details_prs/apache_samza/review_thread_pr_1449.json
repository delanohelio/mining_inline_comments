{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwOTgyMjAx", "number": 1449, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMToxMjowOFrOFA-wuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzoyNToyMFrOFCfRmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTcyNjAwOnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMToxMjowOFrOH_iK2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMToxMjowOFrOH_iK2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM4MjE3MQ==", "bodyText": "Change \"attempt as\" to \"attempt are\".", "url": "https://github.com/apache/samza/pull/1449#discussion_r536382171", "createdAt": "2020-12-04T21:12:08Z", "author": {"login": "PawasChhokra"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt as defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83705050341d614de5835874a1ecba676d8c6a61"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTgxMTkzOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozODo1NFrOH_i7Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozODo1NFrOH_i7Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDU5OA==", "bodyText": "Can we also add an example of an epoch ID, config ID and job model ID for better visualization?", "url": "https://github.com/apache/samza/pull/1449#discussion_r536394598", "createdAt": "2020-12-04T21:38:54Z", "author": {"login": "PawasChhokra"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public final class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83705050341d614de5835874a1ecba676d8c6a61"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg3MzU2OnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozOTozNlrOIA_8Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjoyNDozOVrOIBD59Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxODUxNQ==", "bodyText": "does it change across deployment lifecycle? might stay same if config subset is same right.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537918515", "createdAt": "2020-12-07T23:39:36Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4MzQ3Nw==", "bodyText": "It remains the same. clarified in the doc.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537983477", "createdAt": "2020-12-08T02:24:39Z", "author": {"login": "mynameborat"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxODUxNQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg3NzA0OnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo0MDo0OVrOIA_-Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo0MDo0OVrOIA_-Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxODk5NQ==", "bodyText": "same here.. wrt deployment?", "url": "https://github.com/apache/samza/pull/1449#discussion_r537918995", "createdAt": "2020-12-07T23:40:49Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg5Nzg2OnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo0NzozOVrOIBAJog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjoyNDowNVrOIBD5Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMTk1NA==", "bodyText": "wondering if the obvious needs to be stated.. \"unique\" -- aka -- two job models JM1 != JM2 means JM_id1 != JM_id2? Or more specifically JM1.containerModel != JM2.containerModel then JM_id1 != JM_id2\nor is this what you mean by deterministic?\ncause i feel both reproducible and deterministic mean the same -->\nif n_th run of getJobModelId(JM) = JM_id1\nthen n+1_th run of getJobModelId(JM) should also give JM_id1 itself.\nmaybe i just need some clarification here", "url": "https://github.com/apache/samza/pull/1449#discussion_r537921954", "createdAt": "2020-12-07T23:47:39Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4MzI1NA==", "bodyText": "it should be unique. Updated the docs to say unique and reproducible", "url": "https://github.com/apache/samza/pull/1449#discussion_r537983254", "createdAt": "2020-12-08T02:24:05Z", "author": {"login": "mynameborat"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMTk1NA=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjkwMjI0OnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo0OToxNVrOIBAMKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo0OToxNVrOIBAMKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMjYwMA==", "bodyText": "check notNull?", "url": "https://github.com/apache/samza/pull/1449#discussion_r537922600", "createdAt": "2020-12-07T23:49:15Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjkwNjIzOnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo1MDozNVrOIBAOPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo0ODo0N1rOIBDDpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMzEzNQ==", "bodyText": "is this a deep or shallow equals cause its happening at object level and not really looking into the 3 ids.\nah, this is supposed to catch the case of -- exactly same object right?", "url": "https://github.com/apache/samza/pull/1449#discussion_r537923135", "createdAt": "2020-12-07T23:50:35Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {\n+    this.configId = configId;\n+    this.epochId = epochId;\n+    this.jobModelId = jobModelId;\n+  }\n+\n+  public String getConfigId() {\n+    return configId;\n+  }\n+\n+  public String getEpochId() {\n+    return this.epochId;\n+  }\n+\n+  public String getJobModelId() {\n+    return jobModelId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2OTU3NQ==", "bodyText": "optimizes for the case when they are same instances.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537969575", "createdAt": "2020-12-08T01:48:47Z", "author": {"login": "mynameborat"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {\n+    this.configId = configId;\n+    this.epochId = epochId;\n+    this.jobModelId = jobModelId;\n+  }\n+\n+  public String getConfigId() {\n+    return configId;\n+  }\n+\n+  public String getEpochId() {\n+    return this.epochId;\n+  }\n+\n+  public String getJobModelId() {\n+    return jobModelId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMzEzNQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjkwODY4OnYy", "diffSide": "RIGHT", "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo1MToyNlrOIBAPpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzoxOTozMFrOIBrDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMzQ5NQ==", "bodyText": "when the Ids are Strings why not use String.equals? any specific reason for choosing Objects.equals?", "url": "https://github.com/apache/samza/pull/1449#discussion_r537923495", "createdAt": "2020-12-07T23:51:26Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {\n+    this.configId = configId;\n+    this.epochId = epochId;\n+    this.jobModelId = jobModelId;\n+  }\n+\n+  public String getConfigId() {\n+    return configId;\n+  }\n+\n+  public String getEpochId() {\n+    return this.epochId;\n+  }\n+\n+  public String getJobModelId() {\n+    return jobModelId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (!(o instanceof JobCoordinatorMetadata)) {\n+      return false;\n+    }\n+    JobCoordinatorMetadata metadata = (JobCoordinatorMetadata) o;\n+    return Objects.equals(configId, metadata.configId) && Objects.equals(epochId, metadata.epochId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2OTg5NA==", "bodyText": "It is cleaner and agnostic to types and also handles nulls etc.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537969894", "createdAt": "2020-12-08T01:49:28Z", "author": {"login": "mynameborat"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {\n+    this.configId = configId;\n+    this.epochId = epochId;\n+    this.jobModelId = jobModelId;\n+  }\n+\n+  public String getConfigId() {\n+    return configId;\n+  }\n+\n+  public String getEpochId() {\n+    return this.epochId;\n+  }\n+\n+  public String getJobModelId() {\n+    return jobModelId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (!(o instanceof JobCoordinatorMetadata)) {\n+      return false;\n+    }\n+    JobCoordinatorMetadata metadata = (JobCoordinatorMetadata) o;\n+    return Objects.equals(configId, metadata.configId) && Objects.equals(epochId, metadata.epochId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMzQ5NQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYyNDgzNA==", "bodyText": "ah i see. got it.", "url": "https://github.com/apache/samza/pull/1449#discussion_r538624834", "createdAt": "2020-12-08T17:19:30Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-api/src/main/java/org/apache/samza/job/JobCoordinatorMetadata.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.job;\n+\n+import java.util.Objects;\n+import org.apache.samza.annotation.InterfaceStability;\n+\n+/**\n+ * A data model to represent the metadata of the job coordinator. The metadata refers to attributes of job coordinator\n+ * scoped to attempt within a deployment. For the purpose of this data model, deployment and attempt are defined\n+ * as follows\n+ *\n+ * Deployment - Set of actions to stop an existing application, install new binaries and submit a request to run the new binaries\n+ * Attempt    - Incarnations of application within a deployment for fault tolerance; e.g. Job coordinator failures or\n+ *              job model changes detected by partition count monitoring or regex monitor.\n+ *\n+ * Metadata generation may require underlying cluster manager's interaction. The following describes the properties\n+ * of the attributes to provide guidelines for implementors of contracts related to metadata generation.\n+ *\n+ * Epoch ID - An identifier to associated with the job coordinator's lifecycle within the scope of a single deployment.\n+ * The properties of the epoch identifier are as follows\n+ *    1. Unique across applications in the cluster\n+ *    2. Remains unchanged within a single deployment lifecycle\n+ *    3. Remains unchanged across application attempt within a single deployment lifecycle\n+ *    4. Changes across deployment lifecycle\n+ *\n+ * Config ID - An identifier associated with a subset of configuration snapshot used by the job in an application attempt.\n+ * Current prefixes that impacts the identifier are job.autosizing.*\n+ * The properties of the config identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the subset of configuration remains unchanged.\n+ *\n+ * Job Model ID - An identifier associated with the JobModel used by the job in an application attempt. JobModel\n+ * has both configurations and list of container model. We don't account for changes in the configuration as part of this\n+ * identifier since it is separately tracked and handled by Config ID.\n+ * The properties of the job model identifier are as follows\n+ *    1. Reproducible and deterministic\n+ *    2. Remains unchanged across application attempts as long as the work assignment remains unchanged\n+ *\n+ * Notes on interface stability - It is used internally by Samza for job coordinator high availability in YARN\n+ * deployment offering. It may evolve depending on expanding the scope beyond YARN and hence unstable.\n+ *\n+ */\n+@InterfaceStability.Unstable\n+public class JobCoordinatorMetadata {\n+  private final String configId;\n+  private final String epochId;\n+  private final String jobModelId;\n+\n+  public JobCoordinatorMetadata(String epochId, String configId, String jobModelId) {\n+    this.configId = configId;\n+    this.epochId = epochId;\n+    this.jobModelId = jobModelId;\n+  }\n+\n+  public String getConfigId() {\n+    return configId;\n+  }\n+\n+  public String getEpochId() {\n+    return this.epochId;\n+  }\n+\n+  public String getJobModelId() {\n+    return jobModelId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (!(o instanceof JobCoordinatorMetadata)) {\n+      return false;\n+    }\n+    JobCoordinatorMetadata metadata = (JobCoordinatorMetadata) o;\n+    return Objects.equals(configId, metadata.configId) && Objects.equals(epochId, metadata.epochId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyMzQ5NQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njk1NzMyOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDowNzozMVrOIBAqOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1MTo0NVrOIBDIjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMDI5Ng==", "bodyText": "what values can cluster type take? should we have an enum for this maybe?", "url": "https://github.com/apache/samza/pull/1449#discussion_r537930296", "createdAt": "2020-12-08T00:07:31Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MDgzMQ==", "bodyText": "Good idea although we only support YARN. Might be useful to extract this to enum.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537970831", "createdAt": "2020-12-08T01:51:45Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMDI5Ng=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njk3NzMxOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoxNDozOFrOIBA1DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzoxOTozNVrOIBrDog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMzA2OQ==", "bodyText": "would swallowing the exception lead to issues like incorrect metrics as previousMetadata is non-existent due to exception but metric records new deployment? or cause unnecessary restart of containers.\nisnt this an important enough thing to fail JC for? cause this will be invoked only when AM HA is enabled right, so wont fail a non-AM HA JC", "url": "https://github.com/apache/samza/pull/1449#discussion_r537933069", "createdAt": "2020-12-08T00:14:38Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkState(StringUtils.isNotBlank(clusterType), \"Cluster type cannot be empty\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);\n+        }\n+      }\n+    }\n+\n+    LOG.info(\"Fetched the job coordinator metadata for cluster {} as {}.\", clusterType, metadata);\n+    return metadata;\n+  }\n+\n+  /**\n+   * Persist the {@link JobCoordinatorMetadata} in metadata store. The job coordinator metadata is associated\n+   * with the cluster type specified at the creation of the manager.\n+   *\n+   * @param metadata metadata to be persisted\n+   *\n+   * @return true if the write succeeded, false otherwise\n+   */\n+  public boolean writeJobCoordinatorMetadata(JobCoordinatorMetadata metadata) {\n+    Preconditions.checkNotNull(metadata, \"Job coordinator metadata cannot be null\");\n+\n+    boolean writeSucceeded = false;\n+    try {\n+      String metadataValueString = metadataMapper.writeValueAsString(metadata);\n+      metadataStore.put(clusterType, valueSerde.toBytes(metadataValueString));\n+      writeSucceeded = true;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to write the job coordinator metadata to metadata store due to \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MzQ5Ng==", "bodyText": "Good catch. We will need to bubble it up to bring down the AM.\nAlthough, I don't think metrics should be impacted as you will notice why in the orchestration PR. That said, the subsequent runs of AM will not have a consistent view of metadata and the running containers.\nFixing it to bubble it up.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537973496", "createdAt": "2020-12-08T01:57:13Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkState(StringUtils.isNotBlank(clusterType), \"Cluster type cannot be empty\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);\n+        }\n+      }\n+    }\n+\n+    LOG.info(\"Fetched the job coordinator metadata for cluster {} as {}.\", clusterType, metadata);\n+    return metadata;\n+  }\n+\n+  /**\n+   * Persist the {@link JobCoordinatorMetadata} in metadata store. The job coordinator metadata is associated\n+   * with the cluster type specified at the creation of the manager.\n+   *\n+   * @param metadata metadata to be persisted\n+   *\n+   * @return true if the write succeeded, false otherwise\n+   */\n+  public boolean writeJobCoordinatorMetadata(JobCoordinatorMetadata metadata) {\n+    Preconditions.checkNotNull(metadata, \"Job coordinator metadata cannot be null\");\n+\n+    boolean writeSucceeded = false;\n+    try {\n+      String metadataValueString = metadataMapper.writeValueAsString(metadata);\n+      metadataStore.put(clusterType, valueSerde.toBytes(metadataValueString));\n+      writeSucceeded = true;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to write the job coordinator metadata to metadata store due to \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMzA2OQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYyNDkzMA==", "bodyText": "yeah i meant the new AM wont see metadata properly -- when i said \"previousMetadata\".\nthanks for addressing it..", "url": "https://github.com/apache/samza/pull/1449#discussion_r538624930", "createdAt": "2020-12-08T17:19:35Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkState(StringUtils.isNotBlank(clusterType), \"Cluster type cannot be empty\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);\n+        }\n+      }\n+    }\n+\n+    LOG.info(\"Fetched the job coordinator metadata for cluster {} as {}.\", clusterType, metadata);\n+    return metadata;\n+  }\n+\n+  /**\n+   * Persist the {@link JobCoordinatorMetadata} in metadata store. The job coordinator metadata is associated\n+   * with the cluster type specified at the creation of the manager.\n+   *\n+   * @param metadata metadata to be persisted\n+   *\n+   * @return true if the write succeeded, false otherwise\n+   */\n+  public boolean writeJobCoordinatorMetadata(JobCoordinatorMetadata metadata) {\n+    Preconditions.checkNotNull(metadata, \"Job coordinator metadata cannot be null\");\n+\n+    boolean writeSucceeded = false;\n+    try {\n+      String metadataValueString = metadataMapper.writeValueAsString(metadata);\n+      metadataStore.put(clusterType, valueSerde.toBytes(metadataValueString));\n+      writeSucceeded = true;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to write the job coordinator metadata to metadata store due to \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMzA2OQ=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njk4NjU1OnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoxODowMlrOIBA6JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1ODo1OVrOIBDVnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNDM3Mw==", "bodyText": "just clarifying - this is very yarn specific right. should we call out this is ONLY for YARN at the moment?\nand even within Yarn - it is very specific to the way yarn names containers/app attempts right now -- i dont forsee yarn changing this due to backwards compatibility but wanted to sure we are aware of this.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537934373", "createdAt": "2020-12-08T00:18:02Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkState(StringUtils.isNotBlank(clusterType), \"Cluster type cannot be empty\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);\n+        }\n+      }\n+    }\n+\n+    LOG.info(\"Fetched the job coordinator metadata for cluster {} as {}.\", clusterType, metadata);\n+    return metadata;\n+  }\n+\n+  /**\n+   * Persist the {@link JobCoordinatorMetadata} in metadata store. The job coordinator metadata is associated\n+   * with the cluster type specified at the creation of the manager.\n+   *\n+   * @param metadata metadata to be persisted\n+   *\n+   * @return true if the write succeeded, false otherwise\n+   */\n+  public boolean writeJobCoordinatorMetadata(JobCoordinatorMetadata metadata) {\n+    Preconditions.checkNotNull(metadata, \"Job coordinator metadata cannot be null\");\n+\n+    boolean writeSucceeded = false;\n+    try {\n+      String metadataValueString = metadataMapper.writeValueAsString(metadata);\n+      metadataStore.put(clusterType, valueSerde.toBytes(metadataValueString));\n+      writeSucceeded = true;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to write the job coordinator metadata to metadata store due to \", e);\n+    }\n+\n+    LOG.info(\"Successfully written job coordinator metadata: {} for cluster {}.\", metadata, clusterType);\n+    return writeSucceeded;\n+  }\n+\n+  @VisibleForTesting\n+  Counter getApplicationAttemptCount() {\n+    return applicationAttemptCount;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getJobModelChangedAcrossApplicationAttempt() {\n+    return jobModelChangedAcrossApplicationAttempt;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getConfigChangedAcrossApplicationAttempt() {\n+    return configChangedAcrossApplicationAttempt;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getNewDeployment() {\n+    return newDeployment;\n+  }\n+\n+  @VisibleForTesting\n+  String getEnvProperty(String propertyName) {\n+    return System.getenv(propertyName);\n+  }\n+\n+  /**\n+   * Generate the epoch id using the execution container id that is passed through system environment. This isn't ideal\n+   * way of generating this ID and we will need some contract between the underlying cluster manager and samza engine\n+   * around what the epoch ID should be like and what is needed to generate is across different cluster offerings.\n+   * Due to unknowns defined above, we leave it as is and keep it simple for now. It is favorable to keep it this way\n+   * instead of introducing a loosely defined interface/API and marking it unstable.\n+   *\n+   * The properties of the epoch identifier are as follows\n+   *  1. Unique across applications in the cluster\n+   *  2. Remains unchanged within a single deployment lifecycle\n+   *  3. Remains unchanged across application attempt within a single deployment lifecycle\n+   *  4. Changes across deployment lifecycle\n+   *\n+   *  Note: The above properties is something we want keep intact when extracting this into a well defined interface\n+   *  or contract for YARN AM HA to work.\n+   *\n+   * @return an identifier associated with the job coordinator satisfying the above properties\n+   */\n+  private String fetchEpochIdForJobCoordinator() {\n+    String[] containerIdParts = getEnvProperty(CONTAINER_ID_PROPERTY).split(CONTAINER_ID_DELIMITER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NDE3Mg==", "bodyText": "Yeah its public contract by YARN and unlikely to change. Adding a line about the format of the property and the specificity to YARN model.", "url": "https://github.com/apache/samza/pull/1449#discussion_r537974172", "createdAt": "2020-12-08T01:58:59Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final String clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, String clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkState(StringUtils.isNotBlank(clusterType), \"Cluster type cannot be empty\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);\n+        }\n+      }\n+    }\n+\n+    LOG.info(\"Fetched the job coordinator metadata for cluster {} as {}.\", clusterType, metadata);\n+    return metadata;\n+  }\n+\n+  /**\n+   * Persist the {@link JobCoordinatorMetadata} in metadata store. The job coordinator metadata is associated\n+   * with the cluster type specified at the creation of the manager.\n+   *\n+   * @param metadata metadata to be persisted\n+   *\n+   * @return true if the write succeeded, false otherwise\n+   */\n+  public boolean writeJobCoordinatorMetadata(JobCoordinatorMetadata metadata) {\n+    Preconditions.checkNotNull(metadata, \"Job coordinator metadata cannot be null\");\n+\n+    boolean writeSucceeded = false;\n+    try {\n+      String metadataValueString = metadataMapper.writeValueAsString(metadata);\n+      metadataStore.put(clusterType, valueSerde.toBytes(metadataValueString));\n+      writeSucceeded = true;\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to write the job coordinator metadata to metadata store due to \", e);\n+    }\n+\n+    LOG.info(\"Successfully written job coordinator metadata: {} for cluster {}.\", metadata, clusterType);\n+    return writeSucceeded;\n+  }\n+\n+  @VisibleForTesting\n+  Counter getApplicationAttemptCount() {\n+    return applicationAttemptCount;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getJobModelChangedAcrossApplicationAttempt() {\n+    return jobModelChangedAcrossApplicationAttempt;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getConfigChangedAcrossApplicationAttempt() {\n+    return configChangedAcrossApplicationAttempt;\n+  }\n+\n+  @VisibleForTesting\n+  Gauge<Integer> getNewDeployment() {\n+    return newDeployment;\n+  }\n+\n+  @VisibleForTesting\n+  String getEnvProperty(String propertyName) {\n+    return System.getenv(propertyName);\n+  }\n+\n+  /**\n+   * Generate the epoch id using the execution container id that is passed through system environment. This isn't ideal\n+   * way of generating this ID and we will need some contract between the underlying cluster manager and samza engine\n+   * around what the epoch ID should be like and what is needed to generate is across different cluster offerings.\n+   * Due to unknowns defined above, we leave it as is and keep it simple for now. It is favorable to keep it this way\n+   * instead of introducing a loosely defined interface/API and marking it unstable.\n+   *\n+   * The properties of the epoch identifier are as follows\n+   *  1. Unique across applications in the cluster\n+   *  2. Remains unchanged within a single deployment lifecycle\n+   *  3. Remains unchanged across application attempt within a single deployment lifecycle\n+   *  4. Changes across deployment lifecycle\n+   *\n+   *  Note: The above properties is something we want keep intact when extracting this into a well defined interface\n+   *  or contract for YARN AM HA to work.\n+   *\n+   * @return an identifier associated with the job coordinator satisfying the above properties\n+   */\n+  private String fetchEpochIdForJobCoordinator() {\n+    String[] containerIdParts = getEnvProperty(CONTAINER_ID_PROPERTY).split(CONTAINER_ID_DELIMITER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNDM3Mw=="}, "originalCommit": {"oid": "c6f242cc2bcafbf082587b6240f0c71579bde15f"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTUzODgxOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzoyNToyMFrOIBrbVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxODoyOTo0N1rOIBvlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYzMDk5Nw==", "bodyText": "same here..  maybe we should not swallow the exception here also. This is crucial piece of AM HA and also behind the config for it i guess.. so we can just fail JC here.\nif we dont fail JC then what is the behavior when it couldnt read metadata? how does it determine what actions to take? are we planning to blanket restart all containers in this case? what about updating the metrics?", "url": "https://github.com/apache/samza/pull/1449#discussion_r538630997", "createdAt": "2020-12-08T17:25:20Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final ClusterType clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, ClusterType clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkNotNull(clusterType, \"Cluster type cannot be null\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.name().equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fadc9fc2f804daf1ea33b3681ad837738c7a426d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0MTk3MQ==", "bodyText": "unable to read the metadata can still enable AM to proceed and restart all the containers instead of killing the AM. The reason this is better is the scenario where the data is corrupt, you are better of proceeding and rewriting the metadata with new one instead of hoping the errors are transient and retrying (by killing the AM and starting it again).\nUpdating the metrics happens in the check flow. Refer to the orchestration PR on how this read is used subsequently to determine change.", "url": "https://github.com/apache/samza/pull/1449#discussion_r538641971", "createdAt": "2020-12-08T17:35:25Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final ClusterType clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, ClusterType clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkNotNull(clusterType, \"Cluster type cannot be null\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.name().equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYzMDk5Nw=="}, "originalCommit": {"oid": "fadc9fc2f804daf1ea33b3681ad837738c7a426d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY5OTAxMg==", "bodyText": "Sync'd up offline and will add metrics around reads & writes in metadata handling PR.", "url": "https://github.com/apache/samza/pull/1449#discussion_r538699012", "createdAt": "2020-12-08T18:29:47Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorMetadataManager.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.coordinator;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.hash.Funnel;\n+import com.google.common.hash.Hashing;\n+import com.google.common.hash.PrimitiveSink;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.coordinator.stream.CoordinatorStreamValueSerde;\n+import org.apache.samza.coordinator.stream.messages.SetJobCoordinatorMetadataMessage;\n+import org.apache.samza.job.JobCoordinatorMetadata;\n+import org.apache.samza.job.model.JobModel;\n+import org.apache.samza.metadatastore.MetadataStore;\n+import org.apache.samza.metrics.Counter;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.serializers.model.SamzaObjectMapper;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class to manage read and writes of {@link JobCoordinatorMetadata} to {@link MetadataStore}. It also provides\n+ * additional helper functionalities to generate {@link JobCoordinatorMetadata} and check for changes across runs.\n+ */\n+public class JobCoordinatorMetadataManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(JobCoordinatorMetadataManager.class);\n+  private static final String APPLICATION_ATTEMPT_COUNT = \"applicationAttemptCount\";\n+  private static final String JOB_COORDINATOR_MANAGER_METRICS = \"job-coordinator-manager\";\n+  private static final String JOB_MODEL_CHANGED = \"jobModelChanged\";\n+  private static final String CONFIG_CHANGED = \"configChanged\";\n+  private static final String NEW_DEPLOYMENT = \"newDeployment\";\n+\n+  static final String CONTAINER_ID_PROPERTY = \"CONTAINER_ID\";\n+  static final String CONTAINER_ID_DELIMITER = \"_\";\n+\n+  private final Counter applicationAttemptCount;\n+  private final Gauge<Integer> jobModelChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> configChangedAcrossApplicationAttempt;\n+  private final Gauge<Integer> newDeployment;\n+  private final MetadataStore metadataStore;\n+  private final ObjectMapper metadataMapper = SamzaObjectMapper.getObjectMapper();\n+  private final Serde<String> valueSerde;\n+  private final ClusterType clusterType;\n+\n+  public JobCoordinatorMetadataManager(MetadataStore metadataStore, ClusterType clusterType, MetricsRegistry metricsRegistry) {\n+    Preconditions.checkNotNull(clusterType, \"Cluster type cannot be null\");\n+    this.clusterType = clusterType;\n+    this.metadataStore = metadataStore;\n+    this.valueSerde = new CoordinatorStreamValueSerde(SetJobCoordinatorMetadataMessage.TYPE);\n+\n+    applicationAttemptCount = metricsRegistry.newCounter(JOB_COORDINATOR_MANAGER_METRICS, APPLICATION_ATTEMPT_COUNT);\n+    configChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, CONFIG_CHANGED, 0);\n+    jobModelChangedAcrossApplicationAttempt =\n+        metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, JOB_MODEL_CHANGED, 0);\n+    newDeployment = metricsRegistry.newGauge(JOB_COORDINATOR_MANAGER_METRICS, NEW_DEPLOYMENT, 0);\n+  }\n+\n+  /**\n+   * Generates {@link JobCoordinatorMetadata} for the {@link JobCoordinator}.\n+   *\n+   * Epoch ID - It is generated by {@link #fetchEpochIdForJobCoordinator()}. Refer to the javadocs for more\n+   * details on how it is generated and the properties of the identifier.\n+   *\n+   * Config ID - A unique and reproducible identifier that is generated based on the input {@link Config}. It uses\n+   * a {@link Funnel} to use a subset of the input configuration to generate the identifier and as long as the subset\n+   * of the configuration remains same, the identifier is guaranteed to be same. For the list of config prefixes used\n+   * by the funnel refer to {@link ConfigHashFunnel}\n+   *\n+   * JobModel ID - A unique and reproducible identifier that is generated based on the input {@link JobModel}. It only\n+   * uses the {@link org.apache.samza.job.model.ContainerModel} within the {@linkplain JobModel} for generation. We\n+   * serialize the data into bytes and use those bytes to compute the identifier.\n+   *\n+   * In case of YARN, the epoch identifier is extracted from the application attempt and translates to applicationId\n+   * e.g. 1606797336059_0010\n+   * Both config and job model identifiers should a 32 bit integer.\n+   *\n+   * @param jobModel job model used for generating the metadata\n+   * @param config config used for generating the metadata\n+   *\n+   * @return the metadata for the job coordinator\n+   */\n+  public JobCoordinatorMetadata generateJobCoordinatorMetadata(JobModel jobModel, Config config) {\n+    try {\n+      int jobModelId = Hashing\n+          .crc32c()\n+          .hashBytes(SamzaObjectMapper.getObjectMapper().writeValueAsBytes(jobModel.getContainers()))\n+          .asInt();\n+      int configId = Hashing\n+          .crc32()\n+          .hashObject(config, new ConfigHashFunnel())\n+          .asInt();\n+\n+      LOG.info(\"Generated job model id {} and config id {}\", jobModelId, configId);\n+      return new JobCoordinatorMetadata(fetchEpochIdForJobCoordinator(), String.valueOf(configId),\n+          String.valueOf(jobModelId));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to generate metadata for the current attempt due to \", e);\n+      throw new RuntimeException(\"Failed to generate the metadata for the current attempt due to \", e);\n+    }\n+  }\n+\n+  /**\n+   * Check for changes between the metadata passed as inputs. Metadata is considered changed if any of the attributes within\n+   * {@linkplain JobCoordinatorMetadata} changes.\n+   *\n+   * We intentionally check for each changes to help us track at this granularity. We want to use this information\n+   * to determine if complex handling is required to cater these changes instead of blindly restarting all the\n+   * containers upstream.\n+   *\n+   * @param newMetadata new metadata to be compared\n+   * @param previousMetadata previous metadata to be compared against\n+   *\n+   * @return true if metadata changed, false otherwise\n+   */\n+  public boolean checkForMetadataChanges(JobCoordinatorMetadata newMetadata, JobCoordinatorMetadata previousMetadata) {\n+    boolean changed = true;\n+\n+    if (previousMetadata == null) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getEpochId().equals(newMetadata.getEpochId())) {\n+      newDeployment.set(1);\n+    } else if (!previousMetadata.getJobModelId().equals(newMetadata.getJobModelId())) {\n+      jobModelChangedAcrossApplicationAttempt.set(1);\n+    } else if (!previousMetadata.getConfigId().equals(newMetadata.getConfigId())) {\n+      configChangedAcrossApplicationAttempt.set(1);\n+    } else {\n+      changed = false;\n+      applicationAttemptCount.inc();\n+    }\n+\n+    if (changed) {\n+      LOG.info(\"Job coordinator metadata changed from: {} to: {}\", previousMetadata, newMetadata);\n+    } else {\n+      LOG.info(\"Job coordinator metadata {} unchanged.\", newMetadata);\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * Reads the {@link JobCoordinatorMetadata} from the metadata store. It fetches the metadata\n+   * associated with cluster type specified at the creation of the manager.\n+   *\n+   * @return job coordinator metadata\n+   */\n+  public JobCoordinatorMetadata readJobCoordinatorMetadata() {\n+    JobCoordinatorMetadata metadata = null;\n+    for (Map.Entry<String, byte[]> entry : metadataStore.all().entrySet()) {\n+      if (clusterType.name().equals(entry.getKey())) {\n+        try {\n+          String metadataString = valueSerde.fromBytes(entry.getValue());\n+          metadata = metadataMapper.readValue(metadataString, JobCoordinatorMetadata.class);\n+          break;\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read job coordinator metadata due to \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYzMDk5Nw=="}, "originalCommit": {"oid": "fadc9fc2f804daf1ea33b3681ad837738c7a426d"}, "originalPosition": 182}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1382, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}