{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NzI2MTk1", "number": 1242, "title": "SAMZA-2425: Add support for sub-query in joins", "bodyText": "Symptom: Using sub-query with a join fails today with an unsupported exception.\u2028\nCause: We have never supported sub-query in joins due to the way we have been parsing sql statements which was fixed recently.\n\u2028Fix:\u00a0A simple code enhancement to handle logical filter while traversing the calcite logical plan to get the table IO.\nTests: Added a Sql End-To-End test for sub-query and join.", "createdAt": "2020-01-02T17:02:26Z", "url": "https://github.com/apache/samza/pull/1242", "merged": true, "mergeCommit": {"oid": "beb5e1b40c07c092bc6e14aafc131d96eda5fcd4"}, "closed": true, "closedAt": "2020-01-02T18:58:53Z", "author": {"login": "atoomula"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2c0Q2AH2gAyMzU4NzI2MTk1OmFiZWIwNmYxNmQyZWIzYmFjZDg0ZGI5NDY4NmM0YjBmZGUxY2JlM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb2fCw9gFqTMzNzgyMTIxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e", "author": {"user": {"login": "atoomula", "name": "Aditya Toomula"}}, "url": "https://github.com/apache/samza/commit/abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e", "committedDate": "2020-01-02T17:01:16Z", "message": "SAMZA-2425: Add support for sub-query in joins"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NzcyMjEy", "url": "https://github.com/apache/samza/pull/1242#pullrequestreview-337772212", "createdAt": "2020-01-02T17:41:31Z", "commit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODIxMjE3", "url": "https://github.com/apache/samza/pull/1242#pullrequestreview-337821217", "createdAt": "2020-01-02T19:36:45Z", "commit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxOTozNjo0NVrOFZzaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxOTozNjo0NVrOFZzaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjYwMTAyNw==", "bodyText": "There're other kinds of RelNode which are not covered by instanceOf checks in recursive function. Do we need to handle other kinds of RelNode here? If not, why?\nCan you please add a unit-test in JoinTranslator for these changes?\nJust curious. Would the schema validations be applied on the result of the sub-queries within joins?", "url": "https://github.com/apache/samza/pull/1242#discussion_r362601027", "createdAt": "2020-01-02T19:36:45Z", "author": {"login": "shanthoosh"}, "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "diffHunk": "@@ -292,17 +294,27 @@ private String dumpRelPlanForNode(RelNode relNode) {\n         SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n   }\n \n-  private SqlIOConfig resolveSourceConfigForTable(RelNode relNode, TranslatorContext context) {\n+  private SqlIOConfig resolveSQlIOForTable(RelNode relNode, TranslatorContext context) {\n+    // Let's recursively get to the TableScan node to identify IO for the table.\n     if (relNode instanceof LogicalProject) {\n-      return resolveSourceConfigForTable(((LogicalProject) relNode).getInput(), context);\n+      return resolveSQlIOForTable(((LogicalProject) relNode).getInput(), context);\n     }\n \n-    // We are returning the sourceConfig for the table as null when the table is in another join rather than an output\n-    // table, that's because the output of stream-table join is considered a stream.\n-    if (relNode.getInputs().size() > 1) {\n+    if (relNode instanceof LogicalFilter) {\n+      return resolveSQlIOForTable(((LogicalFilter) relNode).getInput(), context);\n+    }\n+\n+    // We return null for table IO as the table seems to be involved in another join. The output of stream-table join\n+    // is considered a stream. Hence, we return null for the table.\n+    if (relNode instanceof LogicalJoin && relNode.getInputs().size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4737, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}