{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNDg0NTAz", "number": 1450, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzozNTozOFrOFCpozg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjoxMzo1NVrOFDAjfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzIzNjYyOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzozNTozOFrOIB7Sdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMToxNTowNVrOIB9qIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MDg3MA==", "bodyText": "is this only for tests?", "url": "https://github.com/apache/samza/pull/1450#discussion_r538890870", "createdAt": "2020-12-08T23:35:38Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -456,6 +482,18 @@ StartpointManager createStartpointManager() {\n \n   @VisibleForTesting\n   ContainerProcessManager createContainerProcessManager() {\n-    return new ContainerProcessManager(config, state, metrics, containerPlacementMetadataStore, localityManager);\n+    return new ContainerProcessManager(config, state, metrics, containerPlacementMetadataStore, localityManager,\n+        metadataChangedAcrossAttempts);\n+  }\n+\n+  @VisibleForTesting\n+  JobCoordinatorMetadataManager createJobCoordinatorMetadataManager() {\n+    return new JobCoordinatorMetadataManager(new NamespaceAwareCoordinatorStreamStore(metadataStore,\n+        SetJobCoordinatorMetadataMessage.TYPE), JobCoordinatorMetadataManager.ClusterType.YARN, metrics);\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMetadataChangedAcrossAttempts() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyOTY5Nw==", "bodyText": "the getter is only for tests.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538929697", "createdAt": "2020-12-09T01:15:05Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -456,6 +482,18 @@ StartpointManager createStartpointManager() {\n \n   @VisibleForTesting\n   ContainerProcessManager createContainerProcessManager() {\n-    return new ContainerProcessManager(config, state, metrics, containerPlacementMetadataStore, localityManager);\n+    return new ContainerProcessManager(config, state, metrics, containerPlacementMetadataStore, localityManager,\n+        metadataChangedAcrossAttempts);\n+  }\n+\n+  @VisibleForTesting\n+  JobCoordinatorMetadataManager createJobCoordinatorMetadataManager() {\n+    return new JobCoordinatorMetadataManager(new NamespaceAwareCoordinatorStreamStore(metadataStore,\n+        SetJobCoordinatorMetadataMessage.TYPE), JobCoordinatorMetadataManager.ClusterType.YARN, metrics);\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMetadataChangedAcrossAttempts() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MDg3MA=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI0MjQxOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ContainerProcessManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzozNzo0MFrOIB7VsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTo0NToxM1rOIB-XJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MTY5Ng==", "bodyText": "wait, if we have to restart all containers then why are we asking allocator for resources for only some of the processors.. is it to avoid a scenario where we spin up a processor with Id 0 though there is a processor with same id from previous attempt leading to orphan container issues?\n\n\nwould benefit from a log here too i feel.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538891696", "createdAt": "2020-12-08T23:37:40Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ContainerProcessManager.java", "diffHunk": "@@ -248,16 +253,23 @@ public void start() {\n     // Request initial set of containers\n     LocalityModel localityModel = localityManager.readLocality();\n     Map<String, String> processorToHost = new HashMap<>();\n-    state.jobModelManager.jobModel().getContainers().keySet().forEach((containerId) -> {\n-      String host = Optional.ofNullable(localityModel.getProcessorLocality(containerId))\n+    state.jobModelManager.jobModel().getContainers().keySet().forEach((processorId) -> {\n+      String host = Optional.ofNullable(localityModel.getProcessorLocality(processorId))\n           .map(ProcessorLocality::host)\n           .filter(StringUtils::isNotBlank)\n           .orElse(null);\n-      processorToHost.put(containerId, host);\n+      processorToHost.put(processorId, host);\n     });\n     if (jobConfig.getApplicationMasterHighAvailabilityEnabled()) {\n       // don't request resource for container that is already running\n-      state.runningProcessors.keySet().forEach(processorToHost::remove);\n+      state.runningProcessors.forEach((processorId, samzaResource) -> {\n+        LOG.info(\"Not requesting container for processorId: {} since its already running as containerId: {}\",\n+            processorId, samzaResource.getContainerId());\n+        processorToHost.remove(processorId);\n+        if (restartContainers) {\n+          clusterResourceManager.stopStreamProcessor(samzaResource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMDk3NA==", "bodyText": "We don't need to request these explicitly as they stop callbacks for the running processors will eventually spin up the container again. Additionally, not removing them will end up requesting resources for those running containers & update some state with double counting.\nI initially had logs but then there is log immediately that follows in the stopStreamProcessor(..) and there is nothing in between. Hence, decided against it.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538930974", "createdAt": "2020-12-09T01:18:18Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ContainerProcessManager.java", "diffHunk": "@@ -248,16 +253,23 @@ public void start() {\n     // Request initial set of containers\n     LocalityModel localityModel = localityManager.readLocality();\n     Map<String, String> processorToHost = new HashMap<>();\n-    state.jobModelManager.jobModel().getContainers().keySet().forEach((containerId) -> {\n-      String host = Optional.ofNullable(localityModel.getProcessorLocality(containerId))\n+    state.jobModelManager.jobModel().getContainers().keySet().forEach((processorId) -> {\n+      String host = Optional.ofNullable(localityModel.getProcessorLocality(processorId))\n           .map(ProcessorLocality::host)\n           .filter(StringUtils::isNotBlank)\n           .orElse(null);\n-      processorToHost.put(containerId, host);\n+      processorToHost.put(processorId, host);\n     });\n     if (jobConfig.getApplicationMasterHighAvailabilityEnabled()) {\n       // don't request resource for container that is already running\n-      state.runningProcessors.keySet().forEach(processorToHost::remove);\n+      state.runningProcessors.forEach((processorId, samzaResource) -> {\n+        LOG.info(\"Not requesting container for processorId: {} since its already running as containerId: {}\",\n+            processorId, samzaResource.getContainerId());\n+        processorToHost.remove(processorId);\n+        if (restartContainers) {\n+          clusterResourceManager.stopStreamProcessor(samzaResource);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MTY5Ng=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTIyMg==", "bodyText": "thanks for clarifying", "url": "https://github.com/apache/samza/pull/1450#discussion_r538941222", "createdAt": "2020-12-09T01:45:13Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ContainerProcessManager.java", "diffHunk": "@@ -248,16 +253,23 @@ public void start() {\n     // Request initial set of containers\n     LocalityModel localityModel = localityManager.readLocality();\n     Map<String, String> processorToHost = new HashMap<>();\n-    state.jobModelManager.jobModel().getContainers().keySet().forEach((containerId) -> {\n-      String host = Optional.ofNullable(localityModel.getProcessorLocality(containerId))\n+    state.jobModelManager.jobModel().getContainers().keySet().forEach((processorId) -> {\n+      String host = Optional.ofNullable(localityModel.getProcessorLocality(processorId))\n           .map(ProcessorLocality::host)\n           .filter(StringUtils::isNotBlank)\n           .orElse(null);\n-      processorToHost.put(containerId, host);\n+      processorToHost.put(processorId, host);\n     });\n     if (jobConfig.getApplicationMasterHighAvailabilityEnabled()) {\n       // don't request resource for container that is already running\n-      state.runningProcessors.keySet().forEach(processorToHost::remove);\n+      state.runningProcessors.forEach((processorId, samzaResource) -> {\n+        LOG.info(\"Not requesting container for processorId: {} since its already running as containerId: {}\",\n+            processorId, samzaResource.getContainerId());\n+        processorToHost.remove(processorId);\n+        if (restartContainers) {\n+          clusterResourceManager.stopStreamProcessor(samzaResource);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MTY5Ng=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI2MTYyOnYy", "diffSide": "RIGHT", "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0NDozOFrOIB7giA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMToyNjo1OFrOIB98NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NDQ3Mg==", "bodyText": "should we put this block behind the AM-HA config?", "url": "https://github.com/apache/samza/pull/1450#discussion_r538894472", "createdAt": "2020-12-08T23:44:38Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNDMyNA==", "bodyText": "The call site for this method in the AM HA flow is behind the config. Hence dropping that here for brevity and readability.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538934324", "createdAt": "2020-12-09T01:26:58Z", "author": {"login": "mynameborat"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NDQ3Mg=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI5MDI1OnYy", "diffSide": "RIGHT", "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1NDoxNFrOIB7wGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMToyNzo0NFrOIB99lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODQ1Ng==", "bodyText": "major: hmm.. some confusion here.. resource.getContainerId() gets the yarn container id right (of the form container_1350670447861_0003_01_000001).  see one ex here \nBut if we see code where the runningProcessors gets populated -- it has key as samza processorId (of the form 0) -- see here \nbut here you are using container id to fetch from runningProcessors.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538898456", "createdAt": "2020-12-08T23:54:14Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {\n+        YarnContainer yarnContainer = state.runningProcessors.get(resource.getContainerId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNDY3Ng==", "bodyText": "Sync'd offline on this. It only uses processorId and the prototype was using a buggy version which populated it with containerId. Fixed it.\nThanks for calling this out \ud83d\udc4d", "url": "https://github.com/apache/samza/pull/1450#discussion_r538934676", "createdAt": "2020-12-09T01:27:44Z", "author": {"login": "mynameborat"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {\n+        YarnContainer yarnContainer = state.runningProcessors.get(resource.getContainerId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODQ1Ng=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzMyOTI5OnYy", "diffSide": "RIGHT", "path": "samza-core/src/test/java/org/apache/samza/clustermanager/TestClusterBasedJobCoordinator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDowODowNVrOIB8FhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDowODowNVrOIB8FhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMzk0MQ==", "bodyText": "nit: add changed \"JC metadata changed should be true\"", "url": "https://github.com/apache/samza/pull/1450#discussion_r538903941", "createdAt": "2020-12-09T00:08:05Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/test/java/org/apache/samza/clustermanager/TestClusterBasedJobCoordinator.java", "diffHunk": "@@ -192,4 +196,38 @@ public void testToArgs() {\n     assertEquals(expected.size(), actual.size());\n     assertTrue(actual.containsAll(expected));\n   }\n+\n+  @Test\n+  public void testGenerateAndUpdateJobCoordinatorMetadata() {\n+    Config jobConfig = new MapConfig(configMap);\n+    when(CoordinatorStreamUtil.readConfigFromCoordinatorStream(anyObject())).thenReturn(jobConfig);\n+    ClusterBasedJobCoordinator clusterBasedJobCoordinator =\n+        spy(ClusterBasedJobCoordinatorRunner.createFromMetadataStore(jobConfig));\n+\n+    JobCoordinatorMetadata previousMetadata = mock(JobCoordinatorMetadata.class);\n+    JobCoordinatorMetadata newMetadata = mock(JobCoordinatorMetadata.class);\n+    JobCoordinatorMetadataManager jobCoordinatorMetadataManager = mock(JobCoordinatorMetadataManager.class);\n+    JobModel mockJobModel = mock(JobModel.class);\n+\n+    when(jobCoordinatorMetadataManager.readJobCoordinatorMetadata()).thenReturn(previousMetadata);\n+    when(jobCoordinatorMetadataManager.generateJobCoordinatorMetadata(any(), any())).thenReturn(newMetadata);\n+    when(jobCoordinatorMetadataManager.checkForMetadataChanges(newMetadata, previousMetadata)).thenReturn(false);\n+    when(clusterBasedJobCoordinator.createJobCoordinatorMetadataManager()).thenReturn(jobCoordinatorMetadataManager);\n+\n+    /*\n+     * Verify if there are no changes to metadata, the metadata changed flag remains false and no interactions\n+     * with job coordinator metadata manager\n+     */\n+    clusterBasedJobCoordinator.generateAndUpdateJobCoordinatorMetadata(mockJobModel);\n+    assertFalse(\"JC metadata should remain unchanged\", clusterBasedJobCoordinator.isMetadataChangedAcrossAttempts());\n+    verify(jobCoordinatorMetadataManager, times(0)).writeJobCoordinatorMetadata(any());\n+\n+    /*\n+     * Verify if there are changes to metadata, we persist the new metadata & update the metadata changed flag\n+     */\n+    when(jobCoordinatorMetadataManager.checkForMetadataChanges(newMetadata, previousMetadata)).thenReturn(true);\n+    clusterBasedJobCoordinator.generateAndUpdateJobCoordinatorMetadata(mockJobModel);\n+    assertTrue(\"JC metadata should be true\", clusterBasedJobCoordinator.isMetadataChangedAcrossAttempts());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzM0MzA4OnYy", "diffSide": "RIGHT", "path": "samza-core/src/test/java/org/apache/samza/clustermanager/TestContainerProcessManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDoxMzoxMVrOIB8NQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDoxMzoxMVrOIB8NQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwNTkyMg==", "bodyText": "should we also check if the ClusterResourceManager.stopStreamProcessor was invoked and with the correct SamzaResource?", "url": "https://github.com/apache/samza/pull/1450#discussion_r538905922", "createdAt": "2020-12-09T00:13:11Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/test/java/org/apache/samza/clustermanager/TestContainerProcessManager.java", "diffHunk": "@@ -272,10 +273,60 @@ public void run() {\n \n     // Verify only 1 was requested with allocator\n     assertEquals(1, allocator.requestedContainers);\n+    assertTrue(\"Ensure no processors were forcefully restarted\", callback.resourceStatuses.isEmpty());\n \n     cpm.stop();\n   }\n \n+  @Test\n+  public void testOnInitToForceRestartAMHighAvailability() throws Exception {\n+    Map<String, String> configMap = new HashMap<>(configVals);\n+    configMap.put(JobConfig.YARN_AM_HIGH_AVAILABILITY_ENABLED, \"true\");\n+    Config conf = new MapConfig(configMap);\n+\n+    SamzaApplicationState state = new SamzaApplicationState(getJobModelManager(2));\n+    state.runningProcessors.put(\"0\", new SamzaResource(1, 1024, \"host\", \"0\"));\n+\n+    MockClusterResourceManagerCallback callback = new MockClusterResourceManagerCallback();\n+    ClusterResourceManager clusterResourceManager = new MockClusterResourceManager(callback, state);\n+    ClusterManagerConfig clusterManagerConfig = spy(new ClusterManagerConfig(conf));\n+    ContainerManager containerManager =\n+        buildContainerManager(containerPlacementMetadataStore, state, clusterResourceManager,\n+            clusterManagerConfig.getHostAffinityEnabled(), false);\n+\n+    ContainerProcessManager cpm =\n+        buildContainerProcessManager(clusterManagerConfig, state, clusterResourceManager, Optional.empty(), true);\n+\n+    MockContainerAllocatorWithoutHostAffinity allocator = new MockContainerAllocatorWithoutHostAffinity(\n+        clusterResourceManager,\n+        conf,\n+        state,\n+        containerManager);\n+\n+    getPrivateFieldFromCpm(\"containerAllocator\", cpm).set(cpm, allocator);\n+    CountDownLatch latch = new CountDownLatch(1);\n+    getPrivateFieldFromCpm(\"allocatorThread\", cpm).set(cpm, new Thread() {\n+      public void run() {\n+        isRunning = true;\n+        latch.countDown();\n+      }\n+    });\n+\n+    cpm.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzM2Mzc0OnYy", "diffSide": "RIGHT", "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDoyMDo0MFrOIB8YjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTo0NzozM1rOIB-avQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwODgxMg==", "bodyText": "after amClient.releaseAssignedContainer(yarnContainer.id()); is done, what do we get the call back as?\nbecause we should use that call back to restart the container right (as earlier we allocated resources only for processors not runnning in prev attempt).", "url": "https://github.com/apache/samza/pull/1450#discussion_r538908812", "createdAt": "2020-12-09T00:20:40Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {\n+        YarnContainer yarnContainer = state.runningProcessors.get(resource.getContainerId());\n+        if (yarnContainer != null) {\n+          log.info(\"Stopping container from previous attempt with Container ID: {} on host: {}\",\n+              resource.getContainerId(), resource.getHost());\n+          amClient.releaseAssignedContainer(yarnContainer.id());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNTI3NA==", "bodyText": "It follows the similar workflow as StopStreamProcessor which is notified through the AMRM client callback onContainersCompleted which will treat it as the container was stopped agnostic to which workflow triggered it and hence you get all the niceties of state update and instantiating new container in its place.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538935274", "createdAt": "2020-12-09T01:29:27Z", "author": {"login": "mynameborat"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {\n+        YarnContainer yarnContainer = state.runningProcessors.get(resource.getContainerId());\n+        if (yarnContainer != null) {\n+          log.info(\"Stopping container from previous attempt with Container ID: {} on host: {}\",\n+              resource.getContainerId(), resource.getHost());\n+          amClient.releaseAssignedContainer(yarnContainer.id());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwODgxMg=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MjE0MQ==", "bodyText": "awesome! thanks for telling me.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538942141", "createdAt": "2020-12-09T01:47:33Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java", "diffHunk": "@@ -331,9 +332,24 @@ public void launchStreamProcessor(SamzaResource resource, CommandBuilder builder\n   public void stopStreamProcessor(SamzaResource resource) {\n     synchronized (lock) {\n       Container container = allocatedResources.get(resource);\n+      /*\n+       * 1. Stop the container through NMClient if the container was instantiated as part of NMClient lifecycle.\n+       * 2. Stop the container through AMClient by release the assigned container if the container was from the previous\n+       *    attempt and managed by the AM due to AM-HA\n+       * 3. Ignore the request if the container associated with the resource isn't present in the bookeeping.\n+       */\n       if (container != null) {\n         log.info(\"Stopping Container ID: {} on host: {}\", resource.getContainerId(), resource.getHost());\n         this.nmClientAsync.stopContainerAsync(container.getId(), container.getNodeId());\n+      } else {\n+        YarnContainer yarnContainer = state.runningProcessors.get(resource.getContainerId());\n+        if (yarnContainer != null) {\n+          log.info(\"Stopping container from previous attempt with Container ID: {} on host: {}\",\n+              resource.getContainerId(), resource.getHost());\n+          amClient.releaseAssignedContainer(yarnContainer.id());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwODgxMg=="}, "originalCommit": {"oid": "24e7af5ef5f74b4c009b7ca1200e88d1da567d1f"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzU5MTE1OnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTo0MzowMVrOIB-UOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzoxMTozN1rOICAQnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDQ3NA==", "bodyText": "what if startpoint is enabled and metadata has changed? we just ignore? as in for AM-HA with metadata changes we dont create startpoint manager? if we are planning another PR for this then lets leave a comment saying tbd.\nsorry missed this in the first pass.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538940474", "createdAt": "2020-12-09T01:43:01Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -260,8 +267,9 @@ public void run() {\n       MetadataResourceUtil metadataResourceUtil = new MetadataResourceUtil(jobModel, this.metrics, config);\n       metadataResourceUtil.createResources();\n \n-      // fan out the startpoints if startpoints is enabled\n-      if (new JobConfig(config).getStartpointEnabled()) {\n+      // fan out the startpoints if startpoints is enabled and if the metadata changed across attempts.\n+      // the metadata changed should be false and only get evaluated if job coordinator high availability is enabled.\n+      if (new JobConfig(config).getStartpointEnabled() && !metadataChangedAcrossAttempts) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9563951ab05542efa3770a15035859bdbcb34ff3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MzIwNw==", "bodyText": "yeah. We will not fanout startpoint since there may be containers that are already running in which case the newly instantiated containers will act on startpoint but the old ones wont. As a result, we skip fanout and applications will force job restart through new deployment like how they do it today.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538943207", "createdAt": "2020-12-09T01:50:22Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -260,8 +267,9 @@ public void run() {\n       MetadataResourceUtil metadataResourceUtil = new MetadataResourceUtil(jobModel, this.metrics, config);\n       metadataResourceUtil.createResources();\n \n-      // fan out the startpoints if startpoints is enabled\n-      if (new JobConfig(config).getStartpointEnabled()) {\n+      // fan out the startpoints if startpoints is enabled and if the metadata changed across attempts.\n+      // the metadata changed should be false and only get evaluated if job coordinator high availability is enabled.\n+      if (new JobConfig(config).getStartpointEnabled() && !metadataChangedAcrossAttempts) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDQ3NA=="}, "originalCommit": {"oid": "9563951ab05542efa3770a15035859bdbcb34ff3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MjMxNg==", "bodyText": "Thanks for pointing this out. I intended to handle it as part of this PR.\nFixed it and added unit tests.", "url": "https://github.com/apache/samza/pull/1450#discussion_r538972316", "createdAt": "2020-12-09T03:11:37Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -260,8 +267,9 @@ public void run() {\n       MetadataResourceUtil metadataResourceUtil = new MetadataResourceUtil(jobModel, this.metrics, config);\n       metadataResourceUtil.createResources();\n \n-      // fan out the startpoints if startpoints is enabled\n-      if (new JobConfig(config).getStartpointEnabled()) {\n+      // fan out the startpoints if startpoints is enabled and if the metadata changed across attempts.\n+      // the metadata changed should be false and only get evaluated if job coordinator high availability is enabled.\n+      if (new JobConfig(config).getStartpointEnabled() && !metadataChangedAcrossAttempts) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDQ3NA=="}, "originalCommit": {"oid": "9563951ab05542efa3770a15035859bdbcb34ff3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Njk5MTMzOnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjoxMzo1NVrOICc7eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo1MjoxMVrOICe5yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0MjA0MA==", "bodyText": "so if metadata has changed then JC will stop all running processors right. additionally if there are startpoints to fanout then they are assigned to respective tasks. I am inferring that since the fanouts for task are fetched before processor entering runloop, the prev-running-now-restarted processors will pick them up. Am i correct? just trying to ensure we dont lose the fanouts for tasks that are part of already running processors.\nminor: if AM HA is enabled: fanout ONLY if  startpoint enabled && metadata changed", "url": "https://github.com/apache/samza/pull/1450#discussion_r539442040", "createdAt": "2020-12-09T16:13:55Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -267,9 +267,12 @@ public void run() {\n       MetadataResourceUtil metadataResourceUtil = new MetadataResourceUtil(jobModel, this.metrics, config);\n       metadataResourceUtil.createResources();\n \n-      // fan out the startpoints if startpoints is enabled and if the metadata changed across attempts.\n-      // the metadata changed should be false and only get evaluated if job coordinator high availability is enabled.\n-      if (new JobConfig(config).getStartpointEnabled() && !metadataChangedAcrossAttempts) {\n+      /*\n+       * We fan out startpoint if and only if\n+       *  1. Startpoint is enabled in configuration\n+       *  2. If AM HA is enabled, fan out only if metadata changed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f78d37a80f8d39b9e299dcfd14391ba53d9746"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3NDM3OA==", "bodyText": "yeah. fanout messages are read as part of the container initialization within OffsetManager. Container's don't read them  after the it has started. So it is guaranteed that the fanout message for a task will not be seen by an existing container (which has the task assigned to).", "url": "https://github.com/apache/samza/pull/1450#discussion_r539474378", "createdAt": "2020-12-09T16:52:11Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/clustermanager/ClusterBasedJobCoordinator.java", "diffHunk": "@@ -267,9 +267,12 @@ public void run() {\n       MetadataResourceUtil metadataResourceUtil = new MetadataResourceUtil(jobModel, this.metrics, config);\n       metadataResourceUtil.createResources();\n \n-      // fan out the startpoints if startpoints is enabled and if the metadata changed across attempts.\n-      // the metadata changed should be false and only get evaluated if job coordinator high availability is enabled.\n-      if (new JobConfig(config).getStartpointEnabled() && !metadataChangedAcrossAttempts) {\n+      /*\n+       * We fan out startpoint if and only if\n+       *  1. Startpoint is enabled in configuration\n+       *  2. If AM HA is enabled, fan out only if metadata changed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0MjA0MA=="}, "originalCommit": {"oid": "d1f78d37a80f8d39b9e299dcfd14391ba53d9746"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1385, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}