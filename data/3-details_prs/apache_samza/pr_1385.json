{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NTMwMjQ3", "number": 1385, "title": "SAMZA-2550: Move side input processing to use RunLoop", "bodyText": "Issues: Side input consumption / processing currently happens in two threads in ContainerStorageManager; one thread polling messages from SystemConsumers and writing entries to the stores, and another thread executing store flush.\nMoving this processing to RunLoop will simplify further changes needed to support transactional state in standby containers, as that requires ssp/task level choose control and queuing of messages within a task, something that RunLoop already does.\nOther benefits of this change include making it easier in the future to implement features like broadcast streams, side input priorities, side input concurrency etc. It is also an incremental step toward addressing SAMZA-2494, which may require side inputs to eventually be merged back into SamzaContainer's RunLoop instance in order for side input exceptions to be propagated back to container.\nChanges: Consolidates the two side input threads in ContainerStorageManager by instead constructing instances of SideInputTask which are executed by a single RunLoop instance/thread.\nNew side input processing metrics emitted by SamzaContainerMetrics and TaskInstanceMetrics are given their own namespace in order to differentiate from the primary container / run loop.\nTests: Existing tests are left in place.\nAPI Changes: None.\nUpgrade Instructions: None.\nUsage Instructions: None.", "createdAt": "2020-06-17T00:14:10Z", "url": "https://github.com/apache/samza/pull/1385", "merged": true, "mergeCommit": {"oid": "5d98e256bc0c38c6a6fc3fc03cf0a882aad13d42"}, "closed": true, "closedAt": "2020-08-11T22:37:38Z", "author": {"login": "bkonold"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcr9wHBgH2gAyNDM1NTMwMjQ3OmY4ODIwM2U3NmFjZmM4Mjc3ZTY4MmUyNTBiYWQyMTFkNzBhZDk2MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9-rhjgFqTQ2NTQ3NTE4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/f88203e76acfc8277e682e250bad211d70ad9626", "committedDate": "2020-06-16T23:21:35Z", "message": "move side inputs onto runloop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODIxMjg1", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-433821285", "createdAt": "2020-06-19T06:00:31Z", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjowMDozMVrOGmI_2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyNDowOVrOGmJbfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ==", "bodyText": "RunLoopTask doc says that if async commit is enabled then process and commit could happen in parallel. Since SideInputTask implements this interface, should we think about adding \"synchronized\" to SideInputTask.process and SideInputTask.commit methods?\nFrom our offline discussion, I understand that these two methods wont be parallel cause the sideInputRunLoop has asycnCommit = false hard coded and it is always single threaded.\nHowever, purely from the interface guarantee point of view, shouldnt this impl of RunLoopTask guard against async commits?", "url": "https://github.com/apache/samza/pull/1385#discussion_r442646491", "createdAt": "2020-06-19T06:00:31Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzU2Ng==", "bodyText": "Since regular task's process and side input task's process are both essentially treated the same (as they both implement RunLoopTask.process) - will this not increase the process_ns metric of the task to include side input processing time?\nFrom our offline discussion, I understand that prefixing the source with \"side-input\" will avoid this issue.\nAdditional doubt: was there a metric for process_ns of side input processing time before your change in this PR? are we changing the metric name as seen by the end user? if so, i think we might have to count it as API change", "url": "https://github.com/apache/samza/pull/1385#discussion_r442653566", "createdAt": "2020-06-19T06:24:09Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzMzNDU4", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-434333458", "createdAt": "2020-06-19T20:46:15Z", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMDo0ODo1NVrOGmg6Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMjoxNjozNFrOGmia3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzODIxOQ==", "bodyText": "Minor: why do we have taskName instead of getTaskName for a getter method? This PR is not introducing the methods but implementing them, so its not really a comment for this PR :)  I wanted to know for my understanding if we changed the guidelines/conventions recently.", "url": "https://github.com/apache/samza/pull/1385#discussion_r443038219", "createdAt": "2020-06-19T20:48:55Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MDIxNA==", "bodyText": "minor: init() so far has been a high-level method one calling helpers to do the actual stuff. So when i read it, I could easily get the steps init is taking without having to understand how to the steps are performed. Hence, wondering if there is value in moving this piece into a helper similar to getStartingoffsets?\nI feel it serves two purposes - keeps init a quick read and also clarifies what this step is in a single glance.. java doc for this helper would be a nice bonus ;)", "url": "https://github.com/apache/samza/pull/1385#discussion_r443040214", "createdAt": "2020-06-19T20:55:23Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,17 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n+      if (metadata != null) {\n+        String offset = metadata.getSystemStreamPartitionMetadata().get(ssp.getPartition()).getNewestOffset();\n+        this.sspOffsetsToBlockUntil.put(ssp, offset);\n+      }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0OTExNg==", "bodyText": "Im confused: starting offset could be the last processed offset on file (or oldest from source), and offsetToBlockUntil is essentially the newest offset from metadata cache right. In this case, isnt the starting offset <= newest offset - \"=\" if nothing is present after the last processed offset and \"<\" if something is present after the last processed offset.\nThis confusion might be arising from: my understanding (or messy understanding) of metadata cache and last processed offset on file.", "url": "https://github.com/apache/samza/pull/1385#discussion_r443049116", "createdAt": "2020-06-19T21:23:27Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +277,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * Checks if whether the given offset for the SSP has reached the latest offset (determined at init),\n+   * removing it from the list of SSPs to catch up. Once the set of SSPs to catch up becomes empty, the latch for the\n+   * task will count down, notifying {@link ContainerStorageManager} that it is caught up.\n+   *\n+   * @param ssp The SSP to be checked\n+   * @param currentOffset The offset to be checked\n+   * @param isStartingOffset Indicates whether the offset being checked is the starting offset of the SSP (and thus has\n+   *                         not yet been processed). This will be set to true when each SSP's starting offset is checked\n+   *                         on init, and false when checking if an ssp is caught up after processing an envelope.\n+   */\n+  private void checkCaughtUp(SystemStreamPartition ssp, String currentOffset, boolean isStartingOffset) {\n+    String offsetToBlockUntil = this.sspOffsetsToBlockUntil.get(ssp);\n+\n+    LOG.trace(\"Checking offset {} against {} for {}. isStartingOffset: {}\", currentOffset, offsetToBlockUntil, ssp, isStartingOffset);\n+\n+    Integer comparatorResult;\n+    if (currentOffset == null || offsetToBlockUntil == null) {\n+      comparatorResult = -1;\n+    } else {\n+      SystemAdmin systemAdmin = systemAdmins.getSystemAdmin(ssp.getSystem());\n+      comparatorResult = systemAdmin.offsetComparator(currentOffset, offsetToBlockUntil);\n+    }\n+\n+    // If the starting offset, it must be greater (since the envelope at the starting offset will not yet have been processed)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODIyNQ==", "bodyText": "Not a comment: Are we not using the RunLoopFactory because we dont need to figure out the type of task or to avoid log statements?", "url": "https://github.com/apache/samza/pull/1385#discussion_r443058225", "createdAt": "2020-06-19T21:56:40Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODY5NA==", "bodyText": "This is supposed to be maxThrottlingDelayMs - as in milli seconds right.. why are we giving a value of 1 to this instead of 1 second?\nSamzaContainer uses the default of TimeUnit.SECONDS.toMillis(1) which is 1 second converted to milliseconds", "url": "https://github.com/apache/samza/pull/1385#discussion_r443058694", "createdAt": "2020-06-19T21:58:42Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,\n+        null, // all operations are executed in the main runloop thread\n+        this.sideInputSystemConsumers,\n+        1, // single message in flight per task\n+        -1, // no windowing\n+        taskConfig.getCommitMs(),\n+        taskConfig.getCallbackTimeoutMs(),\n+        1, // default taken from SamzaContainer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzAwNw==", "bodyText": "so flush (aka commit) was happening in a separate thread right.. now we have moved that into the same thread as read (where the side input runloop now is). Why did we have two threads for read and flush earlier and what is the effect of removing the flush thread?", "url": "https://github.com/apache/samza/pull/1385#discussion_r443063007", "createdAt": "2020-06-19T22:16:34Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -154,17 +149,13 @@\n   private final Map<TaskName, Map<String, Set<SystemStreamPartition>>> taskSideInputStoreSSPs;\n   private final Map<SystemStreamPartition, TaskSideInputHandler> sspSideInputHandlers;\n   private SystemConsumers sideInputSystemConsumers;\n-  private final Map<SystemStreamPartition, SystemStreamMetadata.SystemStreamPartitionMetadata> initialSideInputSSPMetadata\n-      = new ConcurrentHashMap<>(); // Recorded sspMetadata of the taskSideInputSSPs recorded at start, used to determine when sideInputs are caughtup and container init can proceed\n-  private volatile CountDownLatch sideInputsCaughtUp; // Used by the sideInput-read thread to signal to the main thread\n+  private volatile Map<TaskName, CountDownLatch> sideInputTaskLatches; // Used by the sideInput-read thread to signal to the main thread\n   private volatile boolean shouldShutdown = false;\n+  private RunLoop sideInputRunLoop;\n \n   private final ExecutorService sideInputsReadExecutor = Executors.newSingleThreadExecutor(\n       new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_READ_THREAD_NAME).build());\n \n-  private final ScheduledExecutorService sideInputsFlushExecutor = Executors.newSingleThreadScheduledExecutor(\n-      new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_FLUSH_THREAD_NAME).build());\n-  private ScheduledFuture sideInputsFlushFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzY4MDc0", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-434368074", "createdAt": "2020-06-19T22:32:31Z", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMjozMjozMVrOGmioWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMjozMjozMVrOGmioWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NjQ1OQ==", "bodyText": "please clarify what caught up means - because when starting offset = newest offset - it is caught up but the comparator result says not caught up. Oe does consuming newset offset qualify as caught up?", "url": "https://github.com/apache/samza/pull/1385#discussion_r443066459", "createdAt": "2020-06-19T22:32:31Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +277,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * Checks if whether the given offset for the SSP has reached the latest offset (determined at init),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTY3Mjg0", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-435167284", "createdAt": "2020-06-22T18:18:43Z", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxODoxODo0M1rOGnL9gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTo1NjozMVrOGnSXPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MzYxOQ==", "bodyText": "minor: maybe we can call this thread just \"sideInputs thread\" as it does both read and flush?", "url": "https://github.com/apache/samza/pull/1385#discussion_r443743619", "createdAt": "2020-06-22T18:18:43Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -111,13 +109,10 @@\n   private static final Logger LOG = LoggerFactory.getLogger(ContainerStorageManager.class);\n   private static final String RESTORE_THREAD_NAME = \"Samza Restore Thread-%d\";\n   private static final String SIDEINPUTS_READ_THREAD_NAME = \"SideInputs Read Thread\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0ODUxMQ==", "bodyText": "just confirming: the check is the same now because StorageManagerUtil.getStartingOffset will get the Upcoming offset and from the definition of Upcoming and Newest offset - Upcoming > Newest.  So, although the new checkCaughtUp replacing this method is not explicitly using the OffsetTypes, it is still achieving the same.", "url": "https://github.com/apache/samza/pull/1385#discussion_r443848511", "createdAt": "2020-06-22T21:56:31Z", "author": {"login": "lakshmi-manasa-g"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/8b2a2041889ad7ded52744a0366017be3e0e680b", "committedDate": "2020-06-23T05:50:15Z", "message": "incorporating review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDk3MzIy", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-435097322", "createdAt": "2020-06-22T16:39:18Z", "commit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozOToxOFrOGnIqRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjoxNTo0OFrOGrsn2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4OTU0Mw==", "bodyText": "I understand these don't get called for side input tasks. Do we still want to throw exceptions or log warnings here as a safe guard?\nMaybe consider this for other methods that aren't implemented as part of the interface.", "url": "https://github.com/apache/samza/pull/1385#discussion_r443689543", "createdAt": "2020-06-22T16:39:18Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();\n+    try {\n+      this.taskSideInputHandler.process(envelope);\n+      this.metrics.messagesActuallyProcessed().inc();\n+      callback.complete();\n+    } catch (Exception e) {\n+      callback.failure(e);\n+    }\n+  }\n+\n+  @Override\n+  public void window(ReadableCoordinator coordinator) {\n+\n+  }\n+\n+  @Override\n+  public void scheduler(ReadableCoordinator coordinator) {\n+\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMjM4MQ==", "bodyText": "I am not sure I follow the later part of the comment @bkonold. The exclusivity holds regardless due to the fact that the side input handler has synchronization between flush & process. SideInputTask in the current state is also not likely impacted because all it does it delegate calls to handler & increment metrics.\nHandling async commit might be a bit more involved than just synchronizing process & commit. I'd need to think a bit more on this. I'd suggest we have a validation if possible to throw if async commit is enabled for now.\nTo Manasa's point, the fact that process & commit can happen concurrently doesn't translate to thread safety concerns for all implementations. It is possible that the implementations of process & commit don't need synchronization. However, it is useful to call out that synchronization between those were explicitly ignored due to the state of current implementation.", "url": "https://github.com/apache/samza/pull/1385#discussion_r444312381", "createdAt": "2020-06-23T15:27:10Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ=="}, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTE3Ng==", "bodyText": "minor: extract false to meaningful name to help readability.", "url": "https://github.com/apache/samza/pull/1385#discussion_r448021176", "createdAt": "2020-06-30T22:48:01Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,28 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = getOffsetsToBlockUntil();\n+    LOG.info(\"Task {} will catch up to offsets {}\", this.taskName, this.sspOffsetsToBlockUntil);\n+\n+    this.startingOffsets.forEach((ssp, offset) -> checkCaughtUp(ssp, offset, true));\n+  }\n+\n+  /**\n+   * Retrieves the newest offset for each SSP\n+   *\n+   * @return a map of SSP to newest offset\n+   */\n+  private Map<SystemStreamPartition, String> getOffsetsToBlockUntil() {\n+    Map<SystemStreamPartition, String> offsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA4Nw==", "bodyText": "New side input processing metrics emitted by SamzaContainerMetrics and TaskInstanceMetrics are given their own namespace in order to differentiate from the primary container / run loop.\n\nDoes this mean post this change, the old metrics emitted (if any) wouldn't work. If we didn't emit metrics for these prior to this change well and good. If not, would suggest updating the API changes description about metrics", "url": "https://github.com/apache/samza/pull/1385#discussion_r448026087", "createdAt": "2020-06-30T23:02:32Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();\n+    try {\n+      this.taskSideInputHandler.process(envelope);\n+      this.metrics.messagesActuallyProcessed().inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwODc5OQ==", "bodyText": "nit: indicates to CSM would be simpler yet accurate. It requires the entire e2e picture and how CSM interacts with container to understand this comment.", "url": "https://github.com/apache/samza/pull/1385#discussion_r448408799", "createdAt": "2020-07-01T14:36:44Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -63,19 +65,23 @@\n   private final Map<String, SideInputsProcessor> storeToProcessor;\n   private final SystemAdmins systemAdmins;\n   private final StreamMetadataCache streamMetadataCache;\n+  // indicates to container that all side input ssps in this task are caught up", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxOTM0NA==", "bodyText": "minor: would be good to extract the boolean argument to variable for readability.", "url": "https://github.com/apache/samza/pull/1385#discussion_r448419344", "createdAt": "2020-07-01T14:51:44Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,28 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = getOffsetsToBlockUntil();\n+    LOG.info(\"Task {} will catch up to offsets {}\", this.taskName, this.sspOffsetsToBlockUntil);\n+\n+    this.startingOffsets.forEach((ssp, offset) -> checkCaughtUp(ssp, offset, true));\n+  }\n+\n+  /**\n+   * Retrieves the newest offset for each SSP\n+   *\n+   * @return a map of SSP to newest offset\n+   */\n+  private Map<SystemStreamPartition, String> getOffsetsToBlockUntil() {\n+    Map<SystemStreamPartition, String> offsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQzOTczNQ==", "bodyText": "can we keep the existing functionality as is in this PR? why do we need to differentiate this being checked during starting vs process?", "url": "https://github.com/apache/samza/pull/1385#discussion_r448439735", "createdAt": "2020-07-01T15:22:27Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +288,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * An SSP is considered caught up once the offset indicated for it in {@link #sspOffsetsToBlockUntil} has been\n+   * processed. Once the set of SSPs to catch up becomes empty, the latch for the task will count down, notifying\n+   * {@link ContainerStorageManager} that it is caught up.\n+   *\n+   * @param ssp The SSP to be checked\n+   * @param currentOffset The offset to be checked\n+   * @param isStartingOffset Indicates whether the offset being checked is the starting offset of the SSP (and thus has\n+   *                         not yet been processed). This will be set to true when each SSP's starting offset is checked\n+   *                         on init, and false when checking if an ssp is caught up after processing an envelope.\n+   */\n+  private void checkCaughtUp(SystemStreamPartition ssp, String currentOffset, boolean isStartingOffset) {\n+    String offsetToBlockUntil = this.sspOffsetsToBlockUntil.get(ssp);\n+\n+    LOG.trace(\"Checking offset {} against {} for {}. isStartingOffset: {}\", currentOffset, offsetToBlockUntil, ssp, isStartingOffset);\n+\n+    Integer comparatorResult;\n+    if (currentOffset == null || offsetToBlockUntil == null) {\n+      comparatorResult = -1;\n+    } else {\n+      SystemAdmin systemAdmin = systemAdmins.getSystemAdmin(ssp.getSystem());\n+      comparatorResult = systemAdmin.offsetComparator(currentOffset, offsetToBlockUntil);\n+    }\n+\n+    // If the starting offset, it must be greater (since the envelope at the starting offset will not yet have been processed)\n+    // If not the starting offset, it must be greater than OR equal\n+    if (comparatorResult != null && ((isStartingOffset && comparatorResult > 0) || (!isStartingOffset && comparatorResult >= 0))) {\n+      LOG.info(\"Side input ssp {} has caught up to offset {}.\", ssp, offsetToBlockUntil);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0NzYwMw==", "bodyText": "can we update the comment here? this latch is used to check for caught up status currently. The side input exceptions get populated by the runloop flow.\nAlso, I'd suggest to rename this to something like SIDE_INPUT_CAUGHT_CHECK_TIMEOUT instead of of latch as one needs to figure out what this latch is used for. Maybe clarify in the comment that the check timeout applies across all the side inputs.", "url": "https://github.com/apache/samza/pull/1385#discussion_r448447603", "createdAt": "2020-07-01T15:34:14Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -110,14 +108,12 @@\n public class ContainerStorageManager {\n   private static final Logger LOG = LoggerFactory.getLogger(ContainerStorageManager.class);\n   private static final String RESTORE_THREAD_NAME = \"Samza Restore Thread-%d\";\n-  private static final String SIDEINPUTS_READ_THREAD_NAME = \"SideInputs Read Thread\";\n-  private static final String SIDEINPUTS_FLUSH_THREAD_NAME = \"SideInputs Flush Thread\";\n+  private static final String SIDEINPUTS_THREAD_NAME = \"SideInputs Thread\";\n   private static final String SIDEINPUTS_METRICS_PREFIX = \"side-inputs-\";\n   // We use a prefix to differentiate the SystemConsumersMetrics for sideInputs from the ones in SamzaContainer\n \n-  private static final int SIDE_INPUT_READ_THREAD_TIMEOUT_SECONDS = 10; // Timeout with which sideinput read thread checks for exceptions\n-  private static final Duration SIDE_INPUT_FLUSH_TIMEOUT = Duration.ofMinutes(1); // Period with which sideinputs are flushed\n-\n+  private static final int SIDE_INPUT_LATCH_TIMEOUT_SECONDS = 10; // Timeout with which sideinput thread checks for exceptions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDA1OQ==", "bodyText": "can we extract this into a constant in some common file and use the constant in both places(here & SamzaContainer)?", "url": "https://github.com/apache/samza/pull/1385#discussion_r448450059", "createdAt": "2020-07-01T15:38:04Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +745,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,\n+        null, // all operations are executed in the main runloop thread\n+        this.sideInputSystemConsumers,\n+        1, // single message in flight per task\n+        -1, // no windowing\n+        taskConfig.getCommitMs(),\n+        taskConfig.getCallbackTimeoutMs(),\n+        this.config.getLong(\"container.disk.quota.delay.max.ms\", TimeUnit.SECONDS.toMillis(1)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw==", "bodyText": "why do we need granular latches? Can we not use one latch with the size of number of side input tasks & check that reaches 0 instead?", "url": "https://github.com/apache/samza/pull/1385#discussion_r448451883", "createdAt": "2020-07-01T15:41:09Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -604,6 +597,9 @@ private StorageEngine createStore(String storeName, TaskName taskName, TaskModel\n           Map<String, StorageEngine> sideInputStores = getSideInputStores(taskName);\n           Map<String, Set<SystemStreamPartition>> sideInputStoresToSSPs = new HashMap<>();\n \n+          CountDownLatch taskCountDownLatch = new CountDownLatch(1);\n+          this.sideInputTaskLatches.put(taskName, taskCountDownLatch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3MzA0OQ==", "bodyText": "CSM originally only handled state restoration which didn't require any commit/flush semantics. Eventually side inputs got rolled into CSM to pay way for standby and side inputs needed to be flushed in our commit cadence. The need for a separate timer thread to trigger flush/commit on task.commit.ms cadence was required. Instead of having logic to coordinate signals between read thread and the timer thread, flush was embedded as part of the timer thread and synchronization was introduced between process & commit.\nWith run loop, the internal timer thread run loop maintains does this job of signaling commit readiness to the task  and hence you don't need a separate flush thread. However, one thing to note is, previously we can potentially have two operations (process & flush) in parallel for different side inputs but with the new setup, we will need a thread pool size of (number of side input tasks + 1) to ensure parity. We will eventually support parallelism across stores/side input tasks as part of transaction state support (i guess).\nSo it is fine to leave it as is.", "url": "https://github.com/apache/samza/pull/1385#discussion_r448473049", "createdAt": "2020-07-01T16:15:48Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -154,17 +149,13 @@\n   private final Map<TaskName, Map<String, Set<SystemStreamPartition>>> taskSideInputStoreSSPs;\n   private final Map<SystemStreamPartition, TaskSideInputHandler> sspSideInputHandlers;\n   private SystemConsumers sideInputSystemConsumers;\n-  private final Map<SystemStreamPartition, SystemStreamMetadata.SystemStreamPartitionMetadata> initialSideInputSSPMetadata\n-      = new ConcurrentHashMap<>(); // Recorded sspMetadata of the taskSideInputSSPs recorded at start, used to determine when sideInputs are caughtup and container init can proceed\n-  private volatile CountDownLatch sideInputsCaughtUp; // Used by the sideInput-read thread to signal to the main thread\n+  private volatile Map<TaskName, CountDownLatch> sideInputTaskLatches; // Used by the sideInput-read thread to signal to the main thread\n   private volatile boolean shouldShutdown = false;\n+  private RunLoop sideInputRunLoop;\n \n   private final ExecutorService sideInputsReadExecutor = Executors.newSingleThreadExecutor(\n       new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_READ_THREAD_NAME).build());\n \n-  private final ScheduledExecutorService sideInputsFlushExecutor = Executors.newSingleThreadScheduledExecutor(\n-      new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_FLUSH_THREAD_NAME).build());\n-  private ScheduledFuture sideInputsFlushFuture;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzAwNw=="}, "originalCommit": {"oid": "f88203e76acfc8277e682e250bad211d70ad9626"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5c27cbc3ad1b1f63c1e84d4464a71a134a58a0c", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/c5c27cbc3ad1b1f63c1e84d4464a71a134a58a0c", "committedDate": "2020-07-21T06:39:24Z", "message": "Merge branch 'master' into side_input_to_runloop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b715386f34b60d592224527d8bc2eca4cd8726c", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/1b715386f34b60d592224527d8bc2eca4cd8726c", "committedDate": "2020-07-30T18:44:48Z", "message": "responding to PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce8b044327d1ff6ad88a6c89a0b73d7c580ada3d", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/ce8b044327d1ff6ad88a6c89a0b73d7c580ada3d", "committedDate": "2020-07-30T18:50:16Z", "message": "Merge branch 'master' into side_input_to_runloop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1b6e53c4410c7fdff286bad616b6a2b3dedeb7", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/5f1b6e53c4410c7fdff286bad616b6a2b3dedeb7", "committedDate": "2020-08-06T10:00:34Z", "message": "Eliminating unnecessary object creation for side input tasks / handlers\n\nEnd of stream should just be a no-op rather than throw unsupported"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb4c03c3fb0610fabef68597b5829ae3ed025133", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/eb4c03c3fb0610fabef68597b5829ae3ed025133", "committedDate": "2020-08-06T10:13:25Z", "message": "Merge branch 'master' into side_input_to_runloop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1274dcb791728c73bbcd8bfe1c9e07207326e6b0", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/1274dcb791728c73bbcd8bfe1c9e07207326e6b0", "committedDate": "2020-08-06T23:08:55Z", "message": "add todo for config consolidation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDc1MTgy", "url": "https://github.com/apache/samza/pull/1385#pullrequestreview-465475182", "createdAt": "2020-08-11T22:37:07Z", "commit": {"oid": "1274dcb791728c73bbcd8bfe1c9e07207326e6b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4639, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}