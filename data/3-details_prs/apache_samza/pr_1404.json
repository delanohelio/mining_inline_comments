{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MzIxNzMy", "number": 1404, "title": "SAMZA-2562: [Scala cleanup] Clean up Scala in samza-kv-inmemory and samza-kv-couchbase", "bodyText": "Issues:\n\nsamza-kv-couchbase uses the Scala Gradle plugin but does not have Scala code\nsamza-kv-inmemory is in Scala, but we are no longer using Scala in Samza, so it would be good to move to Java.\nsamza-kv-inmemory is missing unit tests\n\nChanges:\n\nRewrite samza-kv-inmemoryin Java (no functional changes)\nRemove usage of Scala Gradle plugin for samza-kv-couchbase and samza-kv-inmemory\nAdd unit tests for InMemoryKeyValueStore in samza-kv-inmemory.\n\nTests:\n\nAdded unit tests for original Scala version of InMemoryKeyValueStore and verified that they passed.\nTests pass for new Java version of InMemoryKeyValueStore.\n./gradlew build (some of the tests in samza-test use InMemoryKeyValueStore).\n\nAPI changes: I don't think the InMemoryKeyValueStore is part of the Samza API, since InMemoryKeyValueStorageEngineFactory is supposed to be used, but the InMemoryKeyValueStore constructor did change from having one KeyValueStoreMetrics argument with a default value of new KeyValueStoreMetrics to having a required KeyValueStoreMetrics argument. I believe this only applies to Scala usage of InMemoryKeyValueStore, since Java usage requires all arguments (even ones with default values) to be passed anyways.\nUpgrade/usage instructions: If using the InMemoryKeyValueStore constructor in another Scala class, then add the KeyValueStoreMetrics argument. It's unlikely that anyone is depending on this constructor explicitly.\nNotes:\nWhile writing the unit tests, I found a couple of bugs: https://issues.apache.org/jira/browse/SAMZA-2563 (InMemoryKeyValueStore double counts deletes in metrics) and https://issues.apache.org/jira/browse/SAMZA-2564 (InMemoryKeyValueStore.snapshot does not satisfy immutability API). I did not include fixes in this PR, since I want to keep the Scala refactoring separate from any functional changes.\nThis PR is not intended to have any functional changes.", "createdAt": "2020-07-27T18:12:46Z", "url": "https://github.com/apache/samza/pull/1404", "merged": true, "mergeCommit": {"oid": "3b7d0d19d1f65048f2ac2194226a83e6223bbd3b"}, "closed": true, "closedAt": "2020-07-28T20:53:49Z", "author": {"login": "cameronlee314"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5FtAbgH2gAyNDU3MzIxNzMyOjQ4MDdhY2Y2YjAxYmVkYmZkMmE2YTdmNGQxM2RmNzZmMjg0MGNhNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5Z-FIAFqTQ1Njg1OTI1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "committedDate": "2020-07-27T17:58:27Z", "message": "SAMZA-2562: [Scala cleanup] Clean up Scala in samza-kv-inmemory and samza-kv-couchbase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTk4NjUx", "url": "https://github.com/apache/samza/pull/1404#pullrequestreview-456198651", "createdAt": "2020-07-27T23:18:33Z", "commit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzoxODozM1rOG325og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMzo0NTowNFrOG33bdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDM1NA==", "bodyText": "link the jira?", "url": "https://github.com/apache/samza/pull/1404#discussion_r461224354", "createdAt": "2020-07-27T23:18:33Z", "author": {"login": "bkonold"}, "path": "samza-kv-inmemory/src/main/java/org/apache/samza/storage/kv/inmemory/InMemoryKeyValueStore.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv.inmemory;\n+\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.UnsignedBytes;\n+import org.apache.samza.checkpoint.CheckpointId;\n+import org.apache.samza.storage.kv.Entry;\n+import org.apache.samza.storage.kv.KeyValueIterator;\n+import org.apache.samza.storage.kv.KeyValueSnapshot;\n+import org.apache.samza.storage.kv.KeyValueStore;\n+import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+\n+\n+/**\n+ * In-memory implementation of a {@link KeyValueStore}.\n+ *\n+ * This uses a {@link ConcurrentSkipListMap} to store the keys in order.\n+ */\n+public class InMemoryKeyValueStore implements KeyValueStore<byte[], byte[]> {\n+  private final KeyValueStoreMetrics metrics;\n+  private final ConcurrentSkipListMap<byte[], byte[]> underlying;\n+\n+  /**\n+   * @param metrics A metrics instance to publish key-value store related statistics\n+   */\n+  public InMemoryKeyValueStore(KeyValueStoreMetrics metrics) {\n+    this.metrics = metrics;\n+    this.underlying = new ConcurrentSkipListMap<>(UnsignedBytes.lexicographicalComparator());\n+  }\n+\n+  @Override\n+  public byte[] get(byte[] key) {\n+    this.metrics.gets().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    byte[] found = this.underlying.get(key);\n+    if (found != null) {\n+      metrics.bytesRead().inc(found.length);\n+    }\n+    return found;\n+  }\n+\n+  @Override\n+  public void put(byte[] key, byte[] value) {\n+    this.metrics.puts().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    if (value == null) {\n+      this.metrics.deletes().inc();\n+      this.underlying.remove(key);\n+    } else {\n+      this.metrics.bytesWritten().inc(key.length + value.length);\n+      this.underlying.put(key, value);\n+    }\n+  }\n+\n+  @Override\n+  public void putAll(List<Entry<byte[], byte[]>> entries) {\n+    // TreeMap's putAll requires a map, so we'd need to iterate over all the entries anyway\n+    // to use it, in order to putAll here.  Therefore, just iterate here.\n+    for (Entry<byte[], byte[]> next : entries) {\n+      put(next.getKey(), next.getValue());\n+    }\n+  }\n+\n+  @Override\n+  public void delete(byte[] key) {\n+    // TODO Bug: This double counts deletes for metrics, because put also counts a delete", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDM4Nw==", "bodyText": "link the jira?", "url": "https://github.com/apache/samza/pull/1404#discussion_r461224387", "createdAt": "2020-07-27T23:18:40Z", "author": {"login": "bkonold"}, "path": "samza-kv-inmemory/src/main/java/org/apache/samza/storage/kv/inmemory/InMemoryKeyValueStore.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv.inmemory;\n+\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.UnsignedBytes;\n+import org.apache.samza.checkpoint.CheckpointId;\n+import org.apache.samza.storage.kv.Entry;\n+import org.apache.samza.storage.kv.KeyValueIterator;\n+import org.apache.samza.storage.kv.KeyValueSnapshot;\n+import org.apache.samza.storage.kv.KeyValueStore;\n+import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+\n+\n+/**\n+ * In-memory implementation of a {@link KeyValueStore}.\n+ *\n+ * This uses a {@link ConcurrentSkipListMap} to store the keys in order.\n+ */\n+public class InMemoryKeyValueStore implements KeyValueStore<byte[], byte[]> {\n+  private final KeyValueStoreMetrics metrics;\n+  private final ConcurrentSkipListMap<byte[], byte[]> underlying;\n+\n+  /**\n+   * @param metrics A metrics instance to publish key-value store related statistics\n+   */\n+  public InMemoryKeyValueStore(KeyValueStoreMetrics metrics) {\n+    this.metrics = metrics;\n+    this.underlying = new ConcurrentSkipListMap<>(UnsignedBytes.lexicographicalComparator());\n+  }\n+\n+  @Override\n+  public byte[] get(byte[] key) {\n+    this.metrics.gets().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    byte[] found = this.underlying.get(key);\n+    if (found != null) {\n+      metrics.bytesRead().inc(found.length);\n+    }\n+    return found;\n+  }\n+\n+  @Override\n+  public void put(byte[] key, byte[] value) {\n+    this.metrics.puts().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    if (value == null) {\n+      this.metrics.deletes().inc();\n+      this.underlying.remove(key);\n+    } else {\n+      this.metrics.bytesWritten().inc(key.length + value.length);\n+      this.underlying.put(key, value);\n+    }\n+  }\n+\n+  @Override\n+  public void putAll(List<Entry<byte[], byte[]>> entries) {\n+    // TreeMap's putAll requires a map, so we'd need to iterate over all the entries anyway\n+    // to use it, in order to putAll here.  Therefore, just iterate here.\n+    for (Entry<byte[], byte[]> next : entries) {\n+      put(next.getKey(), next.getValue());\n+    }\n+  }\n+\n+  @Override\n+  public void delete(byte[] key) {\n+    // TODO Bug: This double counts deletes for metrics, because put also counts a delete\n+    metrics.deletes().inc();\n+    put(key, null);\n+  }\n+\n+  @Override\n+  public KeyValueIterator<byte[], byte[]> range(byte[] from, byte[] to) {\n+    this.metrics.ranges().inc();\n+    Preconditions.checkArgument(from != null, \"Null argument 'from' not allowed\");\n+    Preconditions.checkArgument(to != null, \"Null argument 'to' not allowed\");\n+    return new InMemoryIterator(this.underlying.subMap(from, to).entrySet().iterator(), this.metrics);\n+  }\n+\n+  @Override\n+  public KeyValueSnapshot<byte[], byte[]> snapshot(byte[] from, byte[] to) {\n+    // TODO: Bug: This does not satisfy the immutability constraint, since the entrySet is backed by the underlying map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMDIxNw==", "bodyText": "is there an edge case this is intended to test that testPut doesn't cover?", "url": "https://github.com/apache/samza/pull/1404#discussion_r461230217", "createdAt": "2020-07-27T23:36:29Z", "author": {"login": "bkonold"}, "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMTUwMw==", "bodyText": "doesn't this assume that key(0) and value(0) lengths are the same as key(i) and value(i) from the loop? can we re-write this so it more obviously matches the 10 writes that happen in the loop or add a comment indicating this assumption? or perhaps define a constant that represents the length of an integer key / value... just to make this more readable.\nsame comment applies to other occurrences of loops in your tests", "url": "https://github.com/apache/samza/pull/1404#discussion_r461231503", "createdAt": "2020-07-27T23:40:32Z", "author": {"login": "bkonold"}, "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }\n+\n+  @Test\n+  public void testPutNull() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), null);\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.deletesCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAll() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    verify(this.putsCounter, times(10)).inc();\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllUpdate() {\n+    // check that an existing value is overridden\n+    this.inMemoryKeyValueStore.put(key(0), value(1234));\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    // 1 time for initial value to be overridden, 10 times for \"regular\" puts\n+    verify(this.putsCounter, times(11)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(1234).length);\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzAxMg==", "bodyText": "ty for noting the bug; will make it easy to fix when tests fail once the bug is fixed", "url": "https://github.com/apache/samza/pull/1404#discussion_r461233012", "createdAt": "2020-07-27T23:45:04Z", "author": {"login": "bkonold"}, "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }\n+\n+  @Test\n+  public void testPutNull() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), null);\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.deletesCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAll() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    verify(this.putsCounter, times(10)).inc();\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllUpdate() {\n+    // check that an existing value is overridden\n+    this.inMemoryKeyValueStore.put(key(0), value(1234));\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    // 1 time for initial value to be overridden, 10 times for \"regular\" puts\n+    verify(this.putsCounter, times(11)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(1234).length);\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllWithNull() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    List<Entry<byte[], byte[]>> deleteEntries = new ArrayList<>();\n+    for (int i = 0; i < 3; i++) {\n+      deleteEntries.add(new Entry<>(key(i), null));\n+    }\n+    this.inMemoryKeyValueStore.putAll(deleteEntries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      if (i < 3) {\n+        assertNull(this.inMemoryKeyValueStore.get(key(i)));\n+      } else {\n+        assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+      }\n+    }\n+    // 10 times for \"regular\" puts, 3 times for deletion puts\n+    verify(this.putsCounter, times(13)).inc();\n+    // 10 \"regular\" puts all have same size for key/value\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+    verifyNoMoreInteractions(this.bytesWrittenCounter);\n+    verify(this.deletesCounter, times(3)).inc();\n+  }\n+\n+  @Test\n+  public void testDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+\n+    /*\n+     * There is a bug in which deletes are double counted in metrics. This deletesCounter should only be invoked once", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59"}, "originalPosition": 221}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9720188aaf7ba0d2e2ec1a899acf38a4903e325d", "author": {"user": {"login": "cameronlee314", "name": "Cameron Lee"}}, "url": "https://github.com/apache/samza/commit/9720188aaf7ba0d2e2ec1a899acf38a4903e325d", "committedDate": "2020-07-28T17:25:40Z", "message": "added JIRA tickets, clarified metrics validations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODU5MjU3", "url": "https://github.com/apache/samza/pull/1404#pullrequestreview-456859257", "createdAt": "2020-07-28T17:35:13Z", "commit": {"oid": "9720188aaf7ba0d2e2ec1a899acf38a4903e325d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4667, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}