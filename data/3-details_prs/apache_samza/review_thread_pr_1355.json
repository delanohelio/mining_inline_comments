{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNzUxMDQw", "number": 1355, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNTowNlrOD6bGAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNTowNlrOD6bGAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTg3OTA2OnYy", "diffSide": "RIGHT", "path": "samza-core/src/main/java/org/apache/samza/scheduler/EpochTimeScheduler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNTowNlrOGSQjDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNTowNlrOGSQjDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5ODY3MQ==", "bodyText": "Probably need this to be warn level logging here.", "url": "https://github.com/apache/samza/pull/1355#discussion_r421798671", "createdAt": "2020-05-07T21:15:06Z", "author": {"login": "xinyuiscool"}, "path": "samza-core/src/main/java/org/apache/samza/scheduler/EpochTimeScheduler.java", "diffHunk": "@@ -57,9 +58,33 @@ private EpochTimeScheduler(ScheduledExecutorService executor) {\n     this.executor = executor;\n   }\n \n+  @VisibleForTesting\n+  Map<Object, ScheduledFuture> getScheduledFutures() {\n+    return scheduledFutures;\n+  }\n+\n   public <K> void setTimer(K key, long timestamp, ScheduledCallback<K> callback) {\n-    checkState(!scheduledFutures.containsKey(key),\n-        String.format(\"Duplicate key %s registration for the same timer\", key));\n+    if (scheduledFutures.containsKey(key)) {\n+      LOG.warn(\"Registering duplicate callback for key: {}. Attempting to cancel the previous callback\", key);\n+      ScheduledFuture<?> scheduledFuture = scheduledFutures.get(key);\n+\n+      /*\n+       * We can have a race between the time we check for the presence of the key and the time we attempt to cancel;\n+       * Hence we check for non-null criteria to ensure the executor hasn't kicked off the callback for the key which\n+       * removes the future from the map before invoking onTimer.\n+       *  1. In the event that callback is running then we will not attempt to interrupt the action and\n+       *     cancel will return as unsuccessful.\n+       *  2. In case of the callback successfully executed, we want to allow duplicate registration to keep the\n+       *     behavior consistent with the scenario where the callback is already executed or in progress even before\n+       *     we entered this condition.\n+       */\n+      if (scheduledFuture != null\n+          && !scheduledFuture.cancel(false)\n+          && !scheduledFuture.isDone()) {\n+        LOG.debug(\"Failed to cancel the previous callback successfully. Ignoring the current request to register new callback\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bca3c9043fda8a9be6d1afb47e3bf102841440cf"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1414, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}