{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTM4NjI0", "number": 1393, "title": "SAMZA-2554: Fix the handling of join condition against remote table", "bodyText": "Bug Fix: SAMZA-2554\nSymptom: When the join condition has more than one predicate, current impls just ignore part of the join predicate and returns wrong results.\nChanges: This PR does:\n\n\nBlock any query  with more than one predicate from running and returning wrong results to user. In a follow up work will add some handling for a conjunction of join predicate.\nAnother Item added by this PR is the checking for an existing input reference that is Expression Free and it point directly to the primary key of remote table. As of Today the convention is to call such column __key__. In the future will be better to allow the table implementation chose what every name/type\n\n\nTests: Added more tests and run current tests end to end.\nI did remove one of the very complex mocking setup test. I feel like most of the tests are covered by the end to end tests and mocking is getting very convoluted it is 100 lines of code. If I am missing something and we feel we need such a test then let''s try to clarify what are the missing points and use Calcite RexBuilder to actually build the Rel Plan that will lead to clean code and more readable/testable in case we change any of the implementation details.\n\n\n\nThis change is\u2002", "createdAt": "2020-06-25T16:42:30Z", "url": "https://github.com/apache/samza/pull/1393", "merged": true, "mergeCommit": {"oid": "8a9a5e3c1af882cac50130b8e9bf87449a90cb09"}, "closed": true, "closedAt": "2020-06-30T04:22:31Z", "author": {"login": "b-slim"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvbmmJgFqTQzODcxMzUyMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwFsXhAH2gAyNDQwMTM4NjI0OjhhMDYxZDRkYjc5NTVkYzg3Njg3ZDIxMzZlZjc2N2JmZTY2YmI5Mzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzEzNTIw", "url": "https://github.com/apache/samza/pull/1393#pullrequestreview-438713520", "createdAt": "2020-06-27T17:44:54Z", "commit": {"oid": "042bcf2acfa6c62754da25afd5f0ba664551523d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0NDo1NFrOGp3OAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0NDo1NFrOGp3OAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0OTUwNw==", "bodyText": "could we add tests that go thru' the below code and fail ? If you plan to add them as part of your nested struct support, please feel free to drop this.", "url": "https://github.com/apache/samza/pull/1393#discussion_r446549507", "createdAt": "2020-06-27T17:44:54Z", "author": {"login": "atoomula"}, "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "diffHunk": "@@ -193,88 +215,133 @@ private void validateJoinQuery(LogicalJoin join, JoinInputNode.InputType inputTy\n           dumpRelPlanForNode(join));\n     }\n \n-    if (joinRelType.compareTo(JoinRelType.LEFT) == 0 && isTablePosOnLeft && !isTablePosOnRight) {\n+    if (joinRelType.compareTo(JoinRelType.LEFT) == 0 && isTablePosOnLeft) {\n       throw new SamzaException(\"Invalid query for outer left join. Left side of the join should be a 'stream' and \"\n           + \"right side of join should be a 'table'. \" + dumpRelPlanForNode(join));\n     }\n \n-    if (joinRelType.compareTo(JoinRelType.RIGHT) == 0 && isTablePosOnRight && !isTablePosOnLeft) {\n+    if (joinRelType.compareTo(JoinRelType.RIGHT) == 0 && isTablePosOnRight) {\n       throw new SamzaException(\"Invalid query for outer right join. Left side of the join should be a 'table' and \"\n           + \"right side of join should be a 'stream'. \" + dumpRelPlanForNode(join));\n     }\n \n-    validateJoinCondition(join.getCondition());\n-  }\n-\n-  private void validateJoinCondition(RexNode operand) {\n-    if (!(operand instanceof RexCall)) {\n-      throw new SamzaException(\"SQL Query is not supported. Join condition operand \" + operand +\n-          \" is of type \" + operand.getClass());\n-    }\n-\n-    RexCall condition = (RexCall) operand;\n+    final List<RexNode> conjunctionList = new ArrayList<>();\n+    decomposeAndValidateConjunction(join.getCondition(), conjunctionList);\n \n-    if (condition.isAlwaysTrue()) {\n+    if (conjunctionList.isEmpty()) {\n       throw new SamzaException(\"Query results in a cross join, which is not supported. Please optimize the query.\"\n           + \" It is expected that the joins should include JOIN ON operator in the sql query.\");\n     }\n-\n-    if (condition.getKind() != SqlKind.EQUALS && condition.getKind() != SqlKind.AND) {\n-      throw new SamzaException(\"Only equi-joins and AND operator is supported in join condition.\");\n-    }\n-  }\n-\n-  // Fetch the stream and table key indices corresponding to the fields given in the join condition by parsing through\n-  // the condition. Stream and table key indices are populated in streamKeyIds and tableKeyIds respectively.\n-  private void populateStreamAndTableKeyIds(List<RexNode> operands, final LogicalJoin join, boolean isTablePosOnRight,\n-      List<Integer> streamKeyIds, List<Integer> tableKeyIds) {\n-\n-    // All non-leaf operands in the join condition should be expressions.\n-    if (operands.get(0) instanceof RexCall) {\n-      operands.forEach(operand -> {\n-        validateJoinCondition(operand);\n-        populateStreamAndTableKeyIds(((RexCall) operand).getOperands(), join, isTablePosOnRight, streamKeyIds, tableKeyIds);\n-      });\n+    //TODO Not sure why we can not allow literal as part of the join condition will revisit this in another scope\n+    conjunctionList.forEach(rexNode -> rexNode.accept(new RexShuttle(){\n+      @Override\n+      public RexNode visitLiteral(RexLiteral literal) {\n+        throw new SamzaException(\n+            \"Join Condition can not allow literal \" + literal.toString() + \" join node\" + join.getDigest());\n+      }\n+    }));\n+    final JoinInputNode.InputType rootTableInput = isTablePosOnRight ? inputTypeOnRight : inputTypeOnLeft;\n+    if (rootTableInput.compareTo(JoinInputNode.InputType.REMOTE_TABLE) != 0) {\n+      // it is not a remote table all is good we do not have to validate the project on key Column\n       return;\n     }\n \n-    // We are at the leaf of the join condition. Only binary operators are supported.\n-    Validate.isTrue(operands.size() == 2);\n+    /*\n+    For remote Table we need to validate The join Condition and The project that is above remote table scan.\n+     - As of today Filter need to be exactly one equi-join using the __key__ column (see SAMZA-2554)\n+     - The Project on the top of the remote table has to contain only simple input references to any of the column used in the join.\n+    */\n+\n+    // First let's collect the ref of columns used by the join condition.\n+    List<RexInputRef> refCollector = new ArrayList<>();\n+    join.getCondition().accept(new RexShuttle(){\n+      @Override\n+      public RexNode visitInputRef(RexInputRef inputRef) {\n+        refCollector.add(inputRef);\n+        return inputRef;\n+      }\n+    });\n+    // start index of the Remote table within the Join Row\n+    final int tableStartIndex = isTablePosOnRight ? join.getLeft().getRowType().getFieldCount() : 0;\n+    // end index of the Remote table withing the Join Row\n+    final int tableEndIndex =\n+        isTablePosOnRight ? join.getRowType().getFieldCount() : join.getLeft().getRowType().getFieldCount();\n+\n+    List<Integer> tableRefsIdx = refCollector.stream()\n+        .map(x -> x.getIndex())\n+        .filter(x -> tableStartIndex <= x && x < tableEndIndex) // collect all the refs form table side\n+        .map(x -> x - tableStartIndex) // re-adjust the offset\n+        .sorted()\n+        .collect(Collectors.toList()); // we have a list with all the input from table side with 0 based index.\n+\n+    // Validate the Condition must contain a ref to remote table primary key column.\n+\n+    if (conjunctionList.size() != 1 || tableRefsIdx.size() != 1) {\n+      //TODO We can relax this by allowing another filter to be evaluated post lookup see SAMZA-2554\n+      throw new SamzaException(\n+          \"Invalid query for join condition must contain exactly one predicate for remote table on __key__ column \"\n+              + dumpRelPlanForNode(join));\n+    }\n \n-    // Only reference operands are supported in row expressions and not constants.\n-    // a.key = b.key is supported with a.key and b.key being reference operands.\n-    // a.key = \"constant\" is not yet supported.\n-    if (!(operands.get(0) instanceof RexInputRef) || !(operands.get(1) instanceof RexInputRef)) {\n-      throw new SamzaException(\"SQL query is not supported. Join condition \" + join.getCondition() + \" should have \"\n-          + \"reference operands but the types are \" + operands.get(0).getClass() + \" and \" + operands.get(1).getClass());\n+    // Validate the Project, follow each input and ensure that it is a simple ref with no rexCall in the way.\n+    if (!isValidRemoteJoinRef(tableRefsIdx.get(0), isTablePosOnRight ? join.getRight() : join.getLeft())) {\n+      throw new SamzaException(\"Invalid query for join condition can not have an expression and must be reference \"\n+          + SamzaSqlRelMessage.KEY_NAME + \" column \" + dumpRelPlanForNode(join));\n     }\n+  }\n \n-    // Join condition is commutative, meaning, a.key = b.key is equivalent to b.key = a.key.\n-    // Calcite assigns the indices to the fields based on the order a and b are specified in\n-    // the sql 'from' clause. Let's put the operand with smaller index in leftRef and larger\n-    // index in rightRef so that the order of operands in the join condition is in the order\n-    // the stream and table are specified in the 'from' clause.\n+  /**\n+   * Helper method to check if the join condition can be evaluated by the remote table.\n+   * It does follow single path  using the index ref path checking if it is a simple reference all the way to table scan.\n+   * In case any RexCall is encountered will stop an return null as a marker otherwise will return Column Name.\n+   *\n+   * @param inputRexIndex rex ref index\n+   * @param relNode current Rel Node\n+   * @return false if any Relational Expression is encountered on the path, true if is simple ref to __key__ column.\n+   */\n+  private static boolean isValidRemoteJoinRef(int inputRexIndex, RelNode relNode){\n+    if (relNode instanceof TableScan) {\n+      return relNode.getRowType().getFieldList().get(inputRexIndex).getName().equals(SamzaSqlRelMessage.KEY_NAME);\n+    }\n+    // has to be a single rel kind filter/project/table scan", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "042bcf2acfa6c62754da25afd5f0ba664551523d"}, "originalPosition": 198}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "231853b2aa9da3444ee53a8e05dfd336feb88a15", "author": {"user": {"login": "b-slim", "name": "Slim Bouguerra"}}, "url": "https://github.com/apache/samza/commit/231853b2aa9da3444ee53a8e05dfd336feb88a15", "committedDate": "2020-06-29T18:04:32Z", "message": "SAMZA-2554: Fix the handling of join condition against remote tables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "author": {"user": {"login": "b-slim", "name": "Slim Bouguerra"}}, "url": "https://github.com/apache/samza/commit/38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "committedDate": "2020-06-29T18:04:32Z", "message": "Fixed one tests failing and ignored one complex mocking test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "042bcf2acfa6c62754da25afd5f0ba664551523d", "author": {"user": {"login": "b-slim", "name": "Slim Bouguerra"}}, "url": "https://github.com/apache/samza/commit/042bcf2acfa6c62754da25afd5f0ba664551523d", "committedDate": "2020-06-26T18:01:58Z", "message": "Merge branch 'master' into fix_join_condition_handling"}, "afterCommit": {"oid": "38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "author": {"user": {"login": "b-slim", "name": "Slim Bouguerra"}}, "url": "https://github.com/apache/samza/commit/38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "committedDate": "2020-06-29T18:04:32Z", "message": "Fixed one tests failing and ignored one complex mocking test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a061d4db7955dc87687d2136ef767bfe66bb937", "author": {"user": {"login": "b-slim", "name": "Slim Bouguerra"}}, "url": "https://github.com/apache/samza/commit/8a061d4db7955dc87687d2136ef767bfe66bb937", "committedDate": "2020-06-29T18:52:26Z", "message": "Fix the style issues"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4645, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}