{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NzI2MTk1", "number": 1242, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxOTozNjo0NVrODVhv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxOTozNjo0NVrODVhv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjIzODk5NjQxOnYy", "diffSide": "RIGHT", "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxOTozNjo0NVrOFZzaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwNzo1MjowM1rOFZ7Egw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjYwMTAyNw==", "bodyText": "There're other kinds of RelNode which are not covered by instanceOf checks in recursive function. Do we need to handle other kinds of RelNode here? If not, why?\nCan you please add a unit-test in JoinTranslator for these changes?\nJust curious. Would the schema validations be applied on the result of the sub-queries within joins?", "url": "https://github.com/apache/samza/pull/1242#discussion_r362601027", "createdAt": "2020-01-02T19:36:45Z", "author": {"login": "shanthoosh"}, "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "diffHunk": "@@ -292,17 +294,27 @@ private String dumpRelPlanForNode(RelNode relNode) {\n         SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n   }\n \n-  private SqlIOConfig resolveSourceConfigForTable(RelNode relNode, TranslatorContext context) {\n+  private SqlIOConfig resolveSQlIOForTable(RelNode relNode, TranslatorContext context) {\n+    // Let's recursively get to the TableScan node to identify IO for the table.\n     if (relNode instanceof LogicalProject) {\n-      return resolveSourceConfigForTable(((LogicalProject) relNode).getInput(), context);\n+      return resolveSQlIOForTable(((LogicalProject) relNode).getInput(), context);\n     }\n \n-    // We are returning the sourceConfig for the table as null when the table is in another join rather than an output\n-    // table, that's because the output of stream-table join is considered a stream.\n-    if (relNode.getInputs().size() > 1) {\n+    if (relNode instanceof LogicalFilter) {\n+      return resolveSQlIOForTable(((LogicalFilter) relNode).getInput(), context);\n+    }\n+\n+    // We return null for table IO as the table seems to be involved in another join. The output of stream-table join\n+    // is considered a stream. Hence, we return null for the table.\n+    if (relNode instanceof LogicalJoin && relNode.getInputs().size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjcyNjUzMQ==", "bodyText": "Very good questions.\n\nIn Samza Sql, we currently support only filters, projection and joins along with scan. Hence, only they are handled in this function.\nThere are end-to-end tests for each of these if conditions and for the new addition.\nSchema validations for joins is not yet implemented.", "url": "https://github.com/apache/samza/pull/1242#discussion_r362726531", "createdAt": "2020-01-03T07:52:03Z", "author": {"login": "atoomula"}, "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "diffHunk": "@@ -292,17 +294,27 @@ private String dumpRelPlanForNode(RelNode relNode) {\n         SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n   }\n \n-  private SqlIOConfig resolveSourceConfigForTable(RelNode relNode, TranslatorContext context) {\n+  private SqlIOConfig resolveSQlIOForTable(RelNode relNode, TranslatorContext context) {\n+    // Let's recursively get to the TableScan node to identify IO for the table.\n     if (relNode instanceof LogicalProject) {\n-      return resolveSourceConfigForTable(((LogicalProject) relNode).getInput(), context);\n+      return resolveSQlIOForTable(((LogicalProject) relNode).getInput(), context);\n     }\n \n-    // We are returning the sourceConfig for the table as null when the table is in another join rather than an output\n-    // table, that's because the output of stream-table join is considered a stream.\n-    if (relNode.getInputs().size() > 1) {\n+    if (relNode instanceof LogicalFilter) {\n+      return resolveSQlIOForTable(((LogicalFilter) relNode).getInput(), context);\n+    }\n+\n+    // We return null for table IO as the table seems to be involved in another join. The output of stream-table join\n+    // is considered a stream. Hence, we return null for the table.\n+    if (relNode instanceof LogicalJoin && relNode.getInputs().size() > 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjYwMTAyNw=="}, "originalCommit": {"oid": "abeb06f16d2eb3bacd84db94686c4b0fde1cbe3e"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1534, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}