{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTE2NDQ3", "number": 1334, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMDoxOTozM1rODsNyrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMDoxOTozM1rODsNyrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3Njg5OTAxOnYy", "diffSide": "RIGHT", "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMDoxOTozM1rOF9AmzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMTo0MToyNFrOF9CrIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA==", "bodyText": "I see you are not the author of tests. But, do we need to wait for 2 seconds here for this test? Isn't verifying the scheduler for no task submissions below sufficient?", "url": "https://github.com/apache/samza/pull/1334#discussion_r399517388", "createdAt": "2020-03-27T20:19:33Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "diffHunk": "@@ -20,44 +20,77 @@\n package org.apache.samza.container;\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import junit.framework.Assert;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-public class TestContainerHeartbeatMonitor {\n \n+public class TestContainerHeartbeatMonitor {\n   @Test\n-  public void testCallbackWhenHeartbeatDead()\n-      throws InterruptedException {\n+  public void testCallbackWhenHeartbeatDead() throws InterruptedException {\n     ContainerHeartbeatClient mockClient = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(false);\n     when(mockClient.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);\n-    Assert.assertTrue(success);\n+    assertTrue(success);\n+    // check that the shutdown task got submitted, but don't actually execute it since it will shut down the process\n+    verify(scheduler).schedule(any(Runnable.class), eq((long) ContainerHeartbeatMonitor.SHUTDOWN_TIMOUT_MS),\n+        eq(TimeUnit.MILLISECONDS));\n+\n+    monitor.stop();\n+    verify(scheduler).shutdown();\n   }\n \n   @Test\n-  public void testDoesNotCallbackWhenHeartbeatAlive()\n-      throws InterruptedException {\n+  public void testDoesNotCallbackWhenHeartbeatAlive() throws InterruptedException {\n     ContainerHeartbeatClient client = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(true);\n     when(client.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ab7fc7347ee39eada9c815bef5df85b1c524e76"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyMDgzMw==", "bodyText": "The task executes asynchronously, so this 2 seconds gives some time to make sure that it doesn't actually execute. If we check for no task submission immediately, and there was a bug which caused the task to be submitted, it's possible that the test would still pass because the verification happened before the async execution.", "url": "https://github.com/apache/samza/pull/1334#discussion_r399520833", "createdAt": "2020-03-27T20:27:25Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "diffHunk": "@@ -20,44 +20,77 @@\n package org.apache.samza.container;\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import junit.framework.Assert;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-public class TestContainerHeartbeatMonitor {\n \n+public class TestContainerHeartbeatMonitor {\n   @Test\n-  public void testCallbackWhenHeartbeatDead()\n-      throws InterruptedException {\n+  public void testCallbackWhenHeartbeatDead() throws InterruptedException {\n     ContainerHeartbeatClient mockClient = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(false);\n     when(mockClient.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);\n-    Assert.assertTrue(success);\n+    assertTrue(success);\n+    // check that the shutdown task got submitted, but don't actually execute it since it will shut down the process\n+    verify(scheduler).schedule(any(Runnable.class), eq((long) ContainerHeartbeatMonitor.SHUTDOWN_TIMOUT_MS),\n+        eq(TimeUnit.MILLISECONDS));\n+\n+    monitor.stop();\n+    verify(scheduler).shutdown();\n   }\n \n   @Test\n-  public void testDoesNotCallbackWhenHeartbeatAlive()\n-      throws InterruptedException {\n+  public void testDoesNotCallbackWhenHeartbeatAlive() throws InterruptedException {\n     ContainerHeartbeatClient client = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(true);\n     when(client.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}, "originalCommit": {"oid": "9ab7fc7347ee39eada9c815bef5df85b1c524e76"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyMjgwMg==", "bodyText": "I see that makes sense. Then can we have buildScheduledExecutorService take a CountDownLatch and call run on the Runnable directly instead of spinning up a thread and finally decrementing the lathc?", "url": "https://github.com/apache/samza/pull/1334#discussion_r399522802", "createdAt": "2020-03-27T20:31:43Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "diffHunk": "@@ -20,44 +20,77 @@\n package org.apache.samza.container;\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import junit.framework.Assert;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-public class TestContainerHeartbeatMonitor {\n \n+public class TestContainerHeartbeatMonitor {\n   @Test\n-  public void testCallbackWhenHeartbeatDead()\n-      throws InterruptedException {\n+  public void testCallbackWhenHeartbeatDead() throws InterruptedException {\n     ContainerHeartbeatClient mockClient = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(false);\n     when(mockClient.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);\n-    Assert.assertTrue(success);\n+    assertTrue(success);\n+    // check that the shutdown task got submitted, but don't actually execute it since it will shut down the process\n+    verify(scheduler).schedule(any(Runnable.class), eq((long) ContainerHeartbeatMonitor.SHUTDOWN_TIMOUT_MS),\n+        eq(TimeUnit.MILLISECONDS));\n+\n+    monitor.stop();\n+    verify(scheduler).shutdown();\n   }\n \n   @Test\n-  public void testDoesNotCallbackWhenHeartbeatAlive()\n-      throws InterruptedException {\n+  public void testDoesNotCallbackWhenHeartbeatAlive() throws InterruptedException {\n     ContainerHeartbeatClient client = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(true);\n     when(client.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}, "originalCommit": {"oid": "9ab7fc7347ee39eada9c815bef5df85b1c524e76"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU1MTI2Ng==", "bodyText": "Good idea. This prevents the extra 2s wait and it allows for some common initialization. Updated the tests.", "url": "https://github.com/apache/samza/pull/1334#discussion_r399551266", "createdAt": "2020-03-27T21:41:24Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "diffHunk": "@@ -20,44 +20,77 @@\n package org.apache.samza.container;\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import junit.framework.Assert;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-public class TestContainerHeartbeatMonitor {\n \n+public class TestContainerHeartbeatMonitor {\n   @Test\n-  public void testCallbackWhenHeartbeatDead()\n-      throws InterruptedException {\n+  public void testCallbackWhenHeartbeatDead() throws InterruptedException {\n     ContainerHeartbeatClient mockClient = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(false);\n     when(mockClient.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);\n-    Assert.assertTrue(success);\n+    assertTrue(success);\n+    // check that the shutdown task got submitted, but don't actually execute it since it will shut down the process\n+    verify(scheduler).schedule(any(Runnable.class), eq((long) ContainerHeartbeatMonitor.SHUTDOWN_TIMOUT_MS),\n+        eq(TimeUnit.MILLISECONDS));\n+\n+    monitor.stop();\n+    verify(scheduler).shutdown();\n   }\n \n   @Test\n-  public void testDoesNotCallbackWhenHeartbeatAlive()\n-      throws InterruptedException {\n+  public void testDoesNotCallbackWhenHeartbeatAlive() throws InterruptedException {\n     ContainerHeartbeatClient client = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(true);\n     when(client.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}, "originalCommit": {"oid": "9ab7fc7347ee39eada9c815bef5df85b1c524e76"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1619, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}