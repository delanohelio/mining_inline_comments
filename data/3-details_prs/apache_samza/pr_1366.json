{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDY3OTcz", "number": 1366, "title": "SAMZA-2529: Extract interface from TaskInstance for reuse of RunLoop", "bodyText": "Issues: Hard to reuse RunLoop for non-TaskInstance use cases because of coupling\nChanges: This PR extracts the existing contract between TaskInstance and RunLoop into a new interface RunLoopTask. RunLoopTask will allow other implementers from TaskInstance to also leverage RunLoop, something we anticipate doing with side input processing after this PR is merged.\nThis is largely a refactor. However, I also clean up the unneeded use of TaskInstance.isAsyncTask. Because in SamzaContainer we will always wrap any supplied StreamTask with AsyncStreamTaskAdapter, this method returns true in all cases. This makes it possible to clean up some validation from RunLoopFactory, and the control flow within TaskInstance.process\nTests: I've re-written all unit tests in TestRunLoop to use mocks of RunLoopTask rather than the fake TestTask it embeds in a TaskInstance now. Using mocks verifies the decoupling of TaskInstance from RunLoop, and additionally allowed for writing the tests in a more readable / expressive manner.\nAPI Changes: None. RunLoop, TaskInstance, RunLoopTask are internal to Samza and are not user facing.\nUpgrade Instructions: None.\nUsage Instructions: None.", "createdAt": "2020-05-22T17:51:51Z", "url": "https://github.com/apache/samza/pull/1366", "merged": true, "mergeCommit": {"oid": "f134f0f467814c09e24d00c6b0fc47be7e47622c"}, "closed": true, "closedAt": "2020-06-01T17:35:15Z", "author": {"login": "bkonold"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjtzt_gH2gAyNDIyMDY3OTczOjZhNWEwZWY2MTQxNGVkZDc3YmNmZGYwNDM1MWExN2Q0NTAyZjc3NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmFUTDAFqTQyMTExODkwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/6a5a0ef61414edd77bcfdf04351a17d4502f7771", "committedDate": "2020-05-22T08:15:39Z", "message": "Refactoring TaskInstance methods used by RunLoop into new interface RunLoopTask"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTIwNzcz", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-417120773", "createdAt": "2020-05-22T18:50:33Z", "commit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODo1MDozM1rOGZgwCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODo1NDo0OFrOGZg2bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ==", "bodyText": "Can we add some java docs for this class?", "url": "https://github.com/apache/samza/pull/1366#discussion_r429404171", "createdAt": "2020-05-22T18:50:33Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTEwOA==", "bodyText": "minor: can we either group the methods and order them by ones that require implementation vs default", "url": "https://github.com/apache/samza/pull/1366#discussion_r429405108", "createdAt": "2020-05-22T18:52:56Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTgwNg==", "bodyText": "can we make this interface free of scala and have the implementors or callers adapt to scala if necessary?", "url": "https://github.com/apache/samza/pull/1366#discussion_r429405806", "createdAt": "2020-05-22T18:54:48Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {\n+\n+  TaskName taskName();\n+\n+  default boolean isWindowableTask() {\n+    return false;\n+  }\n+\n+  default boolean isAsyncTask() {\n+    return false;\n+  }\n+\n+  default EpochTimeScheduler epochTimeScheduler() {\n+    return null;\n+  }\n+\n+  default scala.collection.immutable.Set<String> intermediateStreams() {\n+    return JavaConversions.asScalaSet(Collections.emptySet()).toSet();\n+  }\n+\n+  scala.collection.immutable.Set<SystemStreamPartition> systemStreamPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/09f14114336565d54c88c4d076e852bb6be7bc57", "committedDate": "2020-05-22T19:39:14Z", "message": "Addressing review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDYxMTk0", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-418461194", "createdAt": "2020-05-26T16:15:49Z", "commit": {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxNTo0OVrOGal79g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxNTo0OVrOGal79g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzcxOA==", "bodyText": "Let us take this opportunity to document more details about runloop and its interaction with the implementations of this interface.\n\nExclusivity between process, window, scheduler, commit. & endOfStream with the exception of async commit.\nNot thread safe and needs synchronization of shared objects between instances, between commit & other methods in case of async commit enabled within an instance\nLifecycle of this class if applicable; which brings a question on does this need init() and close();", "url": "https://github.com/apache/samza/pull/1366#discussion_r430537718", "createdAt": "2020-05-26T16:15:49Z", "author": {"login": "mynameborat"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, "originalCommit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTI1MTE1", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-418525115", "createdAt": "2020-05-26T17:34:25Z", "commit": {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzozNDoyNVrOGao-8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo1MTowN1rOGaplaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4NzYzNQ==", "bodyText": "+1 regarding adding docs to each method. Ideally, there would have already been more docs in TaskInstance, but it is more useful now that this is an interface.", "url": "https://github.com/apache/samza/pull/1366#discussion_r430587635", "createdAt": "2020-05-26T17:34:25Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, "originalCommit": {"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5MzIyMA==", "bodyText": "In my opinion, default implementations should be used when most of the implementors do not need to implement the methods or when you want to evolve an interface in a backwards compatible way. It doesn't sound like that is the case here, so maybe just require all implementors to implement these methods. The disadvantage of default implementations is that someone could unintentionally forget to implement them when they were supposed to implement them. Requiring implementations makes things explicit, and sometimes that is helpful.", "url": "https://github.com/apache/samza/pull/1366#discussion_r430593220", "createdAt": "2020-05-26T17:43:52Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * The interface required for a task's execution to be managed within {@link RunLoop}.\n+ */\n+public interface RunLoopTask {\n+\n+  TaskName taskName();\n+\n+  Set<SystemStreamPartition> systemStreamPartitions();\n+\n+  TaskInstanceMetrics metrics();\n+\n+  void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator, TaskCallbackFactory callbackFactory);\n+\n+  void endOfStream(ReadableCoordinator coordinator);\n+\n+  void window(ReadableCoordinator coordinator);\n+\n+  void scheduler(ReadableCoordinator coordinator);\n+\n+  void commit();\n+\n+  default boolean isWindowableTask() {\n+    return false;\n+  }\n+\n+  default boolean isAsyncTask() {\n+    return false;\n+  }\n+\n+  default EpochTimeScheduler epochTimeScheduler() {\n+    return null;\n+  }\n+\n+  default Set<String> intermediateStreams() {\n+    return Collections.emptySet();\n+  }\n+\n+  default OffsetManager offsetManager() {\n+    return null;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NzQ4MA==", "bodyText": "Should RunLoopTask now be mocked in this test instead of using a concrete TaskInstance? It could help to validate your extraction of the interface and simplify the test to not depend on TaskInstance.", "url": "https://github.com/apache/samza/pull/1366#discussion_r430597480", "createdAt": "2020-05-26T17:51:07Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -236,7 +236,7 @@ public void testProcessMultipleTasks() throws Exception {\n     TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n     TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81683f1d64d81c7cf5fe7ff57a293e9d5204ade7", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/81683f1d64d81c7cf5fe7ff57a293e9d5204ade7", "committedDate": "2020-05-26T22:17:39Z", "message": "Add documentation to RunLoopTask, remove 'isAsyncTask' from RunLoopTask/TaskInstance/RunLoopFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09dd479a4dac6eb97c48eee523c0d2d4dadf12fd", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/09dd479a4dac6eb97c48eee523c0d2d4dadf12fd", "committedDate": "2020-05-26T23:15:57Z", "message": "Clarify thread safety of process"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ef784b0166d0abac080a5de1267c2ef7e00899c", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/3ef784b0166d0abac080a5de1267c2ef7e00899c", "committedDate": "2020-05-27T05:33:16Z", "message": "Adapt TaskInstance tests for removal of isAsyncTask"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/350f1bccd83e0f6e608df513f2090be2ae84a0f0", "committedDate": "2020-05-27T05:35:36Z", "message": "Removing use of TaskInstance from TestRunLoop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjQ0NDky", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-419644492", "createdAt": "2020-05-27T22:09:22Z", "commit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjowOToyMlrOGbe6DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNDoxOFrOGbfRRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTExNw==", "bodyText": "Was this validation moved somewhere else? Or is it no longer necessary?", "url": "https://github.com/apache/samza/pull/1366#discussion_r431471117", "createdAt": "2020-05-27T22:09:22Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopFactory.java", "diffHunk": "@@ -52,18 +50,6 @@ public static Runnable createRunLoop(scala.collection.immutable.Map<TaskName, Ta\n \n     log.info(\"Got commit milliseconds: {}.\", taskCommitMs);\n \n-    int asyncTaskCount = taskInstances.values().count(new AbstractFunction1<TaskInstance, Object>() {\n-      @Override\n-      public Boolean apply(TaskInstance t) {\n-        return t.isAsyncTask();\n-      }\n-    });\n-\n-    // asyncTaskCount should be either 0 or the number of all taskInstances\n-    if (asyncTaskCount > 0 && asyncTaskCount < taskInstances.size()) {\n-      throw new SamzaException(\"Mixing StreamTask and AsyncStreamTask is not supported\");\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NDEyNQ==", "bodyText": "Just double checking here too: Is this check no longer necessary?", "url": "https://github.com/apache/samza/pull/1366#discussion_r431474125", "createdAt": "2020-05-27T22:16:38Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/main/scala/org/apache/samza/container/TaskInstance.scala", "diffHunk": "@@ -181,22 +181,10 @@ class TaskInstance(\n       trace(\"Processing incoming message envelope for taskName and SSP: %s, %s\"\n         format (taskName, incomingMessageSsp))\n \n-      if (isAsyncTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTUyNg==", "bodyText": "Is this unused now? Could you please check the other tests to see if there are other unused variables too?", "url": "https://github.com/apache/samza/pull/1366#discussion_r431475526", "createdAt": "2020-05-27T22:20:25Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -231,14 +251,12 @@ public void testProcessMultipleTasks() throws Exception {\n     when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTg0OQ==", "bodyText": "Was this intended to be removed?", "url": "https://github.com/apache/samza/pull/1366#discussion_r431475849", "createdAt": "2020-05-27T22:21:15Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -390,23 +401,21 @@ public void testCommitSingleTask() throws Exception {\n     when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n+    TestTask task0 = spy(createTestTask(true, true, false, task0ProcessedMessagesLatch, 0, taskName0, ssp0, offsetManager));\n     task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    TestTask task1 = spy(createTestTask(true, false, true, task1ProcessedMessagesLatch, 0, taskName1, ssp1, offsetManager));\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n     when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n         .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n+//            task0ProcessedMessagesLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzA2MA==", "bodyText": "times(1) is the default for verify, so you don't need to pass as an argument.", "url": "https://github.com/apache/samza/pull/1366#discussion_r431477060", "createdAt": "2020-05-27T22:24:18Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -538,6 +533,9 @@ public void testEndOfStreamWithMultipleTasks() throws Exception {\n     task0ProcessedMessagesLatch.await();\n     task1ProcessedMessagesLatch.await();\n \n+    verify(task0, times(1)).endOfStream(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0"}, "originalPosition": 427}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d5e80637bf8444b41c1a519df6bde6fb13a747", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/71d5e80637bf8444b41c1a519df6bde6fb13a747", "committedDate": "2020-05-28T01:07:07Z", "message": "Cleaning up tests per review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "committedDate": "2020-05-28T17:53:38Z", "message": "An attempt at improving RunLoop tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDk3Mjg5", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-420497289", "createdAt": "2020-05-28T21:14:33Z", "commit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxNDozM1rOGcG-Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0NToyOFrOGcH2tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzU0Ng==", "bodyText": "Nit: Should this be envelope11?", "url": "https://github.com/apache/samza/pull/1366#discussion_r432127546", "createdAt": "2020-05-28T21:14:33Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODI1Nw==", "bodyText": "Should this be when(task1.taskName()).thenReturn(taskName1);? Although if the test passed, then does that mean the test doesn't need the result of taskName()?", "url": "https://github.com/apache/samza/pull/1366#discussion_r432128257", "createdAt": "2020-05-28T21:16:01Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNzI2NQ==", "bodyText": "Would it be good to use containerMetrics to verify that you saw all of the messages?", "url": "https://github.com/apache/samza/pull/1366#discussion_r432137265", "createdAt": "2020-05-28T21:34:38Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task1).process(eq(envelope10), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(2L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n+    assertEquals(4L, containerMetrics.envelopes().getCount());\n   }\n \n   @Test\n-  public void testProcessInOrder() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n+  public void testProcessInOrder() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics taskMetrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(taskMetrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n+    Map<TaskName, RunLoopTask> tasks = ImmutableMap.of(taskName0, task0);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    // Wait till the tasks completes processing all the messages.\n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n-    assertEquals(2L, t0.metrics().asyncCallbackCompleted().getCount());\n-    assertEquals(1L, t1.metrics().asyncCallbackCompleted().getCount());\n-  }\n-\n-  private TestCode buildOutofOrderCallback(final TestTask task) {\n-    final CountDownLatch latch = new CountDownLatch(1);\n-    return new TestCode() {\n-      @Override\n-      public void run(TaskCallback callback) {\n-        IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-        if (envelope.equals(envelope0)) {\n-          // process first message will wait till the second one is processed\n-          try {\n-            latch.await();\n-          } catch (InterruptedException e) {\n-            e.printStackTrace();\n-          }\n-        } else {\n-          // second envelope complete first\n-          assertEquals(0, task.completed.get());\n-          latch.countDown();\n-        }\n-      }\n-    };\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n   }\n \n   @Test\n-  public void testProcessOutOfOrder() throws Exception {\n+  public void testProcessCallbacksCompletedOutOfOrder() {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+\n+    InOrder inOrderOffsetManager = inOrder(offsetManager);\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope00.getOffset()));\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope01.getOffset()));\n \n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    assertEquals(3L, containerMetrics.envelopes().getCount());\n+    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testWindow() throws Exception {\n-    TestTask task0 = new TestTask(true, true, false, null);\n-    TestTask task1 = new TestTask(true, false, true, null);\n-\n+  public void testWindow() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    int maxMessagesInFlight = 1;\n+    long windowMs = 1;\n+    RunLoopTask task = mock(RunLoopTask.class);\n+    when(task.isWindowableTask()).thenReturn(true);\n+\n+    final AtomicInteger windowCount = new AtomicInteger(0);\n+    doAnswer(x -> {\n+        windowCount.incrementAndGet();\n+        if (windowCount.get() == 4) {\n+          x.getArgumentAt(0, ReadableCoordinator.class).shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        }\n+        Thread.sleep(windowMs);\n+        return null;\n+      }).when(task).window(any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task);\n \n-    long windowMs = 1;\n-    int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false)).thenReturn(null);\n     runLoop.run();\n \n-    assertEquals(4, task1.windowCount);\n+    verify(task, times(4)).window(any());\n   }\n \n   @Test\n-  public void testCommitSingleTask() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitSingleTask() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager, never()).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager, never()).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1, never()).commit();\n   }\n \n   @Test\n-  public void testCommitAllTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitAllTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+        coordinator.commit(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n+\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1).commit();\n   }\n \n   @Test\n-  public void testShutdownOnConsensus() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testShutdownOnConsensus() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, true, task0ProcessedMessagesLatch);\n-    task0.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    task1.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n \n     int maxMessagesInFlight = 1;\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task1).process(eq(envelope10), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     // consensus is reached after envelope1 is processed.\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(2L, containerMetrics.envelopes().getCount());\n     assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamWithMultipleTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false))\n-      .thenReturn(envelope0)\n-      .thenReturn(envelope1)\n+      .thenReturn(envelope00)\n+      .thenReturn(envelope10)\n       .thenReturn(ssp0EndOfStream)\n       .thenReturn(ssp1EndOfStream)\n       .thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task0).endOfStream(any());\n+\n+    verify(task1).process(eq(envelope10), any(), any());\n+    verify(task1).endOfStream(any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(4L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithOutOfOrderProcess() throws Exception {\n+  public void testEndOfStreamWaitsForInFlightMessages() throws Exception {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(2);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    doAnswer(invocation -> {\n+        assertEquals(0, task0.metrics().messagesInFlight().getValue());\n+        return null;\n+      }).when(task0).endOfStream(any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream)\n+        .thenAnswer(invocation -> {\n+            // this ensures that the end of stream message has passed through run loop BEFORE the last remaining in flight message completes\n+            firstMessageBarrier.countDown();\n+            return null;\n+          });\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af"}, "originalPosition": 776}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjAwNw==", "bodyText": "Do you know if InOrder keeps track of when a method initially is called or when a method finishes execution? If it keeps track of the initial call, then this seems ok. However, if it tracks when the method finishes, then this test could end up being flaky, since it looks possible for commit to finish before the second process is done.\nMaybe InOrder isn't really necessary for this test, since the latches take care of the ordering.", "url": "https://github.com/apache/samza/pull/1366#discussion_r432142007", "createdAt": "2020-05-28T21:45:28Z", "author": {"login": "cameronlee314"}, "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task1).process(eq(envelope10), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(2L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n+    assertEquals(4L, containerMetrics.envelopes().getCount());\n   }\n \n   @Test\n-  public void testProcessInOrder() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n+  public void testProcessInOrder() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics taskMetrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(taskMetrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n+    Map<TaskName, RunLoopTask> tasks = ImmutableMap.of(taskName0, task0);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    // Wait till the tasks completes processing all the messages.\n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n-    assertEquals(2L, t0.metrics().asyncCallbackCompleted().getCount());\n-    assertEquals(1L, t1.metrics().asyncCallbackCompleted().getCount());\n-  }\n-\n-  private TestCode buildOutofOrderCallback(final TestTask task) {\n-    final CountDownLatch latch = new CountDownLatch(1);\n-    return new TestCode() {\n-      @Override\n-      public void run(TaskCallback callback) {\n-        IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-        if (envelope.equals(envelope0)) {\n-          // process first message will wait till the second one is processed\n-          try {\n-            latch.await();\n-          } catch (InterruptedException e) {\n-            e.printStackTrace();\n-          }\n-        } else {\n-          // second envelope complete first\n-          assertEquals(0, task.completed.get());\n-          latch.countDown();\n-        }\n-      }\n-    };\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n   }\n \n   @Test\n-  public void testProcessOutOfOrder() throws Exception {\n+  public void testProcessCallbacksCompletedOutOfOrder() {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+\n+    InOrder inOrderOffsetManager = inOrder(offsetManager);\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope00.getOffset()));\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope01.getOffset()));\n \n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    assertEquals(3L, containerMetrics.envelopes().getCount());\n+    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testWindow() throws Exception {\n-    TestTask task0 = new TestTask(true, true, false, null);\n-    TestTask task1 = new TestTask(true, false, true, null);\n-\n+  public void testWindow() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    int maxMessagesInFlight = 1;\n+    long windowMs = 1;\n+    RunLoopTask task = mock(RunLoopTask.class);\n+    when(task.isWindowableTask()).thenReturn(true);\n+\n+    final AtomicInteger windowCount = new AtomicInteger(0);\n+    doAnswer(x -> {\n+        windowCount.incrementAndGet();\n+        if (windowCount.get() == 4) {\n+          x.getArgumentAt(0, ReadableCoordinator.class).shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        }\n+        Thread.sleep(windowMs);\n+        return null;\n+      }).when(task).window(any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task);\n \n-    long windowMs = 1;\n-    int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false)).thenReturn(null);\n     runLoop.run();\n \n-    assertEquals(4, task1.windowCount);\n+    verify(task, times(4)).window(any());\n   }\n \n   @Test\n-  public void testCommitSingleTask() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitSingleTask() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager, never()).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager, never()).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1, never()).commit();\n   }\n \n   @Test\n-  public void testCommitAllTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitAllTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+        coordinator.commit(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n+\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1).commit();\n   }\n \n   @Test\n-  public void testShutdownOnConsensus() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testShutdownOnConsensus() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, true, task0ProcessedMessagesLatch);\n-    task0.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    task1.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n \n     int maxMessagesInFlight = 1;\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task1).process(eq(envelope10), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     // consensus is reached after envelope1 is processed.\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(2L, containerMetrics.envelopes().getCount());\n     assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamWithMultipleTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false))\n-      .thenReturn(envelope0)\n-      .thenReturn(envelope1)\n+      .thenReturn(envelope00)\n+      .thenReturn(envelope10)\n       .thenReturn(ssp0EndOfStream)\n       .thenReturn(ssp1EndOfStream)\n       .thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task0).endOfStream(any());\n+\n+    verify(task1).process(eq(envelope10), any(), any());\n+    verify(task1).endOfStream(any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(4L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithOutOfOrderProcess() throws Exception {\n+  public void testEndOfStreamWaitsForInFlightMessages() throws Exception {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(2);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    doAnswer(invocation -> {\n+        assertEquals(0, task0.metrics().messagesInFlight().getValue());\n+        return null;\n+      }).when(task0).endOfStream(any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream)\n+        .thenAnswer(invocation -> {\n+            // this ensures that the end of stream message has passed through run loop BEFORE the last remaining in flight message completes\n+            firstMessageBarrier.countDown();\n+            return null;\n+          });\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    verify(task0).endOfStream(any());\n   }\n \n   @Test\n-  public void testEndOfStreamCommitBehavior() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamCommitBehavior() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    //explicitly configure to disable commits inside process or window calls and invoke commit from end of stream\n-    TestTask task0 = new TestTask(true, false, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(0, ReadableCoordinator.class);\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        return null;\n+      }).when(task0).endOfStream(any());\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    inOrder.verify(task0).endOfStream(any());\n+    inOrder.verify(task0).commit();\n   }\n \n   @Test\n-  public void testEndOfStreamOffsetManagement() throws Exception {\n-    //explicitly configure to disable commits inside process or window calls and invoke commit from end of stream\n-    TestTask mockStreamTask1 = new TestTask(true, false, false, null);\n-    TestTask mockStreamTask2 = new TestTask(true, false, false, null);\n-\n-    Partition p1 = new Partition(1);\n-    Partition p2 = new Partition(2);\n-    SystemStreamPartition ssp1 = new SystemStreamPartition(\"system1\", \"stream1\", p1);\n-    SystemStreamPartition ssp2 = new SystemStreamPartition(\"system1\", \"stream2\", p2);\n-    IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp2, \"1\", \"key1\", \"message1\");\n-    IncomingMessageEnvelope envelope2 = new IncomingMessageEnvelope(ssp2, \"2\", \"key1\", \"message1\");\n-    IncomingMessageEnvelope envelope3 = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp2);\n-\n-    Map<SystemStreamPartition, List<IncomingMessageEnvelope>> sspMap = new HashMap<>();\n-    List<IncomingMessageEnvelope> messageList = new ArrayList<>();\n-    messageList.add(envelope1);\n-    messageList.add(envelope2);\n-    messageList.add(envelope3);\n-    sspMap.put(ssp2, messageList);\n-\n-    SystemConsumer mockConsumer = mock(SystemConsumer.class);\n-    when(mockConsumer.poll(anyObject(), anyLong())).thenReturn(sspMap);\n-\n-    SystemAdmins systemAdmins = Mockito.mock(SystemAdmins.class);\n-    Mockito.when(systemAdmins.getSystemAdmin(\"system1\")).thenReturn(Mockito.mock(SystemAdmin.class));\n-    Mockito.when(systemAdmins.getSystemAdmin(\"testSystem\")).thenReturn(Mockito.mock(SystemAdmin.class));\n-\n-    HashMap<String, SystemConsumer> systemConsumerMap = new HashMap<>();\n-    systemConsumerMap.put(\"system1\", mockConsumer);\n-\n-    SystemConsumers consumers = TestSystemConsumers.getSystemConsumers(systemConsumerMap, systemAdmins);\n-\n-    TaskName taskName1 = new TaskName(\"task1\");\n-    TaskName taskName2 = new TaskName(\"task2\");\n-\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    when(offsetManager.getLastProcessedOffset(taskName1, ssp1)).thenReturn(Option.apply(\"3\"));\n-    when(offsetManager.getLastProcessedOffset(taskName2, ssp2)).thenReturn(Option.apply(\"0\"));\n-    when(offsetManager.getStartingOffset(taskName1, ssp1)).thenReturn(Option.apply(IncomingMessageEnvelope.END_OF_STREAM_OFFSET));\n-    when(offsetManager.getStartingOffset(taskName2, ssp2)).thenReturn(Option.apply(\"1\"));\n-    when(offsetManager.getStartpoint(anyObject(), anyObject())).thenReturn(Option.empty());\n-\n-    TaskInstance taskInstance1 = createTaskInstance(mockStreamTask1, taskName1, ssp1, offsetManager, consumers);\n-    TaskInstance taskInstance2 = createTaskInstance(mockStreamTask2, taskName2, ssp2, offsetManager, consumers);\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName1, taskInstance1);\n-    tasks.put(taskName2, taskInstance2);\n-\n-    taskInstance1.registerConsumers();\n-    taskInstance2.registerConsumers();\n-    consumers.start();\n-\n-    int maxMessagesInFlight = 1;\n-    RunLoop runLoop = new RunLoop(tasks, executor, consumers, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-\n-    runLoop.run();\n-  }\n-\n-  //@Test\n-  public void testCommitBehaviourWhenAsyncCommitIsEnabled() throws InterruptedException {\n+  public void testCommitWithMessageInFlightWhenAsyncCommitIsEnabled() {\n+    int maxMessagesInFlight = 2;\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(2);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    int maxMessagesInFlight = 3;\n-    TestTask task0 = new TestTask(true, true, false, null, maxMessagesInFlight);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, false, null, maxMessagesInFlight);\n-\n-    IncomingMessageEnvelope firstMsg = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-    IncomingMessageEnvelope secondMsg = new IncomingMessageEnvelope(ssp0, \"1\", \"key1\", \"value1\");\n-    IncomingMessageEnvelope thirdMsg = new IncomingMessageEnvelope(ssp0, \"2\", \"key0\", \"value0\");\n-\n-    final CountDownLatch firstMsgCompletionLatch = new CountDownLatch(1);\n-    final CountDownLatch secondMsgCompletionLatch = new CountDownLatch(1);\n-    task0.callbackHandler = callback -> {\n-      IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-      try {\n-        if (envelope.equals(firstMsg)) {\n-          firstMsgCompletionLatch.await();\n-        } else if (envelope.equals(secondMsg)) {\n-          firstMsgCompletionLatch.countDown();\n-          secondMsgCompletionLatch.await();\n-        } else if (envelope.equals(thirdMsg)) {\n-          secondMsgCompletionLatch.countDown();\n-          // OffsetManager.update with firstMsg offset, task.commit has happened when second message callback has not completed.\n-          verify(offsetManager).update(eq(taskName0), eq(firstMsg.getSystemStreamPartition()), eq(firstMsg.getOffset()));\n-        }\n-      } catch (Exception e) {\n-        e.printStackTrace();\n-      }\n-    };\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n-    when(consumerMultiplexer.choose(false)).thenReturn(firstMsg).thenReturn(secondMsg).thenReturn(thirdMsg).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n-\n-    RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-\n-    runLoop.run();\n-\n-    firstMsgCompletionLatch.await();\n-    secondMsgCompletionLatch.await();\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    CountDownLatch secondMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        taskExecutor.submit(() -> {\n+            // let the first message proceed to ask for a commit\n+            firstMessageBarrier.countDown();\n+            // block this message until commit is executed\n+            secondMessageBarrier.await();\n+            coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    verify(offsetManager, atLeastOnce()).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager, atLeastOnce()).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    assertEquals(3, task0.processed);\n-    assertEquals(3, task0.committed);\n-    assertEquals(1, task1.processed);\n-    assertEquals(0, task1.committed);\n-  }\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().asyncCallbackCompleted().getCount());\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-  @Test\n-  public void testProcessBehaviourWhenAsyncCommitIsEnabled() throws InterruptedException {\n-    int maxMessagesInFlight = 2;\n+        secondMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).commit();\n \n-    SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    TestTask task0 = new TestTask(true, true, false, null, maxMessagesInFlight);\n-    CountDownLatch commitLatch = new CountDownLatch(1);\n-    task0.commitHandler = callback -> {\n-      TaskCallbackImpl taskCallback = (TaskCallbackImpl) callback;\n-      if (taskCallback.getEnvelope().equals(envelope3)) {\n-        try {\n-          commitLatch.await();\n-        } catch (InterruptedException e) {\n-          e.printStackTrace();\n-        }\n-      }\n-    };\n-\n-    task0.callbackHandler = callback -> {\n-      TaskCallbackImpl taskCallback = (TaskCallbackImpl) callback;\n-      if (taskCallback.getEnvelope().equals(envelope0)) {\n-        // Both the process call has gone through when the first commit is in progress.\n-        assertEquals(2, containerMetrics.processes().getCount());\n-        assertEquals(0, containerMetrics.commits().getCount());\n-        commitLatch.countDown();\n-      }\n-    };\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope3).thenReturn(envelope0).thenReturn(ssp0EndOfStream).thenReturn(null);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n-                                            () -> 0L, true);\n-\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, true);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(null);\n     runLoop.run();\n \n-    commitLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+    inOrder.verify(task0).commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af"}, "originalPosition": 1040}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6038e0dece3582a98ab06b1f782881014a5408a", "author": {"user": null}, "url": "https://github.com/apache/samza/commit/e6038e0dece3582a98ab06b1f782881014a5408a", "committedDate": "2020-05-29T00:18:06Z", "message": "Add assertion on completed callbacks into testEndofStreamWaitsForInFlightMessages\n\nFix flakiness of testProcessCallbacksCompletedOutOfOrder\n\nIn testWindow, use a task that has non-empty set of ssps so endOfStream isn't triggered to shut down the task"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjE4ODY1", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-420618865", "createdAt": "2020-05-29T02:48:45Z", "commit": {"oid": "e6038e0dece3582a98ab06b1f782881014a5408a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTE4OTA3", "url": "https://github.com/apache/samza/pull/1366#pullrequestreview-421118907", "createdAt": "2020-05-29T16:46:55Z", "commit": {"oid": "e6038e0dece3582a98ab06b1f782881014a5408a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4605, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}