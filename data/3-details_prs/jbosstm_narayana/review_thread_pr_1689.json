{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNDE2NTM0", "number": 1689, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNDoyM1rOEsioEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNDoyM1rOEsioEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTQwMTE0OnYy", "diffSide": "RIGHT", "path": "ArjunaJTA/jta/classes/com/arjuna/ats/internal/jta/recovery/arjunacore/XARecoveryModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNDoyM1rOHf1qjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTowNDoyM1rOHf1qjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0NzE1MQ==", "bodyText": "Let's hope there are no legacy XTS customers that fall into this category.", "url": "https://github.com/jbosstm/narayana/pull/1689#discussion_r503147151", "createdAt": "2020-10-12T09:04:23Z", "author": {"login": "mmusgrov"}, "path": "ArjunaJTA/jta/classes/com/arjuna/ats/internal/jta/recovery/arjunacore/XARecoveryModule.java", "diffHunk": "@@ -352,14 +352,63 @@ private XAResource getNewXAResource(Xid xid, String jndiName)\n \t\t\t\t * after the call to periodicWorkFirstPass but before the call to getTheKey\n \t\t\t\t */\n \t\t\t\tperiodicWorkFirstPass(ScanStates.IDLE);\n-\t\t\t\ttoReturn = getTheKey(key);\n+\t\t\t\ttoReturn = getTheKey(key, false);\n+\t\t\t\tif(toReturn == null) {\n+\t\t\t\t\t// last resort, accept a weaker match if there is one\n+\t\t\t\t\ttoReturn = getTheKey(key, true);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn toReturn;\n     }\n \n-    private XAResource getTheKey(NameScopedXid scopedXid) {\n+\t/*\n+\t An Xid value we're looking for, described from the objectstore log record by scopedXid,\n+\t   also appears in the recovery xa scan of theKey.\n+\t However, that does not necessarily mean that theKey's XAResource can be used for recovering it\n+\t   as non-unique (inflowed) xids may appear under multiple, potentially non-interchangeable, keys.\n+\t */\n+\tprivate boolean isReasonableMatch(NameScopedXid scopedXid, NameScopedXAResource theKey, boolean relaxedMatch) {\n+\t\tjtaLogger.logger.trace(\"isReasonableMatch \"+scopedXid+\" \"+theKey+\" \"+relaxedMatch);\n+\n+\t\t// JTA Xids are always unique (see TransactionImple::createXid)\n+\t\t// so can appear in only one place. Just ignore any metadata.\n+\t\tif(scopedXid.getXid().getFormatId() == XATxConverter.FORMAT_ID) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by FORMAT_ID\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// all other xids may be non-uniq branches and appear under more than one theKey\n+\t\t// so we need some additional rules to try and get the right one...\n+\n+\t\t// where the jndi name in the log matches the resources name, it's a good bet.\n+\t\t// this covers the ironjacamar integration case for databases in wildfly/EAP\n+\t\tif(!scopedXid.isAnonymous() && scopedXid.isSameName(theKey)) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by exact name\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// some integrations, notable HornetQ, provide name metadata in the enlistment side\n+\t\t// (so it winds up in the logs and hence in scopedXid)\n+\t\t// but not on the recovery side (so theKey is unnamed).\n+\t\t// If we've failed to make a stronger match, then that will have to do,\n+\t\t// even though it's potentially wrong.\n+\t\tif(relaxedMatch && !(!scopedXid.isAnonymous() && !theKey.isAnonymous())) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by relaxed name\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// at this point there is one remaining valid case... the names on both side are set and don't match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daddd12330a25edfcbb7309e34a9ad2934c4d06d"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1225, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}