{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MDY2NTcw", "number": 1603, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0Mjo0OVrODzly_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo1ODowOVrOD1PwOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDIzMjMxOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0Mjo0OVrOGIHX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozMzo0M1rOGKidmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA==", "bodyText": "I think it would be good to log the full exception stacktrace when asked by more verbose logging.\nIt's handy in ivestigation on what's happening in the system.\nI think when TRACE level is enabled the exception with stacktrace and probably some information what was the reason should be logged in to the coordinator log.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411162590", "createdAt": "2020-04-20T07:42:49Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNjA2Mw==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411206063", "createdAt": "2020-04-20T08:51:44Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNDA1Mw==", "bodyText": "Although this stack trace will only be showing Resteasy internals since the exception is saying that the user passed an invalid URI and therefore the stacktrace will not provide any useful information (just noise).", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411524053", "createdAt": "2020-04-20T16:35:55Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0NTM0MQ==", "bodyText": "I think information that the uri syntax was wrong with details why it was wrong could be still usable for a detailed analysis.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412145341", "createdAt": "2020-04-21T12:35:45Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI0OTM1Mw==", "bodyText": "Oh yes definitely. All I am saying is that the stacktrace will not provide any additional information. I am adding trace level stack traces for the other places you ask for though.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412249353", "createdAt": "2020-04-21T14:45:21Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzU3Nw==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703577", "createdAt": "2020-04-23T10:33:43Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDI1MjQ4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0Nzo1OFrOGIHjWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjozNDozMFrOGJDS7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NTUzMQ==", "bodyText": "If I'm not mistaken by looking into the code the failedList (and neither the preparedList) are guarded by some lock or other synchronization guard (while the RecordList is not meant to be thread safe). As I'm not fully in-depth into the logic my point is if this code is safe when executed from different threads (if it may happen)?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411165531", "createdAt": "2020-04-20T07:47:58Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -228,11 +228,35 @@ private boolean restore_list(InputObjectState os, int ot, RecordList list) {\n     public boolean restore_state(InputObjectState os, int ot) {\n \n         if (!super.restore_state(os, ot)\n-                || !restore_list(os, ot, pendingList)\n-                || !restore_list(os, ot, preparedList)) {\n+                || !restore_list(os, ot, pendingList)) { // other lists are maintained in BasicAction\n             return false;\n         }\n \n+        // restore_state may have put failed records onto the prepared list so move them back again:\n+        for (AbstractRecord rec = preparedList.peekFront(); rec != null; rec = preparedList.peekNext(rec)) {\n+            if (rec instanceof LRARecord) {\n+                LRARecord p = (LRARecord) rec;\n+\n+                if (p.isFailed()) {\n+                    boolean moveRec = true;\n+                    AbstractRecord r;\n+\n+                    preparedList.remove(p);\n+\n+                    // put it back on the failedList if it isn't already on it\n+                    for (r = failedList.peekFront(); r != null; r = failedList.peekNext(r)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNTYzMw==", "bodyText": "These lists are managed by ArjunaCore and BasicAction - things like save and restore state and commit etc are controlled from BasicAction which have there own synchronisation control.\nI can create a JIRA that calls for stress testing of the implementation to try to tease out any dormant issues in this area?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411215633", "createdAt": "2020-04-20T09:06:12Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -228,11 +228,35 @@ private boolean restore_list(InputObjectState os, int ot, RecordList list) {\n     public boolean restore_state(InputObjectState os, int ot) {\n \n         if (!super.restore_state(os, ot)\n-                || !restore_list(os, ot, pendingList)\n-                || !restore_list(os, ot, preparedList)) {\n+                || !restore_list(os, ot, pendingList)) { // other lists are maintained in BasicAction\n             return false;\n         }\n \n+        // restore_state may have put failed records onto the prepared list so move them back again:\n+        for (AbstractRecord rec = preparedList.peekFront(); rec != null; rec = preparedList.peekNext(rec)) {\n+            if (rec instanceof LRARecord) {\n+                LRARecord p = (LRARecord) rec;\n+\n+                if (p.isFailed()) {\n+                    boolean moveRec = true;\n+                    AbstractRecord r;\n+\n+                    preparedList.remove(p);\n+\n+                    // put it back on the failedList if it isn't already on it\n+                    for (r = failedList.peekFront(); r != null; r = failedList.peekNext(r)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NTUzMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0NDM2Ng==", "bodyText": "I think the stress testing is good but not necessary for the initial insight. If there is the code which can be accessed from different threads and is not synchronized we should be thinking about the circumstances.\nAs I'm looking into this once again with the understanding the code is invoked from the BasicAction I can see that the lists are used in the Transaction processing which is the instance of the thread local. That way the processing should be bound to the one thread and the concurrent access of the lists would not be possible.\nI\"m resolving this doubt here now.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412144366", "createdAt": "2020-04-21T12:34:30Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -228,11 +228,35 @@ private boolean restore_list(InputObjectState os, int ot, RecordList list) {\n     public boolean restore_state(InputObjectState os, int ot) {\n \n         if (!super.restore_state(os, ot)\n-                || !restore_list(os, ot, pendingList)\n-                || !restore_list(os, ot, preparedList)) {\n+                || !restore_list(os, ot, pendingList)) { // other lists are maintained in BasicAction\n             return false;\n         }\n \n+        // restore_state may have put failed records onto the prepared list so move them back again:\n+        for (AbstractRecord rec = preparedList.peekFront(); rec != null; rec = preparedList.peekNext(rec)) {\n+            if (rec instanceof LRARecord) {\n+                LRARecord p = (LRARecord) rec;\n+\n+                if (p.isFailed()) {\n+                    boolean moveRec = true;\n+                    AbstractRecord r;\n+\n+                    preparedList.remove(p);\n+\n+                    // put it back on the failedList if it isn't already on it\n+                    for (r = failedList.peekFront(); r != null; r = failedList.peekNext(r)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NTUzMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDI1Nzg4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0OToxNVrOGIHmWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozMzo1MlrOGKieBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjI5Ng==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166296", "createdAt": "2020-04-20T07:49:15Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNTg2MQ==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411215861", "createdAt": "2020-04-20T09:06:31Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjI5Ng=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzY4NQ==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703685", "createdAt": "2020-04-23T10:33:52Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjI5Ng=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDI1ODI2OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0OToyNVrOGIHmpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozMzo1OFrOGKieOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjM3Mg==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166372", "createdAt": "2020-04-20T07:49:25Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjA1OA==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216058", "createdAt": "2020-04-20T09:06:46Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjM3Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzczOQ==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703739", "createdAt": "2020-04-23T10:33:58Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjM3Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDI1OTc4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0OTo0NVrOGIHndg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNDowNlrOGKieog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjU4Mg==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166582", "createdAt": "2020-04-20T07:49:45Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"LRARecoverModule: Object store exception: %s\", e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate();\n+                            lras.put(lra.getId(), lra);\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjEyMg==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216122", "createdAt": "2020-04-20T09:06:54Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"LRARecoverModule: Object store exception: %s\", e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate();\n+                            lras.put(lra.getId(), lra);\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjU4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzg0Mg==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703842", "createdAt": "2020-04-23T10:34:06Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"LRARecoverModule: Object store exception: %s\", e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate();\n+                            lras.put(lra.getId(), lra);\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjU4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDU5Mzg3OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNjo1OFrOGIKpJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODoyMTo0NFrOGJSMIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjE2NQ==", "bodyText": "Wouldn't a 404 here be more suitable?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216165", "createdAt": "2020-04-20T09:06:58Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzMTA2Mg==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411331062", "createdAt": "2020-04-20T12:19:16Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjE2NQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4ODM4Ng==", "bodyText": "I made the change but reordered the APIResponse annotations (with 204 first)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412388386", "createdAt": "2020-04-21T18:21:44Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjE2NQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDU5NzkwOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowODowMlrOGIKrqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNDoyMFrOGKifJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjgwOQ==", "bodyText": "it seems that nothing is returned in the body on successful removal.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216809", "createdAt": "2020-04-20T09:08:02Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzMTc5NA==", "bodyText": "Oops. I will return 204 No Content and update the API doc.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411331794", "createdAt": "2020-04-20T12:20:36Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjgwOQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzk3NA==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703974", "createdAt": "2020-04-23T10:34:20Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjgwOQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDYwMzE5OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowOToyMVrOGIKu2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNDozOFrOGKif4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNzYyNQ==", "bodyText": "It's common to return the removed value on successful removal in usual CRUD models. Maybe we could return the removed LRA.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411217625", "createdAt": "2020-04-20T09:09:21Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNDYxNw==", "bodyText": "Returning a resource, or more correctly a link to it, that no longer exists seems wrong in a REST context. How about just returning 204 No Content with an empty body.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411334617", "createdAt": "2020-04-20T12:25:08Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNzYyNQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNzAzOA==", "bodyText": "This is just from my experience, DB providers etc also do this. But ok 204 can do also.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411427038", "createdAt": "2020-04-20T14:32:08Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNzYyNQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDE2MA==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413704160", "createdAt": "2020-04-23T10:34:38Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNzYyNQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDYyNTYyOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxNDoyMFrOGIK7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMzoxNVrOGIXkVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDkyMQ==", "bodyText": "Why is this call necessary? Aren't the hard-coded booleans correct always? They are a form of self-validation in Narayana codebase so we don't unintentionally call the wrong phase. Also, this will add one additional method invocation to every call which is not much but why to waste performance? I just want to know why did you include these calls.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411220921", "createdAt": "2020-04-20T09:14:20Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -245,7 +245,7 @@ public int topLevelOnePhaseCommit() {\n \n     @Override\n     public int topLevelCommit() {\n-        return doEnd(false);\n+        return doEnd(lra.isCancel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MTU3NA==", "bodyText": "We always commit the transaction (at the level of BasicAction) which then calls commit on each record enlisted with the BasicAction. The private method called LRARecord#doEnd needs to know whether the LRA is cancelling or closing, hence the query to ask the LRA whether it is cancelling or not.\nPreviously we called Abort on the BasicAction if the LRA was cancelled. But the abort route will not necessarily write a persistent record in all cases if there are only failure records.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411341574", "createdAt": "2020-04-20T12:36:31Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -245,7 +245,7 @@ public int topLevelOnePhaseCommit() {\n \n     @Override\n     public int topLevelCommit() {\n-        return doEnd(false);\n+        return doEnd(lra.isCancel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDkyMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNzkyNQ==", "bodyText": "got it, thanks. This can be resolved.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411427925", "createdAt": "2020-04-20T14:33:15Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -245,7 +245,7 @@ public int topLevelOnePhaseCommit() {\n \n     @Override\n     public int topLevelCommit() {\n-        return doEnd(false);\n+        return doEnd(lra.isCancel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDkyMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY0NTY0OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxODo1N1rOGILHsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNzoyNlrOGIXw3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzk4Nw==", "bodyText": "just an idea outside the PR itself. Would it make sense to include some information in the LRARecord about why the participant entered Compensating/Completing state? i.e. because it returned 202 (accepted) or the coordinator couldn't get any expected response? Would this make sense for users in some failure scenarios?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411223987", "createdAt": "2020-04-20T09:18:57Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -367,20 +367,9 @@ private int tryDoEnd(boolean compensate) {\n                         endPath, httpStatus);\n             }\n \n-            if (compensate) {\n-                status = ParticipantStatus.Compensating; // recovery will figure out the status via the status url\n-\n-                /*\n-                 * We are mapping compensate onto Abort. TwoPhaseCoordinator uses presumed abort\n-                 * so if we were to return FINISH_ERROR recovery would not replay the log.\n-                 * To force the record to be eligible for recovery we return a heuristic hazard.\n-                 */\n-                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n-            }\n-\n-            status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n-\n-            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n+            // recovery will figure out the status via the status url\n+            status = compensate ? ParticipantStatus.Compensating : ParticipantStatus.Completing;\n+            accepted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0Njc2OQ==", "bodyText": "That would be useful. Since we'd need to expose that information in the JSON responses can we have a new JIRA for that?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411346769", "createdAt": "2020-04-20T12:44:33Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -367,20 +367,9 @@ private int tryDoEnd(boolean compensate) {\n                         endPath, httpStatus);\n             }\n \n-            if (compensate) {\n-                status = ParticipantStatus.Compensating; // recovery will figure out the status via the status url\n-\n-                /*\n-                 * We are mapping compensate onto Abort. TwoPhaseCoordinator uses presumed abort\n-                 * so if we were to return FINISH_ERROR recovery would not replay the log.\n-                 * To force the record to be eligible for recovery we return a heuristic hazard.\n-                 */\n-                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n-            }\n-\n-            status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n-\n-            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n+            // recovery will figure out the status via the status url\n+            status = compensate ? ParticipantStatus.Compensating : ParticipantStatus.Completing;\n+            accepted = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzk4Nw=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTEzMg==", "bodyText": "https://issues.redhat.com/browse/JBTM-3299", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411431132", "createdAt": "2020-04-20T14:37:26Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -367,20 +367,9 @@ private int tryDoEnd(boolean compensate) {\n                         endPath, httpStatus);\n             }\n \n-            if (compensate) {\n-                status = ParticipantStatus.Compensating; // recovery will figure out the status via the status url\n-\n-                /*\n-                 * We are mapping compensate onto Abort. TwoPhaseCoordinator uses presumed abort\n-                 * so if we were to return FINISH_ERROR recovery would not replay the log.\n-                 * To force the record to be eligible for recovery we return a heuristic hazard.\n-                 */\n-                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n-            }\n-\n-            status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n-\n-            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n+            // recovery will figure out the status via the status url\n+            status = compensate ? ParticipantStatus.Compensating : ParticipantStatus.Completing;\n+            accepted = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzk4Nw=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY2MTc0OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyMjoyNlrOGILRFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNzo1OFrOGIXyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNjM5MQ==", "bodyText": "I don't understand why this is needed? It's not wrong but why not to call forget since this is already the last operation that needs to be called for this participant?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411226391", "createdAt": "2020-04-20T09:22:26Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0ODMwNQ==", "bodyText": "The code has just tried the forget call which has failed (if (!forget())) on the previous line so we need to make sure the forget call is retried later so we return a HEURISTIC_HAZARD)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411348305", "createdAt": "2020-04-20T12:46:58Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNjM5MQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTUxMQ==", "bodyText": "ah, my miss. Thanks. You can resolve this.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411431511", "createdAt": "2020-04-20T14:37:58Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNjM5MQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTEyNDE4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToxODowNFrOGIPiGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzowNjo0MVrOGJ1Yeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg==", "bodyText": "I would expect to also see the operation getFailedLRAs and removeFailed(URI) in NarayanaLRAClient. WDYT?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411296282", "createdAt": "2020-04-20T11:18:04Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2MDM5OQ==", "bodyText": "Currently we only use NarayanaLRAClient internally for the participant JAX-RS filter and some of our tests.\nThe API to the coordinator is the OpenAPI doc.\nSo there would be no consumers of the two methods that you are proposing. But I do agree that these two methods would be useful in a client API at the spec level.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411360399", "createdAt": "2020-04-20T13:05:17Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjM2Ng==", "bodyText": "I would expect narayana users to use the client directly. If they won't be spec only of course. Should we take this in another JIRA or will you update this PR?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411432366", "createdAt": "2020-04-20T14:39:04Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0ODMwOA==", "bodyText": "We don't require a new JIRA. Clients will use the REST api.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412348308", "createdAt": "2020-04-21T17:25:37Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1NDU0OA==", "bodyText": "Okay I will add it", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412354548", "createdAt": "2020-04-21T17:34:13Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NDc3NQ==", "bodyText": "We don't have any methods in NarayanaLRAClient that return collections of LRAs so let's take that to another JIRA if you don't mind.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412384775", "createdAt": "2020-04-21T18:16:27Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTcyMg==", "bodyText": "ah sure because we didn't change it since the spec version. However, I think this is a good idea to add all operations exposed by coordinator to the programmatic API also. Later when we again introduce client API in the spec we will just have more methods in narayana client so users can chose to inject spec version or narayana one. Please create a new JBTM, we should add also other methods that the coordinator exposes as JAX-RS endpoints. This can be resolved.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412391722", "createdAt": "2020-04-21T18:26:45Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk2NDk4Ng==", "bodyText": "https://issues.redhat.com/browse/JBTM-3303", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r412964986", "createdAt": "2020-04-22T13:06:41Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTEzNTgyOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyMTowMlrOGIPoxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNDo0N1rOGKigPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5Nzk4OQ==", "bodyText": "it produces Enums name, so it should be probably text/plain.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411297989", "createdAt": "2020-04-20T11:21:02Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2MDY4Mw==", "bodyText": "Okay", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411360683", "createdAt": "2020-04-20T13:05:44Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5Nzk4OQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDI1NA==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413704254", "createdAt": "2020-04-23T10:34:47Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5Nzk4OQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTEzNzI4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyMToyNFrOGIPplA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNDo1M1rOGKigeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5ODE5Ng==", "bodyText": "also here I would suggest text/plain", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411298196", "createdAt": "2020-04-20T11:21:24Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2MzM5OA==", "bodyText": "Okay", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411363398", "createdAt": "2020-04-20T13:09:50Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5ODE5Ng=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDMxMg==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413704312", "createdAt": "2020-04-23T10:34:53Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5ODE5Ng=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTE0NDM1OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyMzoxN1rOGIPtkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozOTozMVrOGIX3Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTIxNw==", "bodyText": "Don't Narayana retry on 500 status code? In the spec we use 200 and only the response body (here correct FailedToComplete) to distinguish failed states.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411299217", "createdAt": "2020-04-20T11:23:17Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MzE0MQ==", "bodyText": "That is only if the method returns an invalid enum value. The actual meaning of the relevant codes is:\n200 means the resource has completed (https://github.com/eclipse/microprofile-lra/blob/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Complete.java#L116)\n500 means the resource has failed to complete (https://github.com/eclipse/microprofile-lra/blob/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Complete.java#L129)\nIf any other code is returned (or, in the 500 case, the body does not correspond to a valid state)  then the implementation SHOULD either keep retrying or attempt to discover the status (https://github.com/eclipse/microprofile-lra/blob/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Complete.java#L163)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411383141", "createdAt": "2020-04-20T13:37:23Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTIxNw=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjc1MQ==", "bodyText": "My mistake, thanks. This can be resolved.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411432751", "createdAt": "2020-04-20T14:39:31Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTIxNw=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTE0NTg2OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyMzo0M1rOGIPuZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozNTowMFrOGKigww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTQzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Response foget() {\n          \n          \n            \n                public Response forget() {", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411299431", "createdAt": "2020-04-20T11:23:43Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"delete\")\n+    @Forget\n+    public Response foget() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4Mzc0OA==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411383748", "createdAt": "2020-04-20T13:38:10Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"delete\")\n+    @Forget\n+    public Response foget() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTQzMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDM4Nw==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413704387", "createdAt": "2020-04-23T10:35:00Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"delete\")\n+    @Forget\n+    public Response foget() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTQzMQ=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTE2MTc4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyNzo0N1rOGIP3eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDozMzoyN1rOGKic-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwMTc1Mg==", "bodyText": "This method is called also in tests that should test LRAParticipantWithoutStatusURI so this value can't be hardcoded if the method is to be reused.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411301752", "createdAt": "2020-04-20T11:27:47Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1NDkxMQ==", "bodyText": "Hmm, that's a good point, thanks.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411354911", "createdAt": "2020-04-20T12:57:05Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwMTc1Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzQxNw==", "bodyText": "Fixed with the last commit", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413703417", "createdAt": "2020-04-23T10:33:27Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwMTc1Mg=="}, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDQ5ODMzOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0Mjo0N1rOGKbTBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjoyNzoyMFrOGKmpog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjE4MQ==", "bodyText": "This won't print the stacktrace as it uses the tracef definition of tracef(String format, Object... params) but it needs to be used the tracef(Throwable t, String format, Object... params)\nThen printing \"manually\" the exception message with e.getMessage() is not necessary as the message will be automatically printed by logger when exception e is passed as Throwable.\nIt could be like\nLRALogger.logger.tracef(e, \"failed to access transaction store %s\", currentUid);\n\nAnd maybe one more question on the message. Is the currentUid meaning \"an access of the transaction store\". Should not be the message informs about not able to accessing some LRA UID or similar?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586181", "createdAt": "2020-04-23T07:42:47Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -177,7 +152,10 @@ private void processTransactionsStatus() {\n                         doRecoverTransaction(currentUid);\n                     }\n                 } catch (ObjectStoreException e) {\n-                    if (LRALogger.logger.isInfoEnabled()) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\"failed to access transaction store %s: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NDUyOQ==", "bodyText": "The ObjectStore API does not say under what circumstances the exception is thrown since it depends upon which underlying store is in use and the reasons for a failure are varied and we certainly don't want to start adding logging logic for the different store types. Hence the generic message.\n\n\nThe log messages are for the benefit of the support organisation to figure out where the issue lies. The actual message text (excluding the values of variables) is less relevant (provided an engineer can identify where in the code the message was generated from).\n\n\nIncluding the exception message in the trace message means that users who aren't interested in the call stack can still read the log messages and see what the precise reason for the error was (without having to scan down to the stacktrace).\n\n\nBut I did fix the log message text.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413744529", "createdAt": "2020-04-23T11:42:50Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -177,7 +152,10 @@ private void processTransactionsStatus() {\n                         doRecoverTransaction(currentUid);\n                     }\n                 } catch (ObjectStoreException e) {\n-                    if (LRALogger.logger.isInfoEnabled()) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\"failed to access transaction store %s: %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjE4MQ=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3MjE5NA==", "bodyText": "Just for the technical merit I would mention that user don't need to scan down to the stacktrace to see the error message as it's always logged on the first line. For more details he needs to really go down to cause clauses but he has to go through exception stacktrace always for it.\nNot a thing which I consider important.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413772194", "createdAt": "2020-04-23T12:27:20Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -177,7 +152,10 @@ private void processTransactionsStatus() {\n                         doRecoverTransaction(currentUid);\n                     }\n                 } catch (ObjectStoreException e) {\n-                    if (LRALogger.logger.isInfoEnabled()) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\"failed to access transaction store %s: %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjE4MQ=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDUwMTM4OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0MzozMVrOGKbU3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo0Mzo1MFrOGKk_sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjY1NQ==", "bodyText": "as above, please use the tracef method tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586655", "createdAt": "2020-04-23T07:43:31Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NTA3Mg==", "bodyText": "fixed with the latest push", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413745072", "createdAt": "2020-04-23T11:43:50Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjY1NQ=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDUwMzMxOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0Mzo1NVrOGKbV5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo0Mzo1NVrOGKk_6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjkxNw==", "bodyText": "the same as above, please use the tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586917", "createdAt": "2020-04-23T07:43:55Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NTEyOA==", "bodyText": "fixed with the latest push", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413745128", "createdAt": "2020-04-23T11:43:55Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjkxNw=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDUwNjEzOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0NDozMlrOGKbXfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo0Mzo1OFrOGKlAFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NzMyNw==", "bodyText": "the same as above, please use the tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413587327", "createdAt": "2020-04-23T07:44:32Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(\n+                            \"LRARecoverModule: Exception %s while unpacking records of type %s\",\n+                            e.getMessage(), _transactionType, e);\n+                } else if (LRALogger.logger.isInfoEnabled()) {\n+                    LRALogger.logger.infof(\"LRARecoverModule: Exception %s while unpacking records of type : %s\",\n+                            e.getMessage());\n+                }\n+\n+                return false;\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Iterate over a collection of Uids\n+     * This could be moved to an ArjunaCore class (such as UidHelper) if its useful\n+     *\n+     * @param uids the uids to iterate over\n+     * @param consumer the consumer that should be called for each Uid\n+     */\n+    private void forEach(InputObjectState uids, Consumer<Uid> consumer) {\n+        do {\n+            try {\n+                Uid uid = new Uid(uids.unpackBytes());\n+\n+                if (uid.equals(Uid.nullUid())) {\n+                    return;\n+                }\n+\n+                consumer.accept(uid);\n+            } catch (IOException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NTE3Mw==", "bodyText": "fixed with the latest push", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413745173", "createdAt": "2020-04-23T11:43:58Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(\n+                            \"LRARecoverModule: Exception %s while unpacking records of type %s\",\n+                            e.getMessage(), _transactionType, e);\n+                } else if (LRALogger.logger.isInfoEnabled()) {\n+                    LRALogger.logger.infof(\"LRARecoverModule: Exception %s while unpacking records of type : %s\",\n+                            e.getMessage());\n+                }\n+\n+                return false;\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Iterate over a collection of Uids\n+     * This could be moved to an ArjunaCore class (such as UidHelper) if its useful\n+     *\n+     * @param uids the uids to iterate over\n+     * @param consumer the consumer that should be called for each Uid\n+     */\n+    private void forEach(InputObjectState uids, Consumer<Uid> consumer) {\n+        do {\n+            try {\n+                Uid uid = new Uid(uids.unpackBytes());\n+\n+                if (uid.equals(Uid.nullUid())) {\n+                    return;\n+                }\n+\n+                consumer.accept(uid);\n+            } catch (IOException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NzMyNw=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDc5ODEzOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo0ODoxMVrOGKeFjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzo0MjoxN1rOGLYStQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng==", "bodyText": "I wonder if it would make sense to also give specific (different) status code for recognized LRA which is still active. I guess it shouldn't be possible to remove LRA which is still in flight.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413631886", "createdAt": "2020-04-23T08:48:11Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5ODEzOQ==", "bodyText": "So what are you asking for?\nAre you saying that we should throw an error if the record is not in the failed state. If so I will reword the API and update the implementation.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413798139", "createdAt": "2020-04-23T13:04:41Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5OTkyMQ==", "bodyText": "412 precondition failed would be more appropriate I think", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413799921", "createdAt": "2020-04-23T13:07:16Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTU4MQ==", "bodyText": "So are you saying that we should return 412 if the record is not in a failed state. If so I will reword the API and update the implementation (since in progress LRAs should not be deleted)?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413815581", "createdAt": "2020-04-23T13:55:53Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzAyMg==", "bodyText": "@mmusgrov yes, exactly. Thanks.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413823022", "createdAt": "2020-04-23T14:04:32Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0OTMxMA==", "bodyText": "Thanks, now I know how to code it up.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413849310", "createdAt": "2020-04-23T14:34:24Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU4NTUyNQ==", "bodyText": "@xstefank I added OpenAPI APIResponse annotations for 204, 412, 412 and 500 (and I had to make some updates to LRARecoveryModule so this code can distinguish between them).", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r414585525", "createdAt": "2020-04-24T13:42:17Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng=="}, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTUyMTcwOnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTozOTo0MFrOGKk2bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDoxMTozNVrOGKqJPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MjcwMA==", "bodyText": "reason should be that the forget call was requested but user didn't define the forget URI/method?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413742700", "createdAt": "2020-04-23T11:39:40Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle\n+                                    return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                }\n                             }\n \n-                            if (compensate) {\n-                                return TwoPhaseOutcome.FINISH_OK;\n-                            }\n-\n-                            return TwoPhaseOutcome.FINISH_OK;\n+                            return reportFailure(compensate, endPath, \"Unknown\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNTkxMw==", "bodyText": "@xstefank Same here. We do not know why the participant failed to compensate (ie we are not reporting the failure because there isn't a forget method as you suggest). We ask for the status (on line 521) and the participant told us it failed to compensate (but we don't know why it couldn't - perhaps that information is private to the microservice and is not willing to divulge it).", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413805913", "createdAt": "2020-04-23T13:42:42Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle\n+                                    return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                }\n                             }\n \n-                            if (compensate) {\n-                                return TwoPhaseOutcome.FINISH_OK;\n-                            }\n-\n-                            return TwoPhaseOutcome.FINISH_OK;\n+                            return reportFailure(compensate, endPath, \"Unknown\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MjcwMA=="}, "originalCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyOTQzNw==", "bodyText": "sorry, that was my mistake, you're right about the call handling. But we should include here that it was a participant response that caused the failure state. But again not that essential, just an idea.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413829437", "createdAt": "2020-04-23T14:11:35Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle\n+                                    return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                }\n                             }\n \n-                            if (compensate) {\n-                                return TwoPhaseOutcome.FINISH_OK;\n-                            }\n-\n-                            return TwoPhaseOutcome.FINISH_OK;\n+                            return reportFailure(compensate, endPath, \"Unknown\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MjcwMA=="}, "originalCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTUzMDE0OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo0MTo0N1rOGKk7VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo0NjoxN1rOGKsAGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0Mzk1Nw==", "bodyText": "\"unknown\" isn't probably right here", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413743957", "createdAt": "2020-04-23T11:41:47Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -508,7 +507,7 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                         return TwoPhaseOutcome.HEURISTIC_HAZARD;\n                     case FailedToClose:\n                     case FailedToCancel:\n-                        return TwoPhaseOutcome.FINISH_ERROR;\n+                        return reportFailure(compensate, endPath, \"unknown\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwMzM3NA==", "bodyText": "@xstefank  BTW the participant has failed to compensate and the reason is unknown.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413803374", "createdAt": "2020-04-23T13:12:14Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -508,7 +507,7 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                         return TwoPhaseOutcome.HEURISTIC_HAZARD;\n                     case FailedToClose:\n                     case FailedToCancel:\n-                        return TwoPhaseOutcome.FINISH_ERROR;\n+                        return reportFailure(compensate, endPath, \"unknown\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0Mzk1Nw=="}, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNjAwMQ==", "bodyText": "@mmusgrov this will be used in the log message on line https://github.com/jbosstm/narayana/pull/1603/files#diff-0f226ae6945188e648e485306754f30cR473. So \"LRARecord: participant %s reported a failure to %s (cause unknown)\" but we know that it is already in failed state, so I would rather say (cause already in failed state) but it's not that important.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413826001", "createdAt": "2020-04-23T14:07:46Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -508,7 +507,7 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                         return TwoPhaseOutcome.HEURISTIC_HAZARD;\n                     case FailedToClose:\n                     case FailedToCancel:\n-                        return TwoPhaseOutcome.FINISH_ERROR;\n+                        return reportFailure(compensate, endPath, \"unknown\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0Mzk1Nw=="}, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1OTg2NA==", "bodyText": "Let's revisit these reasons when we have better reporting of the reasons why participants fail to finish cleanly.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413859864", "createdAt": "2020-04-23T14:46:17Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -508,7 +507,7 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                         return TwoPhaseOutcome.HEURISTIC_HAZARD;\n                     case FailedToClose:\n                     case FailedToCancel:\n-                        return TwoPhaseOutcome.FINISH_ERROR;\n+                        return reportFailure(compensate, endPath, \"unknown\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0Mzk1Nw=="}, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTU5MjI2OnYy", "diffSide": "RIGHT", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo1ODowOVrOGKlg1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo0MzowMFrOGKouHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MzU1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws Exception if the state cannot be determiined\n          \n          \n            \n                 * @throws Exception if the state cannot be determined", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413753556", "createdAt": "2020-04-23T11:58:09Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePrefix, String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(resourcePrefix)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNjEwOQ==", "bodyText": "+1", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413806109", "createdAt": "2020-04-23T13:43:00Z", "author": {"login": "mmusgrov"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePrefix, String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(resourcePrefix)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MzU1Ng=="}, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1311, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}