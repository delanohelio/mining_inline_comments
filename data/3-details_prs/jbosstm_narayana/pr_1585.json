{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NjI5NDYw", "number": 1585, "title": "JBTM-3276 SlotStore implementation.", "bodyText": "This is part one, with the in-memory backend.\nhttps://issues.redhat.com/browse/JBTM-3276\nCORE !TOMCAT !AS_TESTS !RTS !JACOCO !XTS !QA_JTA !QA_JTS_JACORB !QA_JTS_JDKORB !QA_JTS_OPENJDKORB !BLACKTIE !PERF !LRA !NO_WIN !DB_TESTS !mysql !db2 !postgres !oracle\nI have set the PR to only test MAIN. I will investigate the AS_TEST, JACOCO and LRA Jenkin's axis failures.", "createdAt": "2020-04-02T14:52:32Z", "url": "https://github.com/jbosstm/narayana/pull/1585", "merged": true, "mergeCommit": {"oid": "0b7d23a8c9d7b0671a6ae151642cb78fd97e1d2a"}, "closed": true, "closedAt": "2020-04-08T10:43:34Z", "author": {"login": "jhalliday"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTtdjVgH2gAyMzk3NjI5NDYwOjY2N2U0NTQ1NWI2YjI1YzAzYjBhZDM4ZWUwYTNhZDlkNjk3YzQ4OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVlifRgFqTM4OTg1NzE0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "author": {"user": {"login": "jhalliday", "name": "Jonathan Halliday"}}, "url": "https://github.com/jbosstm/narayana/commit/667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "committedDate": "2020-04-02T14:48:39Z", "message": "JBTM-3276 SlotStore implementation.\nThis is part one, with the in-memory backend."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzExOTYz", "url": "https://github.com/jbosstm/narayana/pull/1585#pullrequestreview-387711963", "createdAt": "2020-04-04T16:06:21Z", "commit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNjowNjoyMlrOGAy2hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNjozNDozN1rOGAzBTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjM0Mw==", "bodyText": "Can the file exist if the directory hierarchy hasn't been created?", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403486343", "createdAt": "2020-04-04T16:06:22Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjUyNA==", "bodyText": "Do you ignore the return value because you just want to validate inputBuffer. If so why not add an isValid() method? Is it because SlotStore is only ever accessed via the adaptor (SlotStoreAdaptor), in which case validation as a side effect of unpacking is fine.", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403486524", "createdAt": "2020-04-04T16:08:19Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        storeDirCanonicalPath = storeDir.getCanonicalPath();\n+\n+        slots = new RAMSlots(config);\n+\n+        for (int i = 0; i < config.getNumberOfSlots(); i++) {\n+            freeList.add(i); // TODO recovery, when the backend supports it.\n+        }\n+    }\n+\n+    /**\n+     * @return the \"name\" of the object store. Where in the hierarchy it appears, e.g., /ObjectStore/MyName/...\n+     */\n+    public String getStoreName() {\n+        return this.getClass().getSimpleName() + \":\" + storeDirCanonicalPath;\n+    }\n+\n+    /**\n+     * Retrieve the serialized state for an entry.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return The serialized state\n+     * @throws IOException if the entry is not found\n+     */\n+    public InputObjectState read(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.get(key);\n+        if (slotId == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        byte[] data = slots.read(slotId);\n+        // it's possible, though unlikely, for the data to be null here due to a concurrent remove\n+        if (data == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        InputBuffer inputBuffer = new InputBuffer(data);\n+        SlotStoreKey.unpackFrom(inputBuffer);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzE1Mw==", "bodyText": "Superfluous test for null because matchingKeys cannot be null because SlotStoreAdaptor#getMatchingKeys(key) always returns a valid array.", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403487153", "createdAt": "2020-04-04T16:14:24Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzQzNg==", "bodyText": "I'd have expected this method to return all Uids regardless of their StateStatus value. But since it only returns OS_UNKNOWN ones will you include some javadoc for the method signature.", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403487436", "createdAt": "2020-04-04T16:17:34Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODEzNA==", "bodyText": "The comment is confusing because the array of knownTypes is populated in the method getKnownTypes by the call types.add(key.getTypeName()); but the added typeName can never be null (because the SlotStoreKey constructor dereferences it when checks for \"/\").", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488134", "createdAt": "2020-04-04T16:24:48Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);\n+    }\n+\n+    /**\n+     * Obtain all types of objects stored in the object store.\n+     *\n+     * @param foundTypes The state in which to store the types.\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allTypes(InputObjectState foundTypes) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allTypes()\");\n+        }\n+\n+        String[] knownTypes = store.getKnownTypes(); // may contain trailing null elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODIzMA==", "bodyText": "Remark: ArjunaCore does not document that typename hierarchies are delimited by slashes\nRemark: could you not leverage java.nio.files.Path to split the type name for you instead of using the following tricky code", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488230", "createdAt": "2020-04-04T16:25:59Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);\n+    }\n+\n+    /**\n+     * Obtain all types of objects stored in the object store.\n+     *\n+     * @param foundTypes The state in which to store the types.\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allTypes(InputObjectState foundTypes) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allTypes()\");\n+        }\n+\n+        String[] knownTypes = store.getKnownTypes(); // may contain trailing null elements\n+        Set<String> typeSet = new HashSet<>();\n+\n+        if (knownTypes == null || knownTypes.length == 0) {\n+            return true;\n+        }\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            for (String typeName : knownTypes) {\n+                if (typeName == null) {\n+                    continue;\n+                }\n+\n+                if (typeName.startsWith(\"/\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODU0OQ==", "bodyText": "My IDE is complaining that many of your access modifiers are too permissive. I know the slot store is private to SlotStoreAdaptor but restricting the modifier will stop IDE's from complaining.", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488549", "createdAt": "2020-04-04T16:29:02Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/RAMSlots.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+/**\n+ * Trivial in-memory backend for the SlotStore, useful for benchmarking but not much else.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class RAMSlots {\n+\n+    public final byte[][] slots;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTEwMw==", "bodyText": "So now there are two entries for the same state. Can periodic recovery kick in at this point and attempt to recover both?", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403489103", "createdAt": "2020-04-04T16:34:37Z", "author": {"login": "mmusgrov"}, "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        storeDirCanonicalPath = storeDir.getCanonicalPath();\n+\n+        slots = new RAMSlots(config);\n+\n+        for (int i = 0; i < config.getNumberOfSlots(); i++) {\n+            freeList.add(i); // TODO recovery, when the backend supports it.\n+        }\n+    }\n+\n+    /**\n+     * @return the \"name\" of the object store. Where in the hierarchy it appears, e.g., /ObjectStore/MyName/...\n+     */\n+    public String getStoreName() {\n+        return this.getClass().getSimpleName() + \":\" + storeDirCanonicalPath;\n+    }\n+\n+    /**\n+     * Retrieve the serialized state for an entry.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return The serialized state\n+     * @throws IOException if the entry is not found\n+     */\n+    public InputObjectState read(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.get(key);\n+        if (slotId == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        byte[] data = slots.read(slotId);\n+        // it's possible, though unlikely, for the data to be null here due to a concurrent remove\n+        if (data == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        InputBuffer inputBuffer = new InputBuffer(data);\n+        SlotStoreKey.unpackFrom(inputBuffer);\n+\n+        InputObjectState inputObjectState = new InputObjectState();\n+        inputObjectState.unpackFrom(inputBuffer);\n+\n+        return inputObjectState;\n+    }\n+\n+    /**\n+     * Remove the state for an entry, freeing the slot.\n+     * Depending on the configuration, this change may not be immediately persistent.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return true on success, false otherwise\n+     * @throws IOException unused for now in this impl.\n+     */\n+    public boolean remove(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.remove(key);\n+        if (slotId == null) {\n+            return false;\n+        }\n+\n+        slots.clear(slotId, config.isSyncDeletes());\n+\n+        freeList.add(slotId);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Write (or overwrite) an entry with the given key and value.\n+     *\n+     * @param key               The unique identifier for the entry\n+     * @param outputObjectState The serialized state\n+     * @return true on success, false otherwise e.g. when the store is full.\n+     * @throws IOException if serialization fails\n+     */\n+    public boolean write(SlotStoreKey key, OutputObjectState outputObjectState) throws IOException {\n+\n+        OutputObjectState record = new OutputObjectState();\n+        key.packInto(record);\n+        outputObjectState.packInto(record);\n+        byte[] data = outputObjectState.buffer();\n+\n+        if (data.length > config.getBytesPerSlot()) {\n+            throw new IOException(\"data too big for slot\");\n+        }\n+\n+        // We always write to a new slot, as overwrite in place may be non-atomic and\n+        // risks leaving us with neither the before or after version for crash recovery.\n+\n+        Integer slotId = freeList.poll();\n+        if (slotId == null) {\n+            return false;\n+        }\n+\n+        slots.write(slotId, data, config.isSyncWrites());\n+        slotIdIndex.put(key, slotId);\n+\n+        Integer previousSlot = slotIdIndex.put(key, slotId);\n+\n+        // If it's a rewrite, we need to release the older version's slot\n+        if (previousSlot != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c4f104cd48b3e2140236f5f75c8f5e3c99838d9", "author": {"user": {"login": "jhalliday", "name": "Jonathan Halliday"}}, "url": "https://github.com/jbosstm/narayana/commit/9c4f104cd48b3e2140236f5f75c8f5e3c99838d9", "committedDate": "2020-04-06T14:58:04Z", "message": "JBTM-3276 SlotStore implementation.\npart one review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80c436652c27146ba74fca14c5a81aecb201a46f", "author": {"user": {"login": "jhalliday", "name": "Jonathan Halliday"}}, "url": "https://github.com/jbosstm/narayana/commit/80c436652c27146ba74fca14c5a81aecb201a46f", "committedDate": "2020-04-07T14:54:07Z", "message": "JBTM-3276 SlotStore implementation.\njavadoc improvements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODU3MTQz", "url": "https://github.com/jbosstm/narayana/pull/1585#pullrequestreview-389857143", "createdAt": "2020-04-08T10:42:39Z", "commit": {"oid": "80c436652c27146ba74fca14c5a81aecb201a46f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4553, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}