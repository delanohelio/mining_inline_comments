{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MDY2NTcw", "number": 1603, "title": "JBTM-3247 Do not delete LRA records on the failed list", "bodyText": "https://issues.redhat.com/browse/JBTM-3291\nLRA MAIN !AS_TESTS !QA_JTA !JACOCO !QA_JTS_JACORB !TOMCAT !RTS !XTS !QA_JTS_JDKORB !QA_JTS_OPENJDKORB !BLACKTIE !PERF NO_WIN !DB_TESTS !mysql !db2 !postgres !oracle\nThis PR changes the LRA implementation such that we now retain failure records (previously we reported the failure and then deleted them).\nThe OpenAPI doc for reading the records justifies their retention by saying:\n\"Failure records are vital pieces of data needed to aid failure tracking and analysis and are retained for inspection.\"\nAnd I raised JBTM-3297 to move these records to another part of the store so that standard LRA recovery processing does not need to read them.", "createdAt": "2020-04-17T10:59:59Z", "url": "https://github.com/jbosstm/narayana/pull/1603", "merged": true, "mergeCommit": {"oid": "c708ab706670f0b421c8c500b0836532480faf6a"}, "closed": true, "closedAt": "2020-04-27T10:50:44Z", "author": {"login": "mmusgrov"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZaS8qgFqTM5NjIxMTQ2MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbrG2LAFqTQwMDczODY5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MjExNDYw", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-396211460", "createdAt": "2020-04-20T07:42:49Z", "commit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0Mjo0OVrOGIHX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo0OTo0NVrOGIHndg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2MjU5MA==", "bodyText": "I think it would be good to log the full exception stacktrace when asked by more verbose logging.\nIt's handy in ivestigation on what's happening in the system.\nI think when TRACE level is enabled the exception with stacktrace and probably some information what was the reason should be logged in to the coordinator log.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411162590", "createdAt": "2020-04-20T07:42:49Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();\n+            }\n+\n+            return Response.status(INTERNAL_SERVER_ERROR).build();\n+        } catch (URISyntaxException e) {\n+            return Response.status(INTERNAL_SERVER_ERROR).entity(String.format(\"%s: %s\", lraId, e.getMessage())).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NTUzMQ==", "bodyText": "If I'm not mistaken by looking into the code the failedList (and neither the preparedList) are guarded by some lock or other synchronization guard (while the RecordList is not meant to be thread safe). As I'm not fully in-depth into the logic my point is if this code is safe when executed from different threads (if it may happen)?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411165531", "createdAt": "2020-04-20T07:47:58Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -228,11 +228,35 @@ private boolean restore_list(InputObjectState os, int ot, RecordList list) {\n     public boolean restore_state(InputObjectState os, int ot) {\n \n         if (!super.restore_state(os, ot)\n-                || !restore_list(os, ot, pendingList)\n-                || !restore_list(os, ot, preparedList)) {\n+                || !restore_list(os, ot, pendingList)) { // other lists are maintained in BasicAction\n             return false;\n         }\n \n+        // restore_state may have put failed records onto the prepared list so move them back again:\n+        for (AbstractRecord rec = preparedList.peekFront(); rec != null; rec = preparedList.peekNext(rec)) {\n+            if (rec instanceof LRARecord) {\n+                LRARecord p = (LRARecord) rec;\n+\n+                if (p.isFailed()) {\n+                    boolean moveRec = true;\n+                    AbstractRecord r;\n+\n+                    preparedList.remove(p);\n+\n+                    // put it back on the failedList if it isn't already on it\n+                    for (r = failedList.peekFront(); r != null; r = failedList.peekNext(r)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjI5Ng==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166296", "createdAt": "2020-04-20T07:49:15Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjM3Mg==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166372", "createdAt": "2020-04-20T07:49:25Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NjU4Mg==", "bodyText": "Could we log the exception reason and the stacktrace under TRACE log level, please?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411166582", "createdAt": "2020-04-20T07:49:45Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,6 +207,80 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate(); // or just parse lraId extracting the uid\n+\n+                            if (uid.fileStringForm().equals(lra.getUid())) {\n+                                return _recoveryStore.remove_committed(uid, lra.type());\n+                            }\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;\n+                    }\n+                }\n+            }\n+        } catch (ObjectStoreException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"LRARecoverModule: Object store exception: %s\", e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+\n+        try {\n+            if (getUids(aa_uids)) {\n+                boolean moreUids = true;\n+\n+                while (moreUids) {\n+                    try {\n+                        Uid uid = UidHelper.unpackFrom(aa_uids);\n+\n+                        if (uid.equals(Uid.nullUid())) {\n+                            moreUids = false;\n+                        } else {\n+                            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+                            lra.activate();\n+                            lras.put(lra.getId(), lra);\n+                        }\n+                    } catch (Exception ex) {\n+                        moreUids = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MjcwOTQy", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-396270942", "createdAt": "2020-04-20T09:06:58Z", "commit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNjo1OFrOGIKpJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMToyNzo0N1rOGIP3eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjE2NQ==", "bodyText": "Wouldn't a 404 here be more suitable?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216165", "createdAt": "2020-04-20T09:06:58Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjgwOQ==", "bodyText": "it seems that nothing is returned in the body on successful removal.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411216809", "createdAt": "2020-04-20T09:08:02Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNzYyNQ==", "bodyText": "It's common to return the removed value on successful removal in usual CRUD models. Maybe we could return the removed LRA.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411217625", "createdAt": "2020-04-20T09:09:21Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,41 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"200\",\n+                    description = \"If the LRA was successfully removed\",\n+                    content = @Content(schema = @Schema(implementation = Boolean.class)))\n+    })\n+    public Response deleteLRA(\n+            @Parameter(name = \"LraId\", description = \"The unique identifier of the LRA\", required = true)\n+            @PathParam(\"LraId\")String lraId) throws NotFoundException {\n+        try {\n+            if (lraService.removeLog(new URI(lraId))) {\n+                return Response.ok().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDkyMQ==", "bodyText": "Why is this call necessary? Aren't the hard-coded booleans correct always? They are a form of self-validation in Narayana codebase so we don't unintentionally call the wrong phase. Also, this will add one additional method invocation to every call which is not much but why to waste performance? I just want to know why did you include these calls.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411220921", "createdAt": "2020-04-20T09:14:20Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -245,7 +245,7 @@ public int topLevelOnePhaseCommit() {\n \n     @Override\n     public int topLevelCommit() {\n-        return doEnd(false);\n+        return doEnd(lra.isCancel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzk4Nw==", "bodyText": "just an idea outside the PR itself. Would it make sense to include some information in the LRARecord about why the participant entered Compensating/Completing state? i.e. because it returned 202 (accepted) or the coordinator couldn't get any expected response? Would this make sense for users in some failure scenarios?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411223987", "createdAt": "2020-04-20T09:18:57Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -367,20 +367,9 @@ private int tryDoEnd(boolean compensate) {\n                         endPath, httpStatus);\n             }\n \n-            if (compensate) {\n-                status = ParticipantStatus.Compensating; // recovery will figure out the status via the status url\n-\n-                /*\n-                 * We are mapping compensate onto Abort. TwoPhaseCoordinator uses presumed abort\n-                 * so if we were to return FINISH_ERROR recovery would not replay the log.\n-                 * To force the record to be eligible for recovery we return a heuristic hazard.\n-                 */\n-                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n-            }\n-\n-            status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n-\n-            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n+            // recovery will figure out the status via the status url\n+            status = compensate ? ParticipantStatus.Compensating : ParticipantStatus.Completing;\n+            accepted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNjM5MQ==", "bodyText": "I don't understand why this is needed? It's not wrong but why not to call forget since this is already the last operation that needs to be called for this participant?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411226391", "createdAt": "2020-04-20T09:22:26Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5NjI4Mg==", "bodyText": "I would expect to also see the operation getFailedLRAs and removeFailed(URI) in NarayanaLRAClient. WDYT?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411296282", "createdAt": "2020-04-20T11:18:04Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined\n+     */\n+    private boolean validateStateAndRemove(URI lra, LRAStatus state) throws Exception {\n+        List<JSONObject> failedRecords = getFailedRecords(lra);\n+        for (JSONObject failedLRA : failedRecords) {\n+            String lraId = (String) failedLRA.get(\"lraId\");\n+            lraId = lraId.replaceAll(\"\\\\\\\\\", \"\");\n+            if (lraId.contains(lra.toASCIIString())) {\n+                String status = (String) failedLRA.get(\"status\");\n+                if (status.equals(state.name())) {\n+                    // remove the failed LRA\n+                    Assert.assertEquals(\"Could not remove log\", Response.Status.OK.getStatusCode(), removeFailedLRA(lra));\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    // look up LRAs that are in a failed state (ie FailedToCancel or FailedToClose)\n+    private List<JSONObject> getFailedRecords(URI lra) throws Exception {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+\n+        try {\n+            response = client.target(new URI(recoveryUrl)).path(\"failed\").request().get();\n+\n+            Assert.assertTrue(\"Missing response body when querying for failed LRAs\", response.hasEntity());\n+            String failedLRAs = response.readEntity(String.class);\n+\n+            JSONArray jsonArray = new JSONArray(failedLRAs);\n+            List<JSONObject> failedList = new ArrayList<>();\n+\n+            for (int i = 0; i < jsonArray.length(); i++) {\n+                failedList.add(new JSONObject(jsonArray.getString(i)));\n+            }\n+\n+            return failedList;\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    // ask the recovery coordinator to delete its log for an LRA\n+    private int removeFailedLRA(URI lra) throws URISyntaxException, UnsupportedEncodingException {\n+        Response response = null;\n+        String recoveryUrl = String.format(\"http://%s:%d/%s\",\n+                lra.getHost(), lra.getPort(), LRAConstants.RECOVERY_COORDINATOR_PATH_NAME);\n+        String txId = URLEncoder.encode(lra.toASCIIString(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5Nzk4OQ==", "bodyText": "it produces Enums name, so it should be probably text/plain.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411297989", "createdAt": "2020-04-20T11:21:02Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5ODE5Ng==", "bodyText": "also here I would suggest text/plain", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411298196", "createdAt": "2020-04-20T11:21:24Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTIxNw==", "bodyText": "Don't Narayana retry on 500 status code? In the spec we use 200 and only the response body (here correct FailedToComplete) to distinguish failed states.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411299217", "createdAt": "2020-04-20T11:23:17Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5OTQzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Response foget() {\n          \n          \n            \n                public Response forget() {", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411299431", "createdAt": "2020-04-20T11:23:43Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/LRAParticipantWithStatusURI.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.Compensate;\n+import org.eclipse.microprofile.lra.annotation.Complete;\n+import org.eclipse.microprofile.lra.annotation.Forget;\n+import org.eclipse.microprofile.lra.annotation.ParticipantStatus;\n+import org.eclipse.microprofile.lra.annotation.Status;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER;\n+import static org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_RECOVERY_HEADER;\n+\n+@ApplicationScoped\n+@Path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)\n+public class LRAParticipantWithStatusURI {\n+    public static final String LRA_PARTICIPANT_PATH = \"participant-with-status-reporting\";\n+    public static final String TRANSACTIONAL_CLOSE_PATH = \"close-work\";\n+    public static final String TRANSACTIONAL_CANCEL_PATH = \"cancel-work\";\n+    public static final String FORGET_COUNT_PATH = \"forget-count\";\n+\n+    private static final AtomicInteger forgetCount = new AtomicInteger(0);\n+    private static final AtomicInteger compensateCount = new AtomicInteger(0);\n+    private static final AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CLOSE_PATH)\n+    @LRA\n+    public Response closeLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.ok(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(TRANSACTIONAL_CANCEL_PATH)\n+    @LRA(cancelOn = Response.Status.INTERNAL_SERVER_ERROR)\n+    public Response abortLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(lraId.toASCIIString()).build();\n+    }\n+\n+    @GET\n+    @Path(FORGET_COUNT_PATH)\n+    public int getForgetCount() {\n+        return forgetCount.get();\n+    }\n+\n+    @PUT\n+    @Path(\"compensate\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Compensate\n+    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        compensateCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToCompensate.name()).build();\n+    }\n+\n+    @PUT\n+    @Path(\"complete\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Complete\n+    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)\n+            throws NotFoundException {\n+        completeCount.incrementAndGet();\n+\n+        return Response.status(500).entity(ParticipantStatus.FailedToComplete.name()).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"delete\")\n+    @Forget\n+    public Response foget() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwMTc1Mg==", "bodyText": "This method is called also in tests that should test LRAParticipantWithoutStatusURI so this value can't be hardcoded if the method is to be reused.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r411301752", "createdAt": "2020-04-20T11:27:47Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec24f2465f00ca8ae2992278e113f44393376327"}, "originalPosition": 145}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe8e14c03507bceb29b8a881424249c491a3417d", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/fe8e14c03507bceb29b8a881424249c491a3417d", "committedDate": "2020-04-21T18:11:39Z", "message": "JBTM-3247"}, "afterCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/f8f94513d6ff9272b5f4a20b725a5549b05e5202", "committedDate": "2020-04-21T18:13:12Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODM4NDM4", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-398838438", "createdAt": "2020-04-23T07:42:47Z", "commit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0Mjo0N1rOGKbTBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo0NDozMlrOGKbXfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjE4MQ==", "bodyText": "This won't print the stacktrace as it uses the tracef definition of tracef(String format, Object... params) but it needs to be used the tracef(Throwable t, String format, Object... params)\nThen printing \"manually\" the exception message with e.getMessage() is not necessary as the message will be automatically printed by logger when exception e is passed as Throwable.\nIt could be like\nLRALogger.logger.tracef(e, \"failed to access transaction store %s\", currentUid);\n\nAnd maybe one more question on the message. Is the currentUid meaning \"an access of the transaction store\". Should not be the message informs about not able to accessing some LRA UID or similar?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586181", "createdAt": "2020-04-23T07:42:47Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -177,7 +152,10 @@ private void processTransactionsStatus() {\n                         doRecoverTransaction(currentUid);\n                     }\n                 } catch (ObjectStoreException e) {\n-                    if (LRALogger.logger.isInfoEnabled()) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\"failed to access transaction store %s: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjY1NQ==", "bodyText": "as above, please use the tracef method tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586655", "createdAt": "2020-04-23T07:43:31Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NjkxNw==", "bodyText": "the same as above, please use the tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413586917", "createdAt": "2020-04-23T07:43:55Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4NzMyNw==", "bodyText": "the same as above, please use the tracef(Throwable t, String format, Object... params)", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413587327", "createdAt": "2020-04-23T07:44:32Z", "author": {"login": "ochaloup"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/internal/LRARecoveryModule.java", "diffHunk": "@@ -207,7 +185,103 @@ public void getRecoveringLRAs(Map<URI, Transaction> lras) {\n         }\n     }\n \n-    LRAService lraService;\n+    // remove a log record\n+    public boolean removeCommitted(URI lraId) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        Consumer<Uid> uidDestroyer = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate(); // or just parse lraId extracting the uid\n+\n+            if (uid.fileStringForm().equals(lra.getUid())) {\n+                try {\n+                    success.set(_recoveryStore.remove_committed(uid, lra.type()));\n+                } catch (ObjectStoreException e) {\n+                    if (LRALogger.logger.isTraceEnabled()) {\n+                        LRALogger.logger.tracef(\n+                                \"LRARecoverModule: Object store exception while removing record %s\",\n+                                uid.fileStringForm(), e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, uidDestroyer);\n+        }\n+\n+        return success.get();\n+    }\n+\n+    public void getFailedLRAs(Map<URI, Transaction> lras) {\n+        InputObjectState aa_uids = new InputObjectState();\n+        Consumer<Uid> failedLRACreator = uid -> {\n+            Transaction lra = new Transaction(lraService, new Uid(uid));\n+\n+            lra.activate();\n+            lras.put(lra.getId(), lra);\n+        };\n+\n+        if (getUids(aa_uids)) {\n+            forEach(aa_uids, failedLRACreator);\n+        }\n+    }\n+\n+    private boolean getUids(InputObjectState aa_uids) {\n+        synchronized (this) {\n+            try {\n+                return _recoveryStore.allObjUids(_transactionType, aa_uids);\n+            } catch (ObjectStoreException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(\n+                            \"LRARecoverModule: Exception %s while unpacking records of type %s\",\n+                            e.getMessage(), _transactionType, e);\n+                } else if (LRALogger.logger.isInfoEnabled()) {\n+                    LRALogger.logger.infof(\"LRARecoverModule: Exception %s while unpacking records of type : %s\",\n+                            e.getMessage());\n+                }\n+\n+                return false;\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Iterate over a collection of Uids\n+     * This could be moved to an ArjunaCore class (such as UidHelper) if its useful\n+     *\n+     * @param uids the uids to iterate over\n+     * @param consumer the consumer that should be called for each Uid\n+     */\n+    private void forEach(InputObjectState uids, Consumer<Uid> consumer) {\n+        do {\n+            try {\n+                Uid uid = new Uid(uids.unpackBytes());\n+\n+                if (uid.equals(Uid.nullUid())) {\n+                    return;\n+                }\n+\n+                consumer.accept(uid);\n+            } catch (IOException e) {\n+                if (LRALogger.logger.isTraceEnabled()) {\n+                    LRALogger.logger.tracef(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 172}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/f8f94513d6ff9272b5f4a20b725a5549b05e5202", "committedDate": "2020-04-21T18:13:12Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}, "afterCommit": {"oid": "121a016c152f96a3867b895fbe5847265f6edb21", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/121a016c152f96a3867b895fbe5847265f6edb21", "committedDate": "2020-04-23T10:56:36Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "121a016c152f96a3867b895fbe5847265f6edb21", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/121a016c152f96a3867b895fbe5847265f6edb21", "committedDate": "2020-04-23T10:56:36Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}, "afterCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/8e71a2a192c2b67188a68bc4237822f2ec562ce4", "committedDate": "2020-04-23T11:03:32Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/8e71a2a192c2b67188a68bc4237822f2ec562ce4", "committedDate": "2020-04-23T11:03:32Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}, "afterCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/9201ed79fdc56df3b993812b3762761d94884568", "committedDate": "2020-04-23T11:39:31Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODg5NTk4", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-398889598", "createdAt": "2020-04-23T08:48:10Z", "commit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo0ODoxMVrOGKeFjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTo1ODowOVrOGKlg1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzMTg4Ng==", "bodyText": "I wonder if it would make sense to also give specific (different) status code for recognized LRA which is still active. I guess it shouldn't be possible to remove LRA which is still in flight.", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413631886", "createdAt": "2020-04-23T08:48:11Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/api/RecoveryCoordinator.java", "diffHunk": "@@ -152,4 +153,48 @@ public String replaceCompensator(\n     public List<LRAStatusHolder> getRecoveringLRAs() {\n         return lraService.getAllRecovering(true);\n     }\n+\n+    @GET\n+    @Path(\"failed\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Operation(summary = \"List failed Long Running Actions\",\n+            description = \"Returns LRAs that have failed. \" +\n+                    \" Failure records are vital pieces of data needed to aid failure tracking and analysis \" +\n+                    \" and are retained for inspection.\")\n+    @APIResponse(responseCode = \"200\",\n+            content = @Content(schema = @Schema(type = SchemaType.ARRAY, implementation = LRAStatusHolder.class)))\n+    public List<LRAStatusHolder> getFailedLRAs() {\n+        return lraService.getFailedLRAs();\n+    }\n+\n+    @DELETE\n+    @Path(\"{LraId}\")\n+    @Operation(summary = \"Remove the log for an LRA\")\n+    @APIResponses({\n+            @APIResponse(responseCode = \"204\",\n+                    description = \"If the LRA was successfully removed\"),\n+            @APIResponse(responseCode = \"404\",\n+                    description = \"The LRA was not recognised\"),\n+            @APIResponse(responseCode = \"500\",\n+                    description = \"If the input LRA does not correspond to a valid URI \" +\n+                            \"(in which case the response entity will contain the error message) \" +\n+                            \"or if the attempt to remove the LRA failed\")\n+    })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f94513d6ff9272b5f4a20b725a5549b05e5202"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MjcwMA==", "bodyText": "reason should be that the forget call was requested but user didn't define the forget URI/method?", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413742700", "createdAt": "2020-04-23T11:39:40Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -562,14 +564,13 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                                     compensate, endPath, status);\n \n                             if (forgetURI != null) {\n-                                return forget() ? TwoPhaseOutcome.FINISH_OK : TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                if (!forget()) {\n+                                    // we will retry the forget on the next recovery cycle\n+                                    return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                                }\n                             }\n \n-                            if (compensate) {\n-                                return TwoPhaseOutcome.FINISH_OK;\n-                            }\n-\n-                            return TwoPhaseOutcome.FINISH_OK;\n+                            return reportFailure(compensate, endPath, \"Unknown\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e71a2a192c2b67188a68bc4237822f2ec562ce4"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0Mzk1Nw==", "bodyText": "\"unknown\" isn't probably right here", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413743957", "createdAt": "2020-04-23T11:41:47Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -508,7 +507,7 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n                         return TwoPhaseOutcome.HEURISTIC_HAZARD;\n                     case FailedToClose:\n                     case FailedToCancel:\n-                        return TwoPhaseOutcome.FINISH_ERROR;\n+                        return reportFailure(compensate, endPath, \"unknown\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MzU1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws Exception if the state cannot be determiined\n          \n          \n            \n                 * @throws Exception if the state cannot be determined", "url": "https://github.com/jbosstm/narayana/pull/1603#discussion_r413753556", "createdAt": "2020-04-23T11:58:09Z", "author": {"login": "xstefank"}, "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/FailedLRAIT.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithStatusURI;\n+import io.narayana.lra.arquillian.resource.LRAParticipantWithoutStatusURI;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONObject;\n+import org.eclipse.microprofile.lra.annotation.LRAStatus;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * There is a spec requirement to report failed LRAs but the spec only requires that a failure message is reported\n+ * (not how it is reported). Failure records are vital pieces of data needed to aid failure tracking and analysis.\n+ *\n+ * The Narayana implementation allows failed LRAs to be directly queried. The following tests validate that the\n+ * correct failure records are kept until explicitly removed.\n+ */\n+@RunWith(Arquillian.class)\n+public class FailedLRAIT {\n+\n+    @ArquillianResource\n+    private URL baseURL;\n+\n+    private Client client;\n+\n+    @Deployment\n+    public static WebArchive deploy() {\n+        return ShrinkWrap.create(WebArchive.class, FailedLRAIT.class.getSimpleName() + \".war\")\n+                .addPackages(true, org.codehaus.jettison.JSONSequenceTooLargeException.class.getPackage());\n+    }\n+\n+    @Before\n+    public void before() {\n+        client = ClientBuilder.newClient();\n+    }\n+\n+    @After\n+    public void after() {\n+        if (client != null) {\n+            client.close();\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testWithStatusCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (with status reporting) fails to complete\n+     */\n+    @Test\n+    public void testWithStatusCompleteFailed() throws Exception {\n+        // invoke a method that should run with an LRA\n+        URI lra = invokeInTransaction(LRAParticipantWithStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        // when the invoked method returns validate that the narayana implementation created a failure record\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to compensate\n+     */\n+    @Test\n+    public void testCompensateFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CANCEL_PATH, 500);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToCancel)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    /**\n+     * test that a failure record is created when a participant (without status reporting) fails to complete\n+     */\n+    @Test\n+    public void testCompleteFailed() throws Exception {\n+        URI lra = invokeInTransaction(LRAParticipantWithoutStatusURI.LRA_PARTICIPANT_PATH,\n+                LRAParticipantWithoutStatusURI.TRANSACTIONAL_CLOSE_PATH, 200);\n+\n+        if (!validateStateAndRemove(lra, LRAStatus.FailedToClose)) {\n+            fail(\"lra not in failed list\");\n+        }\n+    }\n+\n+    private URI invokeInTransaction(String resourcePrefix, String resourcePath, int expectedStatus) {\n+        Response response = null;\n+\n+        try {\n+            response = client.target(UriBuilder.fromUri(baseURL.toExternalForm())\n+                    .path(resourcePrefix)\n+                    .path(resourcePath).build())\n+                    .request()\n+                    .get();\n+\n+            assertEquals(expectedStatus, response.getStatus());\n+            Assert.assertTrue(response.hasEntity());\n+\n+            return URI.create(response.readEntity(String.class));\n+        } finally {\n+            if (response != null) {\n+                response.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate whether or not a given LRA is in a particular state.\n+     * Also validate that the corresponding record is removed.\n+     *\n+     * @param lra the LRA whose state is to be validated\n+     * @param state the state that the target LRA should be in\n+     * @return true if the LRA is in the target state and that its log was successfully removed\n+     * @throws Exception if the state cannot be determiined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MDY4MjY5", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-399068269", "createdAt": "2020-04-23T12:53:11Z", "commit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6df261724c14184fa637a0d82aa6ab255019785c", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/6df261724c14184fa637a0d82aa6ab255019785c", "committedDate": "2020-04-24T13:32:06Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9201ed79fdc56df3b993812b3762761d94884568", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/9201ed79fdc56df3b993812b3762761d94884568", "committedDate": "2020-04-23T11:39:31Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}, "afterCommit": {"oid": "6df261724c14184fa637a0d82aa6ab255019785c", "author": {"user": {"login": "mmusgrov", "name": "Michael Musgrove"}}, "url": "https://github.com/jbosstm/narayana/commit/6df261724c14184fa637a0d82aa6ab255019785c", "committedDate": "2020-04-24T13:32:06Z", "message": "JBTM-3247 Do not delete records on the failed list\n - report TwoPhaseOutcome.FINISH_ERROR\n - use Basic#commit always since abort does not produce a log unless\n   there's a failure but we need the log to perform after processing\n   (ie listener and forget notifications)\n - delete failure logs on user request\n - move prepared items to the failed list on restore\n - make sure failed states don't show up in the preparedList\n - don't check the failedList when checking Transaction#hasPendingActions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNzM4Njky", "url": "https://github.com/jbosstm/narayana/pull/1603#pullrequestreview-400738692", "createdAt": "2020-04-27T08:35:26Z", "commit": {"oid": "6df261724c14184fa637a0d82aa6ab255019785c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4577, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}