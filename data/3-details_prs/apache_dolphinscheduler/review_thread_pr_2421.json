{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMDAyMTIz", "number": 2421, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzoxNzoyMlrODywD0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzoxNzoyMlrODywD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTQyODAwOnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/WorkFlowLineageService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzoxNzoyMlrOGG-hdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzo1MzowM1rOGG_DGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2OTAxNA==", "bodyText": "You can translate this to english.", "url": "https://github.com/apache/dolphinscheduler/pull/2421#discussion_r409969014", "createdAt": "2020-04-17T03:17:22Z", "author": {"login": "lgcareer"}, "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/WorkFlowLineageService.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.dolphinscheduler.api.service;\n+\n+import org.apache.dolphinscheduler.api.enums.Status;\n+import org.apache.dolphinscheduler.common.Constants;\n+import org.apache.dolphinscheduler.dao.mapper.WorkFlowLineageMapper;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowLineage;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowRelation;\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class WorkFlowLineageService extends BaseService {\n+    private static final Logger logger = LoggerFactory.getLogger(WorkFlowLineageService.class);\n+\n+    @Autowired\n+    private WorkFlowLineageMapper workFlowLineageMapper;\n+\n+    public Map<String, Object> queryWorkFlowLineageByName(String workFlowName, int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByName(workFlowName, projectId);\n+        result.put(Constants.DATA_LIST, workFlowLineageList);\n+        putMsg(result, Status.SUCCESS);\n+        return result;\n+    }\n+\n+    private List<WorkFlowRelation> getWorkFlowRelationRecursion(Set<Integer> ids, List<WorkFlowRelation> workFlowRelations) {\n+        for(int id : ids) {\n+            List<WorkFlowRelation> workFlowRelationsTmp = workFlowLineageMapper.querySourceTarget(id);\n+\n+            if(workFlowRelationsTmp != null && workFlowRelationsTmp.size()>0) {\n+                Set<Integer> idsTmp = new HashSet<>();\n+                for(WorkFlowRelation workFlowRelation:workFlowRelationsTmp) {\n+                    idsTmp.add(workFlowRelation.getTargetWorkFlowId());\n+                }\n+                workFlowRelations.addAll(workFlowRelationsTmp);\n+                getWorkFlowRelationRecursion(idsTmp, workFlowRelations);\n+            }\n+        }\n+        return workFlowRelations;\n+    }\n+\n+    public Map<String, Object> queryWorkFlowLineageByIds(Set<Integer> ids,int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByIds(ids, projectId);\n+        Map<String, Object> workFlowLists = new HashMap<>(5);\n+        Set<Integer> idsV = ids;\n+        if(ids == null || ids.size() == 0){\n+            for(WorkFlowLineage workFlowLineage:workFlowLineageList) {\n+                idsV.add(workFlowLineage.getWorkFlowId());\n+            }\n+        }\n+        List<WorkFlowRelation> workFlowRelations = new ArrayList<>();\n+        getWorkFlowRelationRecursion(idsV, workFlowRelations);\n+\n+        Set<Integer> idSet = new HashSet<>();\n+        //\u5982\u679c\u4f20\u5165\u53c2\u6570\u4e0d\u4e3a\u7a7a\uff0c\u5219\u9700\u8981\u8865\u5145\u4e0b\u6e38\u5de5\u4f5c\u6d41\u660e\u7ec6\u5c5e\u6027", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3be09b0eccb75323336056aa3cf9e87856141c83"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MjYwMw==", "bodyText": "OK, thanks for your remind", "url": "https://github.com/apache/dolphinscheduler/pull/2421#discussion_r409972603", "createdAt": "2020-04-17T03:32:13Z", "author": {"login": "LiemLin"}, "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/WorkFlowLineageService.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.dolphinscheduler.api.service;\n+\n+import org.apache.dolphinscheduler.api.enums.Status;\n+import org.apache.dolphinscheduler.common.Constants;\n+import org.apache.dolphinscheduler.dao.mapper.WorkFlowLineageMapper;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowLineage;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowRelation;\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class WorkFlowLineageService extends BaseService {\n+    private static final Logger logger = LoggerFactory.getLogger(WorkFlowLineageService.class);\n+\n+    @Autowired\n+    private WorkFlowLineageMapper workFlowLineageMapper;\n+\n+    public Map<String, Object> queryWorkFlowLineageByName(String workFlowName, int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByName(workFlowName, projectId);\n+        result.put(Constants.DATA_LIST, workFlowLineageList);\n+        putMsg(result, Status.SUCCESS);\n+        return result;\n+    }\n+\n+    private List<WorkFlowRelation> getWorkFlowRelationRecursion(Set<Integer> ids, List<WorkFlowRelation> workFlowRelations) {\n+        for(int id : ids) {\n+            List<WorkFlowRelation> workFlowRelationsTmp = workFlowLineageMapper.querySourceTarget(id);\n+\n+            if(workFlowRelationsTmp != null && workFlowRelationsTmp.size()>0) {\n+                Set<Integer> idsTmp = new HashSet<>();\n+                for(WorkFlowRelation workFlowRelation:workFlowRelationsTmp) {\n+                    idsTmp.add(workFlowRelation.getTargetWorkFlowId());\n+                }\n+                workFlowRelations.addAll(workFlowRelationsTmp);\n+                getWorkFlowRelationRecursion(idsTmp, workFlowRelations);\n+            }\n+        }\n+        return workFlowRelations;\n+    }\n+\n+    public Map<String, Object> queryWorkFlowLineageByIds(Set<Integer> ids,int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByIds(ids, projectId);\n+        Map<String, Object> workFlowLists = new HashMap<>(5);\n+        Set<Integer> idsV = ids;\n+        if(ids == null || ids.size() == 0){\n+            for(WorkFlowLineage workFlowLineage:workFlowLineageList) {\n+                idsV.add(workFlowLineage.getWorkFlowId());\n+            }\n+        }\n+        List<WorkFlowRelation> workFlowRelations = new ArrayList<>();\n+        getWorkFlowRelationRecursion(idsV, workFlowRelations);\n+\n+        Set<Integer> idSet = new HashSet<>();\n+        //\u5982\u679c\u4f20\u5165\u53c2\u6570\u4e0d\u4e3a\u7a7a\uff0c\u5219\u9700\u8981\u8865\u5145\u4e0b\u6e38\u5de5\u4f5c\u6d41\u660e\u7ec6\u5c5e\u6027", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2OTAxNA=="}, "originalCommit": {"oid": "3be09b0eccb75323336056aa3cf9e87856141c83"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3NzYyNQ==", "bodyText": "You're welcome.I saw you are good at both frontend and backend.It's great!", "url": "https://github.com/apache/dolphinscheduler/pull/2421#discussion_r409977625", "createdAt": "2020-04-17T03:53:03Z", "author": {"login": "lgcareer"}, "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/WorkFlowLineageService.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.dolphinscheduler.api.service;\n+\n+import org.apache.dolphinscheduler.api.enums.Status;\n+import org.apache.dolphinscheduler.common.Constants;\n+import org.apache.dolphinscheduler.dao.mapper.WorkFlowLineageMapper;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowLineage;\n+import org.apache.dolphinscheduler.dao.entity.WorkFlowRelation;\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class WorkFlowLineageService extends BaseService {\n+    private static final Logger logger = LoggerFactory.getLogger(WorkFlowLineageService.class);\n+\n+    @Autowired\n+    private WorkFlowLineageMapper workFlowLineageMapper;\n+\n+    public Map<String, Object> queryWorkFlowLineageByName(String workFlowName, int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByName(workFlowName, projectId);\n+        result.put(Constants.DATA_LIST, workFlowLineageList);\n+        putMsg(result, Status.SUCCESS);\n+        return result;\n+    }\n+\n+    private List<WorkFlowRelation> getWorkFlowRelationRecursion(Set<Integer> ids, List<WorkFlowRelation> workFlowRelations) {\n+        for(int id : ids) {\n+            List<WorkFlowRelation> workFlowRelationsTmp = workFlowLineageMapper.querySourceTarget(id);\n+\n+            if(workFlowRelationsTmp != null && workFlowRelationsTmp.size()>0) {\n+                Set<Integer> idsTmp = new HashSet<>();\n+                for(WorkFlowRelation workFlowRelation:workFlowRelationsTmp) {\n+                    idsTmp.add(workFlowRelation.getTargetWorkFlowId());\n+                }\n+                workFlowRelations.addAll(workFlowRelationsTmp);\n+                getWorkFlowRelationRecursion(idsTmp, workFlowRelations);\n+            }\n+        }\n+        return workFlowRelations;\n+    }\n+\n+    public Map<String, Object> queryWorkFlowLineageByIds(Set<Integer> ids,int projectId) {\n+        Map<String, Object> result = new HashMap<>(5);\n+        List<WorkFlowLineage> workFlowLineageList = workFlowLineageMapper.queryByIds(ids, projectId);\n+        Map<String, Object> workFlowLists = new HashMap<>(5);\n+        Set<Integer> idsV = ids;\n+        if(ids == null || ids.size() == 0){\n+            for(WorkFlowLineage workFlowLineage:workFlowLineageList) {\n+                idsV.add(workFlowLineage.getWorkFlowId());\n+            }\n+        }\n+        List<WorkFlowRelation> workFlowRelations = new ArrayList<>();\n+        getWorkFlowRelationRecursion(idsV, workFlowRelations);\n+\n+        Set<Integer> idSet = new HashSet<>();\n+        //\u5982\u679c\u4f20\u5165\u53c2\u6570\u4e0d\u4e3a\u7a7a\uff0c\u5219\u9700\u8981\u8865\u5145\u4e0b\u6e38\u5de5\u4f5c\u6d41\u660e\u7ec6\u5c5e\u6027", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2OTAxNA=="}, "originalCommit": {"oid": "3be09b0eccb75323336056aa3cf9e87856141c83"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3532, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}