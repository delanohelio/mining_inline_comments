{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5OTcxNDM4", "number": 1881, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxMDoyNzozNVrODcda8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NToyMVrODc6f7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTY4NzU1OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxMDoyNzozNVrOFkhEuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNzowODozNFrOFkn73A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDkzOQ==", "bodyText": "datasource -> dataSource", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373834939", "createdAt": "2020-02-02T10:27:35Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0NzM1Ng==", "bodyText": "thx, let me fix it", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373947356", "createdAt": "2020-02-03T07:08:34Z", "author": {"login": "wen-hemin"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDkzOQ=="}, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTY4Nzg0OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxMDoyODoxOVrOFkhE4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNzowODo0N1rOFkn8CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDk3Nw==", "bodyText": "datatarget -> dataTarget", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373834977", "createdAt": "2020-02-02T10:28:19Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0NzQwMA==", "bodyText": "thx, let me fix it", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373947400", "createdAt": "2020-02-03T07:08:47Z", "author": {"login": "wen-hemin"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDk3Nw=="}, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTY5MTQzOnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxMDozNjo1NlrOFkhGrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNzoxNDozOFrOFkoBkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQzNw==", "bodyText": "Whether these two if condition are considered to be combined into one\uff1f", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373835437", "createdAt": "2020-02-02T10:36:56Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;\n+\n+    /**\n+     * sql\n+     */\n+    private String sql;\n+\n+    /**\n+     * target table\n+     */\n+    private String targetTable;\n+\n+    /**\n+     * Pre Statements\n+     */\n+    private List<String> preStatements;\n+\n+    /**\n+     * Post Statements\n+     */\n+    private List<String> postStatements;\n+\n+    /**\n+     * speed byte num\n+     */\n+    private int jobSpeedByte;\n+\n+    /**\n+     * speed record count\n+     */\n+    private int jobSpeedRecord;\n+\n+    public String getDsType() {\n+        return dsType;\n+    }\n+\n+    public void setDsType(String dsType) {\n+        this.dsType = dsType;\n+    }\n+\n+    public int getDatasource() {\n+        return datasource;\n+    }\n+\n+    public void setDatasource(int datasource) {\n+        this.datasource = datasource;\n+    }\n+\n+    public String getDtType() {\n+        return dtType;\n+    }\n+\n+    public void setDtType(String dtType) {\n+        this.dtType = dtType;\n+    }\n+\n+    public int getDatatarget() {\n+        return datatarget;\n+    }\n+\n+    public void setDatatarget(int datatarget) {\n+        this.datatarget = datatarget;\n+    }\n+\n+    public String getSql() {\n+        return sql;\n+    }\n+\n+    public void setSql(String sql) {\n+        this.sql = sql;\n+    }\n+\n+    public String getTargetTable() {\n+        return targetTable;\n+    }\n+\n+    public void setTargetTable(String targetTable) {\n+        this.targetTable = targetTable;\n+    }\n+\n+    public List<String> getPreStatements() {\n+        return preStatements;\n+    }\n+\n+    public void setPreStatements(List<String> preStatements) {\n+        this.preStatements = preStatements;\n+    }\n+\n+    public List<String> getPostStatements() {\n+        return postStatements;\n+    }\n+\n+    public void setPostStatements(List<String> postStatements) {\n+        this.postStatements = postStatements;\n+    }\n+\n+    public int getJobSpeedByte() {\n+        return jobSpeedByte;\n+    }\n+\n+    public void setJobSpeedByte(int jobSpeedByte) {\n+        this.jobSpeedByte = jobSpeedByte;\n+    }\n+\n+    public int getJobSpeedRecord() {\n+        return jobSpeedRecord;\n+    }\n+\n+    public void setJobSpeedRecord(int jobSpeedRecord) {\n+        this.jobSpeedRecord = jobSpeedRecord;\n+    }\n+\n+    @Override\n+    public boolean checkParameters() {\n+        if (!(datasource != 0 && StringUtils.isNotEmpty(dsType) && StringUtils.isNotEmpty(sql))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0ODgxOA==", "bodyText": "thx, let me fix it", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373948818", "createdAt": "2020-02-03T07:14:38Z", "author": {"login": "wen-hemin"}, "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;\n+\n+    /**\n+     * sql\n+     */\n+    private String sql;\n+\n+    /**\n+     * target table\n+     */\n+    private String targetTable;\n+\n+    /**\n+     * Pre Statements\n+     */\n+    private List<String> preStatements;\n+\n+    /**\n+     * Post Statements\n+     */\n+    private List<String> postStatements;\n+\n+    /**\n+     * speed byte num\n+     */\n+    private int jobSpeedByte;\n+\n+    /**\n+     * speed record count\n+     */\n+    private int jobSpeedRecord;\n+\n+    public String getDsType() {\n+        return dsType;\n+    }\n+\n+    public void setDsType(String dsType) {\n+        this.dsType = dsType;\n+    }\n+\n+    public int getDatasource() {\n+        return datasource;\n+    }\n+\n+    public void setDatasource(int datasource) {\n+        this.datasource = datasource;\n+    }\n+\n+    public String getDtType() {\n+        return dtType;\n+    }\n+\n+    public void setDtType(String dtType) {\n+        this.dtType = dtType;\n+    }\n+\n+    public int getDatatarget() {\n+        return datatarget;\n+    }\n+\n+    public void setDatatarget(int datatarget) {\n+        this.datatarget = datatarget;\n+    }\n+\n+    public String getSql() {\n+        return sql;\n+    }\n+\n+    public void setSql(String sql) {\n+        this.sql = sql;\n+    }\n+\n+    public String getTargetTable() {\n+        return targetTable;\n+    }\n+\n+    public void setTargetTable(String targetTable) {\n+        this.targetTable = targetTable;\n+    }\n+\n+    public List<String> getPreStatements() {\n+        return preStatements;\n+    }\n+\n+    public void setPreStatements(List<String> preStatements) {\n+        this.preStatements = preStatements;\n+    }\n+\n+    public List<String> getPostStatements() {\n+        return postStatements;\n+    }\n+\n+    public void setPostStatements(List<String> postStatements) {\n+        this.postStatements = postStatements;\n+    }\n+\n+    public int getJobSpeedByte() {\n+        return jobSpeedByte;\n+    }\n+\n+    public void setJobSpeedByte(int jobSpeedByte) {\n+        this.jobSpeedByte = jobSpeedByte;\n+    }\n+\n+    public int getJobSpeedRecord() {\n+        return jobSpeedRecord;\n+    }\n+\n+    public void setJobSpeedRecord(int jobSpeedRecord) {\n+        this.jobSpeedRecord = jobSpeedRecord;\n+    }\n+\n+    @Override\n+    public boolean checkParameters() {\n+        if (!(datasource != 0 && StringUtils.isNotEmpty(dsType) && StringUtils.isNotEmpty(sql))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQzNw=="}, "originalCommit": {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQxNjI2OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozNDoxNFrOFlNZIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMzo0Mjo0OVrOFlUZvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTA1Nw==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374561057", "createdAt": "2020-02-04T09:34:14Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "diffHunk": "@@ -84,9 +99,10 @@ public void testConvertKeywordsColumns() throws Exception {\n      */\n     @Test\n     public void testDoConvertKeywordsColumn() throws Exception {\n-        String fromColumn = \" \\\"`select`\\\" \";\n-        String targetColumn = \"`select`\";\n-\n-        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, fromColumn), targetColumn);\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, \" \\\"`select`\\\" \"), \"`select`\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3NTkwMA==", "bodyText": "thx, I fixed", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374675900", "createdAt": "2020-02-04T13:42:49Z", "author": {"login": "wen-hemin"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "diffHunk": "@@ -84,9 +99,10 @@ public void testConvertKeywordsColumns() throws Exception {\n      */\n     @Test\n     public void testDoConvertKeywordsColumn() throws Exception {\n-        String fromColumn = \" \\\"`select`\\\" \";\n-        String targetColumn = \"`select`\";\n-\n-        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, fromColumn), targetColumn);\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, \" \\\"`select`\\\" \"), \"`select`\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTA1Nw=="}, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQxODA5OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozNDo0OFrOFlNaTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozNDo0OFrOFlNaTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTM1OQ==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params, from 102-105 lines.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374561359", "createdAt": "2020-02-04T09:34:48Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "diffHunk": "@@ -84,9 +99,10 @@ public void testConvertKeywordsColumns() throws Exception {\n      */\n     @Test\n     public void testDoConvertKeywordsColumn() throws Exception {\n-        String fromColumn = \" \\\"`select`\\\" \";\n-        String targetColumn = \"`select`\";\n-\n-        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, fromColumn), targetColumn);\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, \" \\\"`select`\\\" \"), \"`select`\");\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.POSTGRESQL, \" \\\"`select`\\\" \"), \"\\\"select\\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQ0NTM5OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0MzoyMFrOFlNq0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0MzoyMFrOFlNq0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NTU4NA==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374565584", "createdAt": "2020-02-04T09:43:20Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQ0NzI1OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0Mzo1NVrOFlNsFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0Mzo1NVrOFlNsFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NTkxMQ==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374565911", "createdAt": "2020-02-04T09:43:55Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQ0ODAwOnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NDoxMFrOFlNsjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NDoxMFrOFlNsjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjAyOQ==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566029", "createdAt": "2020-02-04T09:44:10Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQ0ODQ3OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NDoxOVrOFlNs1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NDoxOVrOFlNs1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjEwMA==", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566100", "createdAt": "2020-02-04T09:44:19Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);\n+\n+            JSONObject writer = (JSONObject) content.get(\"writer\");\n+            Assert.assertNotNull(writer);\n+\n+            String writerPluginName = (String) writer.get(\"name\");\n+            Assert.assertEquals(writerPluginName, DataxUtils.DATAX_WRITER_PLUGIN_MYSQL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjQ1MTY3OnYy", "diffSide": "RIGHT", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NToyMVrOFlNu6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0NToyMVrOFlNu6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjYzNQ==", "bodyText": "this Test no assert?", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566635", "createdAt": "2020-02-04T09:45:21Z", "author": {"login": "Eights-Li"}, "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);\n+\n+            JSONObject writer = (JSONObject) content.get(\"writer\");\n+            Assert.assertNotNull(writer);\n+\n+            String writerPluginName = (String) writer.get(\"name\");\n+            Assert.assertEquals(writerPluginName, DataxUtils.DATAX_WRITER_PLUGIN_MYSQL);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobSettingJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobSettingJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobSettingJson\");\n+            method.setAccessible(true);\n+            JSONObject setting = (JSONObject) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(setting);\n+            Assert.assertNotNull(setting.get(\"speed\"));\n+            Assert.assertNotNull(setting.get(\"errorLimit\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxCoreJson()\n+     */\n+    @Test\n+    public void testBuildDataxCoreJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxCoreJson\");\n+            method.setAccessible(true);\n+            JSONObject coreConfig = (JSONObject) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(coreConfig);\n+            Assert.assertNotNull(coreConfig.get(\"transport\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildShellCommandFile(String jobConfigFilePath)\n+     */\n+    @Test\n+    public void testBuildShellCommandFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildShellCommandFile\", String.class);\n+            method.setAccessible(true);\n+            Assert.assertNotNull(method.invoke(dataxTask, \"test.json\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: getParameters\n+     */\n+    @Test\n+    public void testGetParameters()\n+            throws Exception {\n+        Assert.assertTrue(dataxTask.getParameters() != null);\n+    }\n+\n+    /**\n+     * Method: notNull(Object obj, String message)\n+     */\n+    @Test\n+    public void testNotNull()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"notNull\", Object.class, String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49"}, "originalPosition": 336}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3425, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}