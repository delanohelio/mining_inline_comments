{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3Nzk2Mjgy", "number": 4042, "title": "[FIX-3900][server] kill multi yarn app in one job", "bodyText": "What is the purpose of the pull request\nfix #3900 kill multi yarn app in one job\nBrief change log\n\nmodify server/utils/ProcessUtils.java  cancelApplication method\n\nVerify this pull request\n\nserver/utils/ProcessUtilsTest to verify this pr", "createdAt": "2020-11-09T14:18:20Z", "url": "https://github.com/apache/dolphinscheduler/pull/4042", "merged": true, "mergeCommit": {"oid": "368d3e8968c391c17c5ea12821bc9570bca8e9ee"}, "closed": true, "closedAt": "2020-11-22T14:30:28Z", "author": {"login": "Eights-Li"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABda1QXxgH2gAyNTE3Nzk2MjgyOjhmZGQ2ZjU0N2QwZGU4ODQ5M2UwNTUzODFmODk0ZTMyMjNlYTI1MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfBcjlgFqTUzNjA2NzYyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8fdd6f547d0de88493e055381f894e3223ea2526", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/8fdd6f547d0de88493e055381f894e3223ea2526", "committedDate": "2020-11-09T14:02:07Z", "message": "fix #3900 kill multi yarn app in one job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cad271749474af505357e7f21cdd1402ebc3921", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/2cad271749474af505357e7f21cdd1402ebc3921", "committedDate": "2020-11-11T14:58:51Z", "message": "add ProcessUtils UT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "134cef36ffc16cb82776be434f5244e5cac803f1", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/134cef36ffc16cb82776be434f5244e5cac803f1", "committedDate": "2020-11-12T04:17:49Z", "message": "Merge branch 'dev' of https://github.com/apache/incubator-dolphinscheduler into dev"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12801559562aba95134581c4a3e76c1cf7270e77", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/12801559562aba95134581c4a3e76c1cf7270e77", "committedDate": "2020-11-12T04:18:52Z", "message": "add ProcessUtils UT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NzgyMzEy", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-528782312", "createdAt": "2020-11-12T06:31:39Z", "commit": {"oid": "12801559562aba95134581c4a3e76c1cf7270e77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjozMTo0MFrOHxsQjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjozMTo0MFrOHxsQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2NzQwNA==", "bodyText": "i think we should reduce its cognitive complexity here.", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r521867404", "createdAt": "2020-11-12T06:31:40Z", "author": {"login": "lenboo"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,385 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n-    }\n-    if (allowAmbiguousCommands) {\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n+            if (value != null) {\n+                allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n+            }\n+        }\n+        if (allowAmbiguousCommands) {\n \n-      String executablePath = new File(cmd[0]).getPath();\n+            String executablePath = new File(cmd[0]).getPath();\n \n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n \n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n-        }\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n \n-        cmd = getTokensFromCommand(join.toString());\n-        executablePath = getExecutablePath(cmd[0]);\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n \n-        // Check new executable name once more\n-        if (security != null) {\n-          security.checkExec(executablePath);\n-        }\n-      }\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n \n-      cmdstr = createCommandLine(\n+            cmdstr = createCommandLine(\n \n-              isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n-    }\n-    return cmdstr;\n-  }\n-\n-  /**\n-   * get executable path.\n-   *\n-   * @param path path\n-   * @return executable path\n-   */\n-  private static String getExecutablePath(String path) {\n-    boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n-\n-    File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n-    return fileToRun.getPath();\n-  }\n-\n-  /**\n-   * whether is shell file.\n-   *\n-   * @param executablePath executable path\n-   * @return true if endsWith .CMD or .BAT\n-   */\n-  private static boolean isShellFile(String executablePath) {\n-    String upPath = executablePath.toUpperCase();\n-    return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n-  }\n-\n-  /**\n-   * quote string.\n-   *\n-   * @param arg argument\n-   * @return format arg\n-   */\n-  private static String quoteString(String arg) {\n-    StringBuilder argbuf = new StringBuilder(arg.length() + 2);\n-    return argbuf.append('\"').append(arg).append('\"').toString();\n-  }\n-\n-  /**\n-   * get tokens from command.\n-   *\n-   * @param command command\n-   * @return token string array\n-   */\n-  private static String[] getTokensFromCommand(String command) {\n-    ArrayList<String> matchList = new ArrayList<>(8);\n-    Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n-    while (regexMatcher.find()) {\n-      matchList.add(regexMatcher.group());\n-    }\n-    return matchList.toArray(new String[matchList.size()]);\n-  }\n-\n-  /**\n-   * Lazy Pattern.\n-   */\n-  private static class LazyPattern {\n-    // Escape-support version:\n-    // \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n-    private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n-  }\n-\n-  /**\n-   * verification cmd bat.\n-   */\n-  private static final int VERIFICATION_CMD_BAT = 0;\n-\n-  /**\n-   * verification win32.\n-   */\n-  private static final int VERIFICATION_WIN32 = 1;\n-\n-  /**\n-   * verification legacy.\n-   */\n-  private static final int VERIFICATION_LEGACY = 2;\n-\n-  /**\n-   * escape verification.\n-   */\n-  private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n-\n-    {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n-\n-  /**\n-   * create command line.\n-   * @param verificationType  verification type\n-   * @param executablePath    executable path\n-   * @param cmd               cmd\n-   * @return command line\n-   */\n-  private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n-    StringBuilder cmdbuf = new StringBuilder(80);\n-\n-    cmdbuf.append(executablePath);\n-\n-    for (int i = 1; i < cmd.length; ++i) {\n-      cmdbuf.append(' ');\n-      String s = cmd[i];\n-      if (needsEscaping(verificationType, s)) {\n-        cmdbuf.append('\"').append(s);\n-\n-        if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n-          cmdbuf.append('\\\\');\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n         }\n-        cmdbuf.append('\"');\n-      } else {\n-        cmdbuf.append(s);\n-      }\n+        return cmdstr;\n     }\n-    return cmdbuf.toString();\n-  }\n-\n-  /**\n-   * whether is quoted.\n-   * @param noQuotesInside\n-   * @param arg\n-   * @param errorMessage\n-   * @return boolean\n-   */\n-  private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n-    int lastPos = arg.length() - 1;\n-    if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n-      // The argument has already been quoted.\n-      if (noQuotesInside) {\n-        if (arg.indexOf('\"', 1) != lastPos) {\n-          // There is [\"] inside.\n-          throw new IllegalArgumentException(errorMessage);\n-        }\n-      }\n-      return true;\n+\n+    /**\n+     * get executable path.\n+     *\n+     * @param path path\n+     * @return executable path\n+     */\n+    private static String getExecutablePath(String path) {\n+        boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n+\n+        File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n+        return fileToRun.getPath();\n     }\n-    if (noQuotesInside) {\n-      if (arg.indexOf('\"') >= 0) {\n-        // There is [\"] inside.\n-        throw new IllegalArgumentException(errorMessage);\n-      }\n+\n+    /**\n+     * whether is shell file.\n+     *\n+     * @param executablePath executable path\n+     * @return true if endsWith .CMD or .BAT\n+     */\n+    private static boolean isShellFile(String executablePath) {\n+        String upPath = executablePath.toUpperCase();\n+        return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n     }\n-    return false;\n-  }\n-\n-  /**\n-   * whether needs escaping.\n-   *\n-   * @param verificationType  verification type\n-   * @param arg               arg\n-   * @return boolean\n-   */\n-  private static boolean needsEscaping(int verificationType, String arg) {\n-\n-    boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n-\n-    if (!argIsQuoted) {\n-      char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n-      for (int i = 0; i < testEscape.length; ++i) {\n-        if (arg.indexOf(testEscape[i]) >= 0) {\n-          return true;\n-        }\n-      }\n+\n+    /**\n+     * quote string.\n+     *\n+     * @param arg argument\n+     * @return format arg\n+     */\n+    private static String quoteString(String arg) {\n+        return '\"' + arg + '\"';\n     }\n-    return false;\n-  }\n-\n-  /**\n-   * kill yarn application.\n-   *\n-   * @param appIds      app id list\n-   * @param logger      logger\n-   * @param tenantCode  tenant code\n-   * @param executePath     execute path\n-   */\n-  public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n-    if (appIds.size() > 0) {\n-      String appid = appIds.get(appIds.size() - 1);\n-      String commandFile = String\n-              .format(\"%s/%s.kill\", executePath, appid);\n-      String cmd = \"yarn application -kill \" + appid;\n-      try {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"#!/bin/sh\\n\");\n-        sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n-        sb.append(\"cd $BASEDIR\\n\");\n-        if (CommonUtils.getSystemEnvPath() != null) {\n-          sb.append(\"source \" + CommonUtils.getSystemEnvPath() + \"\\n\");\n+\n+    /**\n+     * get tokens from command.\n+     *\n+     * @param command command\n+     * @return token string array\n+     */\n+    private static String[] getTokensFromCommand(String command) {\n+        ArrayList<String> matchList = new ArrayList<>(8);\n+        Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n+        while (regexMatcher.find()) {\n+            matchList.add(regexMatcher.group());\n         }\n-        sb.append(\"\\n\\n\");\n-        sb.append(cmd);\n+        return matchList.toArray(new String[0]);\n+    }\n \n-        File f = new File(commandFile);\n+    /**\n+     * Lazy Pattern.\n+     */\n+    private static class LazyPattern {\n+        // Escape-support version:\n+        // \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n+        private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n+    }\n \n-        if (!f.exists()) {\n-          FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+    /**\n+     * verification cmd bat.\n+     */\n+    private static final int VERIFICATION_CMD_BAT = 0;\n+\n+    /**\n+     * verification win32.\n+     */\n+    private static final int VERIFICATION_WIN32 = 1;\n+\n+    /**\n+     * verification legacy.\n+     */\n+    private static final int VERIFICATION_LEGACY = 2;\n+\n+    /**\n+     * escape verification.\n+     */\n+    private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n+\n+        {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n+\n+    /**\n+     * create command line.\n+     *\n+     * @param verificationType verification type\n+     * @param executablePath   executable path\n+     * @param cmd              cmd\n+     * @return command line\n+     */\n+    private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n+        StringBuilder cmdbuf = new StringBuilder(80);\n+\n+        cmdbuf.append(executablePath);\n+\n+        for (int i = 1; i < cmd.length; ++i) {\n+            cmdbuf.append(' ');\n+            String s = cmd[i];\n+            if (needsEscaping(verificationType, s)) {\n+                cmdbuf.append('\"').append(s);\n+\n+                if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n+                    cmdbuf.append('\\\\');\n+                }\n+                cmdbuf.append('\"');\n+            } else {\n+                cmdbuf.append(s);\n+            }\n         }\n+        return cmdbuf.toString();\n+    }\n \n-        String runCmd = \"sh \" + commandFile;\n-        if (StringUtils.isNotEmpty(tenantCode)) {\n-          runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+    /**\n+     * whether is quoted.\n+     *\n+     * @param noQuotesInside no quotes inside\n+     * @param arg            arg\n+     * @param errorMessage   error message\n+     * @return boolean\n+     */\n+    private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n+        int lastPos = arg.length() - 1;\n+        if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n+            // The argument has already been quoted.\n+            if (noQuotesInside) {\n+                if (arg.indexOf('\"', 1) != lastPos) {\n+                    // There is [\"] inside.\n+                    throw new IllegalArgumentException(errorMessage);\n+                }\n+            }\n+            return true;\n+        }\n+        if (noQuotesInside) {\n+            if (arg.indexOf('\"') >= 0) {\n+                // There is [\"] inside.\n+                throw new IllegalArgumentException(errorMessage);\n+            }\n         }\n+        return false;\n+    }\n \n-        logger.info(\"kill cmd:{}\", runCmd);\n+    /**\n+     * whether needs escaping.\n+     *\n+     * @param verificationType verification type\n+     * @param arg              arg\n+     * @return boolean\n+     */\n+    private static boolean needsEscaping(int verificationType, String arg) {\n+\n+        boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n+\n+        if (!argIsQuoted) {\n+            char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n+            for (char c : testEscape) {\n+                if (arg.indexOf(c) >= 0) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n \n-        Runtime.getRuntime().exec(runCmd);\n-      } catch (Exception e) {\n-        logger.error(\"kill application error\", e);\n-      }\n+    /**\n+     * kill yarn application.\n+     *\n+     * @param appIds      app id list\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param executePath execute path\n+     */\n+    public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n+        if (CollectionUtils.isNotEmpty(appIds)) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12801559562aba95134581c4a3e76c1cf7270e77"}, "originalPosition": 507}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4Nzg1MDUz", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-528785053", "createdAt": "2020-11-12T06:38:11Z", "commit": {"oid": "12801559562aba95134581c4a3e76c1cf7270e77"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/aac762a2679014659b71a21b0ffb7e9f9946a3e3", "committedDate": "2020-11-13T08:20:04Z", "message": "modify ProcessUtils & ProcessUtilsTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMTg5MzI1", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-531189325", "createdAt": "2020-11-16T10:23:57Z", "commit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDoyMzo1N1rOHzzhHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDoyMzo1N1rOHzzhHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA4MzQ4NQ==", "bodyText": "magic number here", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r524083485", "createdAt": "2020-11-16T10:23:57Z", "author": {"login": "lenboo"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,406 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = isAllowAmbiguousCommands(security);\n+        if (allowAmbiguousCommands) {\n+\n+            String executablePath = new File(cmd[0]).getPath();\n+\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n+\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n+\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n+\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n+\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n+\n+            cmdstr = createCommandLine(\n+\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+        }\n+        return cmdstr;\n     }\n-    if (allowAmbiguousCommands) {\n-\n-      String executablePath = new File(cmd[0]).getPath();\n-\n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n-\n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n+    /**\n+     * check is allow ambiguous commands\n+     *\n+     * @param security security manager\n+     * @return allow ambiguous command flag\n+     */\n+    private static boolean isAllowAmbiguousCommands(SecurityManager security) {\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMTg5ODU1", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-531189855", "createdAt": "2020-11-16T10:24:38Z", "commit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDoyNDozOFrOHzzkDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDoyNDozOFrOHzzkDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA4NDIzNw==", "bodyText": "also magic number.", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r524084237", "createdAt": "2020-11-16T10:24:38Z", "author": {"login": "lenboo"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,406 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = isAllowAmbiguousCommands(security);\n+        if (allowAmbiguousCommands) {\n+\n+            String executablePath = new File(cmd[0]).getPath();\n+\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n+\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n+\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n+\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n+\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n+\n+            cmdstr = createCommandLine(\n+\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+        }\n+        return cmdstr;\n     }\n-    if (allowAmbiguousCommands) {\n-\n-      String executablePath = new File(cmd[0]).getPath();\n-\n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n-\n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n+    /**\n+     * check is allow ambiguous commands\n+     *\n+     * @param security security manager\n+     * @return allow ambiguous command flag\n+     */\n+    private static boolean isAllowAmbiguousCommands(SecurityManager security) {\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n+            if (value != null) {\n+                allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n+            }\n         }\n+        return allowAmbiguousCommands;\n+    }\n \n-        cmd = getTokensFromCommand(join.toString());\n-        executablePath = getExecutablePath(cmd[0]);\n+    /**\n+     * get executable path.\n+     *\n+     * @param path path\n+     * @return executable path\n+     */\n+    private static String getExecutablePath(String path) {\n+        boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMTkwNDM1", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-531190435", "createdAt": "2020-11-16T10:25:22Z", "commit": {"oid": "aac762a2679014659b71a21b0ffb7e9f9946a3e3"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78445084ef2d9fa23c5ffe59acd04e466e1f4d4e", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/78445084ef2d9fa23c5ffe59acd04e466e1f4d4e", "committedDate": "2020-11-16T12:25:37Z", "message": "Merge branch 'dev' of https://github.com/apache/incubator-dolphinscheduler into dev-kill-yarn-job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/cb669b5900c9382d65c246700e0af44d061c4371", "committedDate": "2020-11-16T12:34:32Z", "message": "deal with magic value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDk2OTI0", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-532096924", "createdAt": "2020-11-17T07:58:20Z", "commit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNzo1ODoyMVrOH0oNxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNzo1ODoyMVrOH0oNxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg4NA==", "bodyText": "is this \"sh \" can be instead?\nI can find it elsewhere.", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r524946884", "createdAt": "2020-11-17T07:58:21Z", "author": {"login": "lenboo"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,408 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    private static final String LOCAL_PROCESS_EXEC = \"jdk.lang.Process.allowAmbiguousCommands\";\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = isAllowAmbiguousCommands(security);\n+        if (allowAmbiguousCommands) {\n+\n+            String executablePath = new File(cmd[0]).getPath();\n+\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n+\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n+\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n+\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n+\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n+\n+            cmdstr = createCommandLine(\n+\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+        }\n+        return cmdstr;\n     }\n-    if (allowAmbiguousCommands) {\n-\n-      String executablePath = new File(cmd[0]).getPath();\n-\n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n-\n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n+    /**\n+     * check is allow ambiguous commands\n+     *\n+     * @param security security manager\n+     * @return allow ambiguous command flag\n+     */\n+    private static boolean isAllowAmbiguousCommands(SecurityManager security) {\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(LOCAL_PROCESS_EXEC);\n+            if (value != null) {\n+                allowAmbiguousCommands = !Constants.STRING_FALSE.equalsIgnoreCase(value);\n+            }\n         }\n+        return allowAmbiguousCommands;\n+    }\n \n-        cmd = getTokensFromCommand(join.toString());\n-        executablePath = getExecutablePath(cmd[0]);\n+    /**\n+     * get executable path.\n+     *\n+     * @param path path\n+     * @return executable path\n+     */\n+    private static String getExecutablePath(String path) {\n+        boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n+\n+        File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n+        return fileToRun.getPath();\n+    }\n \n-        // Check new executable name once more\n-        if (security != null) {\n-          security.checkExec(executablePath);\n-        }\n-      }\n+    /**\n+     * whether is shell file.\n+     *\n+     * @param executablePath executable path\n+     * @return true if endsWith .CMD or .BAT\n+     */\n+    private static boolean isShellFile(String executablePath) {\n+        String upPath = executablePath.toUpperCase();\n+        return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n+    }\n \n-      cmdstr = createCommandLine(\n+    /**\n+     * quote string.\n+     *\n+     * @param arg argument\n+     * @return format arg\n+     */\n+    private static String quoteString(String arg) {\n+        return '\"' + arg + '\"';\n+    }\n \n-              isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+    /**\n+     * get tokens from command.\n+     *\n+     * @param command command\n+     * @return token string array\n+     */\n+    private static String[] getTokensFromCommand(String command) {\n+        ArrayList<String> matchList = new ArrayList<>(8);\n+        Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n+        while (regexMatcher.find()) {\n+            matchList.add(regexMatcher.group());\n+        }\n+        return matchList.toArray(new String[0]);\n     }\n-    return cmdstr;\n-  }\n-\n-  /**\n-   * get executable path.\n-   *\n-   * @param path path\n-   * @return executable path\n-   */\n-  private static String getExecutablePath(String path) {\n-    boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n-\n-    File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n-    return fileToRun.getPath();\n-  }\n-\n-  /**\n-   * whether is shell file.\n-   *\n-   * @param executablePath executable path\n-   * @return true if endsWith .CMD or .BAT\n-   */\n-  private static boolean isShellFile(String executablePath) {\n-    String upPath = executablePath.toUpperCase();\n-    return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n-  }\n-\n-  /**\n-   * quote string.\n-   *\n-   * @param arg argument\n-   * @return format arg\n-   */\n-  private static String quoteString(String arg) {\n-    StringBuilder argbuf = new StringBuilder(arg.length() + 2);\n-    return argbuf.append('\"').append(arg).append('\"').toString();\n-  }\n-\n-  /**\n-   * get tokens from command.\n-   *\n-   * @param command command\n-   * @return token string array\n-   */\n-  private static String[] getTokensFromCommand(String command) {\n-    ArrayList<String> matchList = new ArrayList<>(8);\n-    Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n-    while (regexMatcher.find()) {\n-      matchList.add(regexMatcher.group());\n+\n+    /**\n+     * Lazy Pattern.\n+     */\n+    private static class LazyPattern {\n+        /**\n+         * Escape-support version:\n+         * \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n+         */\n+        private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n     }\n-    return matchList.toArray(new String[matchList.size()]);\n-  }\n-\n-  /**\n-   * Lazy Pattern.\n-   */\n-  private static class LazyPattern {\n-    // Escape-support version:\n-    // \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n-    private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n-  }\n-\n-  /**\n-   * verification cmd bat.\n-   */\n-  private static final int VERIFICATION_CMD_BAT = 0;\n-\n-  /**\n-   * verification win32.\n-   */\n-  private static final int VERIFICATION_WIN32 = 1;\n-\n-  /**\n-   * verification legacy.\n-   */\n-  private static final int VERIFICATION_LEGACY = 2;\n-\n-  /**\n-   * escape verification.\n-   */\n-  private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n-\n-    {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n-\n-  /**\n-   * create command line.\n-   * @param verificationType  verification type\n-   * @param executablePath    executable path\n-   * @param cmd               cmd\n-   * @return command line\n-   */\n-  private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n-    StringBuilder cmdbuf = new StringBuilder(80);\n-\n-    cmdbuf.append(executablePath);\n-\n-    for (int i = 1; i < cmd.length; ++i) {\n-      cmdbuf.append(' ');\n-      String s = cmd[i];\n-      if (needsEscaping(verificationType, s)) {\n-        cmdbuf.append('\"').append(s);\n-\n-        if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n-          cmdbuf.append('\\\\');\n+\n+    /**\n+     * verification cmd bat.\n+     */\n+    private static final int VERIFICATION_CMD_BAT = 0;\n+\n+    /**\n+     * verification win32.\n+     */\n+    private static final int VERIFICATION_WIN32 = 1;\n+\n+    /**\n+     * verification legacy.\n+     */\n+    private static final int VERIFICATION_LEGACY = 2;\n+\n+    /**\n+     * escape verification.\n+     */\n+    private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n+\n+        {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n+\n+    /**\n+     * create command line.\n+     *\n+     * @param verificationType verification type\n+     * @param executablePath   executable path\n+     * @param cmd              cmd\n+     * @return command line\n+     */\n+    private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n+        StringBuilder cmdbuf = new StringBuilder(80);\n+\n+        cmdbuf.append(executablePath);\n+\n+        for (int i = 1; i < cmd.length; ++i) {\n+            cmdbuf.append(' ');\n+            String s = cmd[i];\n+            if (needsEscaping(verificationType, s)) {\n+                cmdbuf.append('\"').append(s);\n+\n+                if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n+                    cmdbuf.append('\\\\');\n+                }\n+                cmdbuf.append('\"');\n+            } else {\n+                cmdbuf.append(s);\n+            }\n         }\n-        cmdbuf.append('\"');\n-      } else {\n-        cmdbuf.append(s);\n-      }\n+        return cmdbuf.toString();\n     }\n-    return cmdbuf.toString();\n-  }\n-\n-  /**\n-   * whether is quoted.\n-   * @param noQuotesInside\n-   * @param arg\n-   * @param errorMessage\n-   * @return boolean\n-   */\n-  private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n-    int lastPos = arg.length() - 1;\n-    if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n-      // The argument has already been quoted.\n-      if (noQuotesInside) {\n-        if (arg.indexOf('\"', 1) != lastPos) {\n-          // There is [\"] inside.\n-          throw new IllegalArgumentException(errorMessage);\n+\n+    /**\n+     * whether is quoted.\n+     *\n+     * @param noQuotesInside no quotes inside\n+     * @param arg            arg\n+     * @param errorMessage   error message\n+     * @return boolean\n+     */\n+    private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n+        int lastPos = arg.length() - 1;\n+        if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n+            // The argument has already been quoted.\n+            if (noQuotesInside && arg.indexOf('\"', 1) != lastPos) {\n+                // There is [\"] inside.\n+                throw new IllegalArgumentException(errorMessage);\n+            }\n+            return true;\n         }\n-      }\n-      return true;\n-    }\n-    if (noQuotesInside) {\n-      if (arg.indexOf('\"') >= 0) {\n-        // There is [\"] inside.\n-        throw new IllegalArgumentException(errorMessage);\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * whether needs escaping.\n-   *\n-   * @param verificationType  verification type\n-   * @param arg               arg\n-   * @return boolean\n-   */\n-  private static boolean needsEscaping(int verificationType, String arg) {\n-\n-    boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n-\n-    if (!argIsQuoted) {\n-      char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n-      for (int i = 0; i < testEscape.length; ++i) {\n-        if (arg.indexOf(testEscape[i]) >= 0) {\n-          return true;\n+        if (noQuotesInside && arg.indexOf('\"') >= 0) {\n+            // There is [\"] inside.\n+            throw new IllegalArgumentException(errorMessage);\n         }\n-      }\n+        return false;\n     }\n-    return false;\n-  }\n-\n-  /**\n-   * kill yarn application.\n-   *\n-   * @param appIds      app id list\n-   * @param logger      logger\n-   * @param tenantCode  tenant code\n-   * @param executePath     execute path\n-   */\n-  public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n-    if (appIds.size() > 0) {\n-      String appid = appIds.get(appIds.size() - 1);\n-      String commandFile = String\n-              .format(\"%s/%s.kill\", executePath, appid);\n-      String cmd = \"yarn application -kill \" + appid;\n-      try {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"#!/bin/sh\\n\");\n-        sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n-        sb.append(\"cd $BASEDIR\\n\");\n-        if (CommonUtils.getSystemEnvPath() != null) {\n-          sb.append(\"source \" + CommonUtils.getSystemEnvPath() + \"\\n\");\n-        }\n-        sb.append(\"\\n\\n\");\n-        sb.append(cmd);\n-\n-        File f = new File(commandFile);\n \n-        if (!f.exists()) {\n-          FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+    /**\n+     * whether needs escaping.\n+     *\n+     * @param verificationType verification type\n+     * @param arg              arg\n+     * @return boolean\n+     */\n+    private static boolean needsEscaping(int verificationType, String arg) {\n+\n+        boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n+\n+        if (!argIsQuoted) {\n+            char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n+            for (char c : testEscape) {\n+                if (arg.indexOf(c) >= 0) {\n+                    return true;\n+                }\n+            }\n         }\n+        return false;\n+    }\n \n-        String runCmd = \"sh \" + commandFile;\n-        if (StringUtils.isNotEmpty(tenantCode)) {\n-          runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+    /**\n+     * kill yarn application.\n+     *\n+     * @param appIds      app id list\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param executePath execute path\n+     */\n+    public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n+        if (CollectionUtils.isNotEmpty(appIds)) {\n+\n+            for (String appId : appIds) {\n+                try {\n+                    ExecutionStatus applicationStatus = HadoopUtils.getInstance().getApplicationStatus(appId);\n+\n+                    if (!applicationStatus.typeIsFinished()) {\n+                        String commandFile = String\n+                            .format(\"%s/%s.kill\", executePath, appId);\n+                        String cmd = \"yarn application -kill \" + appId;\n+                        execYarnKillCommand(logger, tenantCode, appId, commandFile, cmd);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(String.format(\"Get yarn application app id [%s] status failed: [%s]\", appId, e.getMessage()));\n+                }\n+            }\n         }\n+    }\n \n-        logger.info(\"kill cmd:{}\", runCmd);\n-\n-        Runtime.getRuntime().exec(runCmd);\n-      } catch (Exception e) {\n-        logger.error(\"kill application error\", e);\n-      }\n+    /**\n+     * build kill command for yarn application\n+     *\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param appId       app id\n+     * @param commandFile command file\n+     * @param cmd         cmd\n+     */\n+    private static void execYarnKillCommand(Logger logger, String tenantCode, String appId, String commandFile, String cmd) {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"#!/bin/sh\\n\");\n+            sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n+            sb.append(\"cd $BASEDIR\\n\");\n+            if (CommonUtils.getSystemEnvPath() != null) {\n+                sb.append(\"source \").append(CommonUtils.getSystemEnvPath()).append(\"\\n\");\n+            }\n+            sb.append(\"\\n\\n\");\n+            sb.append(cmd);\n+\n+            File f = new File(commandFile);\n+\n+            if (!f.exists()) {\n+                FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+            }\n+\n+            String runCmd = \"sh \" + commandFile;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371"}, "originalPosition": 565}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTAzMTAw", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-532103100", "createdAt": "2020-11-17T08:01:57Z", "commit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODowMTo1N1rOH0oU9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODowMTo1N1rOH0oU9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0ODcyNw==", "bodyText": "i think this \"pstree \" can be extracted to one variable,  then I can easily replace this variable.", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r524948727", "createdAt": "2020-11-17T08:01:57Z", "author": {"login": "lenboo"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,408 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    private static final String LOCAL_PROCESS_EXEC = \"jdk.lang.Process.allowAmbiguousCommands\";\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = isAllowAmbiguousCommands(security);\n+        if (allowAmbiguousCommands) {\n+\n+            String executablePath = new File(cmd[0]).getPath();\n+\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n+\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n+\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n+\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n+\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n+\n+            cmdstr = createCommandLine(\n+\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+        }\n+        return cmdstr;\n     }\n-    if (allowAmbiguousCommands) {\n-\n-      String executablePath = new File(cmd[0]).getPath();\n-\n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n-\n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n+    /**\n+     * check is allow ambiguous commands\n+     *\n+     * @param security security manager\n+     * @return allow ambiguous command flag\n+     */\n+    private static boolean isAllowAmbiguousCommands(SecurityManager security) {\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(LOCAL_PROCESS_EXEC);\n+            if (value != null) {\n+                allowAmbiguousCommands = !Constants.STRING_FALSE.equalsIgnoreCase(value);\n+            }\n         }\n+        return allowAmbiguousCommands;\n+    }\n \n-        cmd = getTokensFromCommand(join.toString());\n-        executablePath = getExecutablePath(cmd[0]);\n+    /**\n+     * get executable path.\n+     *\n+     * @param path path\n+     * @return executable path\n+     */\n+    private static String getExecutablePath(String path) {\n+        boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n+\n+        File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n+        return fileToRun.getPath();\n+    }\n \n-        // Check new executable name once more\n-        if (security != null) {\n-          security.checkExec(executablePath);\n-        }\n-      }\n+    /**\n+     * whether is shell file.\n+     *\n+     * @param executablePath executable path\n+     * @return true if endsWith .CMD or .BAT\n+     */\n+    private static boolean isShellFile(String executablePath) {\n+        String upPath = executablePath.toUpperCase();\n+        return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n+    }\n \n-      cmdstr = createCommandLine(\n+    /**\n+     * quote string.\n+     *\n+     * @param arg argument\n+     * @return format arg\n+     */\n+    private static String quoteString(String arg) {\n+        return '\"' + arg + '\"';\n+    }\n \n-              isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+    /**\n+     * get tokens from command.\n+     *\n+     * @param command command\n+     * @return token string array\n+     */\n+    private static String[] getTokensFromCommand(String command) {\n+        ArrayList<String> matchList = new ArrayList<>(8);\n+        Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n+        while (regexMatcher.find()) {\n+            matchList.add(regexMatcher.group());\n+        }\n+        return matchList.toArray(new String[0]);\n     }\n-    return cmdstr;\n-  }\n-\n-  /**\n-   * get executable path.\n-   *\n-   * @param path path\n-   * @return executable path\n-   */\n-  private static String getExecutablePath(String path) {\n-    boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n-\n-    File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n-    return fileToRun.getPath();\n-  }\n-\n-  /**\n-   * whether is shell file.\n-   *\n-   * @param executablePath executable path\n-   * @return true if endsWith .CMD or .BAT\n-   */\n-  private static boolean isShellFile(String executablePath) {\n-    String upPath = executablePath.toUpperCase();\n-    return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n-  }\n-\n-  /**\n-   * quote string.\n-   *\n-   * @param arg argument\n-   * @return format arg\n-   */\n-  private static String quoteString(String arg) {\n-    StringBuilder argbuf = new StringBuilder(arg.length() + 2);\n-    return argbuf.append('\"').append(arg).append('\"').toString();\n-  }\n-\n-  /**\n-   * get tokens from command.\n-   *\n-   * @param command command\n-   * @return token string array\n-   */\n-  private static String[] getTokensFromCommand(String command) {\n-    ArrayList<String> matchList = new ArrayList<>(8);\n-    Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n-    while (regexMatcher.find()) {\n-      matchList.add(regexMatcher.group());\n+\n+    /**\n+     * Lazy Pattern.\n+     */\n+    private static class LazyPattern {\n+        /**\n+         * Escape-support version:\n+         * \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n+         */\n+        private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n     }\n-    return matchList.toArray(new String[matchList.size()]);\n-  }\n-\n-  /**\n-   * Lazy Pattern.\n-   */\n-  private static class LazyPattern {\n-    // Escape-support version:\n-    // \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n-    private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n-  }\n-\n-  /**\n-   * verification cmd bat.\n-   */\n-  private static final int VERIFICATION_CMD_BAT = 0;\n-\n-  /**\n-   * verification win32.\n-   */\n-  private static final int VERIFICATION_WIN32 = 1;\n-\n-  /**\n-   * verification legacy.\n-   */\n-  private static final int VERIFICATION_LEGACY = 2;\n-\n-  /**\n-   * escape verification.\n-   */\n-  private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n-\n-    {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n-\n-  /**\n-   * create command line.\n-   * @param verificationType  verification type\n-   * @param executablePath    executable path\n-   * @param cmd               cmd\n-   * @return command line\n-   */\n-  private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n-    StringBuilder cmdbuf = new StringBuilder(80);\n-\n-    cmdbuf.append(executablePath);\n-\n-    for (int i = 1; i < cmd.length; ++i) {\n-      cmdbuf.append(' ');\n-      String s = cmd[i];\n-      if (needsEscaping(verificationType, s)) {\n-        cmdbuf.append('\"').append(s);\n-\n-        if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n-          cmdbuf.append('\\\\');\n+\n+    /**\n+     * verification cmd bat.\n+     */\n+    private static final int VERIFICATION_CMD_BAT = 0;\n+\n+    /**\n+     * verification win32.\n+     */\n+    private static final int VERIFICATION_WIN32 = 1;\n+\n+    /**\n+     * verification legacy.\n+     */\n+    private static final int VERIFICATION_LEGACY = 2;\n+\n+    /**\n+     * escape verification.\n+     */\n+    private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n+\n+        {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n+\n+    /**\n+     * create command line.\n+     *\n+     * @param verificationType verification type\n+     * @param executablePath   executable path\n+     * @param cmd              cmd\n+     * @return command line\n+     */\n+    private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n+        StringBuilder cmdbuf = new StringBuilder(80);\n+\n+        cmdbuf.append(executablePath);\n+\n+        for (int i = 1; i < cmd.length; ++i) {\n+            cmdbuf.append(' ');\n+            String s = cmd[i];\n+            if (needsEscaping(verificationType, s)) {\n+                cmdbuf.append('\"').append(s);\n+\n+                if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n+                    cmdbuf.append('\\\\');\n+                }\n+                cmdbuf.append('\"');\n+            } else {\n+                cmdbuf.append(s);\n+            }\n         }\n-        cmdbuf.append('\"');\n-      } else {\n-        cmdbuf.append(s);\n-      }\n+        return cmdbuf.toString();\n     }\n-    return cmdbuf.toString();\n-  }\n-\n-  /**\n-   * whether is quoted.\n-   * @param noQuotesInside\n-   * @param arg\n-   * @param errorMessage\n-   * @return boolean\n-   */\n-  private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n-    int lastPos = arg.length() - 1;\n-    if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n-      // The argument has already been quoted.\n-      if (noQuotesInside) {\n-        if (arg.indexOf('\"', 1) != lastPos) {\n-          // There is [\"] inside.\n-          throw new IllegalArgumentException(errorMessage);\n+\n+    /**\n+     * whether is quoted.\n+     *\n+     * @param noQuotesInside no quotes inside\n+     * @param arg            arg\n+     * @param errorMessage   error message\n+     * @return boolean\n+     */\n+    private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n+        int lastPos = arg.length() - 1;\n+        if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n+            // The argument has already been quoted.\n+            if (noQuotesInside && arg.indexOf('\"', 1) != lastPos) {\n+                // There is [\"] inside.\n+                throw new IllegalArgumentException(errorMessage);\n+            }\n+            return true;\n         }\n-      }\n-      return true;\n-    }\n-    if (noQuotesInside) {\n-      if (arg.indexOf('\"') >= 0) {\n-        // There is [\"] inside.\n-        throw new IllegalArgumentException(errorMessage);\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * whether needs escaping.\n-   *\n-   * @param verificationType  verification type\n-   * @param arg               arg\n-   * @return boolean\n-   */\n-  private static boolean needsEscaping(int verificationType, String arg) {\n-\n-    boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n-\n-    if (!argIsQuoted) {\n-      char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n-      for (int i = 0; i < testEscape.length; ++i) {\n-        if (arg.indexOf(testEscape[i]) >= 0) {\n-          return true;\n+        if (noQuotesInside && arg.indexOf('\"') >= 0) {\n+            // There is [\"] inside.\n+            throw new IllegalArgumentException(errorMessage);\n         }\n-      }\n+        return false;\n     }\n-    return false;\n-  }\n-\n-  /**\n-   * kill yarn application.\n-   *\n-   * @param appIds      app id list\n-   * @param logger      logger\n-   * @param tenantCode  tenant code\n-   * @param executePath     execute path\n-   */\n-  public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n-    if (appIds.size() > 0) {\n-      String appid = appIds.get(appIds.size() - 1);\n-      String commandFile = String\n-              .format(\"%s/%s.kill\", executePath, appid);\n-      String cmd = \"yarn application -kill \" + appid;\n-      try {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"#!/bin/sh\\n\");\n-        sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n-        sb.append(\"cd $BASEDIR\\n\");\n-        if (CommonUtils.getSystemEnvPath() != null) {\n-          sb.append(\"source \" + CommonUtils.getSystemEnvPath() + \"\\n\");\n-        }\n-        sb.append(\"\\n\\n\");\n-        sb.append(cmd);\n-\n-        File f = new File(commandFile);\n \n-        if (!f.exists()) {\n-          FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+    /**\n+     * whether needs escaping.\n+     *\n+     * @param verificationType verification type\n+     * @param arg              arg\n+     * @return boolean\n+     */\n+    private static boolean needsEscaping(int verificationType, String arg) {\n+\n+        boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n+\n+        if (!argIsQuoted) {\n+            char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n+            for (char c : testEscape) {\n+                if (arg.indexOf(c) >= 0) {\n+                    return true;\n+                }\n+            }\n         }\n+        return false;\n+    }\n \n-        String runCmd = \"sh \" + commandFile;\n-        if (StringUtils.isNotEmpty(tenantCode)) {\n-          runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+    /**\n+     * kill yarn application.\n+     *\n+     * @param appIds      app id list\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param executePath execute path\n+     */\n+    public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n+        if (CollectionUtils.isNotEmpty(appIds)) {\n+\n+            for (String appId : appIds) {\n+                try {\n+                    ExecutionStatus applicationStatus = HadoopUtils.getInstance().getApplicationStatus(appId);\n+\n+                    if (!applicationStatus.typeIsFinished()) {\n+                        String commandFile = String\n+                            .format(\"%s/%s.kill\", executePath, appId);\n+                        String cmd = \"yarn application -kill \" + appId;\n+                        execYarnKillCommand(logger, tenantCode, appId, commandFile, cmd);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(String.format(\"Get yarn application app id [%s] status failed: [%s]\", appId, e.getMessage()));\n+                }\n+            }\n         }\n+    }\n \n-        logger.info(\"kill cmd:{}\", runCmd);\n-\n-        Runtime.getRuntime().exec(runCmd);\n-      } catch (Exception e) {\n-        logger.error(\"kill application error\", e);\n-      }\n+    /**\n+     * build kill command for yarn application\n+     *\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param appId       app id\n+     * @param commandFile command file\n+     * @param cmd         cmd\n+     */\n+    private static void execYarnKillCommand(Logger logger, String tenantCode, String appId, String commandFile, String cmd) {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"#!/bin/sh\\n\");\n+            sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n+            sb.append(\"cd $BASEDIR\\n\");\n+            if (CommonUtils.getSystemEnvPath() != null) {\n+                sb.append(\"source \").append(CommonUtils.getSystemEnvPath()).append(\"\\n\");\n+            }\n+            sb.append(\"\\n\\n\");\n+            sb.append(cmd);\n+\n+            File f = new File(commandFile);\n+\n+            if (!f.exists()) {\n+                FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+            }\n+\n+            String runCmd = \"sh \" + commandFile;\n+            if (StringUtils.isNotEmpty(tenantCode)) {\n+                runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+            }\n+\n+            logger.info(\"kill cmd:{}\", runCmd);\n+            Runtime.getRuntime().exec(runCmd);\n+        } catch (Exception e) {\n+            logger.error(String.format(\"Kill yarn application app id [%s] failed: [%s]\", appId, e.getMessage()));\n+        }\n     }\n-  }\n \n-  /**\n-   * kill tasks according to different task types.\n-   *\n-   * @param taskExecutionContext  taskExecutionContext\n-   */\n-  public static void kill(TaskExecutionContext taskExecutionContext) {\n-    try {\n-      int processId = taskExecutionContext.getProcessId();\n-      if (processId == 0) {\n-        logger.error(\"process kill failed, process id :{}, task id:{}\",\n-                processId, taskExecutionContext.getTaskInstanceId());\n-        return;\n-      }\n+    /**\n+     * kill tasks according to different task types.\n+     *\n+     * @param taskExecutionContext taskExecutionContext\n+     */\n+    public static void kill(TaskExecutionContext taskExecutionContext) {\n+        try {\n+            int processId = taskExecutionContext.getProcessId();\n+            if (processId == 0) {\n+                logger.error(\"process kill failed, process id :{}, task id:{}\",\n+                    processId, taskExecutionContext.getTaskInstanceId());\n+                return;\n+            }\n \n-      String cmd = String.format(\"sudo kill -9 %s\", getPidsStr(processId));\n+            String cmd = String.format(\"sudo kill -9 %s\", getPidsStr(processId));\n \n-      logger.info(\"process id:{}, cmd:{}\", processId, cmd);\n+            logger.info(\"process id:{}, cmd:{}\", processId, cmd);\n \n-      OSUtils.exeCmd(cmd);\n+            OSUtils.exeCmd(cmd);\n \n-      // find log and kill yarn job\n-      killYarnJob(taskExecutionContext);\n+            // find log and kill yarn job\n+            killYarnJob(taskExecutionContext);\n \n-    } catch (Exception e) {\n-      logger.error(\"kill task failed\", e);\n-    }\n-  }\n-\n-  /**\n-   * get pids str.\n-   *\n-   * @param processId process id\n-   * @return pids\n-   * @throws Exception exception\n-   */\n-  public static String getPidsStr(int processId) throws Exception {\n-    StringBuilder sb = new StringBuilder();\n-    Matcher mat;\n-    // pstree pid get sub pids\n-    if (OSUtils.isMacOS()) {\n-      String pids = OSUtils.exeCmd(\"pstree -sp \" + processId);\n-      mat = MACPATTERN.matcher(pids);\n-    } else {\n-      String pids = OSUtils.exeCmd(\"pstree -p \" + processId);\n-      mat = WINDOWSATTERN.matcher(pids);\n+        } catch (Exception e) {\n+            logger.error(\"kill task failed\", e);\n+        }\n     }\n \n-    while (mat.find()) {\n-      sb.append(mat.group(1)).append(\" \");\n-    }\n-    return sb.toString().trim();\n-  }\n-\n-  /**\n-   * find logs and kill yarn tasks.\n-   *\n-   * @param taskExecutionContext  taskExecutionContext\n-   */\n-  public static void killYarnJob(TaskExecutionContext taskExecutionContext) {\n-    try {\n-      Thread.sleep(Constants.SLEEP_TIME_MILLIS);\n-      LogClientService logClient = null;\n-      String log = null;\n-      try {\n-        logClient = new LogClientService();\n-        log = logClient.viewLog(Host.of(taskExecutionContext.getHost()).getIp(),\n-                Constants.RPC_PORT,\n-                taskExecutionContext.getLogPath());\n-      } finally {\n-        if (logClient != null) {\n-          logClient.close();\n-        }\n-      }\n-      if (StringUtils.isNotEmpty(log)) {\n-        List<String> appIds = LoggerUtils.getAppIds(log, logger);\n-        String workerDir = taskExecutionContext.getExecutePath();\n-        if (StringUtils.isEmpty(workerDir)) {\n-          logger.error(\"task instance work dir is empty\");\n-          throw new RuntimeException(\"task instance work dir is empty\");\n+    /**\n+     * get pids str.\n+     *\n+     * @param processId process id\n+     * @return pids pid String\n+     * @throws Exception exception\n+     */\n+    public static String getPidsStr(int processId) throws Exception {\n+        StringBuilder sb = new StringBuilder();\n+        Matcher mat = null;\n+        // pstree pid get sub pids\n+        if (OSUtils.isMacOS()) {\n+            String pids = OSUtils.exeCmd(\"pstree -sp \" + processId);\n+            if (null != pids) {\n+                mat = MACPATTERN.matcher(pids);\n+            }\n+        } else {\n+            String pids = OSUtils.exeCmd(\"pstree -p \" + processId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371"}, "originalPosition": 695}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTA0MjU5", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-532104259", "createdAt": "2020-11-17T08:02:33Z", "commit": {"oid": "cb669b5900c9382d65c246700e0af44d061c4371"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3397b8ddb81630edc8c96e5df2d7a2274decb45", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/d3397b8ddb81630edc8c96e5df2d7a2274decb45", "committedDate": "2020-11-17T13:39:56Z", "message": "Merge branch 'dev' of https://github.com/apache/incubator-dolphinscheduler into dev-kill-yarn-job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/c24dbc448d9f8fc00878b287e421708c19a00fdc", "committedDate": "2020-11-17T14:25:25Z", "message": "deal with magic value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMDQ5MjMx", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-533049231", "createdAt": "2020-11-18T02:51:32Z", "commit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMDc4NjQy", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-533078642", "createdAt": "2020-11-18T03:30:43Z", "commit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDAwNzkz", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-534000793", "createdAt": "2020-11-19T00:58:18Z", "commit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMDo1ODoxOFrOH2IYEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMDo1ODoxOFrOH2IYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjM4Nw==", "bodyText": "please use OSUtils.exeCmd method instead\uff0cthx", "url": "https://github.com/apache/dolphinscheduler/pull/4042#discussion_r526522387", "createdAt": "2020-11-19T00:58:18Z", "author": {"login": "dailidong"}, "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/utils/ProcessUtils.java", "diffHunk": "@@ -38,368 +41,408 @@\n import java.util.regex.Pattern;\n \n /**\n- *  mainly used to get the start command line of a process.\n+ * mainly used to get the start command line of a process.\n  */\n public class ProcessUtils {\n-  /**\n-   * logger.\n-   */\n-  private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n-\n-  /**\n-   * Initialization regularization, solve the problem of pre-compilation performance,\n-   * avoid the thread safety problem of multi-thread operation.\n-   */\n-  private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n-\n-  private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n-\n-  /**\n-   * build command line characters.\n-   * @param commandList command list\n-   * @return command\n-   */\n-  public static String buildCommandStr(List<String> commandList) {\n-    String cmdstr;\n-    String[] cmd = commandList.toArray(new String[commandList.size()]);\n-    SecurityManager security = System.getSecurityManager();\n-    boolean allowAmbiguousCommands = false;\n-    if (security == null) {\n-      allowAmbiguousCommands = true;\n-      String value = System.getProperty(\"jdk.lang.Process.allowAmbiguousCommands\");\n-      if (value != null) {\n-        allowAmbiguousCommands = !\"false\".equalsIgnoreCase(value);\n-      }\n+    /**\n+     * logger.\n+     */\n+    private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class);\n+\n+    /**\n+     * Initialization regularization, solve the problem of pre-compilation performance,\n+     * avoid the thread safety problem of multi-thread operation.\n+     */\n+    private static final Pattern MACPATTERN = Pattern.compile(\"-[+|-]-\\\\s(\\\\d+)\");\n+\n+    private static final Pattern WINDOWSATTERN = Pattern.compile(\"(\\\\d+)\");\n+\n+    private static final String LOCAL_PROCESS_EXEC = \"jdk.lang.Process.allowAmbiguousCommands\";\n+\n+    /**\n+     * build command line characters.\n+     *\n+     * @param commandList command list\n+     * @return command\n+     */\n+    public static String buildCommandStr(List<String> commandList) {\n+        String cmdstr;\n+        String[] cmd = commandList.toArray(new String[0]);\n+        SecurityManager security = System.getSecurityManager();\n+        boolean allowAmbiguousCommands = isAllowAmbiguousCommands(security);\n+        if (allowAmbiguousCommands) {\n+\n+            String executablePath = new File(cmd[0]).getPath();\n+\n+            if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n+                executablePath = quoteString(executablePath);\n+            }\n+\n+            cmdstr = createCommandLine(\n+                VERIFICATION_LEGACY, executablePath, cmd);\n+        } else {\n+            String executablePath;\n+            try {\n+                executablePath = getExecutablePath(cmd[0]);\n+            } catch (IllegalArgumentException e) {\n+\n+                StringBuilder join = new StringBuilder();\n+                for (String s : cmd) {\n+                    join.append(s).append(' ');\n+                }\n+\n+                cmd = getTokensFromCommand(join.toString());\n+                executablePath = getExecutablePath(cmd[0]);\n+\n+                // Check new executable name once more\n+                if (security != null) {\n+                    security.checkExec(executablePath);\n+                }\n+            }\n+\n+            cmdstr = createCommandLine(\n+\n+                isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+        }\n+        return cmdstr;\n     }\n-    if (allowAmbiguousCommands) {\n-\n-      String executablePath = new File(cmd[0]).getPath();\n-\n-      if (needsEscaping(VERIFICATION_LEGACY, executablePath)) {\n-        executablePath = quoteString(executablePath);\n-      }\n-\n-      cmdstr = createCommandLine(\n-              VERIFICATION_LEGACY, executablePath, cmd);\n-    } else {\n-      String executablePath;\n-      try {\n-        executablePath = getExecutablePath(cmd[0]);\n-      } catch (IllegalArgumentException e) {\n \n-        StringBuilder join = new StringBuilder();\n-        for (String s : cmd) {\n-          join.append(s).append(' ');\n+    /**\n+     * check is allow ambiguous commands\n+     *\n+     * @param security security manager\n+     * @return allow ambiguous command flag\n+     */\n+    private static boolean isAllowAmbiguousCommands(SecurityManager security) {\n+        boolean allowAmbiguousCommands = false;\n+        if (security == null) {\n+            allowAmbiguousCommands = true;\n+            String value = System.getProperty(LOCAL_PROCESS_EXEC);\n+            if (value != null) {\n+                allowAmbiguousCommands = !Constants.STRING_FALSE.equalsIgnoreCase(value);\n+            }\n         }\n+        return allowAmbiguousCommands;\n+    }\n \n-        cmd = getTokensFromCommand(join.toString());\n-        executablePath = getExecutablePath(cmd[0]);\n+    /**\n+     * get executable path.\n+     *\n+     * @param path path\n+     * @return executable path\n+     */\n+    private static String getExecutablePath(String path) {\n+        boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n+\n+        File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n+        return fileToRun.getPath();\n+    }\n \n-        // Check new executable name once more\n-        if (security != null) {\n-          security.checkExec(executablePath);\n-        }\n-      }\n+    /**\n+     * whether is shell file.\n+     *\n+     * @param executablePath executable path\n+     * @return true if endsWith .CMD or .BAT\n+     */\n+    private static boolean isShellFile(String executablePath) {\n+        String upPath = executablePath.toUpperCase();\n+        return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n+    }\n \n-      cmdstr = createCommandLine(\n+    /**\n+     * quote string.\n+     *\n+     * @param arg argument\n+     * @return format arg\n+     */\n+    private static String quoteString(String arg) {\n+        return '\"' + arg + '\"';\n+    }\n \n-              isShellFile(executablePath) ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32, quoteString(executablePath), cmd);\n+    /**\n+     * get tokens from command.\n+     *\n+     * @param command command\n+     * @return token string array\n+     */\n+    private static String[] getTokensFromCommand(String command) {\n+        ArrayList<String> matchList = new ArrayList<>(8);\n+        Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n+        while (regexMatcher.find()) {\n+            matchList.add(regexMatcher.group());\n+        }\n+        return matchList.toArray(new String[0]);\n     }\n-    return cmdstr;\n-  }\n-\n-  /**\n-   * get executable path.\n-   *\n-   * @param path path\n-   * @return executable path\n-   */\n-  private static String getExecutablePath(String path) {\n-    boolean pathIsQuoted = isQuoted(true, path, \"Executable name has embedded quote, split the arguments\");\n-\n-    File fileToRun = new File(pathIsQuoted ? path.substring(1, path.length() - 1) : path);\n-    return fileToRun.getPath();\n-  }\n-\n-  /**\n-   * whether is shell file.\n-   *\n-   * @param executablePath executable path\n-   * @return true if endsWith .CMD or .BAT\n-   */\n-  private static boolean isShellFile(String executablePath) {\n-    String upPath = executablePath.toUpperCase();\n-    return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n-  }\n-\n-  /**\n-   * quote string.\n-   *\n-   * @param arg argument\n-   * @return format arg\n-   */\n-  private static String quoteString(String arg) {\n-    StringBuilder argbuf = new StringBuilder(arg.length() + 2);\n-    return argbuf.append('\"').append(arg).append('\"').toString();\n-  }\n-\n-  /**\n-   * get tokens from command.\n-   *\n-   * @param command command\n-   * @return token string array\n-   */\n-  private static String[] getTokensFromCommand(String command) {\n-    ArrayList<String> matchList = new ArrayList<>(8);\n-    Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);\n-    while (regexMatcher.find()) {\n-      matchList.add(regexMatcher.group());\n+\n+    /**\n+     * Lazy Pattern.\n+     */\n+    private static class LazyPattern {\n+        /**\n+         * Escape-support version:\n+         * \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n+         */\n+        private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n     }\n-    return matchList.toArray(new String[matchList.size()]);\n-  }\n-\n-  /**\n-   * Lazy Pattern.\n-   */\n-  private static class LazyPattern {\n-    // Escape-support version:\n-    // \"(\\\")((?:\\\\\\\\\\\\1|.)+?)\\\\1|([^\\\\s\\\"]+)\";\n-    private static final Pattern PATTERN = Pattern.compile(\"[^\\\\s\\\"]+|\\\"[^\\\"]*\\\"\");\n-  }\n-\n-  /**\n-   * verification cmd bat.\n-   */\n-  private static final int VERIFICATION_CMD_BAT = 0;\n-\n-  /**\n-   * verification win32.\n-   */\n-  private static final int VERIFICATION_WIN32 = 1;\n-\n-  /**\n-   * verification legacy.\n-   */\n-  private static final int VERIFICATION_LEGACY = 2;\n-\n-  /**\n-   * escape verification.\n-   */\n-  private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n-\n-    {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n-\n-  /**\n-   * create command line.\n-   * @param verificationType  verification type\n-   * @param executablePath    executable path\n-   * @param cmd               cmd\n-   * @return command line\n-   */\n-  private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n-    StringBuilder cmdbuf = new StringBuilder(80);\n-\n-    cmdbuf.append(executablePath);\n-\n-    for (int i = 1; i < cmd.length; ++i) {\n-      cmdbuf.append(' ');\n-      String s = cmd[i];\n-      if (needsEscaping(verificationType, s)) {\n-        cmdbuf.append('\"').append(s);\n-\n-        if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n-          cmdbuf.append('\\\\');\n+\n+    /**\n+     * verification cmd bat.\n+     */\n+    private static final int VERIFICATION_CMD_BAT = 0;\n+\n+    /**\n+     * verification win32.\n+     */\n+    private static final int VERIFICATION_WIN32 = 1;\n+\n+    /**\n+     * verification legacy.\n+     */\n+    private static final int VERIFICATION_LEGACY = 2;\n+\n+    /**\n+     * escape verification.\n+     */\n+    private static final char[][] ESCAPE_VERIFICATION = {{' ', '\\t', '<', '>', '&', '|', '^'},\n+\n+        {' ', '\\t', '<', '>'}, {' ', '\\t'}};\n+\n+    /**\n+     * create command line.\n+     *\n+     * @param verificationType verification type\n+     * @param executablePath   executable path\n+     * @param cmd              cmd\n+     * @return command line\n+     */\n+    private static String createCommandLine(int verificationType, final String executablePath, final String[] cmd) {\n+        StringBuilder cmdbuf = new StringBuilder(80);\n+\n+        cmdbuf.append(executablePath);\n+\n+        for (int i = 1; i < cmd.length; ++i) {\n+            cmdbuf.append(' ');\n+            String s = cmd[i];\n+            if (needsEscaping(verificationType, s)) {\n+                cmdbuf.append('\"').append(s);\n+\n+                if ((verificationType != VERIFICATION_CMD_BAT) && s.endsWith(\"\\\\\")) {\n+                    cmdbuf.append('\\\\');\n+                }\n+                cmdbuf.append('\"');\n+            } else {\n+                cmdbuf.append(s);\n+            }\n         }\n-        cmdbuf.append('\"');\n-      } else {\n-        cmdbuf.append(s);\n-      }\n+        return cmdbuf.toString();\n     }\n-    return cmdbuf.toString();\n-  }\n-\n-  /**\n-   * whether is quoted.\n-   * @param noQuotesInside\n-   * @param arg\n-   * @param errorMessage\n-   * @return boolean\n-   */\n-  private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n-    int lastPos = arg.length() - 1;\n-    if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n-      // The argument has already been quoted.\n-      if (noQuotesInside) {\n-        if (arg.indexOf('\"', 1) != lastPos) {\n-          // There is [\"] inside.\n-          throw new IllegalArgumentException(errorMessage);\n+\n+    /**\n+     * whether is quoted.\n+     *\n+     * @param noQuotesInside no quotes inside\n+     * @param arg            arg\n+     * @param errorMessage   error message\n+     * @return boolean\n+     */\n+    private static boolean isQuoted(boolean noQuotesInside, String arg, String errorMessage) {\n+        int lastPos = arg.length() - 1;\n+        if (lastPos >= 1 && arg.charAt(0) == '\"' && arg.charAt(lastPos) == '\"') {\n+            // The argument has already been quoted.\n+            if (noQuotesInside && arg.indexOf('\"', 1) != lastPos) {\n+                // There is [\"] inside.\n+                throw new IllegalArgumentException(errorMessage);\n+            }\n+            return true;\n         }\n-      }\n-      return true;\n-    }\n-    if (noQuotesInside) {\n-      if (arg.indexOf('\"') >= 0) {\n-        // There is [\"] inside.\n-        throw new IllegalArgumentException(errorMessage);\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * whether needs escaping.\n-   *\n-   * @param verificationType  verification type\n-   * @param arg               arg\n-   * @return boolean\n-   */\n-  private static boolean needsEscaping(int verificationType, String arg) {\n-\n-    boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n-\n-    if (!argIsQuoted) {\n-      char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n-      for (int i = 0; i < testEscape.length; ++i) {\n-        if (arg.indexOf(testEscape[i]) >= 0) {\n-          return true;\n+        if (noQuotesInside && arg.indexOf('\"') >= 0) {\n+            // There is [\"] inside.\n+            throw new IllegalArgumentException(errorMessage);\n         }\n-      }\n+        return false;\n     }\n-    return false;\n-  }\n-\n-  /**\n-   * kill yarn application.\n-   *\n-   * @param appIds      app id list\n-   * @param logger      logger\n-   * @param tenantCode  tenant code\n-   * @param executePath     execute path\n-   */\n-  public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n-    if (appIds.size() > 0) {\n-      String appid = appIds.get(appIds.size() - 1);\n-      String commandFile = String\n-              .format(\"%s/%s.kill\", executePath, appid);\n-      String cmd = \"yarn application -kill \" + appid;\n-      try {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"#!/bin/sh\\n\");\n-        sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n-        sb.append(\"cd $BASEDIR\\n\");\n-        if (CommonUtils.getSystemEnvPath() != null) {\n-          sb.append(\"source \" + CommonUtils.getSystemEnvPath() + \"\\n\");\n-        }\n-        sb.append(\"\\n\\n\");\n-        sb.append(cmd);\n-\n-        File f = new File(commandFile);\n \n-        if (!f.exists()) {\n-          FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+    /**\n+     * whether needs escaping.\n+     *\n+     * @param verificationType verification type\n+     * @param arg              arg\n+     * @return boolean\n+     */\n+    private static boolean needsEscaping(int verificationType, String arg) {\n+\n+        boolean argIsQuoted = isQuoted((verificationType == VERIFICATION_CMD_BAT), arg, \"Argument has embedded quote, use the explicit CMD.EXE call.\");\n+\n+        if (!argIsQuoted) {\n+            char[] testEscape = ESCAPE_VERIFICATION[verificationType];\n+            for (char c : testEscape) {\n+                if (arg.indexOf(c) >= 0) {\n+                    return true;\n+                }\n+            }\n         }\n+        return false;\n+    }\n \n-        String runCmd = \"sh \" + commandFile;\n-        if (StringUtils.isNotEmpty(tenantCode)) {\n-          runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+    /**\n+     * kill yarn application.\n+     *\n+     * @param appIds      app id list\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param executePath execute path\n+     */\n+    public static void cancelApplication(List<String> appIds, Logger logger, String tenantCode, String executePath) {\n+        if (CollectionUtils.isNotEmpty(appIds)) {\n+\n+            for (String appId : appIds) {\n+                try {\n+                    ExecutionStatus applicationStatus = HadoopUtils.getInstance().getApplicationStatus(appId);\n+\n+                    if (!applicationStatus.typeIsFinished()) {\n+                        String commandFile = String\n+                            .format(\"%s/%s.kill\", executePath, appId);\n+                        String cmd = \"yarn application -kill \" + appId;\n+                        execYarnKillCommand(logger, tenantCode, appId, commandFile, cmd);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(String.format(\"Get yarn application app id [%s] status failed: [%s]\", appId, e.getMessage()));\n+                }\n+            }\n         }\n+    }\n \n-        logger.info(\"kill cmd:{}\", runCmd);\n-\n-        Runtime.getRuntime().exec(runCmd);\n-      } catch (Exception e) {\n-        logger.error(\"kill application error\", e);\n-      }\n+    /**\n+     * build kill command for yarn application\n+     *\n+     * @param logger      logger\n+     * @param tenantCode  tenant code\n+     * @param appId       app id\n+     * @param commandFile command file\n+     * @param cmd         cmd\n+     */\n+    private static void execYarnKillCommand(Logger logger, String tenantCode, String appId, String commandFile, String cmd) {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"#!/bin/sh\\n\");\n+            sb.append(\"BASEDIR=$(cd `dirname $0`; pwd)\\n\");\n+            sb.append(\"cd $BASEDIR\\n\");\n+            if (CommonUtils.getSystemEnvPath() != null) {\n+                sb.append(\"source \").append(CommonUtils.getSystemEnvPath()).append(\"\\n\");\n+            }\n+            sb.append(\"\\n\\n\");\n+            sb.append(cmd);\n+\n+            File f = new File(commandFile);\n+\n+            if (!f.exists()) {\n+                FileUtils.writeStringToFile(new File(commandFile), sb.toString(), StandardCharsets.UTF_8);\n+            }\n+\n+            String runCmd = String.format(\"%s %s\", Constants.SH, commandFile);\n+            if (StringUtils.isNotEmpty(tenantCode)) {\n+                runCmd = \"sudo -u \" + tenantCode + \" \" + runCmd;\n+            }\n+\n+            logger.info(\"kill cmd:{}\", runCmd);\n+            Runtime.getRuntime().exec(runCmd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc"}, "originalPosition": 571}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDAxMjQw", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-534001240", "createdAt": "2020-11-19T00:59:23Z", "commit": {"oid": "c24dbc448d9f8fc00878b287e421708c19a00fdc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6672ac8f1f1fc4c8c508808cb4774abdbece4514", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/6672ac8f1f1fc4c8c508808cb4774abdbece4514", "committedDate": "2020-11-20T13:35:22Z", "message": "Merge branch 'dev' of https://github.com/apache/incubator-dolphinscheduler into dev-kill-yarn-job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "802de19cc0d7d493962bd1c3fd7abf452565f487", "author": {"user": {"login": "Eights-Li", "name": "Yelli"}}, "url": "https://github.com/apache/dolphinscheduler/commit/802de19cc0d7d493962bd1c3fd7abf452565f487", "committedDate": "2020-11-20T13:40:22Z", "message": "using OSUtils.execCmd when kill yarn app"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MDY3NjIy", "url": "https://github.com/apache/dolphinscheduler/pull/4042#pullrequestreview-536067622", "createdAt": "2020-11-22T14:29:59Z", "commit": {"oid": "802de19cc0d7d493962bd1c3fd7abf452565f487"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2352, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}