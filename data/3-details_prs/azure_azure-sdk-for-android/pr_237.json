{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzMxMTY0", "number": 237, "title": "Support for providing Content URI of the content to be transferred", "bodyText": "This PR add support to TransferClient to transfer content identified by content URI.\nTwo internal abstractions - ReadableContent and WritableContent are introduced. These types exposes operations on Content - taking read & write permissions, checking granting state of read & write permissions, performing block read and write on Content, etc..\nBoth upload and download APIs now supports accepting content URI. The existing upload, download overloads that takes the File object are still there, which can be removed later if we identify that there are no use-case for it.\nReadable|WritableContent also result in some code cleanup such as removing unnecessary columns from upload|download DB entities. An two issues identified during testing are fixed -\n(1).  Fixed block offset calculation error.\n(2). Removed unnecessary message dispatching that won't be handled.\nA good read on ContentURI: https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html", "createdAt": "2020-05-19T19:52:32Z", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237", "merged": true, "mergeCommit": {"oid": "daa09584f64a0dcf84d686529274c98419b42952"}, "closed": true, "closedAt": "2020-06-02T02:04:25Z", "author": {"login": "anuchandy"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABci53NcAH2gAyNDIwMzMxMTY0OjcyNGNlMGU4NzQ2NjU4YWYyNjIzMDM5YjAxZGUwZGUxYmZkNTdhM2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnLBfpgFqTQyMjI5MzA1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "724ce0e8746658af2623039b01de0de1bfd57a3b", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/724ce0e8746658af2623039b01de0de1bfd57a3b", "committedDate": "2020-05-19T19:44:24Z", "message": "Basic infa to support Content URI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90d0eefe17236b84212ffba05af7e99cdb138d0d", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/90d0eefe17236b84212ffba05af7e99cdb138d0d", "committedDate": "2020-05-19T23:05:33Z", "message": "using ContentResolver::query to get the content size."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "285e48ed6a52ed619e74d1b7165d70c96e458610", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/285e48ed6a52ed619e74d1b7165d70c96e458610", "committedDate": "2020-05-19T23:06:15Z", "message": "Updating sample to use upload API that takes ContentUri."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODcwNDc0", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#pullrequestreview-415870474", "createdAt": "2020-05-21T04:27:44Z", "commit": {"oid": "285e48ed6a52ed619e74d1b7165d70c96e458610"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "committedDate": "2020-05-30T18:00:29Z", "message": "Renaming ContentDescription to RedableContent to better indicate the purpose of type, Removing content specific columns from BlockUpload entity instead using the same from BlobUpload entity."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09a828eb49a0bedc1b1438c1c8153da56464b364", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/09a828eb49a0bedc1b1438c1c8153da56464b364", "committedDate": "2020-05-30T18:07:13Z", "message": "Fix: Download BlockOffset calculation, Removing unncessary message dispatch in DownloadHandler."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "committedDate": "2020-05-30T18:13:55Z", "message": "Adding WritableContent representing the content in device to store the downloaded blob, Updating types to use WritableContent."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDk1OTQy", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#pullrequestreview-422095942", "createdAt": "2020-06-01T18:51:25Z", "commit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxODo1MToyNlrOGdWFjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDoyMDoxMlrOGdYvMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMzc1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to store the downloaded blob.\n          \n          \n            \n                 * The URI to the content where the downloaded blob will be stored.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433423756", "createdAt": "2020-06-01T18:51:26Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -51,10 +50,16 @@\n     public long blobSize;\n \n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to store the downloaded blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyNDM5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param content describes the content to store the downloaded blob.\n          \n          \n            \n                 * @param content Describes the content where the downloaded blob will be stored.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433424390", "createdAt": "2020-06-01T18:52:43Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -98,22 +103,26 @@ public BlobDownloadEntity() {}\n      * @param storageBlobClientId identifies the blob storage client to be used\n      * @param containerName The container name.\n      * @param blobName The blob name.\n-     * @param file The local file.\n+     * @param blobSize The blob size.\n+     * @param content describes the content to store the downloaded blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyODU5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"' is cannot be processed, failed to open the content to write.\", t));\n          \n          \n            \n                                    \"' cannot be processed, failed to open the content to write.\", t));", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433428595", "createdAt": "2020-06-01T19:01:07Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -168,6 +168,16 @@ private void handleInit() {\n                     .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n                 this.getLooper().quit();\n             } else {\n+                this.content = new WritableContent(appContext,\n+                    Uri.parse(this.blob.contentUri),\n+                    this.blob.useContentResolver);\n+                try {\n+                    this.content.openForWrite(appContext);\n+                } catch (Throwable t) {\n+                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n+                        \"' is cannot be processed, failed to open the content to write.\", t));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTI0OA==", "bodyText": "Are we not creating a message because we are calling onComplete() and quitting the looper anyways?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429248", "createdAt": "2020-06-01T19:02:33Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -205,8 +215,7 @@ private void handleDownloadCompleted(Message message) {\n             if (runningBlockDownloads.isEmpty()) {\n                 db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n \n-                Message nextMessage = DownloadHandlerMessage.createBlobDownloadCompletedMessage(DownloadHandler.this);\n-                nextMessage.sendToTarget();\n+                closeContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTc3Nw==", "bodyText": "Same as above.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429777", "createdAt": "2020-06-01T19:03:39Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -230,13 +239,11 @@ private void handleDownloadFailed(Message message) {\n             pair.second.cancel();\n         }\n \n-        Throwable downloadError = failedPair.first.getDownloadError();\n+        closeContent();\n \n+        Throwable downloadError = failedPair.first.getDownloadError();\n         blob.setDownloadError(downloadError);\n \n-        Message nextMessage = DownloadHandlerMessage.createBlobDownloadFailedMessage(DownloadHandler.this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTE3OQ==", "bodyText": "What are the possible consequences of not being able to close a content instance?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431179", "createdAt": "2020-06-01T19:06:30Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -330,6 +338,14 @@ public void onFailure(Throwable t) {\n         }\n     }\n \n+    private void closeContent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTQxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Upload content of a file.\n          \n          \n            \n                 * Upload the content of a file.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431414", "createdAt": "2020-06-01T19:06:57Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -73,7 +74,7 @@ private TransferClient(Context context,\n     }\n \n     /**\n-     * Upload a file.\n+     * Upload content of a file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjA3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri uri to the Content to upload, the contentUri is resolved using\n          \n          \n            \n                 * @param contentUri URI to the Content to upload, the contentUri is resolved using", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432076", "createdAt": "2020-06-01T19:08:12Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjM3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://\n          \n          \n            \n                 *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432371", "createdAt": "2020-06-01T19:08:47Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using\n+     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n+     *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMzY3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri The uri to the local content to write the downloaded blob\n          \n          \n            \n                 * @param contentUri The URI to the local content where the downloaded blob will be stored.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433433672", "createdAt": "2020-06-01T19:11:34Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg==", "bodyText": "What is the difference with the upload() URI overload where the useContentResolver value is set to true? Are we setting it to false here because the content would not yet exist in storage when this is called?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433438522", "createdAt": "2020-06-01T19:21:37Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, contentUri, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);\n          \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433439909", "createdAt": "2020-06-01T19:24:37Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java", "diffHunk": "@@ -277,10 +283,23 @@ private void stageBlocks(List<BlockUploadEntity> blocks) {\n         for (BlockUploadEntity block : blocks) {\n             this.finalizeIfStopped();\n             Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n+            byte [] blockContent;\n+            try {\n+                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n+            } catch (Throwable t) {\n+                Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MDY4Mw==", "bodyText": "Making this a little easier to read. Although I would understand if you felt like explicitly talking about thread name and block id is not desired.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433440683", "createdAt": "2020-06-01T19:26:15Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java", "diffHunk": "@@ -277,10 +283,23 @@ private void stageBlocks(List<BlockUploadEntity> blocks) {\n         for (BlockUploadEntity block : blocks) {\n             this.finalizeIfStopped();\n             Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n+            byte [] blockContent;\n+            try {\n+                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n+            } catch (Throwable t) {\n+                Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ=="}, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MzUzMg==", "bodyText": "I feel weird reading isUse at the beginning although I understand it's based on a convention for boolean values. Would it be ok to rename this to isUsingContentResolver instead?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433443532", "createdAt": "2020-06-01T19:31:04Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ==", "bodyText": "This could return 0 if the file does not exist. We might want to consider that for when we decide to throw. Source.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433444189", "createdAt": "2020-06-01T19:32:32Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTYyNw==", "bodyText": "Any reason you preferred to use Throwable here instead of a specific exception? I feel like using the latter would be more descriptive.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445627", "createdAt": "2020-06-01T19:35:35Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTk4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n          \n          \n            \n                 * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445980", "createdAt": "2020-06-01T19:36:17Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Mjk3MQ==", "bodyText": "A little nitpick: maybe we can modify a little this to avoid code duplication? To be honest this is not really a big deal.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n          \n          \n            \n                                seek(fileInputStream, blockOffset);\n          \n          \n            \n                                byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                                read(fileInputStream, blockContent);\n          \n          \n            \n                                return blockContent;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        try (FileInputStream fileInputStream = new FileInputStream(file)) {\n          \n          \n            \n                            seek(fileInputStream, blockOffset);\n          \n          \n            \n                            byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                            read(fileInputStream, blockContent);\n          \n          \n            \n                            return blockContent;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    FileInputStream fileInputStream;\n          \n          \n            \n                    \n          \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            fileInputStream = descriptor.createInputStream();\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        fileInputStream = new FileInputStream(file);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    try {\n          \n          \n            \n                        seek(fileInputStream, blockOffset);\n          \n          \n            \n                        byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                        read(fileInputStream, blockContent);\n          \n          \n            \n                        return blockContent;\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        fileInputStream.close();\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433452971", "createdAt": "2020-06-01T19:50:42Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1MzQ0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param seekTo the seek position\n          \n          \n            \n                 * @param seekTo the stream position to seek", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433453447", "createdAt": "2020-06-01T19:51:44Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ==", "bodyText": "What does m stand for?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454701", "createdAt": "2020-06-01T19:54:22Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDg3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Read the stream content into a buffer starting from stream's read cursor position.\n          \n          \n            \n                 * Read the stream content into a buffer starting from the stream's read cursor position.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454875", "createdAt": "2020-06-01T19:54:45Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NTA0MA==", "bodyText": "Same as above.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433455040", "createdAt": "2020-06-01T19:55:03Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.\n+     *\n+     * @param stream the file stream\n+     * @param buffer the output buffer\n+     * @return the number of bytes read\n+     * @throws IOException if read fails\n+     */\n+    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n+        int bytesToRead = buffer.length;\n+        int bytesRead = 0;\n+        while (bytesRead < bytesToRead) {\n+            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjM5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to be uploaded as blob.\n          \n          \n            \n                 * The URI to the content to be uploaded as a blob.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433456394", "createdAt": "2020-06-01T19:57:41Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java", "diffHunk": "@@ -32,15 +31,20 @@\n     @ColumnInfo(name = \"key\")\n     public Long key;\n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to be uploaded as blob.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Nzc1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true if resolving content URI requires content resolver.\n          \n          \n            \n                 * @return true if resolving content URI requires {@link android.content.ContentResolver}.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433457751", "createdAt": "2020-06-01T20:00:23Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1OTMxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                 * @throws IOException if not possible to open underlying content resource in write mode", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433459311", "createdAt": "2020-06-01T20:03:50Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MDA5Nw==", "bodyText": "See comment above about the naming of this method on ReadableContent.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433460097", "createdAt": "2020-06-01T20:05:25Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MzAyNg==", "bodyText": "Do we want to capitalize Content wherever its mentioned to make the distinction between ReadableContent/WritableContent and the word \"content\" in the general sense?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433463026", "createdAt": "2020-06-01T20:11:37Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NDAyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param context the context to resolve the content uri\n          \n          \n            \n                     * @param contentUri the uri of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                     * @param context the context to resolve the content URI\n          \n          \n            \n                     * @param contentUri the URI of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if failed to open the underlying content resource in write mode", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433464021", "createdAt": "2020-06-01T20:13:43Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.\n+     */\n+    private static class WriteToContentChannel implements Closeable {\n+        private final Context context;\n+        private final Uri contentUri;\n+        private final ParcelFileDescriptor parcelFileDescriptor;\n+        private final FileOutputStream fileOutputStream;\n+        private final FileChannel fileChannel;\n+        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+        /**\n+         * Creates WriteToContentChannel to write to the Content identified by the given ContentUri.\n+         *\n+         * @param context the context to resolve the content uri\n+         * @param contentUri the uri of the content to write to using this Channel.\n+         *\n+         * @throws IOException if fails to open underlying content resource in write mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NTY4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Check a persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access content resolver\n          \n          \n            \n                 * @param contentUri the content uri\n          \n          \n            \n                 * Check if persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access {@link android.content.ContentResolver}\n          \n          \n            \n                 * @param contentUri the content URI", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433465683", "createdAt": "2020-06-01T20:17:14Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjE3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if close operation fails\n          \n          \n            \n                 * Close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if the close operation fails", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466172", "createdAt": "2020-06-01T20:18:10Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjY3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466674", "createdAt": "2020-06-01T20:19:08Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njk3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        // so that providers that return subsections of a file are supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466976", "createdAt": "2020-06-01T20:19:45Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NzE4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433467187", "createdAt": "2020-06-01T20:20:12Z", "author": {"login": "vcolin7"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "710f50b854de3eef4dab2e9637c0703de587be6b", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/710f50b854de3eef4dab2e9637c0703de587be6b", "committedDate": "2020-06-01T22:06:47Z", "message": "Cleaning up javadoc\n\nCo-authored-by: vcolin7 <vicolina@microsoft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1d43844d8519f29a09c8cb127be02607210d632", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/d1d43844d8519f29a09c8cb127be02607210d632", "committedDate": "2020-06-02T01:39:15Z", "message": "More stable ReadableContent::getLength implementation, rename isUseContentResolver to isUsingContentResolver."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjkwMDI3", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#pullrequestreview-422290027", "createdAt": "2020-06-02T01:48:59Z", "commit": {"oid": "d1d43844d8519f29a09c8cb127be02607210d632"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d974b2f0779e2cd0c5741dcc4505201f956262f", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/2d974b2f0779e2cd0c5741dcc4505201f956262f", "committedDate": "2020-06-02T01:58:29Z", "message": "Really passing useContentResolver:true for download(Uri), comment update Content to content"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjkzMDU0", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#pullrequestreview-422293054", "createdAt": "2020-06-02T01:59:43Z", "commit": {"oid": "2d974b2f0779e2cd0c5741dcc4505201f956262f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1313, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}