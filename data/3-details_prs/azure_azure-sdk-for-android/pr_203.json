{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTc4MTg2", "number": 203, "title": "TransferInfo LiveData ", "bodyText": "Features:\n\nTransferInfo: a model representing current state of transfer. From transfer APIs, users will receive a LiveData that emits TransferInfo events.\nSerialExecutor: A variant of Executor contract that serially delegate TransferClient book keeping work to another Executor.\nTransferClient.Builder: Adding a minimal builder around TransferClient.\n\nBug Fixes\n\nFixing a bug in UploadDao w.r.t aggregating uploaded bytes.", "createdAt": "2020-02-26T02:51:01Z", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203", "merged": true, "mergeCommit": {"oid": "ac078393af2a5830af7b1cf24013e737b6cbbe3e"}, "closed": true, "closedAt": "2020-03-09T16:49:03Z", "author": {"login": "anuchandy"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIQbMyAFqTM2NTM0NjY4Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMAnWKgH2gAyMzc5OTc4MTg2Ojc3YWM5ZTVhYTUxMTZhODg2MmVmZTYyZWNhZmZmZmNiMTMyNTcwODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ2Njg3", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#pullrequestreview-365346687", "createdAt": "2020-02-27T00:45:39Z", "commit": {"oid": "896bd4e2183a50e8794cae392ac53f6569bc9fb0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0NTozOVrOFvBmlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0NTozOVrOFvBmlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA==", "bodyText": "How would you feel about just using androidx.work.impl.utils.SerialExecutor instead? It's public, but it's also in an impl package. However it does pretty much exactly the same thing as this class.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384853654", "createdAt": "2020-02-27T00:45:39Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/SerialExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.WorkManager;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * Package private.\n+ *\n+ * An {@link Executor} that wrap and delegate work execution to another {@link Executor}.\n+ * SerialExecutor ensure that the submitted works are executed serially using\n+ * the wrapped executor.\n+ *\n+ * SerialExecutor is used by {@link TransferClient} for all its internal book keeping,\n+ * which includes creating DB entries for transfer workers, querying DB for status,\n+ * submitting transfer request to {@link WorkManager}.\n+ *\n+ * This is similar to a {@link android.os.Looper} that serially process messages from\n+ * it's message queue. The difference is while Looper hold a dedicated thread throughout\n+ * it lifetime, SerialExecutor delegate the work execution to another executor.\n+ *\n+ * @see <a href=\"https://developer.android.com/reference/java/util/concurrent/Executor\">Executor</a>\n+ */\n+final class SerialExecutor implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896bd4e2183a50e8794cae392ac53f6569bc9fb0"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ3MTE3", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#pullrequestreview-365347117", "createdAt": "2020-02-27T00:47:00Z", "commit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0NzowMFrOFvBoGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0NzowMFrOFvBoGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw==", "bodyText": "How would you feel about using WorkManager's Configuration.getTaskExecutor() here as the default? The docs say that this function \"Gets the Executor used by WorkManager for all its internal business logic\".", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043", "createdAt": "2020-02-27T00:47:00Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setBookKeepingExecutor(@NonNull Executor executor) {\n+            this.serialBackgroundExecutor = new SerialExecutor(executor);\n+            return this;\n+        }\n+\n+        /**\n+         * @return A {@link TransferClient} configured with settings applied through this builder\n+         */\n+        public TransferClient build() {\n+            if (this.storageBlobClient == null) {\n+                throw new IllegalArgumentException(\"storageBlobClient must be set.\");\n+            }\n+            Constraints.Builder constraintsBuilder = new Constraints.Builder();\n+            switch (this.networkType) {\n+                case TransferNetworkType.ANY:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.CONNECTED);\n+                    break;\n+                case TransferNetworkType.UNMETERED:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.UNMETERED);\n+                    break;\n+                case TransferNetworkType.METERED:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.METERED);\n+                    break;\n+                case TransferNetworkType.NOT_ROAMING:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.NOT_ROAMING);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"networkType must be set.\");\n+            }\n+            if (this.serialBackgroundExecutor == null) {\n+                this.serialBackgroundExecutor =  new SerialExecutor(Executors.newFixedThreadPool(2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "originalPosition": 236}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ5ODU5", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#pullrequestreview-365349859", "createdAt": "2020-02-27T00:55:09Z", "commit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1NTowOVrOFvByEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTowNDowOFrOFvB8OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ==", "bodyText": "Just as a thought, we could perhaps allow customers to provide their own Constraints instance. It does leak out the WorkManager API surface but I'm not convinced that's necessarily a bad thing in this situation - wrapping the whole thing would be worse. We could just check and make sure it contains a network constraint when build() is called and add NetworkType.CONNECTED by default if not.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384856595", "createdAt": "2020-02-27T00:55:09Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzQ5Mw==", "bodyText": "Maybe call this setTaskExecutor ?? I think your name conveys more semantics, but WorkManager and Room both call this the \"task executor\" so maybe better to be consistent?", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384857493", "createdAt": "2020-02-27T00:58:11Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setBookKeepingExecutor(@NonNull Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTE5Mg==", "bodyText": "Just to clarify, the only reason we initialize this class with a LiveData<long> rather than just long is that we're using the LiveData as a communication channel, waiting for the transfer operation to be stored in the database so we can get its ID which happens in a callback. This implies that we only ever expect the transferIdLiveData to update once, right?\nIf my understanding is correct we should document this somewhere. It wasn't obvious until I stared at this for awhile why we were using a LiveData<long> at all.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384859192", "createdAt": "2020-02-27T01:04:08Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdMappedToTransferInfo.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MediatorLiveData;\n+import androidx.lifecycle.Transformations;\n+import androidx.work.Data;\n+import androidx.work.WorkInfo;\n+import androidx.work.WorkManager;\n+\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type to transform an input LiveData that emit a transfer id to an output LiveData that emit\n+ * a stream of {@link TransferInfo}.\n+ *\n+ * Each {@link TransferInfo} event from output LiveData describes current state of the transfer\n+ * identified by the transfer id.\n+ */\n+final class TransferIdMappedToTransferInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d7e9478828a30d61eb4fd0337900363dc7c19b"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTUxOTMx", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#pullrequestreview-369151931", "createdAt": "2020-03-04T21:54:33Z", "commit": {"oid": "c12a66e7d1ee617450d21ded222386e8030366dc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMTo1NDozM1rOFx_C4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMTo1NjoyNFrOFx_GkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg==", "bodyText": "Maybe we should just default this to CONNECTED if not specified. That seems like a reasonable default.", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r387957472", "createdAt": "2020-03-04T21:54:33Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -3,93 +3,274 @@\n \n package com.azure.android.storage.blob.transfer;\n \n+import android.annotation.SuppressLint;\n import android.content.Context;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n+import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n+     */\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // indicate whether the device should be charging for running the transfers.\n+        private boolean requiresCharging;\n+        // indicate whether the device should be idle for running the transfers.\n+        private boolean requiresDeviceIdle;\n+        // indicate whether the device battery should be at an acceptable level for running the transfers\n+        private boolean requiresBatteryNotLow;\n+        // indicate whether the device's available storage should be at an acceptable level for running\n+        // the transfers\n+        private boolean requiresStorageNotLow;\n+        // the network type required for transfers.\n+        private NetworkType networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be charging for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresCharging {@code true} if device must be charging for the transfer to run\n+         * @return Builder with provided charging requirement set\n+         */\n+        public Builder setRequiresCharging(boolean requiresCharging) {\n+            this.requiresCharging = requiresCharging;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be idle for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresDeviceIdle {@code true} if device must be idle for transfers to run\n+         * @return Builder with provided idle requirement set\n+         */\n+        @RequiresApi(23)\n+        public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {\n+            this.requiresDeviceIdle = requiresDeviceIdle;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link NetworkType} the device should be in for running\n+         * the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@NonNull NetworkType networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device battery should be at an acceptable level for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresBatteryNotLow {@code true} if the battery should be at an acceptable level\n+         *                              for the transfers to run\n+         * @return Builder with provided battery requirement set\n+         */\n+        public Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow) {\n+            this.requiresBatteryNotLow = requiresBatteryNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether the device's available storage should be at an acceptable level for running\n+         * the transfers. The default value is {@code false}.\n+         *\n+         * @param requiresStorageNotLow {@code true} if the available storage should not be below a\n+         *                              a critical threshold for the transfer to run\n+         * @return Builder with provided storage requirement set\n+         */\n+        public Builder setRequiresStorageNotLow(boolean requiresStorageNotLow) {\n+            this.requiresStorageNotLow = requiresStorageNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setTaskExecutor(@NonNull Executor executor) {\n+            this.serialBackgroundExecutor = new SerialExecutor(executor);\n+            return this;\n+        }\n+\n+        /**\n+         * @return A {@link TransferClient} configured with settings applied through this builder\n+         */\n+        // Following annotation is added to suppress library restricted WorkManager\n+        // androidx.work.Configuration Object access\n+        @SuppressLint(\"RestrictedApi\")\n+        public TransferClient build() {\n+            if (this.storageBlobClient == null) {\n+                throw new IllegalArgumentException(\"storageBlobClient must be set.\");\n+            }\n+            final Constraints.Builder constraintsBuilder = new Constraints.Builder();\n+            constraintsBuilder.setRequiresCharging(this.requiresCharging);\n+            constraintsBuilder.setRequiresDeviceIdle(this.requiresDeviceIdle);\n+            if (this.networkType == null) {\n+                throw new IllegalArgumentException(\"networkType must be set.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c12a66e7d1ee617450d21ded222386e8030366dc"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODQxNw==", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n          \n          \n            \n                     * TransferClient will enqueue a maximum of two commands to the taskExecutor at any time.\n          \n      \n    \n    \n  \n\nAlso for consistency it might be nice to rename the field to e.g. \"serialTaskExecutor\"", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r387958417", "createdAt": "2020-03-04T21:56:24Z", "author": {"login": "bsiegel"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -3,93 +3,274 @@\n \n package com.azure.android.storage.blob.transfer;\n \n+import android.annotation.SuppressLint;\n import android.content.Context;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n+import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n+     */\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // indicate whether the device should be charging for running the transfers.\n+        private boolean requiresCharging;\n+        // indicate whether the device should be idle for running the transfers.\n+        private boolean requiresDeviceIdle;\n+        // indicate whether the device battery should be at an acceptable level for running the transfers\n+        private boolean requiresBatteryNotLow;\n+        // indicate whether the device's available storage should be at an acceptable level for running\n+        // the transfers\n+        private boolean requiresStorageNotLow;\n+        // the network type required for transfers.\n+        private NetworkType networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be charging for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresCharging {@code true} if device must be charging for the transfer to run\n+         * @return Builder with provided charging requirement set\n+         */\n+        public Builder setRequiresCharging(boolean requiresCharging) {\n+            this.requiresCharging = requiresCharging;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be idle for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresDeviceIdle {@code true} if device must be idle for transfers to run\n+         * @return Builder with provided idle requirement set\n+         */\n+        @RequiresApi(23)\n+        public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {\n+            this.requiresDeviceIdle = requiresDeviceIdle;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link NetworkType} the device should be in for running\n+         * the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@NonNull NetworkType networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device battery should be at an acceptable level for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresBatteryNotLow {@code true} if the battery should be at an acceptable level\n+         *                              for the transfers to run\n+         * @return Builder with provided battery requirement set\n+         */\n+        public Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow) {\n+            this.requiresBatteryNotLow = requiresBatteryNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether the device's available storage should be at an acceptable level for running\n+         * the transfers. The default value is {@code false}.\n+         *\n+         * @param requiresStorageNotLow {@code true} if the available storage should not be below a\n+         *                              a critical threshold for the transfer to run\n+         * @return Builder with provided storage requirement set\n+         */\n+        public Builder setRequiresStorageNotLow(boolean requiresStorageNotLow) {\n+            this.requiresStorageNotLow = requiresStorageNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c12a66e7d1ee617450d21ded222386e8030366dc"}, "originalPosition": 268}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9646a17de62d674cc498d5e8ba1caba2c1c87049", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/9646a17de62d674cc498d5e8ba1caba2c1c87049", "committedDate": "2020-03-09T16:36:08Z", "message": "UploadDao: Correcting getUploadedBytesCount(blobKey) to only aggregate byes of completed blocks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3c770819be1809e685b7a867f1e9286e4de6dbd", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/a3c770819be1809e685b7a867f1e9286e4de6dbd", "committedDate": "2020-03-09T16:36:08Z", "message": "SerialExecutor: A facade Executor to serially delegate work to another Executor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77ac9e5aa5116a8862efe62ecaffffcb13257089", "author": {"user": {"login": "anuchandy", "name": "Anu Thomas Chandy"}}, "url": "https://github.com/Azure/azure-sdk-for-android/commit/77ac9e5aa5116a8862efe62ecaffffcb13257089", "committedDate": "2020-03-09T16:36:09Z", "message": "TransferInfo LiveData: Defining TransferInfo event to describe the state of transfer, Adding mapping of WorkInfo to TransferInfo, Updating TransferClient::upload to use SerialExecutor and return LiveData of TransferInfo, adding minimal builder for TransferClient"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1290, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}