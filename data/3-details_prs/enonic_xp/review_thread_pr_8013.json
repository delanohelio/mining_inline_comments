{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTUxMTk2", "number": 8013, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0Nzo0N1rODy3tzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0Nzo0N1rODy3tzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjY4MjM3OnYy", "diffSide": "RIGHT", "path": "modules/core/core-repo/src/main/java/com/enonic/xp/repo/impl/dump/writer/AbstractDumpWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0Nzo0N1rOGHK0yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo1ODoyNFrOGHLHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MDU2OQ==", "bodyText": "what about to check on NULL before closing?", "url": "https://github.com/enonic/xp/pull/8013#discussion_r410170569", "createdAt": "2020-04-17T11:47:47Z", "author": {"login": "anatol-sialitski"}, "path": "modules/core/core-repo/src/main/java/com/enonic/xp/repo/impl/dump/writer/AbstractDumpWriter.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.enonic.xp.repo.impl.dump.writer;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.stream.Stream;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.enonic.xp.blob.BlobKey;\n+import com.enonic.xp.blob.BlobRecord;\n+import com.enonic.xp.blob.BlobStore;\n+import com.enonic.xp.blob.NodeVersionKey;\n+import com.enonic.xp.blob.Segment;\n+import com.enonic.xp.branch.Branch;\n+import com.enonic.xp.repo.impl.dump.DumpConstants;\n+import com.enonic.xp.repo.impl.dump.FilePaths;\n+import com.enonic.xp.repo.impl.dump.PathRef;\n+import com.enonic.xp.repo.impl.dump.RepoDumpException;\n+import com.enonic.xp.repo.impl.dump.blobstore.DumpBlobStore;\n+import com.enonic.xp.repo.impl.dump.model.BranchDumpEntry;\n+import com.enonic.xp.repo.impl.dump.model.CommitDumpEntry;\n+import com.enonic.xp.repo.impl.dump.model.DumpMeta;\n+import com.enonic.xp.repo.impl.dump.model.VersionsDumpEntry;\n+import com.enonic.xp.repo.impl.dump.serializer.DumpSerializer;\n+import com.enonic.xp.repo.impl.dump.serializer.json.DumpMetaJsonSerializer;\n+import com.enonic.xp.repo.impl.dump.serializer.json.JsonDumpSerializer;\n+import com.enonic.xp.repo.impl.node.NodeConstants;\n+import com.enonic.xp.repository.RepositoryId;\n+import com.enonic.xp.repository.RepositorySegmentUtils;\n+\n+public abstract class AbstractDumpWriter\n+    implements DumpWriter\n+{\n+    private final static Logger LOG = LoggerFactory.getLogger( FileDumpWriter.class );\n+\n+    private final DumpBlobStore dumpBlobStore;\n+\n+    private final BlobStore blobStore;\n+\n+    private final DumpSerializer serializer;\n+\n+    protected final FilePaths filePaths;\n+\n+    protected TarArchiveOutputStream tarOutputStream;\n+\n+    protected AbstractDumpWriter( final BlobStore blobStore, FilePaths filePaths, DumpBlobStore dumpBlobStore )\n+    {\n+        this.dumpBlobStore = dumpBlobStore;\n+        this.serializer = new JsonDumpSerializer();\n+        this.blobStore = blobStore;\n+        this.filePaths = filePaths;\n+    }\n+\n+    @Override\n+    public void writeDumpMetaData( final DumpMeta dumpMeta )\n+    {\n+        final PathRef dumpMetaFile = filePaths.metaDataFile();\n+\n+        try (final OutputStream outputStream = openMetaFileStream( dumpMetaFile ))\n+        {\n+            outputStream.write( new DumpMetaJsonSerializer().serialize( dumpMeta ) );\n+        }\n+        catch ( IOException e )\n+        {\n+            throw new RepoDumpException( \"Cannot write dump-meta file\", e );\n+        }\n+    }\n+\n+    @Override\n+    public void openBranchMeta( final RepositoryId repositoryId, final Branch branch )\n+    {\n+        final PathRef branchMetaPath = filePaths.branchMetaPath( repositoryId, branch );\n+        openTarStream( branchMetaPath );\n+    }\n+\n+    @Override\n+    public void openVersionsMeta( final RepositoryId repositoryId )\n+    {\n+        final PathRef versionMetaPath = filePaths.versionMetaPath( repositoryId );\n+        openTarStream( versionMetaPath );\n+    }\n+\n+    @Override\n+    public void openCommitsMeta( final RepositoryId repositoryId )\n+    {\n+        final PathRef commitMetaPath = filePaths.commitMetaPath( repositoryId );\n+        openTarStream( commitMetaPath );\n+    }\n+\n+    @Override\n+    public void closeMeta()\n+    {\n+        try\n+        {\n+            this.tarOutputStream.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e7679a658eb4556e83af197466fa146585df674"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3NTI1Ng==", "bodyText": "NPE is better because it will indicate a bug in the code.There are no normal conditions which would lead to tarOutputStream == null", "url": "https://github.com/enonic/xp/pull/8013#discussion_r410175256", "createdAt": "2020-04-17T11:58:24Z", "author": {"login": "rymsha"}, "path": "modules/core/core-repo/src/main/java/com/enonic/xp/repo/impl/dump/writer/AbstractDumpWriter.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.enonic.xp.repo.impl.dump.writer;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.stream.Stream;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.enonic.xp.blob.BlobKey;\n+import com.enonic.xp.blob.BlobRecord;\n+import com.enonic.xp.blob.BlobStore;\n+import com.enonic.xp.blob.NodeVersionKey;\n+import com.enonic.xp.blob.Segment;\n+import com.enonic.xp.branch.Branch;\n+import com.enonic.xp.repo.impl.dump.DumpConstants;\n+import com.enonic.xp.repo.impl.dump.FilePaths;\n+import com.enonic.xp.repo.impl.dump.PathRef;\n+import com.enonic.xp.repo.impl.dump.RepoDumpException;\n+import com.enonic.xp.repo.impl.dump.blobstore.DumpBlobStore;\n+import com.enonic.xp.repo.impl.dump.model.BranchDumpEntry;\n+import com.enonic.xp.repo.impl.dump.model.CommitDumpEntry;\n+import com.enonic.xp.repo.impl.dump.model.DumpMeta;\n+import com.enonic.xp.repo.impl.dump.model.VersionsDumpEntry;\n+import com.enonic.xp.repo.impl.dump.serializer.DumpSerializer;\n+import com.enonic.xp.repo.impl.dump.serializer.json.DumpMetaJsonSerializer;\n+import com.enonic.xp.repo.impl.dump.serializer.json.JsonDumpSerializer;\n+import com.enonic.xp.repo.impl.node.NodeConstants;\n+import com.enonic.xp.repository.RepositoryId;\n+import com.enonic.xp.repository.RepositorySegmentUtils;\n+\n+public abstract class AbstractDumpWriter\n+    implements DumpWriter\n+{\n+    private final static Logger LOG = LoggerFactory.getLogger( FileDumpWriter.class );\n+\n+    private final DumpBlobStore dumpBlobStore;\n+\n+    private final BlobStore blobStore;\n+\n+    private final DumpSerializer serializer;\n+\n+    protected final FilePaths filePaths;\n+\n+    protected TarArchiveOutputStream tarOutputStream;\n+\n+    protected AbstractDumpWriter( final BlobStore blobStore, FilePaths filePaths, DumpBlobStore dumpBlobStore )\n+    {\n+        this.dumpBlobStore = dumpBlobStore;\n+        this.serializer = new JsonDumpSerializer();\n+        this.blobStore = blobStore;\n+        this.filePaths = filePaths;\n+    }\n+\n+    @Override\n+    public void writeDumpMetaData( final DumpMeta dumpMeta )\n+    {\n+        final PathRef dumpMetaFile = filePaths.metaDataFile();\n+\n+        try (final OutputStream outputStream = openMetaFileStream( dumpMetaFile ))\n+        {\n+            outputStream.write( new DumpMetaJsonSerializer().serialize( dumpMeta ) );\n+        }\n+        catch ( IOException e )\n+        {\n+            throw new RepoDumpException( \"Cannot write dump-meta file\", e );\n+        }\n+    }\n+\n+    @Override\n+    public void openBranchMeta( final RepositoryId repositoryId, final Branch branch )\n+    {\n+        final PathRef branchMetaPath = filePaths.branchMetaPath( repositoryId, branch );\n+        openTarStream( branchMetaPath );\n+    }\n+\n+    @Override\n+    public void openVersionsMeta( final RepositoryId repositoryId )\n+    {\n+        final PathRef versionMetaPath = filePaths.versionMetaPath( repositoryId );\n+        openTarStream( versionMetaPath );\n+    }\n+\n+    @Override\n+    public void openCommitsMeta( final RepositoryId repositoryId )\n+    {\n+        final PathRef commitMetaPath = filePaths.commitMetaPath( repositoryId );\n+        openTarStream( commitMetaPath );\n+    }\n+\n+    @Override\n+    public void closeMeta()\n+    {\n+        try\n+        {\n+            this.tarOutputStream.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MDU2OQ=="}, "originalCommit": {"oid": "4e7679a658eb4556e83af197466fa146585df674"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1043, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}