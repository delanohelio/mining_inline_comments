{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMzc4MTg1", "number": 4387, "title": "netty connector/container modifications", "bodyText": "POC adaptation for netty-connector (from #4286) + fix for netty-container (which depends on NettyInputStream).\nSigned-off-by: Maxim Nesen maxim.nesen@oracle.com", "createdAt": "2020-02-05T13:38:08Z", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387", "merged": true, "mergeCommit": {"oid": "a19a446bd6428d62db181349775d99fe8b687c49"}, "closed": true, "closedAt": "2020-02-19T10:36:04Z", "author": {"login": "senivam"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBnFw6AFqTM1NDI5MzYzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFz0axgFqTM2MDk5MTMyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjkzNjM4", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-354293638", "createdAt": "2020-02-06T09:12:36Z", "commit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5ODgyNTcy", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-359882572", "createdAt": "2020-02-17T17:16:44Z", "commit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNzoxNjo0NFrOFqrkuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODoyMzo1MVrOFqs9Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5ODQyNA==", "bodyText": "NettyInputStream is available through requestContext#getEnityStream. Removing available implementation is therefore a backward incompatible change", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380298424", "createdAt": "2020-02-17T17:16:44Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();\n+          current = null;\n+          buffer = null;\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n-\n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n     }\n \n     @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n-        }\n-        super.close();\n+    public synchronized void close() {\n+       if (current != null) {\n+          current.release();\n+       }\n+\n+       current = null;\n+       buffer = null;\n+       cleanup(true);\n     }\n \n-    @Override\n-    public int available() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTExMQ==", "bodyText": "call synchronized close() instead?", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380321111", "createdAt": "2020-02-17T18:23:51Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTYwNDg1", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360160485", "createdAt": "2020-02-18T08:56:20Z", "commit": {"oid": "eeb7d9a3196657972596f4fdbe561d441bfd825a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aea67d4f43a6c3d33d52fac0825596f47180df64", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/aea67d4f43a6c3d33d52fac0825596f47180df64", "committedDate": "2020-02-18T09:57:21Z", "message": "netty connector/container modifications (OO)\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c7d90cb06e6f5a217c25afd56291dbb7a42092e", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/8c7d90cb06e6f5a217c25afd56291dbb7a42092e", "committedDate": "2020-02-18T09:57:21Z", "message": "available and releaseByteBuf methods added\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTk0MjUy", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-359994252", "createdAt": "2020-02-17T22:49:07Z", "commit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjo0OTowN1rOFqxJIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjo1NDo0OVrOFqxNlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4OTY2NA==", "bodyText": "No. current potentially references different buffers throughout the lifetime of NettyInputStream. current.release() returns one buffer back to Netty.\nObserve how it interacts with https://github.com/eclipse-ee4j/jersey/pull/4387/files/c6d6efa596c9108e32e0a1c36a885a087423ae65#diff-24846529fe20a75e53f3b1b063c46521R132 and assignment of new current in awaitNext", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380389664", "createdAt": "2020-02-17T22:49:07Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTExMQ=="}, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDgwNg==", "bodyText": "No, it is not a breaking change. available has a default implementation in super class. There are no requirements what it should return - it is only an estimate.\nBut I agree it can be implemented.\npublic int available() {\n    return buffer == null? 0: buffer.remaining();\n}", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380390806", "createdAt": "2020-02-17T22:54:49Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();\n+          current = null;\n+          buffer = null;\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n-\n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n     }\n \n     @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n-        }\n-        super.close();\n+    public synchronized void close() {\n+       if (current != null) {\n+          current.release();\n+       }\n+\n+       current = null;\n+       buffer = null;\n+       cleanup(true);\n     }\n \n-    @Override\n-    public int available() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5ODQyNA=="}, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df5add259e2f510dfdfe83aeadbb906e0e9b70ab", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/df5add259e2f510dfdfe83aeadbb906e0e9b70ab", "committedDate": "2020-02-18T10:40:40Z", "message": "synchronized releaseByteBuf\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeb7d9a3196657972596f4fdbe561d441bfd825a", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/eeb7d9a3196657972596f4fdbe561d441bfd825a", "committedDate": "2020-02-18T08:34:07Z", "message": "available and releaseByteBuf methods added\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}, "afterCommit": {"oid": "df5add259e2f510dfdfe83aeadbb906e0e9b70ab", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/df5add259e2f510dfdfe83aeadbb906e0e9b70ab", "committedDate": "2020-02-18T10:40:40Z", "message": "synchronized releaseByteBuf\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f6111333ea37c17a7348fca80c31b672b7f23ef", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/5f6111333ea37c17a7348fca80c31b672b7f23ef", "committedDate": "2020-02-18T10:57:23Z", "message": "available simplified\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/b6daf7ed02532ebe58801da65ccf8cb1812407b2", "committedDate": "2020-02-18T11:15:27Z", "message": "available simplified (stylecheck)\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjkwNjE1", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360290615", "createdAt": "2020-02-18T12:15:55Z", "commit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjoxNTo1NVrOFrAJTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjoxNTo1NVrOFrAJTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ==", "bodyText": "should be synchronized", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380635471", "createdAt": "2020-02-18T12:15:55Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55615c8d8105659c46cd48b8f33b6398dd37bf86", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/55615c8d8105659c46cd48b8f33b6398dd37bf86", "committedDate": "2020-02-18T12:17:03Z", "message": "available synchronized\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjkzMTEy", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360293112", "createdAt": "2020-02-18T12:20:11Z", "commit": {"oid": "55615c8d8105659c46cd48b8f33b6398dd37bf86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjk4NDg2", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360298486", "createdAt": "2020-02-18T12:29:33Z", "commit": {"oid": "55615c8d8105659c46cd48b8f33b6398dd37bf86"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzE0MjUz", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360714253", "createdAt": "2020-02-18T22:16:10Z", "commit": {"oid": "55615c8d8105659c46cd48b8f33b6398dd37bf86"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7d9ba7b19c54b76cd8c3ee2b684088d3f7bdcb2", "author": {"user": {"login": "senivam", "name": "Maxim Nesen"}}, "url": "https://github.com/eclipse-ee4j/jersey/commit/c7d9ba7b19c54b76cd8c3ee2b684088d3f7bdcb2", "committedDate": "2020-02-19T06:43:05Z", "message": "complete, close, available, releaseByteBuf are not synchronized, cleanup synchronized\n\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTg5Mzk1", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360589395", "createdAt": "2020-02-18T18:55:29Z", "commit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODo1NTozMFrOFrOZkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODo1NTozMFrOFrfqxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2OTAwOA==", "bodyText": "I think you are right, moving synchronized to the methods that are not part of InputStream is better. I agree it will retain the intended logic. So, need to make sure publish, complete, awaitNext and cleanup synchronized, remove synchronized from the others to avoid confusion about thread safety in the future.", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380869008", "createdAt": "2020-02-18T18:55:30Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MTk0MA==", "bodyText": "LGTM", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r381151940", "createdAt": "2020-02-19T08:55:30Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwOTkxMzI3", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#pullrequestreview-360991327", "createdAt": "2020-02-19T10:18:07Z", "commit": {"oid": "c7d9ba7b19c54b76cd8c3ee2b684088d3f7bdcb2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1276, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}