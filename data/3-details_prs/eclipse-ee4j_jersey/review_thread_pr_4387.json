{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMzc4MTg1", "number": 4387, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNzoxNjo0NFrODgdkbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjoxNTo1NVrODgq_nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzY1NDg2OnYy", "diffSide": "LEFT", "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNzoxNjo0NFrOFqrkuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDo1ODowMlrOFq-BAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5ODQyNA==", "bodyText": "NettyInputStream is available through requestContext#getEnityStream. Removing available implementation is therefore a backward incompatible change", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380298424", "createdAt": "2020-02-17T17:16:44Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();\n+          current = null;\n+          buffer = null;\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n-\n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n     }\n \n     @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n-        }\n-        super.close();\n+    public synchronized void close() {\n+       if (current != null) {\n+          current.release();\n+       }\n+\n+       current = null;\n+       buffer = null;\n+       cleanup(true);\n     }\n \n-    @Override\n-    public int available() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDgwNg==", "bodyText": "No, it is not a breaking change. available has a default implementation in super class. There are no requirements what it should return - it is only an estimate.\nBut I agree it can be implemented.\npublic int available() {\n    return buffer == null? 0: buffer.remaining();\n}", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380390806", "createdAt": "2020-02-17T22:54:49Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();\n+          current = null;\n+          buffer = null;\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n-\n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n     }\n \n     @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n-        }\n-        super.close();\n+    public synchronized void close() {\n+       if (current != null) {\n+          current.release();\n+       }\n+\n+       current = null;\n+       buffer = null;\n+       cleanup(true);\n     }\n \n-    @Override\n-    public int available() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5ODQyNA=="}, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwMDU3Nw==", "bodyText": "modified", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380600577", "createdAt": "2020-02-18T10:58:02Z", "author": {"login": "senivam"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();\n+          current = null;\n+          buffer = null;\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n-\n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n     }\n \n     @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n-        }\n-        super.close();\n+    public synchronized void close() {\n+       if (current != null) {\n+          current.release();\n+       }\n+\n+       current = null;\n+       buffer = null;\n+       cleanup(true);\n     }\n \n-    @Override\n-    public int available() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5ODQyNA=="}, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzgwNDQwOnYy", "diffSide": "RIGHT", "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODoyMzo1MVrOFqs9Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjo0OTowN1rOFqxJIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTExMQ==", "bodyText": "call synchronized close() instead?", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380321111", "createdAt": "2020-02-17T18:23:51Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4OTY2NA==", "bodyText": "No. current potentially references different buffers throughout the lifetime of NettyInputStream. current.release() returns one buffer back to Netty.\nObserve how it interacts with https://github.com/eclipse-ee4j/jersey/pull/4387/files/c6d6efa596c9108e32e0a1c36a885a087423ae65#diff-24846529fe20a75e53f3b1b063c46521R132 and assignment of new current in awaitNext", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380389664", "createdAt": "2020-02-17T22:49:07Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,141 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n+\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          current.release();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTExMQ=="}, "originalCommit": {"oid": "c6d6efa596c9108e32e0a1c36a885a087423ae65"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTg1NDM5OnYy", "diffSide": "RIGHT", "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjoxNTo1NVrOFrAJTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODo1NTozMFrOFrfqxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ==", "bodyText": "should be synchronized", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380635471", "createdAt": "2020-02-18T12:15:55Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNjY5Mg==", "bodyText": "ok", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380636692", "createdAt": "2020-02-18T12:18:43Z", "author": {"login": "senivam"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzODE5OQ==", "bodyText": "Totally disagree. NettyInputStream has been, and remains, not thread safe. available, read and close methods have never been, and are not synchronized, therefore it has always been assumed to be used by a single thread, or access is synchronized by out of band means. Adding synchronized for available alone is pointless. Please, either remove it, or justify Jersey assumptions, and make all content input streams for all connectors thread safe.\nFor example, close is synchronized now, because it interacts with publish.", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380638199", "createdAt": "2020-02-18T12:22:05Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMTY2OQ==", "bodyText": "I see your point. We need to synchronize isList and reading. So only awaitNext(), publish(), and cleanup() are needed to be synchronized. We can remove it from available, close, releaseByteBuf and complete. Or do I miss something?", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380731669", "createdAt": "2020-02-18T15:08:36Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczNjk2MQ==", "bodyText": "No, just do not add to available and releaseByteBuf.\npublish, awaitNext and close interact with each other. A simple way to achieve total order of state transitions between things that are mostly done by two threads, and very rarely, is to use synchronized.\nSo we have one thread (Netty event loop) that receives byte buffers from the socket, and hands these buffers off to a different thread (Jersey thread that wants to readEntity). This is done through publish, and is potentially observed by awaitNext. publish also needs to see if maybe close has been called, so it does not assume anyone is going to release the buffers in the future. That's the purpose of synchronized around those three. It's possible to reduce synchronized block of close to just the place where end=true is set, but I think it will be fine even like this - mostly close will be called after all chunks have been passed through publish, and only maybe in some very rare cases someone will close the stream before reading the full Entity or whatever binary blob they are receiving.\nsynchronized on cleanup is not harmful, but not necessary, because it is invoked from synchronized sections. synchronized on available I think is low cost, but because it does not achieve any improved correctness, I would recommend not adding it. synchronized on releaseByteBuf can be seen as a little harmful - it will potentially add synchronization around current and buffer that are accessed only single-threadedly at that stage. (current is modified by the same thread that does read - publish only notifies awaitNext when new chunks arrive to isList)", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380736961", "createdAt": "2020-02-18T15:16:35Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MTc2MA==", "bodyText": "Sounds like we agree here.\n\nEither we have publish, awaitNext, complete and close synchronized\nOr we have publish, awaitNext, and we move the synchronized from complete and close down to cleanup, where end=true and mainly if (reading) is used.\nBoth are fine, though having close() synchronized could be a bit misleading as the NettyInputStream is not threadsafe.", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380771760", "createdAt": "2020-02-18T16:06:33Z", "author": {"login": "jansupol"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2OTAwOA==", "bodyText": "I think you are right, moving synchronized to the methods that are not part of InputStream is better. I agree it will retain the intended logic. So, need to make sure publish, complete, awaitNext and cleanup synchronized, remove synchronized from the others to avoid confusion about thread safety in the future.", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r380869008", "createdAt": "2020-02-18T18:55:30Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwMzE0MQ==", "bodyText": "OK, as per discussion, I've implemented the B) way - compete and close (including available and releaseByteBuf) are not synchronized, cleanup became synchronized.", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r381103141", "createdAt": "2020-02-19T06:46:30Z", "author": {"login": "senivam"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MTk0MA==", "bodyText": "LGTM", "url": "https://github.com/eclipse-ee4j/jersey/pull/4387#discussion_r381151940", "createdAt": "2020-02-19T08:55:30Z", "author": {"login": "olotenko"}, "path": "connectors/netty-connector/src/main/java/org/glassfish/jersey/netty/connector/internal/NettyInputStream.java", "diffHunk": "@@ -16,107 +16,150 @@\n \n package org.glassfish.jersey.netty.connector.internal;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n \n /**\n  * Input stream which servers as Request entity input.\n  * <p>\n- * Consumes a list of pending {@link ByteBuf}s and processes them on request by Jersey\n+ * Converts Netty NIO buffers to an input streams and stores them in the queue,\n+ * waiting for Jersey to process it.\n+ *\n+ * @author Pavel Bucek\n  */\n public class NettyInputStream extends InputStream {\n \n-    private final LinkedBlockingDeque<ByteBuf> isList;\n+    private volatile boolean end = false;\n+    private Throwable cause;\n+\n+    private final ArrayDeque<ByteBuf> isList;\n+    private ByteBuf current;\n+    private ByteBuffer buffer;\n \n-    public NettyInputStream(LinkedBlockingDeque<ByteBuf> isList) {\n-        this.isList = isList;\n+    private byte[] ONE_BYTE;\n+    private boolean reading;\n+\n+    public NettyInputStream() {\n+        this.isList = new ArrayDeque<>();\n     }\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-\n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            int read = -1;\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n+       if (current == null) {\n+          buffer = awaitNext();\n+          if (buffer == null) {\n+             // assert: end is true\n+             if (cause == null) {\n                 return -1;\n-            }\n-\n-            if (isReadable) {\n-                int readableBytes = take.readableBytes();\n-                read = Math.min(readableBytes, len);\n-                take.readBytes(b, off, read);\n-                if (read < len) {\n-                    take.release();\n-                } else {\n-                    isList.addFirst(take);\n-                }\n-            } else {\n-                read = 0;\n-                take.release(); //We don't need `0`\n-            }\n-\n-            return read;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+             }\n+\n+             throw new IOException(cause);\n+          }\n+       }\n+\n+       int rem = buffer.remaining();\n+       if (rem < len) {\n+          len = rem;\n+       }\n+       buffer.get(b, off, len);\n+       if (rem == len) {\n+          releaseByteBuf();\n+       }\n+\n+       return len;\n     }\n \n     @Override\n     public int read() throws IOException {\n+       if (ONE_BYTE == null) {\n+          ONE_BYTE = new byte[1];\n+       }\n+       int r = read(ONE_BYTE, 0, 1);\n+       if (r < 0) {\n+          return r;\n+       }\n+\n+       return ONE_BYTE[0] & 0xff;\n+    }\n \n-        ByteBuf take;\n-        try {\n-            take = isList.take();\n-            boolean isReadable = take.isReadable();\n-            if (checkEndOfInputOrError(take)) {\n-                take.release();\n-                return -1;\n-            }\n+    @Override\n+    public synchronized void close() {\n \n-            if (isReadable) {\n-                return take.readInt();\n-            } else {\n-                take.release(); //We don't need `0`\n-            }\n+        releaseByteBuf();\n \n-            return 0;\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted.\", e);\n-        }\n+        cleanup(true);\n     }\n \n-    @Override\n-    public void close() throws IOException {\n-        if (isList != null) {\n-            while (!isList.isEmpty()) {\n-                try {\n-                    isList.take().release();\n-                } catch (InterruptedException e) {\n-                    throw new IOException(\"Interrupted. Potential ByteBuf Leak.\", e);\n-                }\n-            }\n+    private synchronized void releaseByteBuf() {\n+        if (current != null) {\n+            current.release();\n         }\n-        super.close();\n+\n+        current = null;\n+        buffer = null;\n+    }\n+\n+    protected synchronized ByteBuffer awaitNext() {\n+       while (isList.isEmpty()) {\n+          if (end) {\n+             return null;\n+          }\n+\n+          try {\n+             reading = true;\n+             wait();\n+             reading = false;\n+          } catch (InterruptedException ie) {\n+             // waiting uninterruptibly\n+          }\n+       }\n+\n+       current = isList.poll();\n+       return current.nioBuffer().asReadOnlyBuffer();\n+    }\n+\n+    public synchronized void complete(Throwable cause) {\n+       this.cause = cause;\n+       cleanup(cause != null);\n+    }\n+\n+    protected void cleanup(boolean drain) {\n+       if (drain) {\n+          while (!isList.isEmpty()) {\n+             isList.poll().release();\n+          }\n+       }\n+\n+       end = true;\n+\n+       if (reading) {\n+          notifyAll();\n+       }\n     }\n \n     @Override\n     public int available() throws IOException {\n-        ByteBuf peek = isList.peek();\n-        if (peek != null && peek.isReadable()) {\n-            return peek.readableBytes();\n-        }\n-        return 0;\n+        return buffer == null ? 0 : buffer.remaining();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYzNTQ3MQ=="}, "originalCommit": {"oid": "b6daf7ed02532ebe58801da65ccf8cb1812407b2"}, "originalPosition": 206}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1361, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}