{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3MjE0Mzkz", "number": 14207, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNDowMFrOFBpW0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNzo0MVrOFBpcRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MjcwNDgyOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/lookup/AsyncLookupJoinRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNDowMFrOIAaQ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNDowMFrOIAaQ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwMTIzMQ==", "bodyText": "rf should always not null ?", "url": "https://github.com/apache/flink/pull/14207#discussion_r537301231", "createdAt": "2020-12-07T08:04:00Z", "author": {"login": "leonardBang"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/lookup/AsyncLookupJoinRunner.java", "diffHunk": "@@ -153,11 +154,20 @@ public void close() throws Exception {\n \t\tif (fetcher != null) {\n \t\t\tFunctionUtils.closeFunction(fetcher);\n \t\t}\n-\t\tfor (JoinedRowResultFuture rf : allResultFutures) {\n-\t\t\trf.close();\n+\t\tif (allResultFutures != null) {\n+\t\t\tfor (JoinedRowResultFuture rf : allResultFutures) {\n+\t\t\t\tif (rf != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da25b44d59f5a02f8d780c17ee45f828fd2fd746"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MjcwNzYxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/AsyncLookupJoinRunnerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNDo0N1rOIAaShw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNDo0N1rOIAaShw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwMTYzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tfail(\"Expected close to fail with null pointer exception.\");\n          \n          \n            \n            \t\t\tfail(\"Unexpected close that failed with \" + e.getMessage());", "url": "https://github.com/apache/flink/pull/14207#discussion_r537301639", "createdAt": "2020-12-07T08:04:47Z", "author": {"login": "leonardBang"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/AsyncLookupJoinRunnerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join;\n+\n+import org.apache.flink.api.common.functions.AbstractRichFunction;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.streaming.api.functions.async.AsyncFunction;\n+import org.apache.flink.streaming.api.functions.async.ResultFuture;\n+import org.apache.flink.streaming.util.MockStreamingRuntimeContext;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.collector.TableFunctionCollector;\n+import org.apache.flink.table.runtime.collector.TableFunctionResultFuture;\n+import org.apache.flink.table.runtime.generated.GeneratedFunctionWrapper;\n+import org.apache.flink.table.runtime.generated.GeneratedResultFutureWrapper;\n+import org.apache.flink.table.runtime.operators.join.lookup.AsyncLookupJoinRunner;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.data.StringData.fromString;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.row;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link AsyncLookupJoinRunner}.\n+ */\n+public class AsyncLookupJoinRunnerTest {\n+\n+\t@Test\n+\tpublic void testCloseAsyncLookupJoinRunner() throws Exception {\n+\t\tfinal InternalTypeInfo<RowData> rightRowTypeInfo = InternalTypeInfo.ofFields(\n+\t\t\t\tDataTypes.INT().getLogicalType(),\n+\t\t\t\tDataTypes.STRING().getLogicalType());\n+\t\tfinal AsyncLookupJoinRunner joinRunner = new AsyncLookupJoinRunner(\n+\t\t\t\tnew GeneratedFunctionWrapper(new TestingFetcherFunction()),\n+\t\t\t\tnew GeneratedResultFutureWrapper<>(new TestingFetcherResultFuture()),\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\ttrue,\n+\t\t\t\t100);\n+\t\tassertNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.setRuntimeContext(new MockStreamingRuntimeContext(false, 1, 0));\n+\t\tjoinRunner.open(new Configuration());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.open(new Configuration());\n+\t\tjoinRunner.asyncInvoke(row(1, \"a\"), new TestingFetcherResultFuture());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\t}\n+\n+\tprivate void closeAsyncLookupJoinRunner(AsyncLookupJoinRunner joinRunner) throws Exception {\n+\t\ttry {\n+\t\t\tjoinRunner.close();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tfail(\"Expected close to fail with null pointer exception.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da25b44d59f5a02f8d780c17ee45f828fd2fd746"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MjcxODc3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/AsyncLookupJoinRunnerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODowNzo0MVrOIAaYmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODo0OToyM1rOIAb4vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwMzE5NQ==", "bodyText": "looks like TestingFetcherFunction and  TestingFetcherResultFuture are redundant,  we defined same inner class in three tests with same versionId, I think it's an existed issue. Could we only define once and reuse them?", "url": "https://github.com/apache/flink/pull/14207#discussion_r537303195", "createdAt": "2020-12-07T08:07:41Z", "author": {"login": "leonardBang"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/AsyncLookupJoinRunnerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join;\n+\n+import org.apache.flink.api.common.functions.AbstractRichFunction;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.streaming.api.functions.async.AsyncFunction;\n+import org.apache.flink.streaming.api.functions.async.ResultFuture;\n+import org.apache.flink.streaming.util.MockStreamingRuntimeContext;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.collector.TableFunctionCollector;\n+import org.apache.flink.table.runtime.collector.TableFunctionResultFuture;\n+import org.apache.flink.table.runtime.generated.GeneratedFunctionWrapper;\n+import org.apache.flink.table.runtime.generated.GeneratedResultFutureWrapper;\n+import org.apache.flink.table.runtime.operators.join.lookup.AsyncLookupJoinRunner;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.data.StringData.fromString;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.row;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link AsyncLookupJoinRunner}.\n+ */\n+public class AsyncLookupJoinRunnerTest {\n+\n+\t@Test\n+\tpublic void testCloseAsyncLookupJoinRunner() throws Exception {\n+\t\tfinal InternalTypeInfo<RowData> rightRowTypeInfo = InternalTypeInfo.ofFields(\n+\t\t\t\tDataTypes.INT().getLogicalType(),\n+\t\t\t\tDataTypes.STRING().getLogicalType());\n+\t\tfinal AsyncLookupJoinRunner joinRunner = new AsyncLookupJoinRunner(\n+\t\t\t\tnew GeneratedFunctionWrapper(new TestingFetcherFunction()),\n+\t\t\t\tnew GeneratedResultFutureWrapper<>(new TestingFetcherResultFuture()),\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\ttrue,\n+\t\t\t\t100);\n+\t\tassertNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.setRuntimeContext(new MockStreamingRuntimeContext(false, 1, 0));\n+\t\tjoinRunner.open(new Configuration());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.open(new Configuration());\n+\t\tjoinRunner.asyncInvoke(row(1, \"a\"), new TestingFetcherResultFuture());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\t}\n+\n+\tprivate void closeAsyncLookupJoinRunner(AsyncLookupJoinRunner joinRunner) throws Exception {\n+\t\ttry {\n+\t\t\tjoinRunner.close();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tfail(\"Expected close to fail with null pointer exception.\");\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------\n+\n+\t/**\n+\t * The {@link TestingFetcherFunction} only accepts a single integer lookup key and\n+\t * returns zero or one or more RowData.\n+\t */\n+\tpublic static final class TestingFetcherFunction\n+\t\t\textends AbstractRichFunction\n+\t\t\timplements AsyncFunction<RowData, RowData> {\n+\n+\t\tprivate static final long serialVersionUID = 4018474964018227081L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da25b44d59f5a02f8d780c17ee45f828fd2fd746"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMyNzgwNg==", "bodyText": "looks like TestingFetcherFunction and TestingFetcherResultFuture are redundant, we defined same inner class in three tests with same versionId, I think it's an existed issue. Could we only define once and reuse them?\n\n@leonardBang I thought that it could be defined once and reused TestingFetcherFunction and TestingFetcherResultFuture. I would like to reuse them.", "url": "https://github.com/apache/flink/pull/14207#discussion_r537327806", "createdAt": "2020-12-07T08:49:23Z", "author": {"login": "SteNicholas"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/AsyncLookupJoinRunnerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join;\n+\n+import org.apache.flink.api.common.functions.AbstractRichFunction;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.streaming.api.functions.async.AsyncFunction;\n+import org.apache.flink.streaming.api.functions.async.ResultFuture;\n+import org.apache.flink.streaming.util.MockStreamingRuntimeContext;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.collector.TableFunctionCollector;\n+import org.apache.flink.table.runtime.collector.TableFunctionResultFuture;\n+import org.apache.flink.table.runtime.generated.GeneratedFunctionWrapper;\n+import org.apache.flink.table.runtime.generated.GeneratedResultFutureWrapper;\n+import org.apache.flink.table.runtime.operators.join.lookup.AsyncLookupJoinRunner;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.data.StringData.fromString;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.row;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link AsyncLookupJoinRunner}.\n+ */\n+public class AsyncLookupJoinRunnerTest {\n+\n+\t@Test\n+\tpublic void testCloseAsyncLookupJoinRunner() throws Exception {\n+\t\tfinal InternalTypeInfo<RowData> rightRowTypeInfo = InternalTypeInfo.ofFields(\n+\t\t\t\tDataTypes.INT().getLogicalType(),\n+\t\t\t\tDataTypes.STRING().getLogicalType());\n+\t\tfinal AsyncLookupJoinRunner joinRunner = new AsyncLookupJoinRunner(\n+\t\t\t\tnew GeneratedFunctionWrapper(new TestingFetcherFunction()),\n+\t\t\t\tnew GeneratedResultFutureWrapper<>(new TestingFetcherResultFuture()),\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\trightRowTypeInfo,\n+\t\t\t\ttrue,\n+\t\t\t\t100);\n+\t\tassertNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.setRuntimeContext(new MockStreamingRuntimeContext(false, 1, 0));\n+\t\tjoinRunner.open(new Configuration());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\n+\t\tjoinRunner.open(new Configuration());\n+\t\tjoinRunner.asyncInvoke(row(1, \"a\"), new TestingFetcherResultFuture());\n+\t\tassertNotNull(joinRunner.getAllResultFutures());\n+\t\tcloseAsyncLookupJoinRunner(joinRunner);\n+\t}\n+\n+\tprivate void closeAsyncLookupJoinRunner(AsyncLookupJoinRunner joinRunner) throws Exception {\n+\t\ttry {\n+\t\t\tjoinRunner.close();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tfail(\"Expected close to fail with null pointer exception.\");\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------\n+\n+\t/**\n+\t * The {@link TestingFetcherFunction} only accepts a single integer lookup key and\n+\t * returns zero or one or more RowData.\n+\t */\n+\tpublic static final class TestingFetcherFunction\n+\t\t\textends AbstractRichFunction\n+\t\t\timplements AsyncFunction<RowData, RowData> {\n+\n+\t\tprivate static final long serialVersionUID = 4018474964018227081L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwMzE5NQ=="}, "originalCommit": {"oid": "da25b44d59f5a02f8d780c17ee45f828fd2fd746"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4754, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}