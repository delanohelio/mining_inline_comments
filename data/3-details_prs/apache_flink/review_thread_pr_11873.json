{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NzA2MDM4", "number": 11873, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1MjoyMlrOEWpB0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoxMzowNlrOEWpL4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTc2MzM3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1MjoyMlrOG-AJrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1MjoyMlrOG-AJrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY2NzM3Mw==", "bodyText": "NIT: executionVertexId would be better than executionVertexID.", "url": "https://github.com/apache/flink/pull/11873#discussion_r467667373", "createdAt": "2020-08-10T02:52:22Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTc2NDk4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1Mzo0OFrOG-AKkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1Mzo0OFrOG-AKkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY2NzYwMg==", "bodyText": "NIT: getExecutionVertexId would be better than getExecutionVertexID", "url": "https://github.com/apache/flink/pull/11873#discussion_r467667602", "createdAt": "2020-08-10T02:53:48Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {\n+\t\tthis(new ExecutionVertexID(), 0);\n \t}\n \n-\tpublic ExecutionAttemptID(long lowerPart, long upperPart) {\n-\t\tsuper(lowerPart, upperPart);\n+\tpublic ExecutionAttemptID(ExecutionVertexID executionVertexID, int attemptNumber) {\n+\t\tPreconditions.checkState(attemptNumber >= 0);\n+\t\tthis.executionVertexID = Preconditions.checkNotNull(executionVertexID);\n+\t\tthis.attemptNumber = attemptNumber;\n \t}\n \n \tpublic void writeTo(ByteBuf buf) {\n-\t\tbuf.writeLong(this.lowerPart);\n-\t\tbuf.writeLong(this.upperPart);\n+\t\texecutionVertexID.writeTo(buf);\n+\t\tbuf.writeInt(this.attemptNumber);\n \t}\n \n \tpublic static ExecutionAttemptID fromByteBuf(ByteBuf buf) {\n-\t\tlong lower = buf.readLong();\n-\t\tlong upper = buf.readLong();\n-\t\treturn new ExecutionAttemptID(lower, upper);\n+\t\tfinal ExecutionVertexID executionVertexID = ExecutionVertexID.fromByteBuf(buf);\n+\t\tfinal int attemptNumber = buf.readInt();\n+\t\treturn new ExecutionAttemptID(executionVertexID, attemptNumber);\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic int getAttemptNumber() {\n+\t\treturn attemptNumber;\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic ExecutionVertexID getExecutionVertexID() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTc2OTkwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMjo1NzozN1rOG-ANCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMzoxMjo0OVrOHBYavQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY2ODIzMg==", "bodyText": "I'd prefer this.executionVertexID.hashCode() * 31 + this.attemptNumber.\nThis is because attemptNumber  == 0 is very common and can result in the same hash code.", "url": "https://github.com/apache/flink/pull/11873#discussion_r467668232", "createdAt": "2020-08-10T02:57:37Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {\n+\t\tthis(new ExecutionVertexID(), 0);\n \t}\n \n-\tpublic ExecutionAttemptID(long lowerPart, long upperPart) {\n-\t\tsuper(lowerPart, upperPart);\n+\tpublic ExecutionAttemptID(ExecutionVertexID executionVertexID, int attemptNumber) {\n+\t\tPreconditions.checkState(attemptNumber >= 0);\n+\t\tthis.executionVertexID = Preconditions.checkNotNull(executionVertexID);\n+\t\tthis.attemptNumber = attemptNumber;\n \t}\n \n \tpublic void writeTo(ByteBuf buf) {\n-\t\tbuf.writeLong(this.lowerPart);\n-\t\tbuf.writeLong(this.upperPart);\n+\t\texecutionVertexID.writeTo(buf);\n+\t\tbuf.writeInt(this.attemptNumber);\n \t}\n \n \tpublic static ExecutionAttemptID fromByteBuf(ByteBuf buf) {\n-\t\tlong lower = buf.readLong();\n-\t\tlong upper = buf.readLong();\n-\t\treturn new ExecutionAttemptID(lower, upper);\n+\t\tfinal ExecutionVertexID executionVertexID = ExecutionVertexID.fromByteBuf(buf);\n+\t\tfinal int attemptNumber = buf.readInt();\n+\t\treturn new ExecutionAttemptID(executionVertexID, attemptNumber);\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic int getAttemptNumber() {\n+\t\treturn attemptNumber;\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic ExecutionVertexID getExecutionVertexID() {\n+\t\treturn executionVertexID;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj == this) {\n+\t\t\treturn true;\n+\t\t} else if (obj != null && obj.getClass() == getClass()) {\n+\t\t\tExecutionAttemptID that = (ExecutionAttemptID) obj;\n+\t\t\treturn that.executionVertexID.equals(this.executionVertexID)\n+\t\t\t\t&& that.attemptNumber == this.attemptNumber;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn this.executionVertexID.hashCode() ^ this.attemptNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIxMDY4NQ==", "bodyText": "Good point!", "url": "https://github.com/apache/flink/pull/11873#discussion_r471210685", "createdAt": "2020-08-17T03:12:49Z", "author": {"login": "KarmaGYZ"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {\n+\t\tthis(new ExecutionVertexID(), 0);\n \t}\n \n-\tpublic ExecutionAttemptID(long lowerPart, long upperPart) {\n-\t\tsuper(lowerPart, upperPart);\n+\tpublic ExecutionAttemptID(ExecutionVertexID executionVertexID, int attemptNumber) {\n+\t\tPreconditions.checkState(attemptNumber >= 0);\n+\t\tthis.executionVertexID = Preconditions.checkNotNull(executionVertexID);\n+\t\tthis.attemptNumber = attemptNumber;\n \t}\n \n \tpublic void writeTo(ByteBuf buf) {\n-\t\tbuf.writeLong(this.lowerPart);\n-\t\tbuf.writeLong(this.upperPart);\n+\t\texecutionVertexID.writeTo(buf);\n+\t\tbuf.writeInt(this.attemptNumber);\n \t}\n \n \tpublic static ExecutionAttemptID fromByteBuf(ByteBuf buf) {\n-\t\tlong lower = buf.readLong();\n-\t\tlong upper = buf.readLong();\n-\t\treturn new ExecutionAttemptID(lower, upper);\n+\t\tfinal ExecutionVertexID executionVertexID = ExecutionVertexID.fromByteBuf(buf);\n+\t\tfinal int attemptNumber = buf.readInt();\n+\t\treturn new ExecutionAttemptID(executionVertexID, attemptNumber);\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic int getAttemptNumber() {\n+\t\treturn attemptNumber;\n+\t}\n+\n+\t@VisibleForTesting\n+\tpublic ExecutionVertexID getExecutionVertexID() {\n+\t\treturn executionVertexID;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj == this) {\n+\t\t\treturn true;\n+\t\t} else if (obj != null && obj.getClass() == getClass()) {\n+\t\t\tExecutionAttemptID that = (ExecutionAttemptID) obj;\n+\t\t\treturn that.executionVertexID.equals(this.executionVertexID)\n+\t\t\t\t&& that.attemptNumber == this.attemptNumber;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn this.executionVertexID.hashCode() ^ this.attemptNumber;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY2ODIzMg=="}, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTc4NzA5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/ExecutionVertexID.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoxMToxOFrOG-AWKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoxMToxOFrOG-AWKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MDU3MA==", "bodyText": "Could we introduce a util method ExecutionGraphTestUtils#createRandomExecutionVertexId() to avoid pollute production code with test code? And make it true random with a random subtaskIndex as well.", "url": "https://github.com/apache/flink/pull/11873#discussion_r467670570", "createdAt": "2020-08-10T03:11:18Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/ExecutionVertexID.java", "diffHunk": "@@ -33,6 +35,10 @@\n \n \tprivate final int subtaskIndex;\n \n+\tpublic ExecutionVertexID() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTc4OTE0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMzoxMzowNlrOG-AXSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNDowNzo0MVrOHBZE4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MDg1OQ==", "bodyText": "This constructor is for tests only. Could we introduce a test util method ExecutionGraphTestUtils#createRandomExecutionAttemptId()? The returned id consists of a random ExecutionVertexId as well as a random attemptNumber. I think it better suites the tests which wants a random ExecutionAttemptID. And we can also avoid to add a test-only code path in production.", "url": "https://github.com/apache/flink/pull/11873#discussion_r467670859", "createdAt": "2020-08-10T03:13:06Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIxODI2OQ==", "bodyText": "Yes, that's a good point. However, it is currently used by production code and a lot of testing code paths. I would move this issue out of the scope of this PR. WDYT?", "url": "https://github.com/apache/flink/pull/11873#discussion_r471218269", "createdAt": "2020-08-17T03:50:57Z", "author": {"login": "KarmaGYZ"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MDg1OQ=="}, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIyMTQ3NA==", "bodyText": "Makes sense.", "url": "https://github.com/apache/flink/pull/11873#discussion_r471221474", "createdAt": "2020-08-17T04:07:41Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionAttemptID.java", "diffHunk": "@@ -18,33 +18,77 @@\n \n package org.apache.flink.runtime.executiongraph;\n \n-import org.apache.flink.util.AbstractID;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n \n import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;\n+import org.apache.flink.util.Preconditions;\n \n /**\n  * Unique identifier for the attempt to execute a tasks. Multiple attempts happen\n  * in cases of failures and recovery.\n  */\n-public class ExecutionAttemptID extends AbstractID {\n+public class ExecutionAttemptID implements java.io.Serializable {\n \n \tprivate static final long serialVersionUID = -1169683445778281344L;\n \n+\tprivate final ExecutionVertexID executionVertexID;\n+\tprivate final int attemptNumber;\n+\n+\t/**\n+\t * Get a random execution attempt id.\n+\t */\n \tpublic ExecutionAttemptID() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MDg1OQ=="}, "originalCommit": {"oid": "04ebeee8b4a19b2aafee9e57a746522cd2c9654f"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1574, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}