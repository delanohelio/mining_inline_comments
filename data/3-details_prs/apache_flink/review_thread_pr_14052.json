{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMDEzOTYz", "number": 14052, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwNzoyOToyMlrOE5TAtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1Mjo1MVrOE5ZomA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTE1NzY2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/resources/log4j2-test.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwNzoyOToyMlrOHzqwSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTozMjo0N1rOH0sAYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkzOTkxNQ==", "bodyText": "There is some reason why it's turned off by default and it should stay this way. If you want to know the reason, I'd have to ask Chesnay or Robert though.", "url": "https://github.com/apache/flink/pull/14052#discussion_r523939915", "createdAt": "2020-11-16T07:29:22Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/resources/log4j2-test.properties", "diffHunk": "@@ -18,7 +18,7 @@\n \n # Set root logger level to OFF to not flood build logs\n # set manually to INFO for debugging purposes\n-rootLogger.level = OFF\n+rootLogger.level = ERROR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b32349343babb0bc132d95172a80105c8ea81a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwODk5Mg==", "bodyText": "After an offline discussion, I dropped this change to keep settings consistent across the project.", "url": "https://github.com/apache/flink/pull/14052#discussion_r525008992", "createdAt": "2020-11-17T09:32:47Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/resources/log4j2-test.properties", "diffHunk": "@@ -18,7 +18,7 @@\n \n # Set root logger level to OFF to not flood build logs\n # set manually to INFO for debugging purposes\n-rootLogger.level = OFF\n+rootLogger.level = ERROR", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkzOTkxNQ=="}, "originalCommit": {"oid": "95b32349343babb0bc132d95172a80105c8ea81a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTUyMDUxOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTowNTowMVrOHzuIlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNDo1OToyNVrOH0Cn_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NTI4NQ==", "bodyText": "You wrote in the PR description that this PR will also avoid numBuffersOvertaken being overwritten, but I don't see a specific change in that regard here. I was assuming that one of the earlier PRs already helped with that by fixing checkForBarrier.", "url": "https://github.com/apache/flink/pull/14052#discussion_r523995285", "createdAt": "2020-11-16T09:05:01Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -481,7 +489,7 @@ private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) throws IOExcept\n \t\tif (channelStatePersister.checkForBarrier(sequenceBuffer.buffer)) {\n \t\t\t// checkpoint was not yet started by task thread,\n \t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\tnumBuffersOvertaken = receivedBuffers.getNumUnprioritizedElements();\n+\t\t\tlastOvertakenSequenceNumber = sequenceBuffer.sequenceNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMzMTAwNA==", "bodyText": "This is addressed in the next commit by adding lastBarrierId and checking it.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524331004", "createdAt": "2020-11-16T14:59:25Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -481,7 +489,7 @@ private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) throws IOExcept\n \t\tif (channelStatePersister.checkForBarrier(sequenceBuffer.buffer)) {\n \t\t\t// checkpoint was not yet started by task thread,\n \t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\tnumBuffersOvertaken = receivedBuffers.getNumUnprioritizedElements();\n+\t\t\tlastOvertakenSequenceNumber = sequenceBuffer.sequenceNumber;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NTI4NQ=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTUzMzg4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTowNzowNFrOHzuQ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjozNzo1MFrOH12v3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg==", "bodyText": "It should be possible to avoid iterating over all buffers by aborting on the first !shouldBeSpilled.", "url": "https://github.com/apache/flink/pull/14052#discussion_r523997432", "createdAt": "2020-11-16T09:07:04Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0NjI3Mg==", "bodyText": "I think it wouldn't work because of a possible sequence number overflow before overtaking.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524346272", "createdAt": "2020-11-16T15:20:25Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDQyNg==", "bodyText": "Is there a scenario where shouldBeSpilled returns [true, false, true] for any given buffer sequence? I don't see it happening even with overflow.", "url": "https://github.com/apache/flink/pull/14052#discussion_r525864426", "createdAt": "2020-11-18T07:28:38Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzMzU2NA==", "bodyText": "I think you're right, I'll change it.", "url": "https://github.com/apache/flink/pull/14052#discussion_r526233564", "createdAt": "2020-11-18T16:37:50Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTU2NjgzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxMjowMlrOHzumXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzozMDozMFrOH1gRSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA==", "bodyText": "Do we need to use similar code later for timeout at a different place? If so, I'd pull it in some Util (even flink-core?).\nAlternatively, we could also just switch to having long sequence numbers. I was originally writing this overflow check, but I'm now thinking that it might be easier to just add these 4 bytes to each buffer header.\nI guess the question is how often we actually reach Int.MAX in one execution attempt on one channel. With a 32kb buffer, it's ~70 Tb data on that channel, so rather unlikely in one attempt. On the other hand, if we ever persist the buffer id (for incremental state channel), we might reach it eventually.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524002910", "createdAt": "2020-11-16T09:12:02Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+\t\t\t\tinflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n \t\t\t}\n \t\t}\n \n+\t\tlastOvertakenSequenceNumber = null;\n+\n \t\treturn inflightBuffers;\n \t}\n \n+\t/**\n+\t * @return if given {@param sequenceNumber} should be spilled given {@link #lastOvertakenSequenceNumber}.\n+\t * We might not have yet received {@link CheckpointBarrier} and we might need to spill everything.\n+\t * If we have already received it, there is a bit nasty corner case of {@link SequenceBuffer#sequenceNumber}\n+\t * overflowing that needs to be handled as well.\n+\t */\n+\tprivate boolean shouldBeSpilled(int sequenceNumber) {\n+\t\tif (lastOvertakenSequenceNumber == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tcheckState(\n+\t\t\treceivedBuffers.size() < Integer.MAX_VALUE / 2,\n+\t\t\t\"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+\t\tboolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastOvertakenSequenceNumber;\n+\t\tboolean possibleOverflowBeforeOvertaking = lastOvertakenSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+\t\tif (possibleOverflowAfterOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber && sequenceNumber > 0;\n+\t\t}\n+\t\telse if (possibleOverflowBeforeOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber || sequenceNumber > 0;\n+\t\t}\n+\t\telse {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NzU1NQ==", "bodyText": "As far as I can tell this is the only such place. AlignedController collects SQNs but eventually passes them to  AlignedController which uses them here.\nI think changing the buffer format would have a broader scope (and require a broad discussion), so I'd stick with the current approach.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524357555", "createdAt": "2020-11-16T15:34:51Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+\t\t\t\tinflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n \t\t\t}\n \t\t}\n \n+\t\tlastOvertakenSequenceNumber = null;\n+\n \t\treturn inflightBuffers;\n \t}\n \n+\t/**\n+\t * @return if given {@param sequenceNumber} should be spilled given {@link #lastOvertakenSequenceNumber}.\n+\t * We might not have yet received {@link CheckpointBarrier} and we might need to spill everything.\n+\t * If we have already received it, there is a bit nasty corner case of {@link SequenceBuffer#sequenceNumber}\n+\t * overflowing that needs to be handled as well.\n+\t */\n+\tprivate boolean shouldBeSpilled(int sequenceNumber) {\n+\t\tif (lastOvertakenSequenceNumber == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tcheckState(\n+\t\t\treceivedBuffers.size() < Integer.MAX_VALUE / 2,\n+\t\t\t\"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+\t\tboolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastOvertakenSequenceNumber;\n+\t\tboolean possibleOverflowBeforeOvertaking = lastOvertakenSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+\t\tif (possibleOverflowAfterOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber && sequenceNumber > 0;\n+\t\t}\n+\t\telse if (possibleOverflowBeforeOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber || sequenceNumber > 0;\n+\t\t}\n+\t\telse {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2MDY3Mw==", "bodyText": "I was originally writing this overflow check\n\nThen I pulled it from Piotr's PR, and now you are reviewing it. The circle is closed :)", "url": "https://github.com/apache/flink/pull/14052#discussion_r524360673", "createdAt": "2020-11-16T15:38:49Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+\t\t\t\tinflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n \t\t\t}\n \t\t}\n \n+\t\tlastOvertakenSequenceNumber = null;\n+\n \t\treturn inflightBuffers;\n \t}\n \n+\t/**\n+\t * @return if given {@param sequenceNumber} should be spilled given {@link #lastOvertakenSequenceNumber}.\n+\t * We might not have yet received {@link CheckpointBarrier} and we might need to spill everything.\n+\t * If we have already received it, there is a bit nasty corner case of {@link SequenceBuffer#sequenceNumber}\n+\t * overflowing that needs to be handled as well.\n+\t */\n+\tprivate boolean shouldBeSpilled(int sequenceNumber) {\n+\t\tif (lastOvertakenSequenceNumber == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tcheckState(\n+\t\t\treceivedBuffers.size() < Integer.MAX_VALUE / 2,\n+\t\t\t\"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+\t\tboolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastOvertakenSequenceNumber;\n+\t\tboolean possibleOverflowBeforeOvertaking = lastOvertakenSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+\t\tif (possibleOverflowAfterOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber && sequenceNumber > 0;\n+\t\t}\n+\t\telse if (possibleOverflowBeforeOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber || sequenceNumber > 0;\n+\t\t}\n+\t\telse {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NTI4OQ==", "bodyText": "If this is the only place, we can leave as is. We just need to be aware of the code in other places where we compare sequence numbers (other than the strict increment of RemoteInputChannel) and pull out on demand.", "url": "https://github.com/apache/flink/pull/14052#discussion_r525865289", "createdAt": "2020-11-18T07:30:30Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+\t\t\t\tinflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n \t\t\t}\n \t\t}\n \n+\t\tlastOvertakenSequenceNumber = null;\n+\n \t\treturn inflightBuffers;\n \t}\n \n+\t/**\n+\t * @return if given {@param sequenceNumber} should be spilled given {@link #lastOvertakenSequenceNumber}.\n+\t * We might not have yet received {@link CheckpointBarrier} and we might need to spill everything.\n+\t * If we have already received it, there is a bit nasty corner case of {@link SequenceBuffer#sequenceNumber}\n+\t * overflowing that needs to be handled as well.\n+\t */\n+\tprivate boolean shouldBeSpilled(int sequenceNumber) {\n+\t\tif (lastOvertakenSequenceNumber == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tcheckState(\n+\t\t\treceivedBuffers.size() < Integer.MAX_VALUE / 2,\n+\t\t\t\"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+\t\tboolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastOvertakenSequenceNumber;\n+\t\tboolean possibleOverflowBeforeOvertaking = lastOvertakenSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+\t\tif (possibleOverflowAfterOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber && sequenceNumber > 0;\n+\t\t}\n+\t\telse if (possibleOverflowBeforeOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber || sequenceNumber > 0;\n+\t\t}\n+\t\telse {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTY0OTI3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToyNDozNlrOHzvcZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODowMDoyMlrOH17Qng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg==", "bodyText": "I'm not sure if all of this particular refactoring makes the test more readable: How should I know which sequence number sequence to expect? The assertion at the end is easy to understand though.\nIt would be much easier to understand with:\nsendBuffer(0);\nsendBuffer(1);\nsendBarrier(2);\nsendBuffer(3);\nsendBuffer(4);\n\nThese building blocks should also be reusable for the other tests.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524016742", "createdAt": "2020-11-16T09:24:36Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1125,70 +1127,137 @@ public void testUnblockReleasedChannel() throws Exception {\n \n \t@Test\n \tpublic void testPrioritySequenceNumbers() throws Exception {\n-\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(4, 4096);\n-\t\tSingleInputGate inputGate = new SingleInputGateBuilder()\n-\t\t\t.setChannelFactory(InputChannelBuilder::buildRemoteChannel)\n-\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(1, 4))\n-\t\t\t.setSegmentProvider(networkBufferPool)\n-\t\t\t.build();\n-\t\tfinal RemoteInputChannel channel = (RemoteInputChannel) inputGate.getChannel(0);\n-\t\tinputGate.setup();\n-\t\tinputGate.requestPartitions();\n+\t\tfinal RemoteInputChannel channel = buildInputGateAndGetChannel();\n+\t\tsendBuffersAndBarrier(channel, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxNzk1Mw==", "bodyText": "I agree that this change doesn't make this test more readable.\nBut if you consider other tests, they have the same logic. Thus, it's easier to understand them if this logic is extracted.\nIf you insist I can inline these steps (sendXxx).", "url": "https://github.com/apache/flink/pull/14052#discussion_r524417953", "createdAt": "2020-11-16T16:52:46Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1125,70 +1127,137 @@ public void testUnblockReleasedChannel() throws Exception {\n \n \t@Test\n \tpublic void testPrioritySequenceNumbers() throws Exception {\n-\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(4, 4096);\n-\t\tSingleInputGate inputGate = new SingleInputGateBuilder()\n-\t\t\t.setChannelFactory(InputChannelBuilder::buildRemoteChannel)\n-\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(1, 4))\n-\t\t\t.setSegmentProvider(networkBufferPool)\n-\t\t\t.build();\n-\t\tfinal RemoteInputChannel channel = (RemoteInputChannel) inputGate.getChannel(0);\n-\t\tinputGate.setup();\n-\t\tinputGate.requestPartitions();\n+\t\tfinal RemoteInputChannel channel = buildInputGateAndGetChannel();\n+\t\tsendBuffersAndBarrier(channel, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NjM3NQ==", "bodyText": "I'd like to see them inlined. I aim to always have a test structured in the given, when, then structure and I think with this change, you managed to get exactly that (much better than it was before).", "url": "https://github.com/apache/flink/pull/14052#discussion_r525866375", "createdAt": "2020-11-18T07:32:58Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1125,70 +1127,137 @@ public void testUnblockReleasedChannel() throws Exception {\n \n \t@Test\n \tpublic void testPrioritySequenceNumbers() throws Exception {\n-\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(4, 4096);\n-\t\tSingleInputGate inputGate = new SingleInputGateBuilder()\n-\t\t\t.setChannelFactory(InputChannelBuilder::buildRemoteChannel)\n-\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(1, 4))\n-\t\t\t.setSegmentProvider(networkBufferPool)\n-\t\t\t.build();\n-\t\tfinal RemoteInputChannel channel = (RemoteInputChannel) inputGate.getChannel(0);\n-\t\tinputGate.setup();\n-\t\tinputGate.requestPartitions();\n+\t\tfinal RemoteInputChannel channel = buildInputGateAndGetChannel();\n+\t\tsendBuffersAndBarrier(channel, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzQ4Ng==", "bodyText": "Inlined.", "url": "https://github.com/apache/flink/pull/14052#discussion_r526307486", "createdAt": "2020-11-18T18:00:22Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1125,70 +1127,137 @@ public void testUnblockReleasedChannel() throws Exception {\n \n \t@Test\n \tpublic void testPrioritySequenceNumbers() throws Exception {\n-\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(4, 4096);\n-\t\tSingleInputGate inputGate = new SingleInputGateBuilder()\n-\t\t\t.setChannelFactory(InputChannelBuilder::buildRemoteChannel)\n-\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(1, 4))\n-\t\t\t.setSegmentProvider(networkBufferPool)\n-\t\t\t.build();\n-\t\tfinal RemoteInputChannel channel = (RemoteInputChannel) inputGate.getChannel(0);\n-\t\tinputGate.setup();\n-\t\tinputGate.requestPartitions();\n+\t\tfinal RemoteInputChannel channel = buildInputGateAndGetChannel();\n+\t\tsendBuffersAndBarrier(channel, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}, "originalCommit": {"oid": "de43e752d21e95496aab69e13d9c007fa29d5b2f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI0MjgwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1Mjo1MVrOHz1dsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODowMzozMFrOH17YMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA==", "bodyText": "Ah that what I was missing in the first main commit.\nI propose to squash the 2 main commits or at least already use the final name/type in the first main commit, so that the two commits don't touch every piece of code twice.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524115378", "createdAt": "2020-11-16T10:52:51Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -98,14 +100,11 @@\n \n \tprivate final BufferManager bufferManager;\n \n-\t/**\n-\t * Indicates the last overtaken sequence number by the most recent {@link CheckpointBarrier}\n-\t * before task thread started checkpoint, or {@code null} if {@link CheckpointBarrier} hasn't\n-\t * arrived yet.\n-\t */\n \t@GuardedBy(\"receivedBuffers\")\n-\t@Nullable\n-\tprivate Integer lastOvertakenSequenceNumber = null;\n+\tprivate int lastBarrierSequenceNumber = NONE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b6d028dde24fc8fd21e3a3542756c813fca9c13"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MTg5Mg==", "bodyText": "The name of this field is also changed, so migrating the type change to the older commit will only eliminate two changes in the 2nd commit.\nBesides that, I'd like to keep the first commit (from the other PR) separate and untouched to avoid confusion.", "url": "https://github.com/apache/flink/pull/14052#discussion_r524391892", "createdAt": "2020-11-16T16:18:49Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -98,14 +100,11 @@\n \n \tprivate final BufferManager bufferManager;\n \n-\t/**\n-\t * Indicates the last overtaken sequence number by the most recent {@link CheckpointBarrier}\n-\t * before task thread started checkpoint, or {@code null} if {@link CheckpointBarrier} hasn't\n-\t * arrived yet.\n-\t */\n \t@GuardedBy(\"receivedBuffers\")\n-\t@Nullable\n-\tprivate Integer lastOvertakenSequenceNumber = null;\n+\tprivate int lastBarrierSequenceNumber = NONE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}, "originalCommit": {"oid": "9b6d028dde24fc8fd21e3a3542756c813fca9c13"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NzE0OA==", "bodyText": "As a reviewer of this PR, I'm more confused by separation. I think Piotr is also not a big fan of touching the same code in multiple commits. The question is which confusion you want to avoid? Is it about code ownership? Then, I wouldn't mind keeping it separate.", "url": "https://github.com/apache/flink/pull/14052#discussion_r525867148", "createdAt": "2020-11-18T07:34:48Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -98,14 +100,11 @@\n \n \tprivate final BufferManager bufferManager;\n \n-\t/**\n-\t * Indicates the last overtaken sequence number by the most recent {@link CheckpointBarrier}\n-\t * before task thread started checkpoint, or {@code null} if {@link CheckpointBarrier} hasn't\n-\t * arrived yet.\n-\t */\n \t@GuardedBy(\"receivedBuffers\")\n-\t@Nullable\n-\tprivate Integer lastOvertakenSequenceNumber = null;\n+\tprivate int lastBarrierSequenceNumber = NONE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}, "originalCommit": {"oid": "9b6d028dde24fc8fd21e3a3542756c813fca9c13"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwOTQyNQ==", "bodyText": "It would be easier I think for us to unroll the history later if needed.\nBut I don't insist, moved type change to Piotr's commit.", "url": "https://github.com/apache/flink/pull/14052#discussion_r526309425", "createdAt": "2020-11-18T18:03:30Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -98,14 +100,11 @@\n \n \tprivate final BufferManager bufferManager;\n \n-\t/**\n-\t * Indicates the last overtaken sequence number by the most recent {@link CheckpointBarrier}\n-\t * before task thread started checkpoint, or {@code null} if {@link CheckpointBarrier} hasn't\n-\t * arrived yet.\n-\t */\n \t@GuardedBy(\"receivedBuffers\")\n-\t@Nullable\n-\tprivate Integer lastOvertakenSequenceNumber = null;\n+\tprivate int lastBarrierSequenceNumber = NONE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}, "originalCommit": {"oid": "9b6d028dde24fc8fd21e3a3542756c813fca9c13"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4784, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}