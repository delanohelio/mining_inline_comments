{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MTc4MzA0", "number": 11531, "title": "[FLINK-16748][python][doc] Add Python UDTF doc", "bodyText": "What is the purpose of the change\nThis pull request will add Python UDTF related doc\nBrief change log\n\n*Add doc description of Python UDTF in python_udfs.md and python_udfs.zh.md *\nAdd some Python UDTF content in udfs.md and python_udfs.zh.md\nMove the ussage of Java UDTF in Python from udfs.md to python_udfs.md\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (no)\nThe serializers: (no)\nThe runtime per-record code paths (performance sensitive): (no)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (no)\nThe S3 file system connector: (no)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (no)\nIf yes, how is the feature documented? (not applicable)", "createdAt": "2020-03-26T13:42:31Z", "url": "https://github.com/apache/flink/pull/11531", "merged": true, "mergeCommit": {"oid": "975149cbd0b5338b409f54166196f7dae0840738"}, "closed": true, "closedAt": "2020-04-15T03:32:38Z", "author": {"login": "HuangXingBo"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcW5JXVAH2gAyMzk0MTc4MzA0OmUwMjA2YmZkNmYwMjRmNmRjMWI2YjQ5MGZlNGMxZWQzNjZmNjhlZDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXkmQ3gH2gAyMzk0MTc4MzA0OjZhOTU0MThmNGY4MDRmMDQ4YmU2MDQxZDdhYTk2Y2ZlNjcxZjk4MDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0", "author": {"user": {"login": "HuangXingBo", "name": null}}, "url": "https://github.com/apache/flink/commit/e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0", "committedDate": "2020-04-12T12:07:14Z", "message": "[FLINK-16748][python][doc] Add Python UDTF doc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0c0de3b4a75fa7bd9555d1897e77be6467265e9", "author": {"user": {"login": "HuangXingBo", "name": null}}, "url": "https://github.com/apache/flink/commit/a0c0de3b4a75fa7bd9555d1897e77be6467265e9", "committedDate": "2020-03-26T13:29:06Z", "message": "[FLINK-16748][python][doc] Add Python UDTF doc"}, "afterCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0", "author": {"user": {"login": "HuangXingBo", "name": null}}, "url": "https://github.com/apache/flink/commit/e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0", "committedDate": "2020-04-12T12:07:14Z", "message": "[FLINK-16748][python][doc] Add Python UDTF doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjkzMzg0", "url": "https://github.com/apache/flink/pull/11531#pullrequestreview-392693384", "createdAt": "2020-04-14T08:05:43Z", "commit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODowNTo0M1rOGFC5aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoyNzo0MVrOGFDs-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk0MzUyOQ==", "bodyText": "class `TableFunction` in `pyflink.table.udtf`", "url": "https://github.com/apache/flink/pull/11531#discussion_r407943529", "createdAt": "2020-04-14T08:05:43Z", "author": {"login": "hequn8128"}, "path": "docs/dev/table/functions/udfs.md", "diffHunk": "@@ -247,53 +253,51 @@ tableEnv.sqlQuery(\"SELECT a, word, length FROM MyTable LEFT JOIN LATERAL TABLE(s\n </div>\n \n <div data-lang=\"python\" markdown=\"1\">\n-{% highlight python %}\n-'''\n-Java code:\n+In order to define a Python table function, one can extend the base class TableFunction in pyflink.table.udtf and Implement an evaluation method. The behavior of a Python table function is determined by the evaluation method which is named eval.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1MTE3NA==", "bodyText": "Unnecessary changes.", "url": "https://github.com/apache/flink/pull/11531#discussion_r407951174", "createdAt": "2020-04-14T08:18:24Z", "author": {"login": "hequn8128"}, "path": "docs/dev/table/functions/udfs.md", "diffHunk": "@@ -314,6 +318,12 @@ public class CustomTypeSplit extends TableFunction<Row> {\n </div>\n \n <div data-lang=\"scala\" markdown=\"1\">\n+Please note that POJO types do not have a deterministic field order. Therefore, you cannot rename the fields of POJO returned by a table function using `AS`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1MjA5NQ==", "bodyText": "Change the link to the Chinese doc link, i.e., zh/dev/", "url": "https://github.com/apache/flink/pull/11531#discussion_r407952095", "createdAt": "2020-04-14T08:19:54Z", "author": {"login": "hequn8128"}, "path": "docs/dev/table/functions/udfs.zh.md", "diffHunk": "@@ -247,53 +255,51 @@ tableEnv.sqlQuery(\"SELECT a, word, length FROM MyTable LEFT JOIN LATERAL TABLE(s\n </div>\n \n <div data-lang=\"python\" markdown=\"1\">\n-{% highlight python %}\n-'''\n-Java code:\n+In order to define a Python table function, one can extend the base class TableFunction in pyflink.table.udtf and Implement an evaluation method. The behavior of a Python table function is determined by the evaluation method which is named eval.\n \n-// The generic type \"Tuple2<String, Integer>\" determines the schema of the returned table as (String, Integer).\n-// The java class must have a public no-argument constructor and can be founded in current java classloader.\n-public class Split extends TableFunction<Tuple2<String, Integer>> {\n-    private String separator = \" \";\n-    \n-    public void eval(String str) {\n-        for (String s : str.split(separator)) {\n-            // use collect(...) to emit a row\n-            collect(new Tuple2<String, Integer>(s, s.length()));\n-        }\n-    }\n-}\n-'''\n+In the Python Table API, a Python table function is used with `.join_lateral` or `.left_outer_join_lateral`. The `join_lateral` operator (cross) joins each row from the outer table (table on the left of the operator) with all rows produced by the table-valued function (which is on the right side of the operator). The `left_outer_join_lateral` operator joins each row from the outer table (table on the left of the operator) with all rows produced by the table-valued function (which is on the right side of the operator) and preserves outer rows for which the table function returns an empty table. In SQL use `LATERAL TABLE(<TableFunction>)` with CROSS JOIN and LEFT JOIN with an ON TRUE join condition (see examples below).\n \n-table_env = BatchTableEnvironment.create(env)\n-my_table = ...  # type: Table, table schema: [a: String]\n+<span class=\"label label-info\">Note</span> Currently, Python UDTF is supported in old planner both under streaming and batch mode while is only supported under streaming mode in Blink planner.\n \n-# Register the java function.\n-table_env.register_java_function(\"split\", \"my.java.function.Split\")\n+The following example shows how to define a Python table function, registered it in the TableEnvironment, and call it in a query. Note that you can configure your table function via a constructor before it is registered:\n \n-# Use the table function in the Python Table API. \"as\" specifies the field names of the table.\n-my_table.join_lateral(\"split(a) as (word, length)\").select(\"a, word, length\")\n-my_table.left_outer_join_lateral(\"split(a) as (word, length)\").select(\"a, word, length\")\n+{% highlight python %}\n+class Split(TableFunction):\n+    def eval(self, string):\n+        for s in string.split(\" \"):\n+            yield s, len(s)\n+\n+env = StreamExecutionEnvironment.get_execution_environment()\n+table_env = StreamTableEnvironment.create(env)\n+my_table = ...  # type: Table, table schema: [a: String]\n \n-# Register the python function.\n+# register the Python Table Function\n+table_env.register_function(\"split\", udtf(Split(), DataTypes.STRING(), [DataTypes.STRING(), DataTypes.INT()]))\n \n-# Use the table function in SQL with LATERAL and TABLE keywords.\n-# CROSS JOIN a table function (equivalent to \"join\" in Table API).\n+# use the Python Table Function in Python Table API\n+my_table.join_lateral(\"split(a) as (word, length)\")\n+my_table.left_outer_join_lateral(\"split(a) as (word, length)\")\n+\n+# use the Python Table function in SQL API\n table_env.sql_query(\"SELECT a, word, length FROM MyTable, LATERAL TABLE(split(a)) as T(word, length)\")\n-# LEFT JOIN a table function (equivalent to \"left_outer_join\" in Table API).\n table_env.sql_query(\"SELECT a, word, length FROM MyTable LEFT JOIN LATERAL TABLE(split(a)) as T(word, length) ON TRUE\")\n+\n {% endhighlight %}\n+\n+There are many ways to define a Python table function besides extending the base class `TableFunction`.\n+Please refer to the [Python Table Function]({{ site.baseurl }}/dev/table/python/python_udfs.html#table-functions) documentation for more details.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1MjM2Ng==", "bodyText": "Unnecessary change.", "url": "https://github.com/apache/flink/pull/11531#discussion_r407952366", "createdAt": "2020-04-14T08:20:21Z", "author": {"login": "hequn8128"}, "path": "docs/dev/table/functions/udfs.zh.md", "diffHunk": "@@ -314,6 +320,12 @@ public class CustomTypeSplit extends TableFunction<Row> {\n </div>\n \n <div data-lang=\"scala\" markdown=\"1\">\n+Please note that POJO types do not have a deterministic field order. Therefore, you cannot rename the fields of POJO returned by a table function using `AS`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1NjczMA==", "bodyText": "Move this as option1, it can avoid creating temporary buffers, thus should be preferred. What do you think?", "url": "https://github.com/apache/flink/pull/11531#discussion_r407956730", "createdAt": "2020-04-14T08:27:41Z", "author": {"login": "hequn8128"}, "path": "docs/dev/table/python/python_udfs.md", "diffHunk": "@@ -125,3 +125,105 @@ table_env.register_function(\"add\", add)\n # use the function in Python Table API\n my_table.select(\"add(a, b)\")\n {% endhighlight %}\n+\n+## Table Functions\n+Similar to a Python user-defined scalar function, a user-defined table function takes zero, one, or \n+multiple scalar values as input parameters. However in contrast to a scalar function, it can return \n+an arbitrary number of rows as output instead of a single value. The return type of a Python UDTF \n+could be of types Iterable, Iterator or generator.\n+\n+<span class=\"label label-info\">Note</span> Currently, Python UDTF is supported in old planner both under streaming and batch mode while is only supported under streaming mode in Blink planner.\n+\n+The following example shows how to define your own Python multi emit function, register it in the \n+TableEnvironment, and call it in a query.\n+\n+{% highlight python %}\n+class Split(TableFunction):\n+    def eval(self, string):\n+        for s in string.split(\" \"):\n+            yield s, len(s)\n+\n+env = StreamExecutionEnvironment.get_execution_environment()\n+table_env = StreamTableEnvironment.create(env)\n+my_table = ...  # type: Table, table schema: [a: String]\n+\n+# register the Python Table Function\n+table_env.register_function(\"split\", udtf(Split(), DataTypes.STRING(), [DataTypes.STRING(), DataTypes.INT()]))\n+\n+# use the Python Table Function in Python Table API\n+my_table.join_lateral(\"split(a) as (word, length)\")\n+my_table.left_outer_join_lateral(\"split(a) as (word, length)\")\n+\n+# use the Python Table function in SQL API\n+table_env.sql_query(\"SELECT a, word, length FROM MyTable, LATERAL TABLE(split(a)) as T(word, length)\")\n+table_env.sql_query(\"SELECT a, word, length FROM MyTable LEFT JOIN LATERAL TABLE(split(a)) as T(word, length) ON TRUE\")\n+\n+{% endhighlight %}\n+\n+\n+It also supports to use Java/Scala table functions in Python Table API programs.\n+{% highlight python %}\n+'''\n+Java code:\n+\n+// The generic type \"Tuple2<String, Integer>\" determines the schema of the returned table as (String, Integer).\n+// The java class must have a public no-argument constructor and can be founded in current java classloader.\n+public class Split extends TableFunction<Tuple2<String, Integer>> {\n+    private String separator = \" \";\n+    \n+    public void eval(String str) {\n+        for (String s : str.split(separator)) {\n+            // use collect(...) to emit a row\n+            collect(new Tuple2<String, Integer>(s, s.length()));\n+        }\n+    }\n+}\n+'''\n+\n+env = StreamExecutionEnvironment.get_execution_environment()\n+table_env = StreamTableEnvironment.create(env)\n+my_table = ...  # type: Table, table schema: [a: String]\n+\n+# Register the java function.\n+table_env.register_java_function(\"split\", \"my.java.function.Split\")\n+\n+# Use the table function in the Python Table API. \"as\" specifies the field names of the table.\n+my_table.join_lateral(\"split(a) as (word, length)\").select(\"a, word, length\")\n+my_table.left_outer_join_lateral(\"split(a) as (word, length)\").select(\"a, word, length\")\n+\n+# Register the python function.\n+\n+# Use the table function in SQL with LATERAL and TABLE keywords.\n+# CROSS JOIN a table function (equivalent to \"join\" in Table API).\n+table_env.sql_query(\"SELECT a, word, length FROM MyTable, LATERAL TABLE(split(a)) as T(word, length)\")\n+# LEFT JOIN a table function (equivalent to \"left_outer_join\" in Table API).\n+table_env.sql_query(\"SELECT a, word, length FROM MyTable LEFT JOIN LATERAL TABLE(split(a)) as T(word, length) ON TRUE\")\n+{% endhighlight %}\n+\n+Like Python scalar functions, you can use the above five ways to define Python TableFunctions.\n+\n+<span class=\"label label-info\">Note</span> The only difference is that the return type of Python Table Functions needs to be an iterable, iterator or generator.\n+\n+{% highlight python %}\n+# option 1: return iterable\n+@udtf(input_types=DataTypes.BIGINT(), result_types=DataTypes.BIGINT())\n+def iterable_func(x):\n+      result = [1, 2, 3]\n+      return result\n+\n+# option 2: return iterator\n+@udtf(input_types=DataTypes.BIGINT(), result_types=DataTypes.BIGINT())\n+def iterator_func(x):\n+      return range(5)\n+\n+# option 3: generator function\n+@udtf(input_types=DataTypes.BIGINT(), result_types=DataTypes.BIGINT())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0206bfd6f024f6dc1b6b490fe4c1ed366f68ed0"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a95418f4f804f048be6041d7aa96cfe671f9805", "author": {"user": {"login": "HuangXingBo", "name": null}}, "url": "https://github.com/apache/flink/commit/6a95418f4f804f048be6041d7aa96cfe671f9805", "committedDate": "2020-04-14T14:44:43Z", "message": "fix comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2589, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}