{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3ODI5ODU0", "number": 12145, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNToyNDozOVrOD9EDvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDo0M1rOD9IZcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU2MjIzOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNToyNDozOVrOGWYUzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNToyNDozOVrOGWYUzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMDM5OQ==", "bodyText": "typo", "url": "https://github.com/apache/flink/pull/12145#discussion_r426120399", "createdAt": "2020-05-16T05:24:39Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala", "diffHunk": "@@ -60,7 +60,7 @@ object FlinkBatchRuleSets {\n   val POST_EXPAND_CLEAN_UP_RULES: RuleSet = RuleSets.ofList(\n     EnumerableToLogicalTableScan.INSTANCE)\n \n-  /**\n+  /**p", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9ee6228cf9eea60df403e37b41b907fef21a28"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3MjQwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NTozNlrOGWYZzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NTozNlrOGWYZzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTY3Ng==", "bodyText": "check false condition here and we can save one level of indent", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121676", "createdAt": "2020-05-16T05:45:36Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3MjgxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NjoyM1rOGWYZ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NjoyM1rOGWYZ-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTcyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n          \n          \n            \n            \n          \n          \n            \n            \t\tDynamicTableSource newTableSource = oldTableSource.copy();\n          \n          \n            \n            \t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121723", "createdAt": "2020-05-16T05:46:23Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3MzA4OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NzoxNFrOGWYaJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo0NzoxNFrOGWYaJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTc2Ng==", "bodyText": "no need to declare this as local variable because it only been used once", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121766", "createdAt": "2020-05-16T05:47:14Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3NTIzOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MDoyOVrOGWYbKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MDoyOVrOGWYbKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjAyNg==", "bodyText": "how about change select to project?", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122026", "createdAt": "2020-05-16T05:50:29Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3NTU5OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MTowMlrOGWYbUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MTowMlrOGWYbUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjA2Nw==", "bodyText": "create a copy method just like the legacy one does", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122067", "createdAt": "2020-05-16T05:51:02Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";\n+\t\t// project push down does not change the statistic, we can reuse origin statistic\n+\t\tTableSourceTable newTableSourceTable = new TableSourceTable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU3NTk2OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MjowNVrOGWYbiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNTo1MjowNVrOGWYbiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjEyMA==", "bodyText": "use a non-deprecated constructor", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122120", "createdAt": "2020-05-16T05:52:05Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";\n+\t\t// project push down does not change the statistic, we can reuse origin statistic\n+\t\tTableSourceTable newTableSourceTable = new TableSourceTable(\n+\t\t\t\toldTableSourceTable.getRelOptSchema(),\n+\t\t\t\toldTableSourceTable.tableIdentifier(),\n+\t\t\t\tnewRowType,\n+\t\t\t\toldTableSourceTable.getStatistic(),\n+\t\t\t\tnewTableSource,\n+\t\t\t\toldTableSourceTable.isStreamingMode(),\n+\t\t\t\toldTableSourceTable.catalogTable(),\n+\t\t\t\toldTableSourceTable.dynamicOptions(),\n+\t\t\t\tnewExtraDigests\n+\t\t);\n+\n+\t\tLogicalTableScan newScan = new LogicalTableScan(scan.getCluster(), scan.getTraitSet(), newTableSourceTable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU5NDU3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestProjectableValuesTableFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNjoyOTowNVrOGWYk9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNjoyOTowNVrOGWYk9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyNDUzNQ==", "bodyText": "getFieldDataTypes has been deleted", "url": "https://github.com/apache/flink/pull/12145#discussion_r426124535", "createdAt": "2020-05-16T06:29:05Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestProjectableValuesTableFactory.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.factories;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.java.io.CollectionInputFormat;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.configuration.ConfigOption;\n+import org.apache.flink.configuration.ConfigOptions;\n+import org.apache.flink.streaming.api.functions.source.FromElementsFunction;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.connector.ChangelogMode;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.InputFormatProvider;\n+import org.apache.flink.table.connector.source.ScanTableSource;\n+import org.apache.flink.table.connector.source.SourceFunctionProvider;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.DynamicTableSourceFactory;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.planner.utils.JavaScalaConversionUtil;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.FieldsDataType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.types.Row;\n+import org.apache.flink.types.RowKind;\n+import org.apache.flink.util.Preconditions;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import scala.collection.Seq;\n+\n+/**\n+ * Test implementation of {@link DynamicTableSourceFactory} that supports projection push down.\n+ */\n+public class TestProjectableValuesTableFactory implements DynamicTableSourceFactory {\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Data Registration\n+\t// --------------------------------------------------------------------------------------------\n+\n+\tprivate static final AtomicInteger idCounter = new AtomicInteger(0);\n+\tprivate static final Map<String, Collection<Tuple2<RowKind, Row>>> registeredData = new HashMap<>();\n+\n+\t/**\n+\t * Register the given data into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t */\n+\tpublic static String registerData(Collection<Row> data) {\n+\t\tList<Tuple2<RowKind, Row>> dataWithKinds = new ArrayList<>();\n+\t\tfor (Row row : data) {\n+\t\t\tdataWithKinds.add(Tuple2.of(RowKind.INSERT, row));\n+\t\t}\n+\t\treturn registerChangelogData(dataWithKinds);\n+\t}\n+\n+\t/**\n+\t * Register the given data into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t */\n+\tpublic static String registerData(Seq<Row> data) {\n+\t\treturn registerData(JavaScalaConversionUtil.toJava(data));\n+\t}\n+\n+\t/**\n+\t * Register the given data with RowKind into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t * TODO: remove this utility once Row supports RowKind.\n+\t */\n+\tpublic static String registerChangelogData(Collection<Tuple2<RowKind, Row>> data) {\n+\t\tString id = String.valueOf(idCounter.incrementAndGet());\n+\t\tregisteredData.put(id, data);\n+\t\treturn id;\n+\t}\n+\n+\t/**\n+\t * Removes the registered data under the given data id.\n+\t */\n+\tpublic static void clearAllRegisteredData() {\n+\t\tregisteredData.clear();\n+\t}\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Factory\n+\t// --------------------------------------------------------------------------------------------\n+\n+\tprivate static final String IDENTIFIER = \"projectable-values\";\n+\n+\tprivate static final ConfigOption<String> DATA_ID = ConfigOptions\n+\t\t\t.key(\"data-id\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(null);\n+\n+\tprivate static final ConfigOption<Boolean> BOUNDED = ConfigOptions\n+\t\t\t.key(\"bounded\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false);\n+\n+\tprivate static final ConfigOption<String> CHANGELOG_MODE = ConfigOptions\n+\t\t\t.key(\"changelog-mode\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(\"I\"); // all available \"I,UA,UB,D\"\n+\n+\tprivate static final ConfigOption<String> RUNTIME_SOURCE = ConfigOptions\n+\t\t\t.key(\"runtime-source\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(\"SourceFunction\"); // another is \"InputFormat\"\n+\n+\tprivate static final ConfigOption<Boolean> NESTED_PROJECTION_SUPPORTED = ConfigOptions\n+\t\t\t.key(\"nested-projection-supported\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false);\n+\n+\t@Override\n+\tpublic String factoryIdentifier() {\n+\t\treturn IDENTIFIER;\n+\t}\n+\n+\t@Override\n+\tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tFactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context);\n+\t\thelper.validate();\n+\t\tChangelogMode changelogMode = parseChangelogMode(helper.getOptions().get(CHANGELOG_MODE));\n+\t\tString runtimeSource = helper.getOptions().get(RUNTIME_SOURCE);\n+\t\tboolean isBounded = helper.getOptions().get(BOUNDED);\n+\t\tString dataId = helper.getOptions().get(DATA_ID);\n+\t\tboolean nestedProjectionSupported = helper.getOptions().get(NESTED_PROJECTION_SUPPORTED);\n+\n+\t\tCollection<Tuple2<RowKind, Row>> data = registeredData.getOrDefault(dataId, Collections.emptyList());\n+\t\tDataType rowDataType = context.getCatalogTable().getSchema().toPhysicalRowDataType();\n+\t\treturn new TestProjectableValuesTableSource(\n+\t\t\t\tchangelogMode,\n+\t\t\t\tisBounded,\n+\t\t\t\truntimeSource,\n+\t\t\t\trowDataType,\n+\t\t\t\tdata,\n+\t\t\t\tnestedProjectionSupported);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> requiredOptions() {\n+\t\treturn Collections.emptySet();\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> optionalOptions() {\n+\t\treturn new HashSet<>(Arrays.asList(\n+\t\t\t\tDATA_ID,\n+\t\t\t\tCHANGELOG_MODE,\n+\t\t\t\tBOUNDED,\n+\t\t\t\tRUNTIME_SOURCE,\n+\t\t\t\tNESTED_PROJECTION_SUPPORTED));\n+\t}\n+\n+\tprivate ChangelogMode parseChangelogMode(String string) {\n+\t\tChangelogMode.Builder builder = ChangelogMode.newBuilder();\n+\t\tfor (String split : string.split(\",\")) {\n+\t\t\tswitch (split.trim()) {\n+\t\t\t\tcase \"I\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.INSERT);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"UB\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.UPDATE_BEFORE);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"UA\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.UPDATE_AFTER);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"D\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.DELETE);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid ChangelogMode string: \" + string);\n+\t\t\t}\n+\t\t}\n+\t\treturn builder.build();\n+\t}\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Table source\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Values {@link DynamicTableSource} for testing.\n+\t */\n+\tprivate static class TestProjectableValuesTableSource implements ScanTableSource, SupportsProjectionPushDown {\n+\n+\t\tprivate final ChangelogMode changelogMode;\n+\t\tprivate final boolean bounded;\n+\t\tprivate final String runtimeSource;\n+\t\tprivate DataType physicalRowDataType;\n+\t\tprivate final Collection<Tuple2<RowKind, Row>> data;\n+\t\tprivate final boolean nestedProjectionSupported;\n+\t\tprivate int[] projectedFields = null;\n+\n+\t\tprivate TestProjectableValuesTableSource(\n+\t\t\t\tChangelogMode changelogMode,\n+\t\t\t\tboolean bounded, String runtimeSource,\n+\t\t\t\tDataType physicalRowDataType,\n+\t\t\t\tCollection<Tuple2<RowKind, Row>> data,\n+\t\t\t\tboolean nestedProjectionSupported) {\n+\t\t\tthis.changelogMode = changelogMode;\n+\t\t\tthis.bounded = bounded;\n+\t\t\tthis.runtimeSource = runtimeSource;\n+\t\t\tthis.physicalRowDataType = physicalRowDataType;\n+\t\t\tthis.data = data;\n+\t\t\tthis.nestedProjectionSupported = nestedProjectionSupported;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ChangelogMode getChangelogMode() {\n+\t\t\treturn changelogMode;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic ScanRuntimeProvider getScanRuntimeProvider(ScanTableSource.Context runtimeProviderContext) {\n+\t\t\tTypeSerializer<RowData> serializer = (TypeSerializer<RowData>) runtimeProviderContext\n+\t\t\t\t\t.createTypeInformation(physicalRowDataType)\n+\t\t\t\t\t.createSerializer(new ExecutionConfig());\n+\t\t\tDataStructureConverter converter = runtimeProviderContext.createDataStructureConverter(physicalRowDataType);\n+\t\t\tCollection<RowData> values = convertToRowData(data, projectedFields, converter);\n+\n+\t\t\tif (runtimeSource.equals(\"SourceFunction\")) {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn SourceFunctionProvider.of(\n+\t\t\t\t\t\t\tnew FromElementsFunction<>(serializer, values),\n+\t\t\t\t\t\t\tbounded);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t} else if (runtimeSource.equals(\"InputFormat\")) {\n+\t\t\t\treturn InputFormatProvider.of(new CollectionInputFormat<>(values, serializer));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Unsupported runtime source class: \" + runtimeSource);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DynamicTableSource copy() {\n+\t\t\tTestProjectableValuesTableSource newTableSource = new TestProjectableValuesTableSource(\n+\t\t\t\t\tchangelogMode, bounded, runtimeSource, physicalRowDataType, data, nestedProjectionSupported);\n+\t\t\tnewTableSource.projectedFields = projectedFields;\n+\t\t\treturn newTableSource;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String asSummaryString() {\n+\t\t\treturn \"TestProjectableValues\";\n+\t\t}\n+\n+\t\tprivate static Collection<RowData> convertToRowData(\n+\t\t\t\tCollection<Tuple2<RowKind, Row>> data,\n+\t\t\t\t@Nullable int[] projectedFields,\n+\t\t\t\tDataStructureConverter converter) {\n+\t\t\tList<RowData> result = new ArrayList<>();\n+\t\t\tfor (Tuple2<RowKind, Row> value : data) {\n+\t\t\t\tRow projectedRow;\n+\t\t\t\tif (projectedFields == null) {\n+\t\t\t\t\tprojectedRow = value.f1;\n+\t\t\t\t} else {\n+\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n+\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n+\t\t\t\t\t\tnewValues[i] = value.f1.getField(projectedFields[i]);\n+\t\t\t\t\t}\n+\t\t\t\t\tprojectedRow = Row.of(newValues);\n+\t\t\t\t}\n+\t\t\t\tRowData rowData = (RowData) converter.toInternal(projectedRow);\n+\t\t\t\tif (rowData != null) {\n+\t\t\t\t\trowData.setRowKind(value.f0);\n+\t\t\t\t\tresult.add(rowData);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsNestedProjection() {\n+\t\t\treturn nestedProjectionSupported;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void applyProjection(int[][] projectedFields) {\n+\t\t\tthis.projectedFields = new int[projectedFields.length];\n+\t\t\tFieldsDataType dataType = (FieldsDataType) physicalRowDataType;\n+\t\t\tRowType rowType = ((RowType) physicalRowDataType.getLogicalType());\n+\t\t\tDataTypes.Field[] fields = new DataTypes.Field[projectedFields.length];\n+\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n+\t\t\t\tint[] projection = projectedFields[i];\n+\t\t\t\tPreconditions.checkArgument(projection.length == 1);\n+\t\t\t\tint index = projection[0];\n+\t\t\t\tthis.projectedFields[i] = index;\n+\t\t\t\tString fieldName = rowType.getFieldNames().get(index);\n+\t\t\t\tfields[i] = DataTypes.FIELD(fieldName, dataType.getFieldDataTypes().get(fieldName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700825f14b6128048bf2aec22947f30eaef40100"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MzAxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDozMlrOGWd41Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDozMlrOGWd41Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tnewProjectPushDownSource.applyProjection(projectedFields);\n          \n          \n            \n            \t\t((SupportsProjectionPushDown) newTableSource).applyProjection(projectedFields);", "url": "https://github.com/apache/flink/pull/12145#discussion_r426211541", "createdAt": "2020-05-17T03:00:32Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null || !(tableSourceTable.tableSource() instanceof SupportsProjectionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t} else {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3747e17ecf18448088dcb467d8bea240b00f12b6"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MzEzOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDo0M1rOGWd44g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDo0M1rOGWd44g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "url": "https://github.com/apache/flink/pull/12145#discussion_r426211554", "createdAt": "2020-05-17T03:00:43Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null || !(tableSourceTable.tableSource() instanceof SupportsProjectionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t} else {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3747e17ecf18448088dcb467d8bea240b00f12b6"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1317, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}