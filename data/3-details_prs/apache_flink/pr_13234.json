{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjMxMzQw", "number": 13234, "title": "[FLINK-18905][task] Allow SourceOperator chaining with MultipleInputStreamTask", "bodyText": "This PR adds a possibility to chain SourceOperator with MultipleInputStreamTask. Currently checkpointing, watermarks or metrics are not tested (part of another ticket).\nBrief change log\nPlease check individual commit messages.\nVerifying this change\nThis change added MultipleInputStreamTaskChainedSourcesTest for the new feature.\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-08-24T16:29:03Z", "url": "https://github.com/apache/flink/pull/13234", "merged": true, "mergeCommit": {"oid": "3ed4930bf3aad7b422ae25331bb9048deb4972b7"}, "closed": true, "closedAt": "2020-09-03T13:00:27Z", "author": {"login": "pnowojski"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCShxoABqjM2ODg4MDM3Njg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFNohagBqjM3MjM5MjIxNzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1c13bbc1899c7c2d7e94d26cdeb47deddf76b50", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e1c13bbc1899c7c2d7e94d26cdeb47deddf76b50", "committedDate": "2020-08-24T16:24:38Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}, "afterCommit": {"oid": "9063c7aff55eee4e446dddff9d74e83ab692f3d4", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/9063c7aff55eee4e446dddff9d74e83ab692f3d4", "committedDate": "2020-08-25T07:59:55Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9063c7aff55eee4e446dddff9d74e83ab692f3d4", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/9063c7aff55eee4e446dddff9d74e83ab692f3d4", "committedDate": "2020-08-25T07:59:55Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}, "afterCommit": {"oid": "705b359ef261cf3c6b1e42c418e7955c90007171", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/705b359ef261cf3c6b1e42c418e7955c90007171", "committedDate": "2020-08-26T13:03:42Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "705b359ef261cf3c6b1e42c418e7955c90007171", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/705b359ef261cf3c6b1e42c418e7955c90007171", "committedDate": "2020-08-26T13:03:42Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}, "afterCommit": {"oid": "e5a866429bf22eb6aeeb26733e5ab1d705780e66", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e5a866429bf22eb6aeeb26733e5ab1d705780e66", "committedDate": "2020-08-26T13:24:23Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5a866429bf22eb6aeeb26733e5ab1d705780e66", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e5a866429bf22eb6aeeb26733e5ab1d705780e66", "committedDate": "2020-08-26T13:24:23Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}, "afterCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/1b6142f9dad4b3893629b2ec774c93adb5875e84", "committedDate": "2020-08-26T13:45:47Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NjYxMjI5", "url": "https://github.com/apache/flink/pull/13234#pullrequestreview-475661229", "createdAt": "2020-08-26T16:31:12Z", "commit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjozMToxMlrOHHUMXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODo1NTozMFrOHHZWOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzMjkyNA==", "bodyText": "Rename Input to InputConfig as there is ..api.operators.Input already? (and subclasses)\nMake it interface and not class? This will allow children to extend other classes and ease testing\nWhy is this class not parameterized? Its serializer is passed to parameterized classes", "url": "https://github.com/apache/flink/pull/13234#discussion_r477432924", "createdAt": "2020-08-26T16:31:12Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -628,4 +622,46 @@ public String toString() {\n \n \t\treturn builder.toString();\n \t}\n+\n+\t/**\n+\t * Interface representing chained inputs.\n+\t */\n+\tpublic static class Input implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNzg4MA==", "bodyText": "Why can this happen?\nShould we return Optional or mark with @Nullable?", "url": "https://github.com/apache/flink/pull/13234#discussion_r477437880", "createdAt": "2020-08-26T16:38:44Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -160,81 +159,84 @@ public TimeCharacteristic getTimeCharacteristic() {\n \t\t}\n \t}\n \n-\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n-\t\tconfig.setInteger(TYPE_SERIALIZERS_IN_COUNT, serializers.length);\n-\t\tfor (int i = 0; i < serializers.length; i++) {\n-\t\t\tsetTypeSerializer(String.format(TYPE_SERIALIZERS_IN_PATTERN, i), serializers[i]);\n-\t\t}\n-\t}\n-\n \tpublic void setTypeSerializerOut(TypeSerializer<?> serializer) {\n \t\tsetTypeSerializer(TYPE_SERIALIZER_OUT_1, serializer);\n \t}\n \n+\tpublic <T> TypeSerializer<T> getTypeSerializerOut(ClassLoader cl) {\n+\t\ttry {\n+\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_OUT_1, cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t}\n+\t}\n+\n \tpublic void setTypeSerializerSideOut(OutputTag<?> outputTag, TypeSerializer<?> serializer) {\n \t\tsetTypeSerializer(TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), serializer);\n \t}\n \n-\t@Deprecated\n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n-\t\treturn getTypeSerializerIn(0, cl);\n+\tprivate void setTypeSerializer(String key, TypeSerializer<?> typeWrapper) {\n+\t\ttry {\n+\t\t\tInstantiationUtil.writeObjectToConfig(typeWrapper, this.config, key);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new StreamTaskException(\"Could not serialize type serializer.\", e);\n+\t\t}\n \t}\n \n-\t@Deprecated\n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n-\t\treturn getTypeSerializerIn(1, cl);\n+\tpublic <T> TypeSerializer<T> getTypeSerializerSideOut(OutputTag<?> outputTag, ClassLoader cl) {\n+\t\tPreconditions.checkNotNull(outputTag, \"Side output id must not be null.\");\n+\t\ttry {\n+\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t}\n \t}\n \n-\tpublic TypeSerializer<?>[] getTypeSerializersIn(ClassLoader cl) {\n-\t\tint typeSerializersCount = config.getInteger(TYPE_SERIALIZERS_IN_COUNT, -1);\n-\t\tcheckState(\n-\t\t\ttypeSerializersCount >= 0,\n-\t\t\t\"Missing value for %s in the config? [%d]\",\n-\t\t\tTYPE_SERIALIZERS_IN_COUNT,\n-\t\t\ttypeSerializersCount);\n-\t\tTypeSerializer<?>[] typeSerializers = new TypeSerializer<?>[typeSerializersCount];\n-\t\tfor (int i = 0; i < typeSerializers.length; i++) {\n-\t\t\ttypeSerializers[i] = getTypeSerializerIn(i, cl);\n+\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n+\t\tInput[] inputs = new Input[serializers.length];\n+\t\tfor (int i = 0; i < serializers.length; i++) {\n+\t\t\tinputs[i] = new NetworkInput(serializers[i], i);\n \t\t}\n-\t\treturn typeSerializers;\n+\t\tsetInputs(inputs);\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn(int index, ClassLoader cl) {\n+\tpublic void setInputs(Input ...inputs) {\n \t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(\n-\t\t\t\tthis.config,\n-\t\t\t\tString.format(TYPE_SERIALIZERS_IN_PATTERN, index),\n-\t\t\t\tcl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\n-\t\t\t\tString.format(\"Could not instantiate serializer for [%d] input.\", index),\n-\t\t\t\te);\n+\t\t\tInstantiationUtil.writeObjectToConfig(inputs, this.config, INPUTS);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new StreamTaskException(\"Could not serialize inputs.\", e);\n \t\t}\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerOut(ClassLoader cl) {\n+\tpublic Input[] getInputs(ClassLoader cl) {\n \t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_OUT_1, cl);\n+\t\t\tInput[] inputs = InstantiationUtil.readObjectFromConfig(this.config, INPUTS, cl);\n+\t\t\tif (inputs == null) {\n+\t\t\t\treturn new Input[0];\n+\t\t\t}\n+\t\t\treturn inputs;\n \t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t\tthrow new StreamTaskException(\"Could not deserialize inputs\", e);\n \t\t}\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerSideOut(OutputTag<?> outputTag, ClassLoader cl) {\n-\t\tPreconditions.checkNotNull(outputTag, \"Side output id must not be null.\");\n-\t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), cl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n-\t\t}\n+\t@Deprecated\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(0, cl);\n \t}\n \n-\tprivate void setTypeSerializer(String key, TypeSerializer<?> typeWrapper) {\n-\t\ttry {\n-\t\t\tInstantiationUtil.writeObjectToConfig(typeWrapper, this.config, key);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new StreamTaskException(\"Could not serialize type serializer.\", e);\n+\t@Deprecated\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(1, cl);\n+\t}\n+\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn(int index, ClassLoader cl) {\n+\t\tInput[] inputs = getInputs(cl);\n+\t\tif (index >= inputs.length) {\n+\t\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0MjMzNQ==", "bodyText": "I think checkState only recognizes %s pattern.", "url": "https://github.com/apache/flink/pull/13234#discussion_r477442335", "createdAt": "2020-08-26T16:45:41Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -160,81 +159,84 @@ public TimeCharacteristic getTimeCharacteristic() {\n \t\t}\n \t}\n \n-\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n-\t\tconfig.setInteger(TYPE_SERIALIZERS_IN_COUNT, serializers.length);\n-\t\tfor (int i = 0; i < serializers.length; i++) {\n-\t\t\tsetTypeSerializer(String.format(TYPE_SERIALIZERS_IN_PATTERN, i), serializers[i]);\n-\t\t}\n-\t}\n-\n \tpublic void setTypeSerializerOut(TypeSerializer<?> serializer) {\n \t\tsetTypeSerializer(TYPE_SERIALIZER_OUT_1, serializer);\n \t}\n \n+\tpublic <T> TypeSerializer<T> getTypeSerializerOut(ClassLoader cl) {\n+\t\ttry {\n+\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_OUT_1, cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t}\n+\t}\n+\n \tpublic void setTypeSerializerSideOut(OutputTag<?> outputTag, TypeSerializer<?> serializer) {\n \t\tsetTypeSerializer(TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), serializer);\n \t}\n \n-\t@Deprecated\n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n-\t\treturn getTypeSerializerIn(0, cl);\n+\tprivate void setTypeSerializer(String key, TypeSerializer<?> typeWrapper) {\n+\t\ttry {\n+\t\t\tInstantiationUtil.writeObjectToConfig(typeWrapper, this.config, key);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new StreamTaskException(\"Could not serialize type serializer.\", e);\n+\t\t}\n \t}\n \n-\t@Deprecated\n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n-\t\treturn getTypeSerializerIn(1, cl);\n+\tpublic <T> TypeSerializer<T> getTypeSerializerSideOut(OutputTag<?> outputTag, ClassLoader cl) {\n+\t\tPreconditions.checkNotNull(outputTag, \"Side output id must not be null.\");\n+\t\ttry {\n+\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t}\n \t}\n \n-\tpublic TypeSerializer<?>[] getTypeSerializersIn(ClassLoader cl) {\n-\t\tint typeSerializersCount = config.getInteger(TYPE_SERIALIZERS_IN_COUNT, -1);\n-\t\tcheckState(\n-\t\t\ttypeSerializersCount >= 0,\n-\t\t\t\"Missing value for %s in the config? [%d]\",\n-\t\t\tTYPE_SERIALIZERS_IN_COUNT,\n-\t\t\ttypeSerializersCount);\n-\t\tTypeSerializer<?>[] typeSerializers = new TypeSerializer<?>[typeSerializersCount];\n-\t\tfor (int i = 0; i < typeSerializers.length; i++) {\n-\t\t\ttypeSerializers[i] = getTypeSerializerIn(i, cl);\n+\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n+\t\tInput[] inputs = new Input[serializers.length];\n+\t\tfor (int i = 0; i < serializers.length; i++) {\n+\t\t\tinputs[i] = new NetworkInput(serializers[i], i);\n \t\t}\n-\t\treturn typeSerializers;\n+\t\tsetInputs(inputs);\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerIn(int index, ClassLoader cl) {\n+\tpublic void setInputs(Input ...inputs) {\n \t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(\n-\t\t\t\tthis.config,\n-\t\t\t\tString.format(TYPE_SERIALIZERS_IN_PATTERN, index),\n-\t\t\t\tcl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\n-\t\t\t\tString.format(\"Could not instantiate serializer for [%d] input.\", index),\n-\t\t\t\te);\n+\t\t\tInstantiationUtil.writeObjectToConfig(inputs, this.config, INPUTS);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new StreamTaskException(\"Could not serialize inputs.\", e);\n \t\t}\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerOut(ClassLoader cl) {\n+\tpublic Input[] getInputs(ClassLoader cl) {\n \t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_OUT_1, cl);\n+\t\t\tInput[] inputs = InstantiationUtil.readObjectFromConfig(this.config, INPUTS, cl);\n+\t\t\tif (inputs == null) {\n+\t\t\t\treturn new Input[0];\n+\t\t\t}\n+\t\t\treturn inputs;\n \t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n+\t\t\tthrow new StreamTaskException(\"Could not deserialize inputs\", e);\n \t\t}\n \t}\n \n-\tpublic <T> TypeSerializer<T> getTypeSerializerSideOut(OutputTag<?> outputTag, ClassLoader cl) {\n-\t\tPreconditions.checkNotNull(outputTag, \"Side output id must not be null.\");\n-\t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), cl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n-\t\t}\n+\t@Deprecated\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(0, cl);\n \t}\n \n-\tprivate void setTypeSerializer(String key, TypeSerializer<?> typeWrapper) {\n-\t\ttry {\n-\t\t\tInstantiationUtil.writeObjectToConfig(typeWrapper, this.config, key);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new StreamTaskException(\"Could not serialize type serializer.\", e);\n+\t@Deprecated\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(1, cl);\n+\t}\n+\n+\tpublic <T> TypeSerializer<T> getTypeSerializerIn(int index, ClassLoader cl) {\n+\t\tInput[] inputs = getInputs(cl);\n+\t\tif (index >= inputs.length) {\n+\t\t\treturn null;\n \t\t}\n+\t\tcheckState(inputs[index] instanceof NetworkInput, \"Input [%d] was assumed to be network input\", index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MjE1NA==", "bodyText": "nit: indentation", "url": "https://github.com/apache/flink/pull/13234#discussion_r477462154", "createdAt": "2020-08-26T17:18:13Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -208,19 +206,100 @@ public OperatorChain(\n \tOperatorChain(\n \t\t\tList<StreamOperatorWrapper<?, ?>> allOperatorWrappers,\n \t\t\tRecordWriterOutput<?>[] streamOutputs,\n-\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> chainEntryPoint,\n-\t\t\tStreamOperatorWrapper<OUT, OP> headOperatorWrapper) {\n+\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> mainOperatorOutput,\n+\t\t\tStreamOperatorWrapper<OUT, OP> mainOperatorWrapper) {\n \n \t\tthis.streamOutputs = checkNotNull(streamOutputs);\n-\t\tthis.chainEntryPoint = checkNotNull(chainEntryPoint);\n+\t\tthis.mainOperatorOutput = checkNotNull(mainOperatorOutput);\n \t\tthis.operatorEventDispatcher = null;\n \n \t\tcheckState(allOperatorWrappers != null && allOperatorWrappers.size() > 0);\n-\t\tthis.headOperatorWrapper = checkNotNull(headOperatorWrapper);\n+\t\tthis.mainOperatorWrapper = checkNotNull(mainOperatorWrapper);\n \t\tthis.tailOperatorWrapper = allOperatorWrappers.get(0);\n \t\tthis.numOperators = allOperatorWrappers.size();\n+\t\tthis.chainedSourceOutputs = new ChainedSourceOutputs();\n \n-\t\tlinkOperatorWrappers(allOperatorWrappers);\n+\t\tfirstOperatorWrapper = linkOperatorWrappers(allOperatorWrappers);\n+\t}\n+\n+\tprivate void createChainOutputs(\n+\t\tList<StreamEdge> outEdgesInOrder,\n+\t\tRecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriterDelegate,\n+\t\tMap<Integer, StreamConfig> chainedConfigs,\n+\t\tStreamTask<OUT, OP> containingTask,\n+\t\tMap<StreamEdge, RecordWriterOutput<?>> streamOutputMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4MzgyMw==", "bodyText": "Objects.equals?\nI guess we should also process record if both tags are null.", "url": "https://github.com/apache/flink/pull/13234#discussion_r477483823", "createdAt": "2020-08-26T17:55:24Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputChainingOutput.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.groups.OperatorIOMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.OperatorMetricGroup;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;\n+import org.apache.flink.util.OutputTag;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+class MultipleInputChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(MultipleInputChainingOutput.class);\n+\n+\tprotected final Input<T> input;\n+\tprotected final Counter numRecordsIn;\n+\tprotected final WatermarkGauge watermarkGauge = new WatermarkGauge();\n+\tprotected final StreamStatusProvider streamStatusProvider;\n+\t@Nullable protected final OutputTag<T> outputTag;\n+\n+\tpublic MultipleInputChainingOutput(\n+\t\t\tInput<T> input,\n+\t\t\tOperatorMetricGroup operatorMetricGroup,\n+\t\t\tStreamStatusProvider streamStatusProvider,\n+\t\t\t@Nullable OutputTag<T> outputTag) {\n+\t\tthis.input = input;\n+\n+\t\t{\n+\t\t\tCounter tmpNumRecordsIn;\n+\t\t\ttry {\n+\t\t\t\tOperatorIOMetricGroup ioMetricGroup = operatorMetricGroup.getIOMetricGroup();\n+\t\t\t\ttmpNumRecordsIn = ioMetricGroup.getNumRecordsInCounter();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.warn(\"An exception occurred during the metrics setup.\", e);\n+\t\t\t\ttmpNumRecordsIn = new SimpleCounter();\n+\t\t\t}\n+\t\t\tnumRecordsIn = tmpNumRecordsIn;\n+\t\t}\n+\n+\t\tthis.streamStatusProvider = streamStatusProvider;\n+\t\tthis.outputTag = outputTag;\n+\t}\n+\n+\t@Override\n+\tpublic void collect(StreamRecord<T> record) {\n+\t\tif (this.outputTag != null) {\n+\t\t\t// we are not responsible for emitting to the main output.\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tpushToOperator(record);\n+\t}\n+\n+\t@Override\n+\tpublic <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {\n+\t\tif (this.outputTag == null || !this.outputTag.equals(outputTag)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NzM3Nw==", "bodyText": "This class duplicates quite some parts of ChainingOutput.\nWhy not re-use it by extending/delegating?", "url": "https://github.com/apache/flink/pull/13234#discussion_r477487377", "createdAt": "2020-08-26T18:01:16Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputChainingOutput.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.groups.OperatorIOMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.OperatorMetricGroup;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;\n+import org.apache.flink.util.OutputTag;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+class MultipleInputChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MTM5Nw==", "bodyText": "Isn't it the same as configuration.getNumberOfNetworkInputs below?", "url": "https://github.com/apache/flink/pull/13234#discussion_r477491397", "createdAt": "2020-08-26T18:08:19Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -53,42 +53,48 @@ public void init() throws Exception {\n \t\tStreamConfig configuration = getConfiguration();\n \t\tClassLoader userClassLoader = getUserCodeClassLoader();\n \n-\t\tTypeSerializer<?>[] inputDeserializers = configuration.getTypeSerializersIn(userClassLoader);\n+\t\tStreamConfig.Input[] inputs = configuration.getInputs(userClassLoader);\n \n-\t\tArrayList<IndexedInputGate>[] inputLists = new ArrayList[inputDeserializers.length];\n-\t\tWatermarkGauge[] watermarkGauges = new WatermarkGauge[inputDeserializers.length];\n+\t\tArrayList<IndexedInputGate>[] inputLists = new ArrayList[\n+\t\t\t(int) Arrays.stream(inputs)\n+\t\t\t\t.filter(input -> (input instanceof StreamConfig.NetworkInput))\n+\t\t\t\t.count()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NTYwMg==", "bodyText": "Something is wrong with return type or name here :)", "url": "https://github.com/apache/flink/pull/13234#discussion_r477495602", "createdAt": "2020-08-26T18:15:54Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -208,19 +206,100 @@ public OperatorChain(\n \tOperatorChain(\n \t\t\tList<StreamOperatorWrapper<?, ?>> allOperatorWrappers,\n \t\t\tRecordWriterOutput<?>[] streamOutputs,\n-\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> chainEntryPoint,\n-\t\t\tStreamOperatorWrapper<OUT, OP> headOperatorWrapper) {\n+\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> mainOperatorOutput,\n+\t\t\tStreamOperatorWrapper<OUT, OP> mainOperatorWrapper) {\n \n \t\tthis.streamOutputs = checkNotNull(streamOutputs);\n-\t\tthis.chainEntryPoint = checkNotNull(chainEntryPoint);\n+\t\tthis.mainOperatorOutput = checkNotNull(mainOperatorOutput);\n \t\tthis.operatorEventDispatcher = null;\n \n \t\tcheckState(allOperatorWrappers != null && allOperatorWrappers.size() > 0);\n-\t\tthis.headOperatorWrapper = checkNotNull(headOperatorWrapper);\n+\t\tthis.mainOperatorWrapper = checkNotNull(mainOperatorWrapper);\n \t\tthis.tailOperatorWrapper = allOperatorWrappers.get(0);\n \t\tthis.numOperators = allOperatorWrappers.size();\n+\t\tthis.chainedSourceOutputs = new ChainedSourceOutputs();\n \n-\t\tlinkOperatorWrappers(allOperatorWrappers);\n+\t\tfirstOperatorWrapper = linkOperatorWrappers(allOperatorWrappers);\n+\t}\n+\n+\tprivate void createChainOutputs(\n+\t\tList<StreamEdge> outEdgesInOrder,\n+\t\tRecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriterDelegate,\n+\t\tMap<Integer, StreamConfig> chainedConfigs,\n+\t\tStreamTask<OUT, OP> containingTask,\n+\t\tMap<StreamEdge, RecordWriterOutput<?>> streamOutputMap) {\n+\t\tfor (int i = 0; i < outEdgesInOrder.size(); i++) {\n+\t\t\tStreamEdge outEdge = outEdgesInOrder.get(i);\n+\n+\t\t\tRecordWriterOutput<?> streamOutput = createStreamOutput(\n+\t\t\t\trecordWriterDelegate.getRecordWriter(i),\n+\t\t\t\toutEdge,\n+\t\t\t\tchainedConfigs.get(outEdge.getSourceId()),\n+\t\t\t\tcontainingTask.getEnvironment());\n+\n+\t\t\tthis.streamOutputs[i] = streamOutput;\n+\t\t\tstreamOutputMap.put(outEdge, streamOutput);\n+\t\t}\n+\t}\n+\n+\tprivate ChainedSourceOutputs createChainedInputs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODE3OA==", "bodyText": "Isn't this method called for any operator?\nThe if check above will not return from function if there are NetworkInputs configured.", "url": "https://github.com/apache/flink/pull/13234#discussion_r477498178", "createdAt": "2020-08-26T18:20:40Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -208,19 +206,100 @@ public OperatorChain(\n \tOperatorChain(\n \t\t\tList<StreamOperatorWrapper<?, ?>> allOperatorWrappers,\n \t\t\tRecordWriterOutput<?>[] streamOutputs,\n-\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> chainEntryPoint,\n-\t\t\tStreamOperatorWrapper<OUT, OP> headOperatorWrapper) {\n+\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> mainOperatorOutput,\n+\t\t\tStreamOperatorWrapper<OUT, OP> mainOperatorWrapper) {\n \n \t\tthis.streamOutputs = checkNotNull(streamOutputs);\n-\t\tthis.chainEntryPoint = checkNotNull(chainEntryPoint);\n+\t\tthis.mainOperatorOutput = checkNotNull(mainOperatorOutput);\n \t\tthis.operatorEventDispatcher = null;\n \n \t\tcheckState(allOperatorWrappers != null && allOperatorWrappers.size() > 0);\n-\t\tthis.headOperatorWrapper = checkNotNull(headOperatorWrapper);\n+\t\tthis.mainOperatorWrapper = checkNotNull(mainOperatorWrapper);\n \t\tthis.tailOperatorWrapper = allOperatorWrappers.get(0);\n \t\tthis.numOperators = allOperatorWrappers.size();\n+\t\tthis.chainedSourceOutputs = new ChainedSourceOutputs();\n \n-\t\tlinkOperatorWrappers(allOperatorWrappers);\n+\t\tfirstOperatorWrapper = linkOperatorWrappers(allOperatorWrappers);\n+\t}\n+\n+\tprivate void createChainOutputs(\n+\t\tList<StreamEdge> outEdgesInOrder,\n+\t\tRecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriterDelegate,\n+\t\tMap<Integer, StreamConfig> chainedConfigs,\n+\t\tStreamTask<OUT, OP> containingTask,\n+\t\tMap<StreamEdge, RecordWriterOutput<?>> streamOutputMap) {\n+\t\tfor (int i = 0; i < outEdgesInOrder.size(); i++) {\n+\t\t\tStreamEdge outEdge = outEdgesInOrder.get(i);\n+\n+\t\t\tRecordWriterOutput<?> streamOutput = createStreamOutput(\n+\t\t\t\trecordWriterDelegate.getRecordWriter(i),\n+\t\t\t\toutEdge,\n+\t\t\t\tchainedConfigs.get(outEdge.getSourceId()),\n+\t\t\t\tcontainingTask.getEnvironment());\n+\n+\t\t\tthis.streamOutputs[i] = streamOutput;\n+\t\t\tstreamOutputMap.put(outEdge, streamOutput);\n+\t\t}\n+\t}\n+\n+\tprivate ChainedSourceOutputs createChainedInputs(\n+\t\t\tStreamTask<OUT, OP> containingTask,\n+\t\t\tStreamConfig.Input[] configuredInputs,\n+\t\t\tMap<Integer, StreamConfig> chainedConfigs,\n+\t\t\tClassLoader userCodeClassloader,\n+\t\t\tList<StreamOperatorWrapper<?, ?>> allOpWrappers) {\n+\t\tif (Arrays.stream(configuredInputs).noneMatch(input -> input instanceof SourceInput)) {\n+\t\t\treturn new ChainedSourceOutputs();\n+\t\t}\n+\t\tcheckState(\n+\t\t\tmainOperatorWrapper.getStreamOperator() instanceof MultipleInputStreamOperator,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMzI0NA==", "bodyText": "I think having a single map on OperatorChain level with values holding a pair of Output + Operator would be easier to read and more efficient (by pair I mean a class, named maybe ChainedSourceOutputs).", "url": "https://github.com/apache/flink/pull/13234#discussion_r477503244", "createdAt": "2020-08-26T18:29:55Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -547,302 +675,38 @@ private void linkOperatorWrappers(List<StreamOperatorWrapper<?, ?>> allOperatorW\n \t\treturn (tailOperatorWrapper == null) ? null : tailOperatorWrapper.getStreamOperator();\n \t}\n \n-\t// ------------------------------------------------------------------------\n-\t//  Collectors for output chaining\n-\t// ------------------------------------------------------------------------\n-\n \t/**\n-\t * An {@link Output} that measures the last emitted watermark with a {@link WatermarkGauge}.\n-\t *\n-\t * @param <T> The type of the elements that can be emitted.\n+\t * Wrapper class to access the chained sources and their's outputs.\n \t */\n-\tpublic interface WatermarkGaugeExposingOutput<T> extends Output<T> {\n-\t\tGauge<Long> getWatermarkGauge();\n-\t}\n-\n-\tstatic class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {\n-\n-\t\tprotected final OneInputStreamOperator<T, ?> operator;\n-\t\tprotected final Counter numRecordsIn;\n-\t\tprotected final WatermarkGauge watermarkGauge = new WatermarkGauge();\n-\n-\t\tprotected final StreamStatusProvider streamStatusProvider;\n-\n-\t\t@Nullable\n-\t\tprotected final OutputTag<T> outputTag;\n-\n-\t\tpublic ChainingOutput(\n-\t\t\t\tOneInputStreamOperator<T, ?> operator,\n-\t\t\t\tStreamStatusProvider streamStatusProvider,\n-\t\t\t\t@Nullable OutputTag<T> outputTag) {\n-\t\t\tthis.operator = operator;\n-\n-\t\t\t{\n-\t\t\t\tCounter tmpNumRecordsIn;\n-\t\t\t\ttry {\n-\t\t\t\t\tOperatorIOMetricGroup ioMetricGroup = ((OperatorMetricGroup) operator.getMetricGroup()).getIOMetricGroup();\n-\t\t\t\t\ttmpNumRecordsIn = ioMetricGroup.getNumRecordsInCounter();\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tLOG.warn(\"An exception occurred during the metrics setup.\", e);\n-\t\t\t\t\ttmpNumRecordsIn = new SimpleCounter();\n-\t\t\t\t}\n-\t\t\t\tnumRecordsIn = tmpNumRecordsIn;\n-\t\t\t}\n+\tpublic static class ChainedSourceOutputs {\n+\t\tprivate final Map<Integer, WatermarkGaugeExposingOutput<StreamRecord<?>>> chainedSourceOutputs;\n+\t\tprivate final Map<Integer, SourceOperator<?, ?>> sourceOperators;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 524}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxMDE4Mg==", "bodyText": "Why do we need first? Isn't it the same as main?", "url": "https://github.com/apache/flink/pull/13234#discussion_r477510182", "createdAt": "2020-08-26T18:42:43Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -90,16 +91,19 @@\n \n \tprivate final RecordWriterOutput<?>[] streamOutputs;\n \n-\tprivate final WatermarkGaugeExposingOutput<StreamRecord<OUT>> chainEntryPoint;\n+\tprivate final WatermarkGaugeExposingOutput<StreamRecord<OUT>> mainOperatorOutput;\n \n \t/**\n \t * For iteration, {@link StreamIterationHead} and {@link StreamIterationTail} used for executing\n-\t * feedback edges do not contain any operators, in which case, {@code headOperatorWrapper} and\n+\t * feedback edges do not contain any operators, in which case, {@code mainOperatorWrapper} and\n \t * {@code tailOperatorWrapper} are null.\n \t */\n-\t@Nullable private final StreamOperatorWrapper<OUT, OP> headOperatorWrapper;\n+\t@Nullable private final StreamOperatorWrapper<OUT, OP> mainOperatorWrapper;\n+\t@Nullable private final StreamOperatorWrapper<?, ?> firstOperatorWrapper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNzM3MQ==", "bodyText": "Map key is the index of input in StreamConfig, right? This seems a bit fragile and not obvious.\nHow about keying by Input instances? I see we have them both on put and get.", "url": "https://github.com/apache/flink/pull/13234#discussion_r477517371", "createdAt": "2020-08-26T18:55:30Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -547,302 +675,38 @@ private void linkOperatorWrappers(List<StreamOperatorWrapper<?, ?>> allOperatorW\n \t\treturn (tailOperatorWrapper == null) ? null : tailOperatorWrapper.getStreamOperator();\n \t}\n \n-\t// ------------------------------------------------------------------------\n-\t//  Collectors for output chaining\n-\t// ------------------------------------------------------------------------\n-\n \t/**\n-\t * An {@link Output} that measures the last emitted watermark with a {@link WatermarkGauge}.\n-\t *\n-\t * @param <T> The type of the elements that can be emitted.\n+\t * Wrapper class to access the chained sources and their's outputs.\n \t */\n-\tpublic interface WatermarkGaugeExposingOutput<T> extends Output<T> {\n-\t\tGauge<Long> getWatermarkGauge();\n-\t}\n-\n-\tstatic class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {\n-\n-\t\tprotected final OneInputStreamOperator<T, ?> operator;\n-\t\tprotected final Counter numRecordsIn;\n-\t\tprotected final WatermarkGauge watermarkGauge = new WatermarkGauge();\n-\n-\t\tprotected final StreamStatusProvider streamStatusProvider;\n-\n-\t\t@Nullable\n-\t\tprotected final OutputTag<T> outputTag;\n-\n-\t\tpublic ChainingOutput(\n-\t\t\t\tOneInputStreamOperator<T, ?> operator,\n-\t\t\t\tStreamStatusProvider streamStatusProvider,\n-\t\t\t\t@Nullable OutputTag<T> outputTag) {\n-\t\t\tthis.operator = operator;\n-\n-\t\t\t{\n-\t\t\t\tCounter tmpNumRecordsIn;\n-\t\t\t\ttry {\n-\t\t\t\t\tOperatorIOMetricGroup ioMetricGroup = ((OperatorMetricGroup) operator.getMetricGroup()).getIOMetricGroup();\n-\t\t\t\t\ttmpNumRecordsIn = ioMetricGroup.getNumRecordsInCounter();\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tLOG.warn(\"An exception occurred during the metrics setup.\", e);\n-\t\t\t\t\ttmpNumRecordsIn = new SimpleCounter();\n-\t\t\t\t}\n-\t\t\t\tnumRecordsIn = tmpNumRecordsIn;\n-\t\t\t}\n+\tpublic static class ChainedSourceOutputs {\n+\t\tprivate final Map<Integer, WatermarkGaugeExposingOutput<StreamRecord<?>>> chainedSourceOutputs;\n+\t\tprivate final Map<Integer, SourceOperator<?, ?>> sourceOperators;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMzI0NA=="}, "originalCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84"}, "originalPosition": 524}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b6142f9dad4b3893629b2ec774c93adb5875e84", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/1b6142f9dad4b3893629b2ec774c93adb5875e84", "committedDate": "2020-08-26T13:45:47Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}, "afterCommit": {"oid": "c14cec5f641450e381b6da1876df3f59f5f436b8", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/c14cec5f641450e381b6da1876df3f59f5f436b8", "committedDate": "2020-08-27T15:56:30Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NjMzMjAz", "url": "https://github.com/apache/flink/pull/13234#pullrequestreview-477633203", "createdAt": "2020-08-28T10:52:56Z", "commit": {"oid": "2382ecb7dcb679dddbc39f44717ed1c4c7c061cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMDo1Mjo1N1rOHI7MBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMDo1Mjo1N1rOHI7MBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTEyMDM4OQ==", "bodyText": "Are we comparing InputEdge vs SourceInputConfig here?", "url": "https://github.com/apache/flink/pull/13234#discussion_r479120389", "createdAt": "2020-08-28T10:52:57Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -628,4 +621,61 @@ public String toString() {\n \n \t\treturn builder.toString();\n \t}\n+\n+\t/**\n+\t * Interface representing chained inputs.\n+\t */\n+\tpublic interface InputConfig extends Serializable {\n+\t}\n+\n+\t/**\n+\t * A representation of a Network {@link InputConfig}.\n+\t */\n+\tpublic static class NetworkInputConfig implements InputConfig {\n+\t\tprivate final TypeSerializer<?> typeSerializer;\n+\t\tprivate int inputGateIndex;\n+\n+\t\tpublic NetworkInputConfig(TypeSerializer<?> typeSerializer, int inputGateIndex) {\n+\t\t\tthis.typeSerializer = typeSerializer;\n+\t\t\tthis.inputGateIndex = inputGateIndex;\n+\t\t}\n+\n+\t\tpublic TypeSerializer<?> getTypeSerializer() {\n+\t\t\treturn typeSerializer;\n+\t\t}\n+\n+\t\tpublic int getInputGateIndex() {\n+\t\t\treturn inputGateIndex;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A serialized representation of an input.\n+\t */\n+\tpublic static class SourceInputConfig implements InputConfig {\n+\t\tprivate final StreamEdge inputEdge;\n+\n+\t\tpublic SourceInputConfig(StreamEdge inputEdge) {\n+\t\t\tthis.inputEdge = inputEdge;\n+\t\t}\n+\n+\t\tpublic StreamEdge getInputEdge() {\n+\t\t\treturn inputEdge;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn inputEdge.toString();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\treturn Objects.equals(obj, inputEdge);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2382ecb7dcb679dddbc39f44717ed1c4c7c061cf"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NjQ3MDIy", "url": "https://github.com/apache/flink/pull/13234#pullrequestreview-477647022", "createdAt": "2020-08-28T11:19:32Z", "commit": {"oid": "2382ecb7dcb679dddbc39f44717ed1c4c7c061cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMToxOTozMlrOHI9Dgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMToxOTozMlrOHI9Dgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1MDk3OQ==", "bodyText": "This method as well as createChainedInputs is full of compiler warnings too - can you fix them please?", "url": "https://github.com/apache/flink/pull/13234#discussion_r479150979", "createdAt": "2020-08-28T11:19:32Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -208,19 +212,97 @@ public OperatorChain(\n \tOperatorChain(\n \t\t\tList<StreamOperatorWrapper<?, ?>> allOperatorWrappers,\n \t\t\tRecordWriterOutput<?>[] streamOutputs,\n-\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> chainEntryPoint,\n-\t\t\tStreamOperatorWrapper<OUT, OP> headOperatorWrapper) {\n+\t\t\tWatermarkGaugeExposingOutput<StreamRecord<OUT>> mainOperatorOutput,\n+\t\t\tStreamOperatorWrapper<OUT, OP> mainOperatorWrapper) {\n \n \t\tthis.streamOutputs = checkNotNull(streamOutputs);\n-\t\tthis.chainEntryPoint = checkNotNull(chainEntryPoint);\n+\t\tthis.mainOperatorOutput = checkNotNull(mainOperatorOutput);\n \t\tthis.operatorEventDispatcher = null;\n \n \t\tcheckState(allOperatorWrappers != null && allOperatorWrappers.size() > 0);\n-\t\tthis.headOperatorWrapper = checkNotNull(headOperatorWrapper);\n+\t\tthis.mainOperatorWrapper = checkNotNull(mainOperatorWrapper);\n \t\tthis.tailOperatorWrapper = allOperatorWrappers.get(0);\n \t\tthis.numOperators = allOperatorWrappers.size();\n+\t\tthis.chainedSources = Collections.emptyMap();\n+\n+\t\tfirstOperatorWrapper = linkOperatorWrappers(allOperatorWrappers);\n+\t}\n+\n+\tprivate void createChainOutputs(\n+\t\t\tList<StreamEdge> outEdgesInOrder,\n+\t\t\tRecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriterDelegate,\n+\t\t\tMap<Integer, StreamConfig> chainedConfigs,\n+\t\t\tStreamTask<OUT, OP> containingTask,\n+\t\t\tMap<StreamEdge, RecordWriterOutput<?>> streamOutputMap) {\n+\t\tfor (int i = 0; i < outEdgesInOrder.size(); i++) {\n+\t\t\tStreamEdge outEdge = outEdgesInOrder.get(i);\n+\n+\t\t\tRecordWriterOutput<?> streamOutput = createStreamOutput(\n+\t\t\t\trecordWriterDelegate.getRecordWriter(i),\n+\t\t\t\toutEdge,\n+\t\t\t\tchainedConfigs.get(outEdge.getSourceId()),\n+\t\t\t\tcontainingTask.getEnvironment());\n+\n+\t\t\tthis.streamOutputs[i] = streamOutput;\n+\t\t\tstreamOutputMap.put(outEdge, streamOutput);\n+\t\t}\n+\t}\n+\n+\tprivate Map<SourceInputConfig, ChainedSource> createChainedInputs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2382ecb7dcb679dddbc39f44717ed1c4c7c061cf"}, "originalPosition": 225}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2382ecb7dcb679dddbc39f44717ed1c4c7c061cf", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/2382ecb7dcb679dddbc39f44717ed1c4c7c061cf", "committedDate": "2020-08-27T15:57:56Z", "message": "[hotfix][task] Add SuppressWarnings to StreamMultipleInputProcessor"}, "afterCommit": {"oid": "36d937d37f057632e795e7a7f4c477641bfb6c1e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/36d937d37f057632e795e7a7f4c477641bfb6c1e", "committedDate": "2020-09-02T12:16:45Z", "message": "[hotfix][task] Add SuppressWarnings to StreamMultipleInputProcessor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTg4MjQ3", "url": "https://github.com/apache/flink/pull/13234#pullrequestreview-481188247", "createdAt": "2020-09-02T19:03:46Z", "commit": {"oid": "36d937d37f057632e795e7a7f4c477641bfb6c1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa63d66817c0a0e3445c3dc24e793ad307a15278", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/fa63d66817c0a0e3445c3dc24e793ad307a15278", "committedDate": "2020-09-03T09:23:50Z", "message": "[FLINK-18904][hotfix] Sort methods in StreamConfig\n\nPlace matching setters and getters close together"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b44ef33ea56ce72ccbd99feb3bd1f717ac0932", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/35b44ef33ea56ce72ccbd99feb3bd1f717ac0932", "committedDate": "2020-09-03T09:23:51Z", "message": "[FLINK-18904][hotfix] Remove unused methods in StreamConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98e42184f2f0743e973fe60fcd1bc6563d23a857", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/98e42184f2f0743e973fe60fcd1bc6563d23a857", "committedDate": "2020-09-03T09:23:51Z", "message": "[FLINK-18904][task] Migrate input serializers to inputs in StreamConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fcbee6f5e7b0d7d1bd750ba2135c5c9bb311325", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/4fcbee6f5e7b0d7d1bd750ba2135c5c9bb311325", "committedDate": "2020-09-03T09:23:51Z", "message": "[FLINK-18904][task] Rename NumberOfInputs to NumberOfNetworkInputs in StreamConfig\n\nThis is a preparation for adding more generic Inputs field/accessor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96096f0556faa545b80dbb9e5dd9f10f92fc2908", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/96096f0556faa545b80dbb9e5dd9f10f92fc2908", "committedDate": "2020-09-03T09:23:51Z", "message": "[FLINK-18905][task] Rename headOperator to mainOperator\n\nmainOperator is driving the execution of the StreamTask, by pulling\nthe records from network inputs and/or source inputs and pushing\nproduced records to the remaining chained operators."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab2247773d8bf61bf53c8769e72390187f30a016", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ab2247773d8bf61bf53c8769e72390187f30a016", "committedDate": "2020-09-03T09:23:52Z", "message": "[FLINK-18905][hotfix][task] Extract OperatorChain#createChainOutputs method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dce0658a38b313ed27009c654cc67c978456274", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/7dce0658a38b313ed27009c654cc67c978456274", "committedDate": "2020-09-03T09:23:52Z", "message": "[FLINK-18905][hotfix][task] Rename OperatorChain#chainEntryPoint to mainOperatorOutput"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4ab4b83bc60387f05057da2412fab6f54e0b55d", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/a4ab4b83bc60387f05057da2412fab6f54e0b55d", "committedDate": "2020-09-03T09:23:52Z", "message": "[FLINK-18905][hotfix][task] Move output and collector helper classes out of OperatorChain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c357ae7a34127573901c97b0c73342455be5707b", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/c357ae7a34127573901c97b0c73342455be5707b", "committedDate": "2020-09-03T09:23:52Z", "message": "[FLINK-18905][hotfix][task/test] Use StreamConfigChainer for setupOutputForSingletonOperatorChain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a3571fde300f71c1ed138374c7454295db16c2e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/6a3571fde300f71c1ed138374c7454295db16c2e", "committedDate": "2020-09-03T09:23:53Z", "message": "[FLINK-18905][hotfix] Extract common OutputTag#isResponsibleFor with explicit Nonnull check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b1578483c8778c638eaa8d086f666df6418edc7", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/9b1578483c8778c638eaa8d086f666df6418edc7", "committedDate": "2020-09-03T09:23:53Z", "message": "[FLINK-18905][task/datastream] Convert OneInputStreamOperator to Input\n\nThis will allow to avoid code duplication/wrapping passing records in the operator chains,\nas we ChainingOuptut class will be able to chain both Input and OneInputStreamOperator at the same\ntime."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49ed29fb090e6fca5fafd8c98d2d11f9a79ef8e6", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/49ed29fb090e6fca5fafd8c98d2d11f9a79ef8e6", "committedDate": "2020-09-03T09:59:38Z", "message": "[FLINK-18905][task] Allow SourceOperator chaining with MultipleInputStreamTask"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "982ad4685cb9ed16f83fc6f27577a6275d1002f8", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/982ad4685cb9ed16f83fc6f27577a6275d1002f8", "committedDate": "2020-09-03T09:59:39Z", "message": "[FLINK-18905][hotfix][task] Simplify exception handling in StreamTask#dispatchOperatorEvent\n\nSince Mails are allowed to throw an exception, there is no need to manually handle\nthe exceptions in every mail."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1608e8ff1cc00fb6cf162f1320305d5f458d64b", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/f1608e8ff1cc00fb6cf162f1320305d5f458d64b", "committedDate": "2020-09-03T09:59:39Z", "message": "[hotfix][task] Add SuppressWarnings to StreamMultipleInputProcessor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36d937d37f057632e795e7a7f4c477641bfb6c1e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/36d937d37f057632e795e7a7f4c477641bfb6c1e", "committedDate": "2020-09-02T12:16:45Z", "message": "[hotfix][task] Add SuppressWarnings to StreamMultipleInputProcessor"}, "afterCommit": {"oid": "f1608e8ff1cc00fb6cf162f1320305d5f458d64b", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/f1608e8ff1cc00fb6cf162f1320305d5f458d64b", "committedDate": "2020-09-03T09:59:39Z", "message": "[hotfix][task] Add SuppressWarnings to StreamMultipleInputProcessor"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4730, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}