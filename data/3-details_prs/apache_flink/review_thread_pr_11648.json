{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5NjgyNDk1", "number": 11648, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxMDo0OFrODvjcSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxNzoyMFrODvjngA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTkwMzQ0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxMDo0OFrOGCCxlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo0MzowM1rOGCcEyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc5NTc5Nw==", "bodyText": "Why did you need to bump those timeouts? Is it because otherwise the checkpoints that you create in your unit test that you introduced could timeout?", "url": "https://github.com/apache/flink/pull/11648#discussion_r404795797", "createdAt": "2020-04-07T13:10:48Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "diffHunk": "@@ -144,11 +228,14 @@ private ExecutionGraph createExecutionGraphAndEnableCheckpointing(\n \t\t\t.setJobGraph(new JobGraph(jobVertex))\n \t\t\t.setRpcTimeout(timeout)\n \t\t\t.setAllocationTimeout(timeout)\n+\t\t\t.setIoExecutor(Executors.directExecutor())\n \t\t\t.build();\n \n+\t\tfinal ExecutionJobVertex executionJobVertex = executionGraph.getVerticesTopologically().iterator().next();\n+\n \t\tCheckpointCoordinatorConfiguration chkConfig = new CheckpointCoordinatorConfiguration(\n-\t\t\t100,\n-\t\t\t100,\n+\t\t\t1000000,\n+\t\t\t1000000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be41fd7ebd6cec17ef830786e89e4d12dcb9fc54"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxMDMxMg==", "bodyText": "Yes, the timeout is one of the reasons. There is another reason that I don't want the periodic checkpoint triggered during testing. It would disturb the verification.", "url": "https://github.com/apache/flink/pull/11648#discussion_r405210312", "createdAt": "2020-04-08T01:43:03Z", "author": {"login": "ifndef-SleePy"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "diffHunk": "@@ -144,11 +228,14 @@ private ExecutionGraph createExecutionGraphAndEnableCheckpointing(\n \t\t\t.setJobGraph(new JobGraph(jobVertex))\n \t\t\t.setRpcTimeout(timeout)\n \t\t\t.setAllocationTimeout(timeout)\n+\t\t\t.setIoExecutor(Executors.directExecutor())\n \t\t\t.build();\n \n+\t\tfinal ExecutionJobVertex executionJobVertex = executionGraph.getVerticesTopologically().iterator().next();\n+\n \t\tCheckpointCoordinatorConfiguration chkConfig = new CheckpointCoordinatorConfiguration(\n-\t\t\t100,\n-\t\t\t100,\n+\t\t\t1000000,\n+\t\t\t1000000,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc5NTc5Nw=="}, "originalCommit": {"oid": "be41fd7ebd6cec17ef830786e89e4d12dcb9fc54"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTkzMjE2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxNzoyMFrOGCDDRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo0NToyMFrOGCcHOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMDMyNw==", "bodyText": "Why is this checkpoint going to be declined? Maybe expand the comment with a bit of explanation?\nIf it's failing, maybe add an assertion that it has failed? Or just skip this code block if it's not necessary for the test as a whole?\nedit:\nreplace\n// trigger a normal checkpoint which would be declined then\n\nwith\n// trigger a normal checkpoint which we will fail/decline later\n\nto avoid confusion as mine above? :)", "url": "https://github.com/apache/flink/pull/11648#discussion_r404800327", "createdAt": "2020-04-07T13:17:20Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "diffHunk": "@@ -131,9 +142,82 @@ public void testShutdownCheckpointCoordinatorOnFinished() throws Exception {\n \t\tassertThat(storeShutdownFuture.get(), is(JobStatus.FINISHED));\n \t}\n \n+\t/**\n+\t * The case is designed to check the race condition between {@link ExecutionGraph} and\n+\t * {@link CheckpointCoordinator}. There should be no checkpoint accepted after\n+\t * {@link CheckpointFailureManager} decides to fail the {@link ExecutionGraph}.\n+\t */\n+\t@Test\n+\tpublic void testNoCheckpointAcceptedWhileFailingExecutionGraph() throws Exception {\n+\t\tCheckpointIDCounter counter = new TestingCheckpointIDCounter(new CompletableFuture<>());\n+\n+\t\tTestingCompletedCheckpointStore store = new TestingCompletedCheckpointStore(new CompletableFuture<>());\n+\n+\t\tfinal ManuallyTriggeredScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\t\tExecutionGraph graph = createExecutionGraphAndEnableCheckpointing(\n+\t\t\tcounter,\n+\t\t\tstore,\n+\t\t\tnew ComponentMainThreadExecutorServiceAdapter(mainThreadExecutor, Thread.currentThread()));\n+\n+\t\tfinal CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator();\n+\n+\t\tassertThat(checkpointCoordinator, Matchers.notNullValue());\n+\t\tassertThat(checkpointCoordinator.isShutdown(), is(false));\n+\n+\t\tgraph.scheduleForExecution();\n+\t\tExecutionGraphTestUtils.switchToRunning(graph);\n+\n+\t\t// trigger a normal checkpoint which would be declined then\n+\t\tcheckpointCoordinator.triggerCheckpoint(System.currentTimeMillis(), true);\n+\t\tmainThreadExecutor.triggerAll();\n+\t\tfinal long checkpointId = checkpointCoordinator.getPendingCheckpoints().keySet().iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be41fd7ebd6cec17ef830786e89e4d12dcb9fc54"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxMDkzOA==", "bodyText": "sure", "url": "https://github.com/apache/flink/pull/11648#discussion_r405210938", "createdAt": "2020-04-08T01:45:20Z", "author": {"login": "ifndef-SleePy"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java", "diffHunk": "@@ -131,9 +142,82 @@ public void testShutdownCheckpointCoordinatorOnFinished() throws Exception {\n \t\tassertThat(storeShutdownFuture.get(), is(JobStatus.FINISHED));\n \t}\n \n+\t/**\n+\t * The case is designed to check the race condition between {@link ExecutionGraph} and\n+\t * {@link CheckpointCoordinator}. There should be no checkpoint accepted after\n+\t * {@link CheckpointFailureManager} decides to fail the {@link ExecutionGraph}.\n+\t */\n+\t@Test\n+\tpublic void testNoCheckpointAcceptedWhileFailingExecutionGraph() throws Exception {\n+\t\tCheckpointIDCounter counter = new TestingCheckpointIDCounter(new CompletableFuture<>());\n+\n+\t\tTestingCompletedCheckpointStore store = new TestingCompletedCheckpointStore(new CompletableFuture<>());\n+\n+\t\tfinal ManuallyTriggeredScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\t\tExecutionGraph graph = createExecutionGraphAndEnableCheckpointing(\n+\t\t\tcounter,\n+\t\t\tstore,\n+\t\t\tnew ComponentMainThreadExecutorServiceAdapter(mainThreadExecutor, Thread.currentThread()));\n+\n+\t\tfinal CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator();\n+\n+\t\tassertThat(checkpointCoordinator, Matchers.notNullValue());\n+\t\tassertThat(checkpointCoordinator.isShutdown(), is(false));\n+\n+\t\tgraph.scheduleForExecution();\n+\t\tExecutionGraphTestUtils.switchToRunning(graph);\n+\n+\t\t// trigger a normal checkpoint which would be declined then\n+\t\tcheckpointCoordinator.triggerCheckpoint(System.currentTimeMillis(), true);\n+\t\tmainThreadExecutor.triggerAll();\n+\t\tfinal long checkpointId = checkpointCoordinator.getPendingCheckpoints().keySet().iterator().next();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMDMyNw=="}, "originalCommit": {"oid": "be41fd7ebd6cec17ef830786e89e4d12dcb9fc54"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 641, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}