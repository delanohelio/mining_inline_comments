{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMjgxMzY0", "number": 12575, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMDoxMTozN1rOEEOziQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0OTo0MlrOEF0nLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODcyMzI5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMDoxMTozN1rOGhuPig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMDoxMTozN1rOGhuPig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxMzgzNA==", "bodyText": "Can we add a check that returned value is a single-element array to prevent future bugs?", "url": "https://github.com/apache/flink/pull/12575#discussion_r438013834", "createdAt": "2020-06-10T10:11:37Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -28,39 +29,28 @@\n \n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.stream.IntStream;\n \n /**\n  * Utility for creating {@link CheckpointedInputGate} based on checkpoint mode\n  * for {@link StreamOneInputProcessor} and {@link StreamTwoInputProcessor}.\n  */\n @Internal\n public class InputProcessorUtil {\n-\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tStreamConfig config,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tIndexedInputGate[] inputGates,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n \t\t\tString taskName) {\n-\t\tInputGate inputGate = InputGateUtil.createInputGate(inputGates);\n-\t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n+\t\treturn createCheckpointedMultipleInputGate(\n+\t\t\ttoNotifyOnCheckpoint,\n \t\t\tconfig,\n-\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels),\n \t\t\tcheckpointCoordinator,\n+\t\t\ttaskIOMetricGroup,\n \t\t\ttaskName,\n-\t\t\tgenerateChannelIndexToInputGateMap(inputGate),\n-\t\t\tgenerateInputGateToChannelIndexOffsetMap(inputGate),\n-\t\t\ttoNotifyOnCheckpoint);\n-\t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n-\n-\t\tbarrierHandler.getBufferReceivedListener().ifPresent(inputGate::registerBufferReceivedListener);\n-\n-\t\treturn new CheckpointedInputGate(inputGate, barrierHandler);\n+\t\t\tArrays.asList(inputGates))[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODk5NzczOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTo0MjoyN1rOGhw-3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwOToxOTowMlrOGi9KQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg==", "bodyText": "I see similar code in CheckpointBarrierAligner constructor and same in InputProcessorUtil.createCheckpointedInputGates.\nWDYT about extracting it into something like InputGateResolver and passing it to barrier handlers, input gates and whoever else need it?\nIdeally, I think we should use self-sufficient IDs, but I guess this would be too invasive change.", "url": "https://github.com/apache/flink/pull/12575#discussion_r438058716", "createdAt": "2020-06-10T11:42:27Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzMDUxMw==", "bodyText": "That's a tough one; I had feared you pointing it out. The issue is that they are all similar but in the end also quite different.\nCheckpointBarrierAligner creates a map gate->offset, because it also creates an index->gate array, which it uses in resumeConsumption to first resolve the gate for a given flattened channel index and then delegate resumeConsumption with adjusted index (that's where the offset is needed).\nCheckpointBarrierUnaligner mainly uses the InputChannelInfo and hence creates a gate index->offset map to create the flattened index for other BarrierHandler stuff.\nThese two versions gets the SingleInputGates (only they have indices).\nInputProcessorUtil.createCheckpointedInputGates uses union input gates, so it cannot use indexes. So it goes by list index. However, now that I write it down this looks also suspicious...\nI guess to use simple offsets in CheckpointedInput (because of union gates), we actually need to assume consecutive indices... @pnowojski however also saw some strange cases, maybe he can add his observations.", "url": "https://github.com/apache/flink/pull/12575#discussion_r439030513", "createdAt": "2020-06-11T19:50:33Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDQ5OA==", "bodyText": "I look at it from a bit different perspective. InputProcessorUtil.createCheckpointedInputGates passes offsets to CheckpointedInputGate which uses them to talk with barrierHandler:\n// CheckpointedInputGate with offsetChannelIndex() inlined for clarity\nbarrierHandler.isBlocked(bufferOrEvent.getChannelIndex() + channelIndexOffset)\nbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelIndex() + channelIndexOffset);\n\nCheckpointBarrierAligner.processBarrier internally calls resumeConsumption which unflattens index back:\nprivate void resumeConsumption(int channelIndex) {\n    InputGate inputGate = channelIndexToInputGate[channelIndex];\n    inputGate.resumeConsumption(channelIndex - inputGateToChannelIndexOffset.get(inputGate));\n}\n\nSo, they are related.\nNow, are they equal?\nThe fact that CheckpointedInputGate can use UnionInputGate is accounted by\nUnionInputGate.getNumberOfInputChannels which returns the total number of input channels. So these offsets indeed are the same.\nI'm more inclined now to use gateId+channelId pairs or InputChannelInfo s :)", "url": "https://github.com/apache/flink/pull/12575#discussion_r439064498", "createdAt": "2020-06-11T20:52:22Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5Mjc1Mg==", "bodyText": "I'd actually love to use InputChannelInfos everywhere. Previous attempts to refactor proved difficult however. I'll check again.", "url": "https://github.com/apache/flink/pull/12575#discussion_r439292752", "createdAt": "2020-06-12T08:50:44Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMwNjgxNg==", "bodyText": "@AHeise are you asking about InputProcessorUtil#generateInputGateToChannelIndexOffsetMap not using the input gate indexes? I'm not sure. I guess it is inconsistent with the numberOfInputChannelsPerGate but it might be correct, as all of the references/usages of inputGateToChannelIndexOffset are going through the offsetting that also uses inputGateToChannelIndexOffset (for example CheckpointedInputGate#offsetChannelIndex). But it's really hard to reason about.\nIt's also quite strange that when polling records from input gate, we are first offsetting them once via using CheckpointedInputGate#offsetChannelIndex and then we are using basically the same information to revert the offset back, to the original value in CheckpointBarrierAligner#resumeConsumption.\nIf we could simplify it by always using pair of ids without affecting performance that would be really nice...", "url": "https://github.com/apache/flink/pull/12575#discussion_r439306816", "createdAt": "2020-06-12T09:19:02Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTAwMTM0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTo0Mzo0OFrOGhxBMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOTozODo0NlrOGir8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTMxMg==", "bodyText": "Replacing an array with Collection allows to lose ordering. Why not to use List instead?", "url": "https://github.com/apache/flink/pull/12575#discussion_r438059312", "createdAt": "2020-06-10T11:43:48Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java", "diffHunk": "@@ -38,18 +40,18 @@ public static InputGate createInputGate(Collection<IndexedInputGate> inputGates1\n \t\tList<IndexedInputGate> gates = new ArrayList<>(inputGates1.size() + inputGates2.size());\n \t\tgates.addAll(inputGates1);\n \t\tgates.addAll(inputGates2);\n-\t\treturn createInputGate(gates.toArray(new IndexedInputGate[gates.size()]));\n+\t\treturn createInputGate(gates);\n \t}\n \n-\tpublic static InputGate createInputGate(IndexedInputGate[] inputGates) {\n-\t\tif (inputGates.length <= 0) {\n+\tpublic static InputGate createInputGate(Collection<IndexedInputGate> inputGates) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAyNDcxMg==", "bodyText": "I had to change a bit of the invoking code, but it's not much because ultimately Lists are used everywhere.", "url": "https://github.com/apache/flink/pull/12575#discussion_r439024712", "createdAt": "2020-06-11T19:38:46Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java", "diffHunk": "@@ -38,18 +40,18 @@ public static InputGate createInputGate(Collection<IndexedInputGate> inputGates1\n \t\tList<IndexedInputGate> gates = new ArrayList<>(inputGates1.size() + inputGates2.size());\n \t\tgates.addAll(inputGates1);\n \t\tgates.addAll(inputGates2);\n-\t\treturn createInputGate(gates.toArray(new IndexedInputGate[gates.size()]));\n+\t\treturn createInputGate(gates);\n \t}\n \n-\tpublic static InputGate createInputGate(IndexedInputGate[] inputGates) {\n-\t\tif (inputGates.length <= 0) {\n+\tpublic static InputGate createInputGate(Collection<IndexedInputGate> inputGates) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTMxMg=="}, "originalCommit": {"oid": "0f4937a770629aaedc86bdf206fd225667965595"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTAzODY3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTozMzowM1rOGkL04w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMDoyNzozN1rOGkVJwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw==", "bodyText": "This seems to be going in the opposite direction - we are replacing indexing based on the real IDs with those based on the order?", "url": "https://github.com/apache/flink/pull/12575#discussion_r440595683", "createdAt": "2020-06-16T05:33:03Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -105,11 +105,11 @@ public UnionInputGate(IndexedInputGate... inputGates) {\n \t\tinputChannelToInputGateIndex = new int[totalNumberOfInputChannels];\n \n \t\tint currentNumberOfInputChannels = 0;\n-\t\tfor (final IndexedInputGate inputGate : inputGates) {\n-\t\t\tinputGateChannelIndexOffsets[inputGate.getGateIndex()] = currentNumberOfInputChannels;\n+\t\tfor (int index = 0; index < inputGates.length; index++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da20240bb34b4ba4b516d67867f9d84819f894fe"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0MTA3NQ==", "bodyText": "Yes you are right. I reverted the change and went into a different direction. The basic issue is that the field inputGates contains all gates in a dense array. We would need a sparse index/map if we access it completely through gateIndex.\nThere were 3 options:\n\nAlways use dense, which results in what you have mentioned.\nUse both, resulting in duplicate fields.\nAlways use sparse index, where we need to skip null values. Or use map and live with slightly longer accesses (current solution).", "url": "https://github.com/apache/flink/pull/12575#discussion_r440641075", "createdAt": "2020-06-16T07:27:59Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -105,11 +105,11 @@ public UnionInputGate(IndexedInputGate... inputGates) {\n \t\tinputChannelToInputGateIndex = new int[totalNumberOfInputChannels];\n \n \t\tint currentNumberOfInputChannels = 0;\n-\t\tfor (final IndexedInputGate inputGate : inputGates) {\n-\t\t\tinputGateChannelIndexOffsets[inputGate.getGateIndex()] = currentNumberOfInputChannels;\n+\t\tfor (int index = 0; index < inputGates.length; index++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw=="}, "originalCommit": {"oid": "da20240bb34b4ba4b516d67867f9d84819f894fe"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0ODQ4MQ==", "bodyText": "Ok, let's try out the Map approach. In case of performance issues, we can later fallback to other solution, like sparse index.", "url": "https://github.com/apache/flink/pull/12575#discussion_r440748481", "createdAt": "2020-06-16T10:27:37Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -105,11 +105,11 @@ public UnionInputGate(IndexedInputGate... inputGates) {\n \t\tinputChannelToInputGateIndex = new int[totalNumberOfInputChannels];\n \n \t\tint currentNumberOfInputChannels = 0;\n-\t\tfor (final IndexedInputGate inputGate : inputGates) {\n-\t\t\tinputGateChannelIndexOffsets[inputGate.getGateIndex()] = currentNumberOfInputChannels;\n+\t\tfor (int index = 0; index < inputGates.length; index++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw=="}, "originalCommit": {"oid": "da20240bb34b4ba4b516d67867f9d84819f894fe"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA3NzI1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NDoyMVrOGkMMcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NDoyMVrOGkMMcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTcxMg==", "bodyText": "It's a bit confusing that above we have sortedInputGates and those input gates here are not sorted. It means we end up with a confusing state, where CheckpointBarrierHandler#inputGates can be accessed via inputGateIndex while UnionInputGate#inputGates can not be.\nI understand why is it so, first one is flattened structure of all input gates, while the other has only a subset of gates. Maybe we can keep it as it is for now, as this commit is already simplifying things, but maybe we should replace UnionInputGate#inputGates array with a map?", "url": "https://github.com/apache/flink/pull/12575#discussion_r440601712", "createdAt": "2020-06-16T05:54:21Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -71,108 +69,55 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tString taskName,\n \t\t\tList<IndexedInputGate>... inputGates) {\n \n-\t\tIntStream numberOfInputChannelsPerGate =\n-\t\t\tArrays\n-\t\t\t\t.stream(inputGates)\n-\t\t\t\t.flatMap(collection -> collection.stream())\n-\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n-\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n-\n-\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n-\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different\n-\t\t// indexing and purposes.\n-\t\t//\n-\t\t// The numberOfInputChannelsPerGate is indexed based on flattened input gates, and sorted based on GateIndex,\n-\t\t// so that it can be used in combination with InputChannelInfo class.\n-\t\t//\n-\t\t// The inputGateToChannelIndexOffset is based upon unioned input gates and it's use for translating channel\n-\t\t// indexes from perspective of UnionInputGate to perspective of SingleInputGate.\n-\n+\t\tIndexedInputGate[] sortedInputGates = Arrays.stream(inputGates)\n+\t\t\t.flatMap(Collection::stream)\n+\t\t\t.sorted(Comparator.comparing(IndexedInputGate::getGateIndex))\n+\t\t\t.toArray(IndexedInputGate[]::new);\n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tconfig,\n-\t\t\tnumberOfInputChannelsPerGate,\n+\t\t\tsortedInputGates,\n \t\t\tcheckpointCoordinator,\n \t\t\ttaskName,\n-\t\t\tgenerateChannelIndexToInputGateMap(unionedInputGates),\n-\t\t\tinputGateToChannelIndexOffset,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n+\t\tInputGate[] unionedInputGates = Arrays.stream(inputGates)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf35ad99fab120c4ea7795406e65dcb1073ab0ed"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTQwMzMzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0OTo0MlrOGkPW2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoyMjo0M1rOGk45EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ==", "bodyText": "Why do we use Map<Key, Boolean> instead of just  Set<Key> (also in CheckpointBarrierUnaligner, ThreadSafeUnaligner)?\n(I guess we can avoid the penalty of dynamic reallocation by setting set capacity in advance)", "url": "https://github.com/apache/flink/pull/12575#discussion_r440653529", "createdAt": "2020-06-16T07:49:42Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1OTgyOQ==", "bodyText": "Yes, you are right (I tried to explain it in the commit message). Also internally HashSet uses LinkedHashMap, so it's even then slower than using HashMap directly even with dynamic reallocation.", "url": "https://github.com/apache/flink/pull/12575#discussion_r440659829", "createdAt": "2020-06-16T08:00:22Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTI4MA==", "bodyText": "Also internally HashSet uses LinkedHashMap\n\nCan you explain what do you mean?\nIn my OpenJDK 11 HashSet uses HashMap under the hood, and I believe this is what most implementations do.", "url": "https://github.com/apache/flink/pull/12575#discussion_r440739280", "createdAt": "2020-06-16T10:10:46Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3MjA3OQ==", "bodyText": "Never mind, I misread the code. It's only used while calling LinkedHashSet -> super(HashSet).\nAnyways, the current way is used to avoid dynamic reallocations. I can also write a small wrapper Set implementation (similar to EnumSet) if it's too hard to read right now.\nPerformance-wise there is no gain on a HashSet#containsKey on an empty set to a HashMap#get on a filled set with same capacity. However, I'd we avoid object creations and deletions if we just update the nodes on write access.", "url": "https://github.com/apache/flink/pull/12575#discussion_r440772079", "createdAt": "2020-06-16T11:13:32Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxOTQ0Nw==", "bodyText": "I'm not sure if it's not a premature optimization (I think contains is faster for set but put/remove slower; and it all may not be visible).\nBut I'm also fine with the current approach.", "url": "https://github.com/apache/flink/pull/12575#discussion_r440819447", "createdAt": "2020-06-16T12:43:36Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzNDAzMg==", "bodyText": "HashSet#contains uses HashMap#containsKey, which fetches the node of the key. Without hash collisions and overflow lists, that is exactly the same. The question is how many collisions we have. It may also depend on whether the respective Set is mostly filled or empty (e.g., blockedChannels should be mostly empty). We might want to potentially invert the current semantics to keep them empty as long as possible.\nMy main motivation was to avoid adding anything to GC pressure and using mostly a constant data structure as before to not change too much. I think I'd leave it as is for now. We can revise it when we adjust the threading model of Unaligner, which will be a major change on the code anyways.", "url": "https://github.com/apache/flink/pull/12575#discussion_r441334032", "createdAt": "2020-06-17T07:22:43Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, "originalCommit": {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4373, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}