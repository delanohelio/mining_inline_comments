{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzIyNjU5", "number": 11687, "title": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint", "bodyText": "What is the purpose of the change\nDuring recovery process for unaligned checkpoint, the remote input channel state should also be recovered besides with existing operator states.\nThe remote channel would request buffer and then interact with ChannelStateReader to fill in the state data.  The filled buffer would be inserted into respective data queue for processing in normal way.\nIt should guarantee that the new data from upstream partition should not overtake the input state data to avoid mis-order issue.\nBrief change log\n\nDelay request partition in RemoteInputChannel after finishing reading channel state.\nAdd related interfaces method from input channel to handler stacks to notify the read of channel state\nImplement the main process to read channel state via interacting with ChannelStateReader\n\nVerifying this change\nAdd some new unit tests to verify the changes\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-04-09T09:48:08Z", "url": "https://github.com/apache/flink/pull/11687", "merged": true, "mergeCommit": {"oid": "d7525baf093035c9b0fe125602814833388d1973"}, "closed": true, "closedAt": "2020-05-12T07:55:59Z", "author": {"login": "zhijiangW"}, "timelineItems": {"totalCount": 66, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcV-muLAFqTM5MDgyNjMxMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgfvB0gFqTQwOTc1NDU1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwODI2MzEy", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-390826312", "createdAt": "2020-04-09T14:08:18Z", "commit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDowODoxOFrOGDaYSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNDozMlrOGDeItQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTExMg==", "bodyText": "Could those changes about dropping int subpartitionIndex be a separate commit?", "url": "https://github.com/apache/flink/pull/11687#discussion_r406231112", "createdAt": "2020-04-09T14:08:18Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -95,7 +95,7 @@ public LocalInputChannel(\n \t// ------------------------------------------------------------------------\n \n \t@Override\n-\tprotected void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\tprotected void requestSubpartition() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MjY2MQ==", "bodyText": "notifyStateBuffersAvailable()? notifyBuffersForReadChannelStateAvailable?", "url": "https://github.com/apache/flink/pull/11687#discussion_r406292661", "createdAt": "2020-04-09T15:34:32Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +367,16 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tshouldNotifyChannelState = isWaitingForStateBuffers;\n+\t\t\tisWaitingForStateBuffers = false;\n+\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (shouldNotifyChannelState) {\n+\t\t\tnotifyReadChannelState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNTIyMzY5", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-391522369", "createdAt": "2020-04-10T16:05:47Z", "commit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjowNTo0N1rOGD-oTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjowNTo0N1rOGD-oTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNTAzOQ==", "bodyText": "stateReader.readInputData is not thread safe as it is currently and this readInputChannelState method can be executed by netty threads concurrently for different channels, right?", "url": "https://github.com/apache/flink/pull/11687#discussion_r406825039", "createdAt": "2020-04-10T16:05:47Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,16 +154,58 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t/**\n+\t * Reads the channel state data executed by netty thread, so it can make use of almost all the\n+\t * existing processes to avoid bringing additional race conditions with task thread. Also it can\n+\t * avoid introducing another thread pool to handle this work to make things more complex.\n+\t */\n+\tprivate void readInputChannelState() throws IOException {\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\tif (buffer != null) {\n+\t\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\tisWaitingForStateBuffers = true;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tChannelStateReader.ReadResult result = inputGate.stateReader.readInputData(channelInfo, buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/c8c0da9e2badf68c11e8466943c7a8e14156c858", "committedDate": "2020-04-09T09:42:43Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7b32c0f208a47925d94e290a91132ec15590236e", "committedDate": "2020-04-14T15:50:28Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTcxNDA2", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-393171406", "createdAt": "2020-04-14T18:05:21Z", "commit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODowNToyMlrOGFatzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODoxOTo0M1rOGFbOiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzMzc3NQ==", "bodyText": "It made the final commit a bit smaller, so I think it was worth it (to speed up reviewing). As hotfix on it's own it's also a nice simplification I think.", "url": "https://github.com/apache/flink/pull/11687#discussion_r408333775", "createdAt": "2020-04-14T18:05:22Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -95,7 +95,7 @@ public LocalInputChannel(\n \t// ------------------------------------------------------------------------\n \n \t@Override\n-\tprotected void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\tprotected void requestSubpartition() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTExMg=="}, "originalCommit": {"oid": "c8c0da9e2badf68c11e8466943c7a8e14156c858"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNjkxOA==", "bodyText": "Could it be that we start reading from a channel before we actually request subpartition? For example:\nOptional<BufferAndAvailability> RemoteInputChannel#getNextBuffer() throws IOException {\n\t(...)\n\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\"); // ??\n\nor what if partitionRequestClient is already not null, but\npartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n\nhasn't completed?", "url": "https://github.com/apache/flink/pull/11687#discussion_r408336918", "createdAt": "2020-04-14T18:10:39Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -243,7 +249,23 @@ void requestPartitions() throws IOException, InterruptedException {\n \t\t\t\t}\n \n \t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.requestSubpartition();\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.initializeState(reader);\n+\t\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.requestSubpartition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzODc2OQ==", "bodyText": "I would move the for loop inside the executor, to avoid race conditions and not depend on executor being single threaded.", "url": "https://github.com/apache/flink/pull/11687#discussion_r408338769", "createdAt": "2020-04-14T18:13:47Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -243,7 +249,23 @@ void requestPartitions() throws IOException, InterruptedException {\n \t\t\t\t}\n \n \t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.requestSubpartition();\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.initializeState(reader);\n+\t\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg==", "bodyText": "Is someone notifing this thread to wake up? Can not we wait on the buffer in another way?", "url": "https://github.com/apache/flink/pull/11687#discussion_r408340272", "createdAt": "2020-04-14T18:16:32Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,6 +149,47 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void initializeState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tnumRequiredBuffers = initialCredit + inputGate.getBufferPool().getMaxNumberOfMemorySegments();\n+\t\tunannouncedCredit.set(initialCredit);\n+\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (!isWaitingForFloatingBuffers) {\n+\t\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\t\tif (buffer == null) {\n+\t\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (buffer == null) {\n+\t\t\t\twait(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MjE1Mg==", "bodyText": "who is now calling this method in batch tasks?", "url": "https://github.com/apache/flink/pull/11687#discussion_r408342152", "createdAt": "2020-04-14T18:19:43Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -213,19 +215,23 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n+\n \n-\t\trequestPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDQxNjk0", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-394441694", "createdAt": "2020-04-16T09:09:59Z", "commit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowOTo1OVrOGGb7Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOToyMTowOFrOGGcXXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMjE5NQ==", "bodyText": "rename channelStateUnspillingExecutor?", "url": "https://github.com/apache/flink/pull/11687#discussion_r409402195", "createdAt": "2020-04-16T09:09:59Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -289,6 +292,8 @@ protected StreamTask(\n \t\t} else {\n \t\t\tthis.timerService = timerService;\n \t\t}\n+\n+\t\tthis.ioExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"state-io\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwOTM3NA==", "bodyText": "could we pass the state recovery parameters here? And have a single step setup method instead of introducing 2nd initialisation step (setup and initializeState).", "url": "https://github.com/apache/flink/pull/11687#discussion_r409409374", "createdAt": "2020-04-16T09:21:08Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -213,19 +215,23 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDU2NDA0", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-394456404", "createdAt": "2020-04-16T09:28:22Z", "commit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOToyODoyMlrOGGcp4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOToyOTo0MlrOGGctbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxNDExMw==", "bodyText": "Does it make sense to rename initializeState to readRecoveredState? or processRecoveredState?", "url": "https://github.com/apache/flink/pull/11687#discussion_r409414113", "createdAt": "2020-04-16T09:28:22Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,6 +149,47 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void initializeState(ChannelStateReader reader) throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxNTAyMQ==", "bodyText": "Oh, I missed that we are already using a separate thread pool. In that case we don't need the not blocking option now.\nIt would be still good to get rid of timed wait in favour of some notifications though.", "url": "https://github.com/apache/flink/pull/11687#discussion_r409415021", "createdAt": "2020-04-16T09:29:42Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,6 +149,47 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void initializeState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tnumRequiredBuffers = initialCredit + inputGate.getBufferPool().getMaxNumberOfMemorySegments();\n+\t\tunannouncedCredit.set(initialCredit);\n+\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (!isWaitingForFloatingBuffers) {\n+\t\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\t\tif (buffer == null) {\n+\t\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (buffer == null) {\n+\t\t\t\twait(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg=="}, "originalCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b32c0f208a47925d94e290a91132ec15590236e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7b32c0f208a47925d94e290a91132ec15590236e", "committedDate": "2020-04-14T15:50:28Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "committedDate": "2020-04-17T12:34:50Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "committedDate": "2020-04-17T12:34:50Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "c236bcd49d282e8f85ee216eced2436bba5a88bf", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/c236bcd49d282e8f85ee216eced2436bba5a88bf", "committedDate": "2020-04-17T14:37:28Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c236bcd49d282e8f85ee216eced2436bba5a88bf", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/c236bcd49d282e8f85ee216eced2436bba5a88bf", "committedDate": "2020-04-17T14:37:28Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "committedDate": "2020-04-17T14:43:00Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "committedDate": "2020-04-17T14:43:00Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "committedDate": "2020-04-17T14:44:47Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "committedDate": "2020-04-17T14:44:47Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "5bad018f00f85a7359345187a12d7938aa510d25", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/5bad018f00f85a7359345187a12d7938aa510d25", "committedDate": "2020-04-17T14:46:01Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bad018f00f85a7359345187a12d7938aa510d25", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/5bad018f00f85a7359345187a12d7938aa510d25", "committedDate": "2020-04-17T14:46:01Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "371f4a669c47fb1ad3d7f7c643edd71c54405195", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/371f4a669c47fb1ad3d7f7c643edd71c54405195", "committedDate": "2020-04-17T14:58:14Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "371f4a669c47fb1ad3d7f7c643edd71c54405195", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/371f4a669c47fb1ad3d7f7c643edd71c54405195", "committedDate": "2020-04-17T14:58:14Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "d51ce7f47381d99b843278cd701dcff223761a0b", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/d51ce7f47381d99b843278cd701dcff223761a0b", "committedDate": "2020-04-17T15:14:59Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d51ce7f47381d99b843278cd701dcff223761a0b", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/d51ce7f47381d99b843278cd701dcff223761a0b", "committedDate": "2020-04-17T15:14:59Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "committedDate": "2020-04-19T16:37:05Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "committedDate": "2020-04-19T16:37:05Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "a18363014fe72d3a0fcc766355639b36f56989b3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/a18363014fe72d3a0fcc766355639b36f56989b3", "committedDate": "2020-04-20T03:36:12Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a18363014fe72d3a0fcc766355639b36f56989b3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/a18363014fe72d3a0fcc766355639b36f56989b3", "committedDate": "2020-04-20T03:36:12Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "cba096ae3d8eba4a0d39c64659f76ad10a62be27", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/cba096ae3d8eba4a0d39c64659f76ad10a62be27", "committedDate": "2020-04-20T04:31:24Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cba096ae3d8eba4a0d39c64659f76ad10a62be27", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/cba096ae3d8eba4a0d39c64659f76ad10a62be27", "committedDate": "2020-04-20T04:31:24Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "bec74b31e59e84487c7fc09165aa44e4c39aa927", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/bec74b31e59e84487c7fc09165aa44e4c39aa927", "committedDate": "2020-04-20T09:29:44Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bec74b31e59e84487c7fc09165aa44e4c39aa927", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/bec74b31e59e84487c7fc09165aa44e4c39aa927", "committedDate": "2020-04-20T09:29:44Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/054de880d6814fd93c782d199a87490d1440a573", "committedDate": "2020-04-20T11:28:33Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MzgyNjI3", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-396382627", "createdAt": "2020-04-20T11:52:39Z", "commit": {"oid": "34a60cefb9c81c3220030ddba2ea99722ed6a622"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMTo1MjozOVrOGIQuYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1Mjo1NFrOGIS79w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNTgxMA==", "bodyText": "Do we want this change here? I would like to avoid introducing many different places that are manually disabling/enabling unaligned checkpoints. Maybe this should be handled generically as part of this ticket https://issues.apache.org/jira/browse/FLINK-17258 ?", "url": "https://github.com/apache/flink/pull/11687#discussion_r411315810", "createdAt": "2020-04-20T11:52:39Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java", "diffHunk": "@@ -914,7 +914,9 @@ public void testInitializeResultPartitionState() throws Exception {\n \n \t\tMockEnvironment mockEnvironment = new MockEnvironmentBuilder().build();\n \t\tmockEnvironment.addOutputs(Arrays.asList(partitions));\n-\t\tStreamTask task = new MockStreamTaskBuilder(mockEnvironment).build();\n+\t\tStreamConfig config = new StreamConfig(new Configuration());\n+\t\tconfig.setUnalignedCheckpointsEnabled(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34a60cefb9c81c3220030ddba2ea99722ed6a622"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNjUzNw==", "bodyText": "readRecoveredStateAndRequestPartitions?", "url": "https://github.com/apache/flink/pull/11687#discussion_r411316537", "createdAt": "2020-04-20T11:53:52Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGate.java", "diffHunk": "@@ -131,7 +135,12 @@\n \t/**\n \t * Setup gate, potentially heavy-weight, blocking operation comparing to just creation.\n \t */\n-\tpublic abstract void setup() throws IOException, InterruptedException;\n+\tpublic abstract void setup() throws IOException;\n+\n+\tpublic abstract void initializeStateAndRequestPartitions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0NTI5MA==", "bodyText": "initializeCreditsForRecoveringState?", "url": "https://github.com/apache/flink/pull/11687#discussion_r411345290", "createdAt": "2020-04-20T12:42:17Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -162,6 +163,95 @@ void assignExclusiveSegments() throws IOException {\n \t// Consume\n \t// ------------------------------------------------------------------------\n \n+\tvoid readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tbeforeReadRecoveredState();\n+\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (!isWaitingForFloatingBuffers) {\n+\t\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\t\tif (buffer == null) {\n+\t\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tbufferQueue.wait();\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tChannelStateReader.ReadResult result = internalReaderRecoveredState(reader, buffer);\n+\t\t\tif (result == ChannelStateReader.ReadResult.NO_MORE_DATA) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void beforeReadRecoveredState() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTk4OA==", "bodyText": "This doesn't look right - boolean hasStates and @Nullable executor - it looks like this check should be on a different layer. As this method looks like it's called only in one place, shouldn't it be just inlined?", "url": "https://github.com/apache/flink/pull/11687#discussion_r411349988", "createdAt": "2020-04-20T12:49:43Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -222,19 +225,65 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n \n-\t\trequestPartitions();\n+\t@Override\n+\tpublic void initializeStateAndRequestPartitions(\n+\t\t\tboolean hasStates,\n+\t\t\t@Nullable ExecutorService executor,\n+\t\t\tChannelStateReader reader) throws Exception {\n+\n+\t\tif (hasStates) {\n+\t\t\tcheckNotNull(executor);\n+\t\t\treadRecoveredStateBeforeRequestPartition(executor, reader);\n+\t\t} else {\n+\t\t\trequestPartitions();\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MjA1NQ==", "bodyText": "Add a TODO that it should be replaced by a global TaskManager ioExecutor?", "url": "https://github.com/apache/flink/pull/11687#discussion_r411352055", "createdAt": "2020-04-20T12:52:54Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -204,6 +205,9 @@\n \n \tprotected final MailboxProcessor mailboxProcessor;\n \n+\t@Nullable\n+\tprivate final ExecutorService channelStateUnspillingExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "054de880d6814fd93c782d199a87490d1440a573", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/054de880d6814fd93c782d199a87490d1440a573", "committedDate": "2020-04-20T11:28:33Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "d6bf8d30b07508e1bfab01026414e9d461fb2a52", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/d6bf8d30b07508e1bfab01026414e9d461fb2a52", "committedDate": "2020-04-20T15:27:06Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6bf8d30b07508e1bfab01026414e9d461fb2a52", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/d6bf8d30b07508e1bfab01026414e9d461fb2a52", "committedDate": "2020-04-20T15:27:06Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "3c8127c5af7014b7368b202fbb3966f3d478a791", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/3c8127c5af7014b7368b202fbb3966f3d478a791", "committedDate": "2020-04-20T15:31:30Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c8127c5af7014b7368b202fbb3966f3d478a791", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/3c8127c5af7014b7368b202fbb3966f3d478a791", "committedDate": "2020-04-20T15:31:30Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "9c84a49b5dfcafda82951da969e169cbe7b15645", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/9c84a49b5dfcafda82951da969e169cbe7b15645", "committedDate": "2020-04-20T16:40:42Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c84a49b5dfcafda82951da969e169cbe7b15645", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/9c84a49b5dfcafda82951da969e169cbe7b15645", "committedDate": "2020-04-20T16:40:42Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "f20368de0bdc14ae26ea92256137a9551bdb0879", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/f20368de0bdc14ae26ea92256137a9551bdb0879", "committedDate": "2020-04-21T02:36:04Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f20368de0bdc14ae26ea92256137a9551bdb0879", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/f20368de0bdc14ae26ea92256137a9551bdb0879", "committedDate": "2020-04-21T02:36:04Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "committedDate": "2020-04-21T05:50:46Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "committedDate": "2020-04-21T05:50:46Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "7da2bce04403094880b080257cc837e94ae41164", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7da2bce04403094880b080257cc837e94ae41164", "committedDate": "2020-04-21T07:17:48Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7da2bce04403094880b080257cc837e94ae41164", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7da2bce04403094880b080257cc837e94ae41164", "committedDate": "2020-04-21T07:17:48Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "23818c4b30eb9714154080253a090fc63d983925", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/23818c4b30eb9714154080253a090fc63d983925", "committedDate": "2020-04-21T10:09:54Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "23818c4b30eb9714154080253a090fc63d983925", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/23818c4b30eb9714154080253a090fc63d983925", "committedDate": "2020-04-21T10:09:54Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "528daec595675b9f2871612186b259a00afc53f0", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/528daec595675b9f2871612186b259a00afc53f0", "committedDate": "2020-04-21T10:34:55Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "528daec595675b9f2871612186b259a00afc53f0", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/528daec595675b9f2871612186b259a00afc53f0", "committedDate": "2020-04-21T10:34:55Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue."}, "afterCommit": {"oid": "9b6278f15a4fc65d78671a145305df2c7310cc6a", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/9b6278f15a4fc65d78671a145305df2c7310cc6a", "committedDate": "2020-04-21T10:56:37Z", "message": "fixup test failure"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b6278f15a4fc65d78671a145305df2c7310cc6a", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/9b6278f15a4fc65d78671a145305df2c7310cc6a", "committedDate": "2020-04-21T10:56:37Z", "message": "fixup test failure"}, "afterCommit": {"oid": "336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "committedDate": "2020-04-21T17:15:56Z", "message": "[fixup] Disable unaligned checkpoint for UnalignedCheckpointITCase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "committedDate": "2020-04-21T17:15:56Z", "message": "[fixup] Disable unaligned checkpoint for UnalignedCheckpointITCase"}, "afterCommit": {"oid": "1a28ea65925ab2094ef7496c4427bb635ff6f70c", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1a28ea65925ab2094ef7496c4427bb635ff6f70c", "committedDate": "2020-04-22T03:06:50Z", "message": "[fixup] Disable unaligned checkpoint in UnalignedCheckpointITCase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a28ea65925ab2094ef7496c4427bb635ff6f70c", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1a28ea65925ab2094ef7496c4427bb635ff6f70c", "committedDate": "2020-04-22T03:06:50Z", "message": "[fixup] Disable unaligned checkpoint in UnalignedCheckpointITCase"}, "afterCommit": {"oid": "a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "committedDate": "2020-04-22T05:37:21Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "committedDate": "2020-04-22T05:37:21Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}, "afterCommit": {"oid": "02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "committedDate": "2020-04-22T09:18:48Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "committedDate": "2020-04-22T09:18:48Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}, "afterCommit": {"oid": "4f7399680818f5d29e917e17720e00900822a43d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4f7399680818f5d29e917e17720e00900822a43d", "committedDate": "2020-04-22T09:31:06Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Mjg5NTA4", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-398289508", "createdAt": "2020-04-22T15:06:55Z", "commit": {"oid": "4f7399680818f5d29e917e17720e00900822a43d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTowNjo1NVrOGJ7hMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTowNjo1NVrOGJ7hMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2NTUyMw==", "bodyText": "I think this block of code is forgetting about getUnconsumedBuffer() from the LocalInputChannel that was spilled as part of the input data.", "url": "https://github.com/apache/flink/pull/11687#discussion_r413065523", "createdAt": "2020-04-22T15:06:55Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -222,19 +226,54 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n+\n+\t@Override\n+\tpublic void readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException {\n+\t\tinternalRequestPartitions(() -> executor.submit(() -> {\n+\n+\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\tif (inputChannel instanceof RemoteInputChannel) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((RemoteInputChannel) inputChannel).readRecoveredState(reader);\n+\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f7399680818f5d29e917e17720e00900822a43d"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f7399680818f5d29e917e17720e00900822a43d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4f7399680818f5d29e917e17720e00900822a43d", "committedDate": "2020-04-22T09:31:06Z", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily"}, "afterCommit": {"oid": "7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "committedDate": "2020-04-23T11:40:55Z", "message": "fixup local input channel recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "committedDate": "2020-04-23T11:40:55Z", "message": "fixup local input channel recovery"}, "afterCommit": {"oid": "672a5e5b1a1c4607cb5e5e191877484f472dad1b", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/672a5e5b1a1c4607cb5e5e191877484f472dad1b", "committedDate": "2020-04-23T18:22:50Z", "message": "fixup local input channel recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "672a5e5b1a1c4607cb5e5e191877484f472dad1b", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/672a5e5b1a1c4607cb5e5e191877484f472dad1b", "committedDate": "2020-04-23T18:22:50Z", "message": "fixup local input channel recovery"}, "afterCommit": {"oid": "12c398dd2dc5b6716a590490575914698573ab76", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/12c398dd2dc5b6716a590490575914698573ab76", "committedDate": "2020-04-24T02:39:06Z", "message": "fixup local input channel recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12c398dd2dc5b6716a590490575914698573ab76", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/12c398dd2dc5b6716a590490575914698573ab76", "committedDate": "2020-04-24T02:39:06Z", "message": "fixup local input channel recovery"}, "afterCommit": {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/95dc7d6ada34179b51849d905f15c740ca585a8d", "committedDate": "2020-04-24T06:58:19Z", "message": "fixup local input channel recovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDc3NDg2", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-400077486", "createdAt": "2020-04-24T16:02:46Z", "commit": {"oid": "6ca8ec305a96d208919ab49244448de89bc7b679"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowMjo0NlrOGLenqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoxNTozMVrOGLfH2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg==", "bodyText": "Why do we have to requestPartitions() once per every record?", "url": "https://github.com/apache/flink/pull/11687#discussion_r414689192", "createdAt": "2020-04-24T16:02:46Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ca8ec305a96d208919ab49244448de89bc7b679"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5NzQzMg==", "bodyText": "requestPartitions() requires similar java doc as readRecoveredState() explaining when it should be called.", "url": "https://github.com/apache/flink/pull/11687#discussion_r414697432", "createdAt": "2020-04-24T16:15:31Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGate.java", "diffHunk": "@@ -131,7 +133,18 @@\n \t/**\n \t * Setup gate, potentially heavy-weight, blocking operation comparing to just creation.\n \t */\n-\tpublic abstract void setup() throws IOException, InterruptedException;\n+\tpublic abstract void setup() throws IOException;\n+\n+\t/**\n+\t * It is only performed for unaligned checkpoint mode together with internal requesting partitions afterwards.\n+\t * Otherwise only {@link #requestPartitions()} is performed for other checkpoint modes.\n+\t *\n+\t * @param executor the dedicated executor for performing the recovery state for all the internal channels.\n+\t * @param reader the dedicated reader for unspilling the respective channel state from stored snapshots.\n+\t */\n+\tpublic abstract void readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException;\n+\n+\tpublic abstract void requestPartitions() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1a1ab6d49159ed54b6ca0cdb40a29366c5f2688", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/f1a1ab6d49159ed54b6ca0cdb40a29366c5f2688", "committedDate": "2020-04-28T10:56:14Z", "message": "fixup! Refactor some processes and control partition request happen after all single gate recovery"}, "afterCommit": {"oid": "968fa03e469b1704f78106b059a5acaca488dbed", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/968fa03e469b1704f78106b059a5acaca488dbed", "committedDate": "2020-04-30T11:24:04Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "968fa03e469b1704f78106b059a5acaca488dbed", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/968fa03e469b1704f78106b059a5acaca488dbed", "committedDate": "2020-04-30T11:24:04Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "committedDate": "2020-04-30T15:48:53Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "committedDate": "2020-04-30T15:48:53Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "44c8e741ef3e7c17492736d441369a56646b6713", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/44c8e741ef3e7c17492736d441369a56646b6713", "committedDate": "2020-04-30T17:12:46Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44c8e741ef3e7c17492736d441369a56646b6713", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/44c8e741ef3e7c17492736d441369a56646b6713", "committedDate": "2020-04-30T17:12:46Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "25bf7d665d0b232621648b7d517376a60aab4311", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/25bf7d665d0b232621648b7d517376a60aab4311", "committedDate": "2020-05-01T16:10:07Z", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25bf7d665d0b232621648b7d517376a60aab4311", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/25bf7d665d0b232621648b7d517376a60aab4311", "committedDate": "2020-05-01T16:10:07Z", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery"}, "afterCommit": {"oid": "b5e4853968886a623cb083fe71933fa2ce7f8932", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/b5e4853968886a623cb083fe71933fa2ce7f8932", "committedDate": "2020-05-02T14:37:35Z", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5e4853968886a623cb083fe71933fa2ce7f8932", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/b5e4853968886a623cb083fe71933fa2ce7f8932", "committedDate": "2020-05-02T14:37:35Z", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery"}, "afterCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/bd26e4d1aae1bfb87dee603ddd51afda409a46df", "committedDate": "2020-05-04T07:46:57Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTAyNTgz", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-400102583", "createdAt": "2020-04-24T16:37:02Z", "commit": {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjozNzowM1rOGLf9Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjowMzoyMFrOGP9R9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMTA1MA==", "bodyText": "?", "url": "https://github.com/apache/flink/pull/11687#discussion_r414711050", "createdAt": "2020-04-24T16:37:03Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -97,6 +100,18 @@ public LocalInputChannel(\n \t// Consume\n \t// ------------------------------------------------------------------------\n \n+\t@Override\n+\tpublic void readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// In most of cases we only need one buffer for reading recovered state except in very large record case.\n+\t\t\t// Then only one floating buffer is required to avoid receive more floating buffers after recovery. Even\n+\t\t\t// though we need more buffers for recovery in large record case, it only increases some interactions with pool.\n+\t\t\tnumRequiredBuffers = 1;\n+\t\t}\n+\n+\t\tsuper.readRecoveredState(reader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjA4OA==", "bodyText": "Why add synchornized section?", "url": "https://github.com/apache/flink/pull/11687#discussion_r416476088", "createdAt": "2020-04-28T09:41:55Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -371,7 +373,14 @@ boolean isWaitingForFloatingBuffers() {\n \n \t@VisibleForTesting\n \tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn receivedBuffers.poll();\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyMjY0Ng==", "bodyText": "I would keep the unsynchronized prefix for this method and getNumberOfAvailableFloatingBuffers as well.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419322646", "createdAt": "2020-05-04T09:46:50Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -477,11 +362,11 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \t}\n \n \tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferQueue.exclusiveBuffers.size());\n+\t\treturn Math.max(0, initialCredit - bufferManager.getNumberOfAvailableExclusiveBuffers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODI4MA==", "bodyText": "This method is not synchronized. However it could be marked as @VisibleForTesting, so we could ignore this issue for now + adding unsynchronized prefix?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419328280", "createdAt": "2020-05-04T09:57:37Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -321,111 +274,43 @@ private void notifyCreditAvailable() {\n \t\tpartitionRequestClient.notifyCreditAvailable(this);\n \t}\n \n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n \tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n+\t\treturn bufferManager.getNumberOfAvailableBuffers();\n \t}\n \n \tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\t\treturn bufferManager.getNumberOfRequiredBuffers();\n \t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODg0Ng==", "bodyText": "unsychronized prefix + @VisibleForTesting?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419328846", "createdAt": "2020-05-04T09:58:47Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyOTQyNw==", "bodyText": "unsychronized prefix?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419329427", "createdAt": "2020-05-04T09:59:52Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {\n+\t\treturn numRequiredBuffers;\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isWaitingForFloatingBuffers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzMTYyNQ==", "bodyText": "unsychronized prefix?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419331625", "createdAt": "2020-05-04T10:04:23Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {\n+\t\treturn numRequiredBuffers;\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isWaitingForFloatingBuffers() {\n+\t\treturn isWaitingForFloatingBuffers;\n+\t}\n+\n+\tint getNumberOfAvailableBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.getAvailableBufferSize();\n+\t\t}\n+\t}\n+\n+\tint getNumberOfAvailableExclusiveBuffers() {\n+\t\treturn bufferQueue.exclusiveBuffers.size();\n+\t}\n+\n+\tint getNumberOfAvailableFloatingBuffers() {\n+\t\treturn bufferQueue.floatingBuffers.size();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDI1Mw==", "bodyText": "I think this method is bugged (unsychronized and used in the multi threaded context), however it seems like it's result is never used in the production code - InputChannel#getNextBuffer doesn't need to return buffersInBacklog, am I right? So we could drop it? If so, we could do it as a follow up ticket, as this is already a pre-existing issue.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419334253", "createdAt": "2020-05-04T10:10:10Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -321,111 +274,43 @@ private void notifyCreditAvailable() {\n \t\tpartitionRequestClient.notifyCreditAvailable(this);\n \t}\n \n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n \tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n+\t\treturn bufferManager.getNumberOfAvailableBuffers();\n \t}\n \n \tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\t\treturn bufferManager.getNumberOfRequiredBuffers();\n \t}\n \n \tpublic int getSenderBacklog() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNzcwMw==", "bodyText": "This cyclic dependency can be an issue for refactoring/reusing the code. Can not we cut it? As it is, you are trying to decouple buffer manager from input channel, but after all they are still very strongly coupled and both have a shared state.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419337703", "createdAt": "2020-05-04T10:17:26Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0MTI4Ng==", "bodyText": "This should probably be injected in the constructor", "url": "https://github.com/apache/flink/pull/11687#discussion_r419341286", "createdAt": "2020-05-04T10:24:57Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f011acf79e07ccefa2eb6db22f2835a100e9b4"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0Njk2OQ==", "bodyText": "It would be better to inject this field instead of relaying on even tighter coupling with inputChannel.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419346969", "createdAt": "2020-05-04T10:36:57Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -65,14 +65,10 @@\n \t@GuardedBy(\"bufferQueue\")\n \tprivate int numRequiredBuffers;\n \n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\tpublic BufferManager(InputChannel inputChannel, int numRequiredBuffers) {\n \t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tthis.globalPool = inputChannel.inputGate.getMemorySegmentProvider();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1da882e9fd7249eb5b78752bc6e8e104e6633cf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0NzczNQ==", "bodyText": "I remembered in the early version, the requestPartitions was also placed inside SingleInputGate#getNext method. Because of the mailbox requirement, it was migrated into #setup afterwards.\n\nBut that wasn't a good design, and it's still not now :(", "url": "https://github.com/apache/flink/pull/11687#discussion_r419347735", "createdAt": "2020-05-04T10:38:46Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, "originalCommit": {"oid": "6ca8ec305a96d208919ab49244448de89bc7b679"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0OTU0Mg==", "bodyText": "Why 6 instead of (NUM_TASKS + 3)? And also why has it increased?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419349542", "createdAt": "2020-05-04T10:42:57Z", "author": {"login": "pnowojski"}, "path": "flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BackPressureITCase.java", "diffHunk": "@@ -94,7 +94,7 @@ private static Configuration createNetworkBufferConfiguration() {\n \t\tfinal Configuration configuration = new Configuration();\n \n \t\tfinal int memorySegmentSizeKb = 32;\n-\t\tfinal MemorySize networkBuffersMemory = MemorySize.parse(memorySegmentSizeKb * (NUM_TASKS + 2) + \"kb\");\n+\t\tfinal MemorySize networkBuffersMemory = MemorySize.parse(memorySegmentSizeKb * 6 + \"kb\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MDYzMw==", "bodyText": "Does it mean that for every LocalInputChannel after recovery we are wasting a single buffer?\nedit: Ok, I see, that it's being released after end of reading from recovered state, but this is very mangled and hard to understand :(", "url": "https://github.com/apache/flink/pull/11687#discussion_r419350633", "createdAt": "2020-05-04T10:45:24Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -87,10 +90,14 @@ public LocalInputChannel(\n \t\tint maxBackoff,\n \t\tInputChannelMetrics metrics) {\n \n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics.getNumBytesInLocalCounter(), metrics.getNumBuffersInLocalCounter());\n+\t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics);\n \n \t\tthis.partitionManager = checkNotNull(partitionManager);\n \t\tthis.taskEventPublisher = checkNotNull(taskEventPublisher);\n+\t\t// In most cases we only need one buffer for reading recovered state except for very large record.\n+\t\t// Then only one floating buffer is required. Even though we need more buffers for recovery for\n+\t\t// large record, it only increases some interactions with pool.\n+\t\tthis.bufferManager = new BufferManager(this, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MjcxNQ==", "bodyText": "Having to go everything through getRecoveredStateBuffer() every time is not very clean.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419382715", "createdAt": "2020-05-04T11:56:48Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -168,6 +175,12 @@ public void run() {\n \tOptional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException {\n \t\tcheckError();\n \n+\t\tBufferAndAvailability bufferAndAvailability = getNextRecoveredStateBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzcxMA==", "bodyText": "If this is null, but we are still recovering, we will actually go through the the subpartitionView.getNextBuffer()?", "url": "https://github.com/apache/flink/pull/11687#discussion_r419383710", "createdAt": "2020-05-04T11:58:52Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -168,6 +175,12 @@ public void run() {\n \tOptional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException {\n \t\tcheckError();\n \n+\t\tBufferAndAvailability bufferAndAvailability = getNextRecoveredStateBuffer();\n+\t\tif (bufferAndAvailability != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4NTg0Ng==", "bodyText": "Integer.MAX_VALUE? Doesn't it mean that all floating buffers will be stuck permanently in on RemoteInputChannel (that happened to ask for them first?)", "url": "https://github.com/apache/flink/pull/11687#discussion_r419385846", "createdAt": "2020-05-04T12:03:20Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -105,12 +98,15 @@ public RemoteInputChannel(\n \t\tint maxBackoff,\n \t\tInputChannelMetrics metrics) {\n \n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff,\n-\t\t\tmetrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n+\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, metrics);\n \n \t\tthis.connectionId = checkNotNull(connectionId);\n \t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(this, 0);\n+\t\t// In theory it should get the total number of states to indicate the numRequiredBuffers.\n+\t\t// Since we can not get this information in advance, and considering only one input channel\n+\t\t// will read state at the same time by design, then we give a maximum value here to reduce\n+\t\t// unnecessary interactions with buffer pool during recovery.\n+\t\tthis.bufferManager = new BufferManager(this, Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTUwMjgz", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-405150283", "createdAt": "2020-05-04T16:29:20Z", "commit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoyOToyMVrOGQINOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoyOToyMVrOGQINOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDg1Nw==", "bodyText": "This seems like we are loosing a test coverage here? However this test was quite fragile in the first place and I'm not entirely sure what is it suppose to test.", "url": "https://github.com/apache/flink/pull/11687#discussion_r419564857", "createdAt": "2020-05-04T16:29:21Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -731,33 +726,29 @@ public void testFailureInNotifyBufferAvailable() throws Exception {\n \t\t\tbuffer = checkNotNull(bufferPool.requestBuffer());\n \n \t\t\t// trigger subscription to buffer pool\n-\t\t\tfailingRemoteIC.onSenderBacklog(1);\n-\t\t\tsuccessfulRemoteIC.onSenderBacklog(numExclusiveBuffers + 1);\n-\t\t\t// recycling will call RemoteInputChannel#notifyBufferAvailable() which will fail and\n-\t\t\t// this exception will be swallowed and set as an error in failingRemoteIC\n+\t\t\tchannelWithoutPartition.onSenderBacklog(1);\n+\t\t\tchannelWithPartition.onSenderBacklog(numExclusiveBuffers + 1);\n+\n+\t\t\t// recycling will call RemoteInputChannel#notifyBufferAvailable() which will not increase\n+\t\t\t// the unannounced credit if the channel has not requested partition\n \t\t\tbuffer.recycleBuffer();\n-\t\t\tbuffer = null;\n-\t\t\ttry {\n-\t\t\t\tfailingRemoteIC.checkError();\n-\t\t\t\tfail(\"The input channel should have an error based on the failure in RemoteInputChannel#notifyBufferAvailable()\");\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tassertThat(e, hasProperty(\"cause\", isA(IllegalStateException.class)));\n-\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 464}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Nzc3NDA5", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-405777409", "createdAt": "2020-05-05T13:18:04Z", "commit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoxODowNFrOGQo7LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoxODowNFrOGQo7LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMDkwOA==", "bodyText": "It would simplify a threading model, if this was executed from the main thread, via mailbox (in your PR there is already a race condition between processing data (receiving EndOfPartitionEvent/InputChannel#releaseAllResources from the main thread, vs channelIOExecutor requesting partitions). Example failure (this happened on a modified version of this code, but I think it's a valid failure on your version as well)\nWe could enqueue in the channelIOExecutor a simple job, that would enqueue a mail into the mailbox OR inputGate.readRecoveredState could return Future, and we could enqueue a mail into the mailbox once all futures are completed.", "url": "https://github.com/apache/flink/pull/11687#discussion_r420100908", "createdAt": "2020-05-05T13:18:04Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -464,6 +472,20 @@ protected void beforeInvoke() throws Exception {\n \t\t\t\t\twriter.readRecoveredState(getEnvironment().getTaskStateManager().getChannelStateReader());\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// It would get possible benefits to recovery input side after output side, which guarantees the\n+\t\t\t// output can request more floating buffers from global firstly.\n+\t\t\tInputGate[] inputGates = getEnvironment().getAllInputGates();\n+\t\t\tif (inputGates != null) {\n+\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\tinputGate.readRecoveredState(channelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n+\t\t\t\t}\n+\n+\t\t\t\t// Note that we must request partition after all the single gate finishes recovery.\n+\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\tinputGate.requestPartitions(channelIOExecutor);\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/bd26e4d1aae1bfb87dee603ddd51afda409a46df", "committedDate": "2020-05-04T07:46:57Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "committedDate": "2020-05-08T07:06:32Z", "message": "Supplement the new unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "committedDate": "2020-05-08T07:06:32Z", "message": "Supplement the new unit tests"}, "afterCommit": {"oid": "2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "committedDate": "2020-05-08T07:49:48Z", "message": "Supplement the new unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDg0MzMw", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-408084330", "createdAt": "2020-05-08T08:26:19Z", "commit": {"oid": "63b78b0d9260f094d0e5b54b1527802f85b89102"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyNjoxOVrOGSdyUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo0Nzo1NlrOGSeYUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxNTU3MA==", "bodyText": "Maybe add\nLOG.debug(\"{}/{} Finished recovering input.\", inputGate.getOwningTaskName(), channelInfo);\n\n?", "url": "https://github.com/apache/flink/pull/11687#discussion_r422015570", "createdAt": "2020-05-08T08:26:19Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java", "diffHunk": "@@ -46,15 +49,19 @@\n \t\t\tint maxBackoff,\n \t\t\tInputChannelMetrics metrics) {\n \t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n+\n+\t\tbufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n \t}\n \n+\tpublic abstract InputChannel toInputChannel() throws IOException;\n+\n \tprotected void readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n \t\tReadResult result = ReadResult.HAS_MORE_DATA;\n \t\twhile (result == ReadResult.HAS_MORE_DATA) {\n-\t\t\tBuffer buffer = getBufferManager().requestBufferBlocking();\n+\t\t\tBuffer buffer = bufferManager.requestBufferBlocking();\n \t\t\tresult = internalReaderRecoveredState(reader, buffer);\n \t\t}\n-\t\tgetBufferManager().releaseFloatingBuffers();\n+\t\tbufferManager.releaseFloatingBuffers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63b78b0d9260f094d0e5b54b1527802f85b89102"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMTY1Ng==", "bodyText": "Hmmm, this is a bit fragile, as it implicitly assumes futures are completed from the task thread? Maybe add a checkState(...) asserting a thread to document this assumption?", "url": "https://github.com/apache/flink/pull/11687#discussion_r422021656", "createdAt": "2020-05-08T08:39:56Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -477,14 +477,18 @@ protected void beforeInvoke() throws Exception {\n \t\t\t// output can request more floating buffers from global firstly.\n \t\t\tInputGate[] inputGates = getEnvironment().getAllInputGates();\n \t\t\tif (inputGates != null) {\n-\t\t\t\tfor (InputGate inputGate : inputGates) {\n-\t\t\t\t\tinputGate.readRecoveredState(channelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n+\t\t\t\tCompletableFuture[] futures = new CompletableFuture[inputGates.length];\n+\t\t\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\t\t\tfutures[i] = inputGates[i].readRecoveredState(\n+\t\t\t\t\t\tchannelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n \t\t\t\t}\n \n-\t\t\t\t// Note that we must request partition after all the single gate finishes recovery.\n-\t\t\t\tfor (InputGate inputGate : inputGates) {\n-\t\t\t\t\tinputGate.requestPartitions(channelIOExecutor);\n-\t\t\t\t}\n+\t\t\t\t// Note that we must request partition after all the single gates finished recovery.\n+\t\t\t\tCompletableFuture.allOf(futures).thenRun(ThrowingRunnable.unchecked(() -> {\n+\t\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\t\tinputGate.requestPartitions();\n+\t\t\t\t\t}\n+\t\t\t\t}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed7f2261646bd55b43d94f9373b02f45bfc7d58d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ==", "bodyText": "Why atomic? It could easily be checked and set under synchronized (receivedBuffers) lock, simplifying threading model a bit and it would also avoid extra AtomicBoolean check on the hot path.", "url": "https://github.com/apache/flink/pull/11687#discussion_r422023059", "createdAt": "2020-05-08T08:43:03Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java", "diffHunk": "@@ -177,17 +178,18 @@ void sendTaskEvent(TaskEvent event) {\n \n \t@Override\n \tboolean isReleased() {\n-\t\treturn isReleased;\n+\t\treturn isReleased.get();\n \t}\n \n \tvoid releaseAllResources() throws IOException {\n-\t\tArrayDeque<Buffer> releasedBuffers = new ArrayDeque<>();\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treleasedBuffers.addAll(receivedBuffers);\n-\t\t\treceivedBuffers.clear();\n-\t\t\tisReleased = true;\n+\t\tif (isReleased.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad2be9470ed6e122bc0990e05ef0648fe4e0ce33"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNTI5Nw==", "bodyText": "Could you explain why do you think:\n\nalso not sensitive for batch code path.\n\n?", "url": "https://github.com/apache/flink/pull/11687#discussion_r422025297", "createdAt": "2020-05-08T08:47:56Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, "originalCommit": {"oid": "6ca8ec305a96d208919ab49244448de89bc7b679"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "committedDate": "2020-05-08T07:49:48Z", "message": "Supplement the new unit tests"}, "afterCommit": {"oid": "6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "committedDate": "2020-05-08T09:49:31Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "committedDate": "2020-05-08T09:49:31Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "2547c306759c683dae0eb54e364066c99d04fa5c", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2547c306759c683dae0eb54e364066c99d04fa5c", "committedDate": "2020-05-08T10:19:09Z", "message": "fixup comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTY5MDk4", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-408169098", "createdAt": "2020-05-08T11:16:25Z", "commit": {"oid": "3e6bf1161b89f0908b6161f13c4ed14d8585decd"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMToxNjoyNVrOGSiJGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMToxNzozOFrOGSiK1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NjkzOQ==", "bodyText": "nit: maybe add a small comment why is done like so here?", "url": "https://github.com/apache/flink/pull/11687#discussion_r422086939", "createdAt": "2020-05-08T11:16:25Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e6bf1161b89f0908b6161f13c4ed14d8585decd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NzM4MQ==", "bodyText": "nit: remove comment", "url": "https://github.com/apache/flink/pull/11687#discussion_r422087381", "createdAt": "2020-05-08T11:17:38Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java", "diffHunk": "@@ -190,6 +190,7 @@ private InputChannel createInputChannel(\n \t\t\t\t\tpartitionRequestMaxBackoff,\n \t\t\t\t\tmetrics);\n \t\t\t},\n+\t\t\t// TODO: can we sometimes call createKnownInputChannel?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e6bf1161b89f0908b6161f13c4ed14d8585decd"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54cceb0663f1a19f43ea8844b2a537872052b0ac", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/54cceb0663f1a19f43ea8844b2a537872052b0ac", "committedDate": "2020-05-08T10:46:42Z", "message": "fixup to assign exclusive buffers for RemoteRecoveredInputChannel"}, "afterCommit": {"oid": "0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "committedDate": "2020-05-09T03:00:24Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "committedDate": "2020-05-09T03:00:24Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "committedDate": "2020-05-09T03:01:21Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "committedDate": "2020-05-09T03:01:21Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "58157b4250ed6a6467202b712b0514a08b41c355", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/58157b4250ed6a6467202b712b0514a08b41c355", "committedDate": "2020-05-09T07:33:34Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58157b4250ed6a6467202b712b0514a08b41c355", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/58157b4250ed6a6467202b712b0514a08b41c355", "committedDate": "2020-05-09T07:33:34Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "ca92d5c0da54186ff37f68ac348e528bbb7f133a", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/ca92d5c0da54186ff37f68ac348e528bbb7f133a", "committedDate": "2020-05-10T13:46:29Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eee9d27ce9ffad0ec71351817d7c6db6e4be36fa", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/eee9d27ce9ffad0ec71351817d7c6db6e4be36fa", "committedDate": "2020-05-11T05:51:00Z", "message": "[hotfix][network] Fix useless backlog value in BufferAndAvailability returned by RemoteInputChannel#getNextBuffer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "955ab36f2ab996f8fdce0c2beaf7eb54af8b4df0", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/955ab36f2ab996f8fdce0c2beaf7eb54af8b4df0", "committedDate": "2020-05-11T05:51:00Z", "message": "[hotfix][network] Extract a general buffer manager for future reuse by recovered input channel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eabeaa27277d8bca2208c2240ee26207c5121d0d", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/eabeaa27277d8bca2208c2240ee26207c5121d0d", "committedDate": "2020-05-11T05:51:00Z", "message": "[hotfix][network] Maintain MemorySegmentProvider from InputChannel to SingleInputGate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90fdb11467d11b3b343e4e0ee2341c58ff4e71f", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/a90fdb11467d11b3b343e4e0ee2341c58ff4e71f", "committedDate": "2020-05-11T05:51:00Z", "message": "[hotfix][tests] Refactor unit tests in RemoteInputChannelTest to avoid mock way"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ca92d5c0da54186ff37f68ac348e528bbb7f133a", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/ca92d5c0da54186ff37f68ac348e528bbb7f133a", "committedDate": "2020-05-10T13:46:29Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "76e38d2b20304cf1e3256763110749a4b0cbf4f3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/76e38d2b20304cf1e3256763110749a4b0cbf4f3", "committedDate": "2020-05-11T06:42:49Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4302180858352cd4fce0668615483a33d2f8e98e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4302180858352cd4fce0668615483a33d2f8e98e", "committedDate": "2020-05-12T02:58:30Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76e38d2b20304cf1e3256763110749a4b0cbf4f3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/76e38d2b20304cf1e3256763110749a4b0cbf4f3", "committedDate": "2020-05-11T06:42:49Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}, "afterCommit": {"oid": "4302180858352cd4fce0668615483a33d2f8e98e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4302180858352cd4fce0668615483a33d2f8e98e", "committedDate": "2020-05-12T02:58:30Z", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NzU0NTU5", "url": "https://github.com/apache/flink/pull/11687#pullrequestreview-409754559", "createdAt": "2020-05-12T07:06:51Z", "commit": {"oid": "4302180858352cd4fce0668615483a33d2f8e98e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzowNjo1MVrOGT43HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzowNjo1MVrOGT43HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzc0MA==", "bodyText": "In the offline discussion about this deadlock, I meant to have !configuration.isCheckpointingEnabled() check here for now. That would solve the deadlock with input selection, while preserving functionality to disable/enable unaligned checkpoints.", "url": "https://github.com/apache/flink/pull/11687#discussion_r423507740", "createdAt": "2020-05-12T07:06:51Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -458,17 +466,50 @@ protected void beforeInvoke() throws Exception {\n \t\t\t// registers a timer, that fires before the open() is called.\n \t\t\toperatorChain.initializeStateAndOpenOperators(createStreamTaskStateInitializer());\n \n-\t\t\tResultPartitionWriter[] writers = getEnvironment().getAllWriters();\n-\t\t\tif (writers != null) {\n-\t\t\t\tfor (ResultPartitionWriter writer : writers) {\n-\t\t\t\t\twriter.readRecoveredState(getEnvironment().getTaskStateManager().getChannelStateReader());\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\treadRecoveredChannelState();\n \t\t});\n \n \t\tisRunning = true;\n \t}\n \n+\tprivate void readRecoveredChannelState() throws IOException, InterruptedException {\n+\t\t//TODO we will support channel state recovery even if the current setting is not unaligned checkpoint.\n+\t\tif (!configuration.isUnalignedCheckpointsEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4302180858352cd4fce0668615483a33d2f8e98e"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2019, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}