{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzOTU3NjUz", "number": 13499, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDoxMjozNlrOEoGWOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMDo0MjowNFrOEo-QGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDgyNDg4OnYy", "diffSide": "LEFT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDoxMjozNlrOHY_p8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoxNjo1M1rOHZeGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk3MDgwMA==", "bodyText": "Have you checked if the BufferPoolOwner is not part of our shuffle service API? Maybe there can be some 3rd party shuffle services using it?\n@zhijiangW seemed to be fine with removing it in the ticket, so I guess that's not an issue (he was involved in the plugable shuffle service story).", "url": "https://github.com/apache/flink/pull/13499#discussion_r495970800", "createdAt": "2020-09-28T14:12:36Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java", "diffHunk": "@@ -48,8 +48,6 @@\n \t * \t\tminimum number of network buffers in this pool\n \t * @param maxUsedBuffers\n \t * \t\tmaximum number of network buffers this pool offers\n-\t * @param bufferPoolOwner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68b0c710d4850f79920a584097c0218a1ace6ca8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ2OTU1NA==", "bodyText": "I just looked into the respective package and nothing buffer related is directly exposed in the API.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496469554", "createdAt": "2020-09-29T07:16:53Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java", "diffHunk": "@@ -48,8 +48,6 @@\n \t * \t\tminimum number of network buffers in this pool\n \t * @param maxUsedBuffers\n \t * \t\tmaximum number of network buffers this pool offers\n-\t * @param bufferPoolOwner", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk3MDgwMA=="}, "originalCommit": {"oid": "68b0c710d4850f79920a584097c0218a1ace6ca8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDk2ODYxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDo0MzoxNVrOHZBBPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTozNjo1MlrOHZ-RXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MzE0OQ==", "bodyText": "What's the purpose of this change? Is it actually working? What if getInputOutputJointFuture returns completed future, but it become unavailable during the input recovery?\nAlso, it's missing a test coverage.", "url": "https://github.com/apache/flink/pull/13499#discussion_r495993149", "createdAt": "2020-09-28T14:43:15Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -518,6 +518,11 @@ private void readRecoveredChannelState() throws IOException, InterruptedExceptio\n \t\t\t\t\t\t\t\"Cannot restore state to a non-checkpointable partition type: \" + writer);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (!recordWriter.isAvailable()) {\n+\t\t\t\tMailboxDefaultAction.Suspension suspendedDefaultAction = mailboxProcessor.suspendDefaultAction();\n+\t\t\t\tgetInputOutputJointFuture(InputStatus.NOTHING_AVAILABLE).thenRun(suspendedDefaultAction::resume);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a59d85b1e23a1c3c904c36c63f6dddae8ccc691c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3NTA2OA==", "bodyText": "I didn't manage to create a unit test, so I will probably add an ITCase. I'm extending commit message to state \"Currently, task thread blocks if all output buffers are taken during recovery: The default action is only suspended after calling StreamTask#processInput once, which will block as soon as one element is emitted. With this fix, the task thread suspends input processing if all output buffers are taken during recovery.\"\n\nWhat if getInputOutputJointFuture returns completed future, but it become unavailable during the input recovery?\n\nThis is the current behavior: input processing is enabled by default. What happens is that the first call to #processInput blocks and sets the future correctly as soon as one output buffer has been processed. Note that the input availability should not be set at this point. It may only happen when the first input is recovered.\n\nIs it actually working?\n\nYes, but I can only merge the corresponding test after we allow concurrent checkpoints or else we run into live locks: Recovery of input channels on a non-rescaling case can only happen if #processInput is called once because of EndOfChannelStateEvent being an extra buffer that is only polled when more input channels are available.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496475068", "createdAt": "2020-09-29T07:26:50Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -518,6 +518,11 @@ private void readRecoveredChannelState() throws IOException, InterruptedExceptio\n \t\t\t\t\t\t\t\"Cannot restore state to a non-checkpointable partition type: \" + writer);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (!recordWriter.isAvailable()) {\n+\t\t\t\tMailboxDefaultAction.Suspension suspendedDefaultAction = mailboxProcessor.suspendDefaultAction();\n+\t\t\t\tgetInputOutputJointFuture(InputStatus.NOTHING_AVAILABLE).thenRun(suspendedDefaultAction::resume);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MzE0OQ=="}, "originalCommit": {"oid": "a59d85b1e23a1c3c904c36c63f6dddae8ccc691c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5NjcwMg==", "bodyText": "I dropped the commit for now, as it would only be relevant for fully blocked output (input selection) or checkpointing during recovery.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496996702", "createdAt": "2020-09-29T19:36:52Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -518,6 +518,11 @@ private void readRecoveredChannelState() throws IOException, InterruptedExceptio\n \t\t\t\t\t\t\t\"Cannot restore state to a non-checkpointable partition type: \" + writer);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (!recordWriter.isAvailable()) {\n+\t\t\t\tMailboxDefaultAction.Suspension suspendedDefaultAction = mailboxProcessor.suspendDefaultAction();\n+\t\t\t\tgetInputOutputJointFuture(InputStatus.NOTHING_AVAILABLE).thenRun(suspendedDefaultAction::resume);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MzE0OQ=="}, "originalCommit": {"oid": "a59d85b1e23a1c3c904c36c63f6dddae8ccc691c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTA0NjU2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDo1NjowOFrOHZBvsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzo0NDowMVrOHZfB2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNTA0Mw==", "bodyText": "why assert and not checkState()?", "url": "https://github.com/apache/flink/pull/13499#discussion_r496005043", "createdAt": "2020-09-28T14:56:08Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -190,6 +205,12 @@\n \t\t\tsubpartitionBufferRecyclers[i] = new SubpartitionBufferRecycler(i, this);\n \t\t}\n \t\tthis.maxBuffersPerChannel = maxBuffersPerChannel;\n+\n+\t\tif (checkAvailability()) {\n+\t\t\tavailabilityHelper.resetAvailable();\n+\t\t}\n+\n+\t\tassert hasConsistentAvailability();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3NjgwNg==", "bodyText": "Similar to NetworkBufferPool#redistributeBuffers these assertions are just to ease debugging during test execution. The few cycles needed to conduct the test are skipped on production. If you rather like to see them being executed for every run, we probably need to align it also in NetworkBufferPool to keep it consistent.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496476806", "createdAt": "2020-09-29T07:29:45Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -190,6 +205,12 @@\n \t\t\tsubpartitionBufferRecyclers[i] = new SubpartitionBufferRecycler(i, this);\n \t\t}\n \t\tthis.maxBuffersPerChannel = maxBuffersPerChannel;\n+\n+\t\tif (checkAvailability()) {\n+\t\t\tavailabilityHelper.resetAvailable();\n+\t\t}\n+\n+\t\tassert hasConsistentAvailability();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNTA0Mw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4NDgyNA==", "bodyText": "I mean I do not see a performance benefit of avoiding a couple of checkStates on per buffer path, while it could provide some help, if bug will occur on some production setup only.\nIn per record paths, I guess I would agree more with asserts", "url": "https://github.com/apache/flink/pull/13499#discussion_r496484824", "createdAt": "2020-09-29T07:44:01Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -190,6 +205,12 @@\n \t\t\tsubpartitionBufferRecyclers[i] = new SubpartitionBufferRecycler(i, this);\n \t\t}\n \t\tthis.maxBuffersPerChannel = maxBuffersPerChannel;\n+\n+\t\tif (checkAvailability()) {\n+\t\t\tavailabilityHelper.resetAvailable();\n+\t\t}\n+\n+\t\tassert hasConsistentAvailability();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNTA0Mw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTI1NTY3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToyMzo1N1rOHZDtnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzozMDoxNlrOHZej0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAzNzI3Ng==", "bodyText": "doing this under the lock would look more consistent? As it is, can not it yield false results? All of the modifications to the availabilityHelper  are happening under the availableMemorySegments lock , so after moving there it should be perfectly accurate.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496037276", "createdAt": "2020-09-28T15:23:57Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3NzEzOQ==", "bodyText": "I was trying to optimize, but I guess it's premature. Segment reallocation is rather rare anyways afaik.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496477139", "createdAt": "2020-09-29T07:30:16Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAzNzI3Ng=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTI2MzEwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToyNTowOVrOHZDyCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzozMDo1N1rOHZelQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAzODQwOA==", "bodyText": "does it need to be volatile if we already have @GuardedBy(\"availableMemorySegments\")? Adding another point of synchronisation makes it more difficult to reason about the concurrency model.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496038408", "createdAt": "2020-09-28T15:25:09Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -92,16 +102,21 @@\n \n \tprivate final int maxBuffersPerChannel;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate final int[] subpartitionBuffersCount;\n \n \tprivate final BufferRecycler[] subpartitionBufferRecyclers;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate int unavailableSubpartitionsCount = 0;\n \n \tprivate boolean isDestroyed;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n \n+\tprivate volatile boolean eagerlyRequesting;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3NzUwNg==", "bodyText": "I'll try to get rid of it. Probably also premature optimization (cheap read-lock).", "url": "https://github.com/apache/flink/pull/13499#discussion_r496477506", "createdAt": "2020-09-29T07:30:57Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -92,16 +102,21 @@\n \n \tprivate final int maxBuffersPerChannel;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate final int[] subpartitionBuffersCount;\n \n \tprivate final BufferRecycler[] subpartitionBufferRecyclers;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate int unavailableSubpartitionsCount = 0;\n \n \tprivate boolean isDestroyed;\n \n+\t@GuardedBy(\"availableMemorySegments\")\n \tprivate final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n \n+\tprivate volatile boolean eagerlyRequesting;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAzODQwOA=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTI4MzU1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNToyOTo0N1rOHZD_Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzo0NTo0M1rOHZfF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA0MTgxNQ==", "bodyText": "nit: for (future) consistency and self documenting code, maybe extract this condition to a private method isRequestedSizeReached()?", "url": "https://github.com/apache/flink/pull/13499#discussion_r496041815", "createdAt": "2020-09-28T15:29:47Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3ODI1NA==", "bodyText": "I had various helper methods in-between and in the end inlined them all as it didn't make them much easier to read imho. But I'll try your suggestion; the semantics is easy enough that you do not need to look into the implementation.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496478254", "createdAt": "2020-09-29T07:32:21Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA0MTgxNQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4NTg2NA==", "bodyText": "It's not only that, but also the check is appearing in multiple places. If it changes in one place, it should also change in the others.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496485864", "createdAt": "2020-09-29T07:45:43Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA0MTgxNQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQyMDM4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowMToxNlrOHZFTpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToyOTo1NlrOHZ98-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2MzM5OQ==", "bodyText": "I guess it's not \"eagerly\" after all? Eagerly would mean to me something like request them upon construction, or something like that?\nHere you mean, request the buffers first, before making LocalBufferPool available?", "url": "https://github.com/apache/flink/pull/13499#discussion_r496063399", "createdAt": "2020-09-28T16:01:16Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3OTIxNQ==", "bodyText": "No, eagerly means that we poll the new segment as soon as we run out of local segments. In the old way, we would only poll lazily when a new local segment is requested. Further, this method even polls the segment as soon as it is returned to the network buffer from a different pool (through avail future).", "url": "https://github.com/apache/flink/pull/13499#discussion_r496479215", "createdAt": "2020-09-29T07:34:01Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2MzM5OQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5MTQ4Mw==", "bodyText": "I actually renamed to requestMemorySegmentFromGlobalWhenAvailable.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496991483", "createdAt": "2020-09-29T19:29:56Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2MzM5OQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQyNDk0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowMjoyM1rOHZFWfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwOToyNDo0MFrOHZkR8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NDEyNw==", "bodyText": "does it mean we can keep requesting segments despite reaching per sub-partition limit? Is it a pre-existing behaviour? (if so, we could leave it as a future improvement)", "url": "https://github.com/apache/flink/pull/13499#discussion_r496064127", "createdAt": "2020-09-28T16:02:23Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// fetch a segment from global pool\n+\t\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t\t} else {\n+\t\t\t\t\t// segment probably taken by other pool, so retry later\n+\t\t\t\t\teagerlyRequestMemorySegmentFromGlobal();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmayNotifyAvailable(toNotify);\n+\t\t});\n+\t}\n \n+\tprivate boolean checkAvailability() {\n+\t\tif (!availableMemorySegments.isEmpty()) {\n+\t\t\treturn unavailableSubpartitionsCount == 0;\n+\t\t}\n \t\tif (numberOfRequestedMemorySegments < currentPoolSize) {\n-\t\t\tfinal MemorySegment segment = networkBufferPool.requestMemorySegment();\n-\t\t\tif (segment != null) {\n-\t\t\t\tnumberOfRequestedMemorySegments++;\n-\t\t\t\treturn segment;\n+\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\treturn unavailableSubpartitionsCount == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4MjA3NA==", "bodyText": "Yes.\nI initially didn't poll it and it would only affect one more test case, however, I decided against it. First of all, it's much easier to reason without having to worry about unavailableSubpartitionsCount: If availableSegments are empty and the pool is allowed to take more buffers, it takes one.\nIt also helps to reach the equilibrium much quicker: every local pool has the segments it is assigned.\nThe clear downside is that if two local buffer pools are competing and one of them reached the quota, the wrong one polls first, keeping both unavailable. I favored simplicity and quicker equilibrium over this edge case, but can also revert to the earlier version if you think that the edge case is very common.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496482074", "createdAt": "2020-09-29T07:39:14Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// fetch a segment from global pool\n+\t\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t\t} else {\n+\t\t\t\t\t// segment probably taken by other pool, so retry later\n+\t\t\t\t\teagerlyRequestMemorySegmentFromGlobal();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmayNotifyAvailable(toNotify);\n+\t\t});\n+\t}\n \n+\tprivate boolean checkAvailability() {\n+\t\tif (!availableMemorySegments.isEmpty()) {\n+\t\t\treturn unavailableSubpartitionsCount == 0;\n+\t\t}\n \t\tif (numberOfRequestedMemorySegments < currentPoolSize) {\n-\t\t\tfinal MemorySegment segment = networkBufferPool.requestMemorySegment();\n-\t\t\tif (segment != null) {\n-\t\t\t\tnumberOfRequestedMemorySegments++;\n-\t\t\t\treturn segment;\n+\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\treturn unavailableSubpartitionsCount == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NDEyNw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3MDg2Nw==", "bodyText": "I don't think this is a big issue. Just wanted to make sure it's not a regression (that would be an issue)", "url": "https://github.com/apache/flink/pull/13499#discussion_r496570867", "createdAt": "2020-09-29T09:24:40Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n-\t\tif (isDestroyed) {\n-\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n+\t/**\n+\t * Tries to obtain a buffer from global pool as soon as one pool is available. Note that multiple\n+\t * {@link LocalBufferPool}s might wait on the future of the global pool, hence this method double-check if a new\n+\t * buffer is really needed at the time it becomes available.\n+\t */\n+\tprivate void eagerlyRequestMemorySegmentFromGlobal() {\n+\t\tif (eagerlyRequesting) {\n+\t\t\treturn;\n \t\t}\n+\t\teagerlyRequesting = true;\n+\t\tnetworkBufferPool.getAvailableFuture().thenRun(() -> {\n+\t\t\teagerlyRequesting = false;\n+\t\t\tif (availabilityHelper.isAvailable()) {\n+\t\t\t\t// there is currently no benefit for this pool to obtain buffer from global; give other pools precedent\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCompletableFuture<?> toNotify = null;\n+\t\t\tsynchronized (availableMemorySegments) {\n+\t\t\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// fetch a segment from global pool\n+\t\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t\t} else {\n+\t\t\t\t\t// segment probably taken by other pool, so retry later\n+\t\t\t\t\teagerlyRequestMemorySegmentFromGlobal();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmayNotifyAvailable(toNotify);\n+\t\t});\n+\t}\n \n+\tprivate boolean checkAvailability() {\n+\t\tif (!availableMemorySegments.isEmpty()) {\n+\t\t\treturn unavailableSubpartitionsCount == 0;\n+\t\t}\n \t\tif (numberOfRequestedMemorySegments < currentPoolSize) {\n-\t\t\tfinal MemorySegment segment = networkBufferPool.requestMemorySegment();\n-\t\t\tif (segment != null) {\n-\t\t\t\tnumberOfRequestedMemorySegments++;\n-\t\t\t\treturn segment;\n+\t\t\tif (requestMemorySegmentFromGlobal()) {\n+\t\t\t\treturn unavailableSubpartitionsCount == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NDEyNw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ0MDk0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNjoyNlrOHZFgbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwOToyNTozM1rOHZkUhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjY2OQ==", "bodyText": "subpartitionBuffersCount[targetChannel]++ vs ++subpartitionBuffersCount[targetChannel], isn't it changing the semantic a bit?", "url": "https://github.com/apache/flink/pull/13499#discussion_r496066669", "createdAt": "2020-09-28T16:06:26Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -292,27 +313,34 @@ private MemorySegment requestMemorySegmentBlocking(int targetChannel) throws Int\n \n \t@Nullable\n \tprivate MemorySegment requestMemorySegment(int targetChannel) {\n-\t\tMemorySegment segment = null;\n+\t\tMemorySegment segment;\n \t\tsynchronized (availableMemorySegments) {\n-\t\t\treturnExcessMemorySegments();\n-\n-\t\t\tif (availableMemorySegments.isEmpty()) {\n-\t\t\t\tsegment = requestMemorySegmentFromGlobal();\n+\t\t\tif (isDestroyed) {\n+\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n \t\t\t}\n-\t\t\t// segment may have been released by buffer pool owner\n-\t\t\tif (segment == null) {\n-\t\t\t\tsegment = availableMemorySegments.poll();\n+\n+\t\t\t// target channel over quota; do not return a segment\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL && subpartitionBuffersCount[targetChannel] >= maxBuffersPerChannel) {\n+\t\t\t\treturn null;\n \t\t\t}\n+\n+\t\t\tsegment = availableMemorySegments.poll();\n+\n \t\t\tif (segment == null) {\n-\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tif (segment != null && targetChannel != UNKNOWN_CHANNEL) {\n-\t\t\t\tif (subpartitionBuffersCount[targetChannel]++ == maxBuffersPerChannel) {\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL) {\n+\t\t\t\tif (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4MzMyNQ==", "bodyText": "Yes, I should probably pull it out. Imho it was wrong before. For me valid subpartitionBuffersCounts are [0, maxBuffersPerChannel], but it used to be [0, maxBuffersPerChannel + 1]. In the end, maxBuffersPerChannel is rather arbitrary, so it shouldn't have a any impact on production applications, but for me, it's also important to have a clear semantics.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496483325", "createdAt": "2020-09-29T07:41:18Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -292,27 +313,34 @@ private MemorySegment requestMemorySegmentBlocking(int targetChannel) throws Int\n \n \t@Nullable\n \tprivate MemorySegment requestMemorySegment(int targetChannel) {\n-\t\tMemorySegment segment = null;\n+\t\tMemorySegment segment;\n \t\tsynchronized (availableMemorySegments) {\n-\t\t\treturnExcessMemorySegments();\n-\n-\t\t\tif (availableMemorySegments.isEmpty()) {\n-\t\t\t\tsegment = requestMemorySegmentFromGlobal();\n+\t\t\tif (isDestroyed) {\n+\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n \t\t\t}\n-\t\t\t// segment may have been released by buffer pool owner\n-\t\t\tif (segment == null) {\n-\t\t\t\tsegment = availableMemorySegments.poll();\n+\n+\t\t\t// target channel over quota; do not return a segment\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL && subpartitionBuffersCount[targetChannel] >= maxBuffersPerChannel) {\n+\t\t\t\treturn null;\n \t\t\t}\n+\n+\t\t\tsegment = availableMemorySegments.poll();\n+\n \t\t\tif (segment == null) {\n-\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tif (segment != null && targetChannel != UNKNOWN_CHANNEL) {\n-\t\t\t\tif (subpartitionBuffersCount[targetChannel]++ == maxBuffersPerChannel) {\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL) {\n+\t\t\t\tif (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjY2OQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3MTUyNQ==", "bodyText": "Yes, it would be better to move it to a separate commit. I agree that [0, maxBuffersPerChannel] makes more sense.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496571525", "createdAt": "2020-09-29T09:25:33Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -292,27 +313,34 @@ private MemorySegment requestMemorySegmentBlocking(int targetChannel) throws Int\n \n \t@Nullable\n \tprivate MemorySegment requestMemorySegment(int targetChannel) {\n-\t\tMemorySegment segment = null;\n+\t\tMemorySegment segment;\n \t\tsynchronized (availableMemorySegments) {\n-\t\t\treturnExcessMemorySegments();\n-\n-\t\t\tif (availableMemorySegments.isEmpty()) {\n-\t\t\t\tsegment = requestMemorySegmentFromGlobal();\n+\t\t\tif (isDestroyed) {\n+\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n \t\t\t}\n-\t\t\t// segment may have been released by buffer pool owner\n-\t\t\tif (segment == null) {\n-\t\t\t\tsegment = availableMemorySegments.poll();\n+\n+\t\t\t// target channel over quota; do not return a segment\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL && subpartitionBuffersCount[targetChannel] >= maxBuffersPerChannel) {\n+\t\t\t\treturn null;\n \t\t\t}\n+\n+\t\t\tsegment = availableMemorySegments.poll();\n+\n \t\t\tif (segment == null) {\n-\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tif (segment != null && targetChannel != UNKNOWN_CHANNEL) {\n-\t\t\t\tif (subpartitionBuffersCount[targetChannel]++ == maxBuffersPerChannel) {\n+\t\t\tif (targetChannel != UNKNOWN_CHANNEL) {\n+\t\t\t\tif (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjY2OQ=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwODU4OTk0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwOToxNjoxM1rOHZj8VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMDozNjo1OVrOHaXf1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU2NTMzMw==", "bodyText": "maybe change it to while (numberOfRequestedMemorySegments < currentPoolSize) loop? (as a follow up commit?)", "url": "https://github.com/apache/flink/pull/13499#discussion_r496565333", "createdAt": "2020-09-29T09:16:13Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5OTU0Mg==", "bodyText": "Is your intent to reach equilibrium much quicker? If so, I like the idea. (If not, then I haven't understood)\nMy main concern is that it means that the first buffer pool would potentially take all available segments while the last buffer pool gets nothing although each of them could take some buffers. However, I must admit that I have not fully understood when excess buffers actually occur in reality. I'd assume that during start of an application all pools are created and exclusive segments are acquired more or less simultaneously and handed out a bit later to the writer/input channels, such that excess buffers are close to non-existant.", "url": "https://github.com/apache/flink/pull/13499#discussion_r496999542", "createdAt": "2020-09-29T19:42:15Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU2NTMzMw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMDAwNQ==", "bodyText": "As discussed offline, let's keep it as it is for now.", "url": "https://github.com/apache/flink/pull/13499#discussion_r497410005", "createdAt": "2020-09-30T10:36:59Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -322,23 +350,71 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tif (numberOfRequestedMemorySegments >= currentPoolSize) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU2NTMzMw=="}, "originalCommit": {"oid": "378555e68fc64c708f033109422f8701013fdaed"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzk3NDUzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMDozOToxMVrOHaXkQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTo0MjozN1rOHawYRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMTEzNw==", "bodyText": "Shouldn't this commit change some tests?", "url": "https://github.com/apache/flink/pull/13499#discussion_r497411137", "createdAt": "2020-09-30T10:39:11Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -296,6 +296,11 @@ private MemorySegment requestMemorySegment(int targetChannel) {\n \t\tsynchronized (availableMemorySegments) {\n \t\t\treturnExcessMemorySegments();\n \n+\t\t\t// target channel over quota; do not return a segment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db12e7ec1a83349104a4f6556096f9997c03805"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MTUyNg==", "bodyText": "Yes it changes LocalBufferPoolTest#testMaxBuffersPerChannelAndAvailability. Other test played nicely (only took buffer they should have taken).", "url": "https://github.com/apache/flink/pull/13499#discussion_r497481526", "createdAt": "2020-09-30T12:48:32Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -296,6 +296,11 @@ private MemorySegment requestMemorySegment(int targetChannel) {\n \t\tsynchronized (availableMemorySegments) {\n \t\t\treturnExcessMemorySegments();\n \n+\t\t\t// target channel over quota; do not return a segment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMTEzNw=="}, "originalCommit": {"oid": "0db12e7ec1a83349104a4f6556096f9997c03805"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNzY2OQ==", "bodyText": "Pulled out the test changes into this commit.", "url": "https://github.com/apache/flink/pull/13499#discussion_r497817669", "createdAt": "2020-09-30T21:42:37Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -296,6 +296,11 @@ private MemorySegment requestMemorySegment(int targetChannel) {\n \t\tsynchronized (availableMemorySegments) {\n \t\t\treturnExcessMemorySegments();\n \n+\t\t\t// target channel over quota; do not return a segment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMTEzNw=="}, "originalCommit": {"oid": "0db12e7ec1a83349104a4f6556096f9997c03805"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzk4NDI0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMDo0MjowNFrOHaXqTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo1MDo1OFrOHab9yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMjY4Ng==", "bodyText": "nit: there are still two places doing numberOfRequestedMemorySegments > currentPoolSize, but I guess they are off by one in the comparison and can not be easily migrated to isRequestedSizeReached()?", "url": "https://github.com/apache/flink/pull/13499#discussion_r497412686", "createdAt": "2020-09-30T10:42:04Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -327,23 +358,83 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tassert Thread.holdsLock(availableMemorySegments);\n+\n+\t\tif (isRequestedSizeReached()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate boolean isRequestedSizeReached() {\n+\t\treturn numberOfRequestedMemorySegments >= currentPoolSize;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df08363e00e50b79ff2492f344a4cef335699b17"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MzIwOA==", "bodyText": "I didn't find a good way, but extracted them into hasExcessBuffers for now.", "url": "https://github.com/apache/flink/pull/13499#discussion_r497483208", "createdAt": "2020-09-30T12:50:58Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java", "diffHunk": "@@ -327,23 +358,83 @@ private MemorySegment requestMemorySegment() {\n \t\treturn requestMemorySegment(UNKNOWN_CHANNEL);\n \t}\n \n-\t@Nullable\n-\tprivate MemorySegment requestMemorySegmentFromGlobal() {\n+\tprivate boolean requestMemorySegmentFromGlobal() {\n+\t\tassert Thread.holdsLock(availableMemorySegments);\n+\n+\t\tif (isRequestedSizeReached()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tMemorySegment segment = networkBufferPool.requestMemorySegment();\n+\t\tif (segment != null) {\n+\t\t\tavailableMemorySegments.add(segment);\n+\t\t\tnumberOfRequestedMemorySegments++;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate boolean isRequestedSizeReached() {\n+\t\treturn numberOfRequestedMemorySegments >= currentPoolSize;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMjY4Ng=="}, "originalCommit": {"oid": "df08363e00e50b79ff2492f344a4cef335699b17"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 195, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}