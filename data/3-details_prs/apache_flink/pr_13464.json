{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxODEyMjAz", "number": 13464, "title": "[FLINK-19307][coordination] Add ResourceTracker", "bodyText": "Adds the ResourceTracker one of the components of the new declarative slot manager.\nThe purpose of this tracker is to answer questions such as \"How many resources does this job have?\" or \"How many resources does job still need?\".\nTo that end the tracker will be informed by the slot manager whenever the JobMaster has updated its ResourceRequirements, a resource was acquired (==TaskExecutor confirmed slot allocation) or a resource was lost (==JobMaster released slot or TaskExecutor failed).\nThe default implementation is the DefaultResourceTracker which mostly delegates tracking work to the JobScopedResourceTracker.\nThis tracker tracks the requirements and acquired resources for a single job. It heavily relies on 2 new data-structures:\n\nResourceCounter: Essentially a wrapper around `Map<ResourceProfile, Integer>, tracking the number of instances of a particular resource profile. This structure is used for tracking the requirements for a job, and acquired resources that exceed the requirements. It ensures that the counts are always positive.\nBiDirectionalResourceToRequirementMapping: This structure tracks which resources are being used for which requirement, and which requirement is being (potentially partially) fulfilled by which resources. Essentially, this structure exists so that we can easily figure out which resources are no longer needed if requirements change, or inversely, which requirements require new slots if we lost one.", "createdAt": "2020-09-23T14:12:29Z", "url": "https://github.com/apache/flink/pull/13464", "merged": true, "mergeCommit": {"oid": "7f07b62723a1b49ab5403b3b2797cb87686fbbd6"}, "closed": true, "closedAt": "2020-10-06T14:12:27Z", "author": {"login": "zentol"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdL9Z3mAFqTQ5NTI1NDc0OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP5A3ZABqjM4NDU2NzcwMzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MjU0NzQ4", "url": "https://github.com/apache/flink/pull/13464#pullrequestreview-495254748", "createdAt": "2020-09-24T06:29:51Z", "commit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoyOTo1MVrOHXLggQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODoyMToxM1rOHXPLWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2Nzg0MQ==", "bodyText": "Not sure about returning ResourceCounter for these two methods.\n\nThis exposes the internal states of BiDirectionalResourceToRequirementMapping in a writable way. Increasing/Decreasing to the returned counters may lead to inconsistent internal states.\nIt is implicit that the returned counters are sometimes immutable (EMPTY).", "url": "https://github.com/apache/flink/pull/13464#discussion_r494067841", "createdAt": "2020-09-24T06:29:51Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/BiDirectionalResourceToRequirementMapping.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A bi-directional mapping between required and acquired resources.\n+ */\n+class BiDirectionalResourceToRequirementMapping {\n+\tprivate final Map<ResourceProfile, ResourceCounter> requirementToFulfillingResources = new HashMap<>();\n+\tprivate final Map<ResourceProfile, ResourceCounter> resourceToFulfilledRequirement = new HashMap<>();\n+\n+\tpublic void incrementCount(ResourceProfile requirement, ResourceProfile resource, int increment) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tinternalIncrementCount(requirementToFulfillingResources, requirement, resource, increment);\n+\t\tinternalIncrementCount(resourceToFulfilledRequirement, resource, requirement, increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile requirement, ResourceProfile resource, int decrement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tinternalDecrementCount(requirementToFulfillingResources, requirement, resource, decrement);\n+\t\tinternalDecrementCount(resourceToFulfilledRequirement, resource, requirement, decrement);\n+\t}\n+\n+\tprivate static void internalIncrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int increment) {\n+\t\tprimaryMap\n+\t\t\t.computeIfAbsent(primaryKey, ignored -> new ResourceCounter())\n+\t\t\t.incrementCount(secondaryKey, increment);\n+\t}\n+\n+\tprivate static void internalDecrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int decrement) {\n+\t\tprimaryMap.computeIfPresent(\n+\t\t\tprimaryKey,\n+\t\t\t(resourceProfile, resourceCounter) -> {\n+\t\t\t\tresourceCounter.decrementCount(secondaryKey, decrement);\n+\t\t\t\treturn resourceCounter.isEmpty() ? null : resourceCounter;\n+\t\t\t});\n+\t}\n+\n+\tpublic ResourceCounter getFulfillingResourcesFor(ResourceProfile requirement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\treturn requirementToFulfillingResources.getOrDefault(requirement, ResourceCounter.EMPTY);\n+\t}\n+\n+\tpublic ResourceCounter getFulfilledRequirementsBy(ResourceProfile resource) {\n+\t\tPreconditions.checkNotNull(resource);\n+\t\treturn resourceToFulfilledRequirement.getOrDefault(resource, ResourceCounter.EMPTY);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3MDY1OQ==", "bodyText": "Attempts for decreasing on non-exist profiles will be ignored silently. Is this intended? Would it be better to fail explicitly on such attempts?\nIt's a bit counterintuitive that we fail on currentCount - decrement being negative, but not on non-exist profiles (equivalent to currentCount being zero).", "url": "https://github.com/apache/flink/pull/13464#discussion_r494070659", "createdAt": "2020-09-24T06:36:47Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/slots/ResourceCounter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.slots;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A counter for resources.\n+ *\n+ * <p>ResourceCounter contains a set of {@link ResourceProfile ResourceProfiles} and their\n+ * associated counts. The counts are always positive (> 0).\n+ */\n+public class ResourceCounter {\n+\tpublic static final ResourceCounter EMPTY = new ResourceCounter(Collections.emptyMap());\n+\n+\tprivate final Map<ResourceProfile, Integer> resources;\n+\n+\tpublic ResourceCounter() {\n+\t\tthis(new HashMap<>());\n+\t}\n+\n+\tprivate ResourceCounter(Map<ResourceProfile, Integer> resources) {\n+\t\tthis.resources = resources;\n+\t}\n+\n+\tpublic void incrementCount(ResourceProfile profile, int increment) {\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tresources.compute(profile, (ignored, currentCount) -> currentCount == null ? increment : currentCount + increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile profile, int decrement) {\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tresources.computeIfPresent(profile, (ignored, currentCount) -> currentCount == decrement ? null : guardAgainstNegativeCount(currentCount - decrement));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3NjEzMw==", "bodyText": "By using computeIfPresent, we are ignoring attempts for decreasing on non-exist  primary keys silently.\nWould it be better to fail explicitly on such attempts?", "url": "https://github.com/apache/flink/pull/13464#discussion_r494076133", "createdAt": "2020-09-24T06:48:52Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/BiDirectionalResourceToRequirementMapping.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A bi-directional mapping between required and acquired resources.\n+ */\n+class BiDirectionalResourceToRequirementMapping {\n+\tprivate final Map<ResourceProfile, ResourceCounter> requirementToFulfillingResources = new HashMap<>();\n+\tprivate final Map<ResourceProfile, ResourceCounter> resourceToFulfilledRequirement = new HashMap<>();\n+\n+\tpublic void incrementCount(ResourceProfile requirement, ResourceProfile resource, int increment) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tinternalIncrementCount(requirementToFulfillingResources, requirement, resource, increment);\n+\t\tinternalIncrementCount(resourceToFulfilledRequirement, resource, requirement, increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile requirement, ResourceProfile resource, int decrement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tinternalDecrementCount(requirementToFulfillingResources, requirement, resource, decrement);\n+\t\tinternalDecrementCount(resourceToFulfilledRequirement, resource, requirement, decrement);\n+\t}\n+\n+\tprivate static void internalIncrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int increment) {\n+\t\tprimaryMap\n+\t\t\t.computeIfAbsent(primaryKey, ignored -> new ResourceCounter())\n+\t\t\t.incrementCount(secondaryKey, increment);\n+\t}\n+\n+\tprivate static void internalDecrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int decrement) {\n+\t\tprimaryMap.computeIfPresent(\n+\t\t\tprimaryKey,\n+\t\t\t(resourceProfile, resourceCounter) -> {\n+\t\t\t\tresourceCounter.decrementCount(secondaryKey, decrement);\n+\t\t\t\treturn resourceCounter.isEmpty() ? null : resourceCounter;\n+\t\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3ODg0NQ==", "bodyText": "IIUC, the tracker is not for only A job?", "url": "https://github.com/apache/flink/pull/13464#discussion_r494078845", "createdAt": "2020-09-24T06:54:47Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * A tracker for required/acquired resources of a job.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDExNDcyNw==", "bodyText": "Actually, this could be way more expensive than copying the map twice. For each map entry, we could write the map as many times as the value of the entry.\nAnd the logs in notifyAcquiredResource could be misleading. It would look like the job acquired some new resources when calling on the already acquired resources.", "url": "https://github.com/apache/flink/pull/13464#discussion_r494114727", "createdAt": "2020-09-24T07:59:25Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getFulfilledRequirementsBy(resourceProfile).getResourceProfiles();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources, otherwise use any\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getRequiredResources() {\n+\t\tfinal Collection<ResourceRequirement> requiredResources = new ArrayList<>();\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirement : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirement.getKey();\n+\n+\t\t\tint numRequiredResources = requirement.getValue();\n+\t\t\tint numAcquiredResources = resourceToRequirementMapping.getNumFulfillingResources(requirementProfile);\n+\n+\t\t\tif (numAcquiredResources < numRequiredResources) {\n+\t\t\t\trequiredResources.add(ResourceRequirement.create(requirementProfile, numRequiredResources - numAcquiredResources));\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn requiredResources;\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getAcquiredResources() {\n+\t\tfinal Set<ResourceProfile> knownResourceProfiles = new HashSet<>();\n+\t\tknownResourceProfiles.addAll(resourceToRequirementMapping.getAllResourceProfiles());\n+\t\tknownResourceProfiles.addAll(excessResources.getResourceProfiles());\n+\n+\t\tfinal List<ResourceRequirement> acquiredResources = new ArrayList<>();\n+\t\tfor (ResourceProfile knownResourceProfile : knownResourceProfiles) {\n+\t\t\tint numTotalAcquiredResources = resourceToRequirementMapping.getNumFulfilledRequirements(knownResourceProfile) + excessResources.getResourceCount(knownResourceProfile);\n+\t\t\tResourceRequirement resourceRequirement = ResourceRequirement.create(knownResourceProfile, numTotalAcquiredResources);\n+\t\t\tacquiredResources.add(resourceRequirement);\n+\t\t}\n+\n+\t\treturn acquiredResources;\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn resourceRequirements.isEmpty() && excessResources.isEmpty();\n+\t}\n+\n+\tprivate void findExcessSlots() {\n+\t\tfinal Collection<ExcessResource> excessResources = new ArrayList<>();\n+\n+\t\tfor (ResourceProfile requirementProfile : resourceToRequirementMapping.getAllRequirementProfiles()) {\n+\t\t\tint numTotalRequiredResources = resourceRequirements.getResourceCount(requirementProfile);\n+\t\t\tint numTotalAcquiredResources = resourceToRequirementMapping.getNumFulfillingResources(requirementProfile);\n+\n+\t\t\tif (numTotalAcquiredResources > numTotalRequiredResources) {\n+\t\t\t\tint numExcessResources = numTotalAcquiredResources - numTotalRequiredResources;\n+\n+\t\t\t\tfor (Map.Entry<ResourceProfile, Integer> acquiredResource : resourceToRequirementMapping.getFulfillingResourcesFor(requirementProfile).getResourceProfilesWithCount()) {\n+\t\t\t\t\tResourceProfile acquiredResourceProfile = acquiredResource.getKey();\n+\t\t\t\t\tint numAcquiredResources = acquiredResource.getValue();\n+\n+\t\t\t\t\tif (numAcquiredResources <= numExcessResources) {\n+\t\t\t\t\t\texcessResources.add(new ExcessResource(requirementProfile, acquiredResourceProfile, numAcquiredResources));\n+\n+\t\t\t\t\t\tnumExcessResources -= numAcquiredResources;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\texcessResources.add(new ExcessResource(requirementProfile, acquiredResourceProfile, numExcessResources));\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tLOG.debug(\"Detected excess resources for job {}: {}\", jobId, excessResources);\n+\t\tfor (ExcessResource excessResource : excessResources) {\n+\t\t\tresourceToRequirementMapping.decrementCount(excessResource.requirementProfile, excessResource.resourceProfile, excessResource.numExcessResources);\n+\t\t\tthis.excessResources.incrementCount(excessResource.resourceProfile, excessResource.numExcessResources);\n+\t\t}\n+\t}\n+\n+\tprivate void tryAssigningExcessSlots() {\n+\t\tif (LOG.isTraceEnabled()) {\n+\t\t\tLOG.trace(\"There are {} excess resources for job {} before re-assignment.\", jobId, excessResources.getResourceCount());\n+\t\t}\n+\t\t// this is a quick-and-dirty solution; in the worse case we copy the excessResources map twice", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzk2MA==", "bodyText": "I'm a bit confused with this comment.\nIIUC, we are actually using any requirement (the first encountered) that has too many resources. There's no \"otherwise\".", "url": "https://github.com/apache/flink/pull/13464#discussion_r494127960", "createdAt": "2020-09-24T08:21:13Z", "author": {"login": "xintongsong"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getFulfilledRequirementsBy(resourceProfile).getResourceProfiles();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources, otherwise use any", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzE1Mzkx", "url": "https://github.com/apache/flink/pull/13464#pullrequestreview-500315391", "createdAt": "2020-10-01T12:55:04Z", "commit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMjo1NTowNFrOHbJBHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0NjowN1rOHb0g7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMTM0Mg==", "bodyText": "Should we give this method a clearer name: getMissingResources, getOutstandingResources, or so?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498221342", "createdAt": "2020-10-01T12:55:04Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getRequiredResources() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNjU5Mg==", "bodyText": "Why are these calls necessary?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498236592", "createdAt": "2020-10-01T13:18:16Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DefaultResourceTracker}.\n+ *\n+ * <p>Note: The majority is of the tracking logic is covered by the {@link JobScopedResourceTrackerTest}.\n+ */\n+public class DefaultResourceTrackerTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\ttracker.notifyLostResource(JobID.generate(), ResourceProfile.ANY);\n+\t\ttracker.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNzQwNQ==", "bodyText": "Does it make sense to make this a fields of DefaultResourceTrackerTest? That way we would not have to create these values multiple times.", "url": "https://github.com/apache/flink/pull/13464#discussion_r498237405", "createdAt": "2020-10-01T13:19:27Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DefaultResourceTracker}.\n+ *\n+ * <p>Note: The majority is of the tracking logic is covered by the {@link JobScopedResourceTrackerTest}.\n+ */\n+public class DefaultResourceTrackerTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\ttracker.notifyLostResource(JobID.generate(), ResourceProfile.ANY);\n+\t\ttracker.clear();\n+\t}\n+\n+\t@Test\n+\tpublic void testGetRequiredResources() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\t\tJobID jobId1 = JobID.generate();\n+\t\tJobID jobId2 = JobID.generate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MjQ5Ng==", "bodyText": "I would make this a separate test with a descriptive test name.", "url": "https://github.com/apache/flink/pull/13464#discussion_r498242496", "createdAt": "2020-10-01T13:26:31Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MzExMQ==", "bodyText": "Same here. I would split this into two tests.", "url": "https://github.com/apache/flink/pull/13464#discussion_r498243111", "createdAt": "2020-10-01T13:27:18Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MDQxMQ==", "bodyText": "How can we tell that the excess resources are used to fulfill the requirement? Aren't we missing a assertThat(tracker.getRequiredResources(), empty());?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498250411", "createdAt": "2020-10-01T13:37:36Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithoutResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(resourceRequirement));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tint numAcquiredSlotsP1 = resourceRequirements[0][0].getNumberOfRequiredSlots() - 1;\n+\t\tint numAcquiredSlotsP2 = resourceRequirements[0][1].getNumberOfRequiredSlots();\n+\n+\t\tfor (int x = 0; x < numAcquiredSlotsP1; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\t\tfor (int x = 0; x < numAcquiredSlotsP2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\t\t}\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_1, resourceRequirement[0].getNumberOfRequiredSlots() - numAcquiredSlotsP1)));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceExceedingRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_1, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceLessThanRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithoutRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[] resourceRequirementsArray = new ResourceRequirement[]{\n+\t\t\tResourceRequirement.create(PROFILE_1, 2),\n+\t\t\tResourceRequirement.create(PROFILE_2, 1)\n+\t\t};\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirementsArray));\n+\n+\t\tfor (int x = 0; x < 2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyLostResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, 1), ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementReductionRetainsExceedingResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnRequirementIncrease() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MDYyMg==", "bodyText": "Same here?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498250622", "createdAt": "2020-10-01T13:37:52Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithoutResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(resourceRequirement));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tint numAcquiredSlotsP1 = resourceRequirements[0][0].getNumberOfRequiredSlots() - 1;\n+\t\tint numAcquiredSlotsP2 = resourceRequirements[0][1].getNumberOfRequiredSlots();\n+\n+\t\tfor (int x = 0; x < numAcquiredSlotsP1; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\t\tfor (int x = 0; x < numAcquiredSlotsP2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\t\t}\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_1, resourceRequirement[0].getNumberOfRequiredSlots() - numAcquiredSlotsP1)));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceExceedingRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_1, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceLessThanRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithoutRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[] resourceRequirementsArray = new ResourceRequirement[]{\n+\t\t\tResourceRequirement.create(PROFILE_1, 2),\n+\t\t\tResourceRequirement.create(PROFILE_2, 1)\n+\t\t};\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirementsArray));\n+\n+\t\tfor (int x = 0; x < 2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyLostResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, 1), ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementReductionRetainsExceedingResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnRequirementIncrease() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnResourceLoss() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTEyOQ==", "bodyText": "Why is this variable called exceedingOrRequiredResources and not requiredResources?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498261129", "createdAt": "2020-10-01T13:52:33Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTracker.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Default {@link ResourceTracker} implementation.\n+ */\n+public class DefaultResourceTracker implements ResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultResourceTracker.class);\n+\n+\tprivate final Map<JobID, JobScopedResourceTracker> trackers = new LinkedHashMap<>();\n+\n+\t@Override\n+\tpublic void notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceRequirements);\n+\t\tLOG.trace(\"Received notification for job {} having new resource requirements {}.\", jobId, resourceRequirements);\n+\t\tgetOrCreateTracker(jobId).notifyResourceRequirements(resourceRequirements);\n+\n+\t\tif (resourceRequirements.isEmpty()) {\n+\t\t\tcheckWhetherTrackerCanBeRemoved(jobId, trackers.get(jobId));\n+\t\t}\n+\t}\n+\n+\tprivate void checkWhetherTrackerCanBeRemoved(JobID jobId, JobScopedResourceTracker tracker) {\n+\t\tif (tracker.isEmpty()) {\n+\t\t\tLOG.debug(\"Stopping tracking of resources for job {}.\", jobId);\n+\t\t\ttrackers.remove(jobId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tLOG.trace(\"Received notification for job {} having acquired resource {}.\", jobId, resourceProfile);\n+\t\tgetOrCreateTracker(jobId).notifyAcquiredResource(resourceProfile);\n+\t}\n+\n+\tprivate JobScopedResourceTracker getOrCreateTracker(JobID jobId) {\n+\t\treturn trackers.computeIfAbsent(jobId, ignored -> {\n+\t\t\tLOG.debug(\"Initiating tracking of resources for job {}.\", jobId);\n+\t\t\treturn new JobScopedResourceTracker(jobId);\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic void notifyLostResource(JobID jobId, ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tJobScopedResourceTracker tracker = trackers.get(jobId);\n+\n+\t\t// during shutdown the tracker is cleared before task executors are unregistered,\n+\t\t// to prevent the loss of resources triggering new allocations\n+\t\tif (tracker != null) {\n+\t\t\tLOG.trace(\"Received notification for job {} having lost resource {}.\", jobId, resourceProfile);\n+\t\t\ttracker.notifyLostResource(resourceProfile);\n+\n+\t\t\tcheckWhetherTrackerCanBeRemoved(jobId, tracker);\n+\t\t} else {\n+\t\t\tLOG.trace(\"Received notification for job {} having lost resource {}, but no such job was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\ttrackers.clear();\n+\t}\n+\n+\t@Override\n+\tpublic Map<JobID, Collection<ResourceRequirement>> getRequiredResources() {\n+\t\tMap<JobID, Collection<ResourceRequirement>> requiredResources = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, JobScopedResourceTracker> jobIDJobScopedRequirementsTrackerEntry : trackers.entrySet()) {\n+\t\t\tCollection<ResourceRequirement> exceedingOrRequiredResources = jobIDJobScopedRequirementsTrackerEntry.getValue().getRequiredResources();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTk0Ng==", "bodyText": "Is it correct that this method returns the excess resources? Need and excess seems to be quite different to me.", "url": "https://github.com/apache/flink/pull/13464#discussion_r498261946", "createdAt": "2020-10-01T13:53:41Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tracks for each job how many resource are required/acquired.\n+ */\n+public interface ResourceTracker {\n+\n+\t/**\n+\t * Notifies the tracker about a new or updated {@link ResourceRequirements}.\n+\t *\n+\t * @param jobId the job that that the resource requirements belongs to\n+\t * @param resourceRequirements new resource requirements\n+\t */\n+\tvoid notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements);\n+\n+\t/**\n+\t * Notifies the tracker about the acquisition of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that acquired the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Notifies the tracker about the loss of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that lost the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyLostResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Returns a collection of {@link ResourceRequirements} that describe which resources the corresponding job is\n+\t * in need/excess of.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2Mjg3Nw==", "bodyText": "I would suggest to give this method a different name because here it means the required resources to fulfill all requirements whereas notifyResourceRequirements specifies the absolute set of required resources. I can see that this will cause confusion (at least it happened to me).", "url": "https://github.com/apache/flink/pull/13464#discussion_r498262877", "createdAt": "2020-10-01T13:54:54Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tracks for each job how many resource are required/acquired.\n+ */\n+public interface ResourceTracker {\n+\n+\t/**\n+\t * Notifies the tracker about a new or updated {@link ResourceRequirements}.\n+\t *\n+\t * @param jobId the job that that the resource requirements belongs to\n+\t * @param resourceRequirements new resource requirements\n+\t */\n+\tvoid notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements);\n+\n+\t/**\n+\t * Notifies the tracker about the acquisition of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that acquired the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Notifies the tracker about the loss of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that lost the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyLostResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Returns a collection of {@link ResourceRequirements} that describe which resources the corresponding job is\n+\t * in need/excess of.\n+\t *\n+\t * @return required/exceeding resources for each jobs\n+\t */\n+\tMap<JobID, Collection<ResourceRequirement>> getRequiredResources();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyOTMyNw==", "bodyText": "is it important that we use a LinkedHashMap here?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498929327", "createdAt": "2020-10-02T16:36:24Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTracker.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Default {@link ResourceTracker} implementation.\n+ */\n+public class DefaultResourceTracker implements ResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultResourceTracker.class);\n+\n+\tprivate final Map<JobID, JobScopedResourceTracker> trackers = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMDgyNw==", "bodyText": "Should this ever happen or is this an invalid state?", "url": "https://github.com/apache/flink/pull/13464#discussion_r498930827", "createdAt": "2020-10-02T16:39:32Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMzk5Ng==", "bodyText": "Should this ever happen? I thought that all slots which over fulfill the requirements will be added to the excessResources field.", "url": "https://github.com/apache/flink/pull/13464#discussion_r498933996", "createdAt": "2020-10-02T16:46:07Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "962f799b61db881874c06dd4b3a38eb972d18a00", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/962f799b61db881874c06dd4b3a38eb972d18a00", "committedDate": "2020-10-05T07:25:12Z", "message": "[FLINK-19307][coordination] Add ResourceTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c6650f6dd0028a481f1ce72318b11c3d901ac92", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/9c6650f6dd0028a481f1ce72318b11c3d901ac92", "committedDate": "2020-10-05T07:25:13Z", "message": "+"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "618e7f37be12a163b5fefd4139a2556480993295", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/618e7f37be12a163b5fefd4139a2556480993295", "committedDate": "2020-10-05T07:25:13Z", "message": "hide internal ResourceCounters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b362cb50d9bf689a0ab497458c39f1cb755d80c4", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/b362cb50d9bf689a0ab497458c39f1cb755d80c4", "committedDate": "2020-10-05T07:25:13Z", "message": "Forbid decrement of non-existent profile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60890a83ce4ec657b7fa936c439265e7a3b54d78", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/60890a83ce4ec657b7fa936c439265e7a3b54d78", "committedDate": "2020-10-05T07:25:13Z", "message": "Forbid decrements for non-existent primary keys"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a7e1a20c1641ce9c3dcc2693bf668fe83ba6caa", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/3a7e1a20c1641ce9c3dcc2693bf668fe83ba6caa", "committedDate": "2020-10-05T07:25:13Z", "message": "unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a96f363e02aa04fe0aba247b671225f2bfe4d29", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/4a96f363e02aa04fe0aba247b671225f2bfe4d29", "committedDate": "2020-10-05T07:25:13Z", "message": "clarify javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db0a92cdb12b3f554b4a2a48d5a4e3a880784f4b", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/db0a92cdb12b3f554b4a2a48d5a4e3a880784f4b", "committedDate": "2020-10-05T07:25:13Z", "message": "clarify comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "committedDate": "2020-09-25T08:33:37Z", "message": "clarify comment"}, "afterCommit": {"oid": "7bca073125251f8e92f1a3e3a9a62bad398b2fd0", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/7bca073125251f8e92f1a3e3a9a62bad398b2fd0", "committedDate": "2020-10-05T07:25:13Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxOTkwMTMy", "url": "https://github.com/apache/flink/pull/13464#pullrequestreview-501990132", "createdAt": "2020-10-05T12:10:32Z", "commit": {"oid": "7bca073125251f8e92f1a3e3a9a62bad398b2fd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "007590e244fca615387ef854fd8c5fb5cd85fa45", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/007590e244fca615387ef854fd8c5fb5cd85fa45", "committedDate": "2020-10-06T14:11:00Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3b5127461f073d54c26f3fe6217361d95f50e97", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/e3b5127461f073d54c26f3fe6217361d95f50e97", "committedDate": "2020-10-06T14:11:01Z", "message": "last comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "242cf05e30ddfd92c5da8d435222c5bd105a4142", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/242cf05e30ddfd92c5da8d435222c5bd105a4142", "committedDate": "2020-10-06T08:06:28Z", "message": "last comments"}, "afterCommit": {"oid": "e3b5127461f073d54c26f3fe6217361d95f50e97", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/e3b5127461f073d54c26f3fe6217361d95f50e97", "committedDate": "2020-10-06T14:11:01Z", "message": "last comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4217, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}