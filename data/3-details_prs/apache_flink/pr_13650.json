{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDQ5MjU0", "number": 13650, "title": "[FLINK-19605][table-runtime-blink] Implement cumulative windowing for window aggregate operator", "bodyText": "What is the purpose of the change\nImplements the cumulative window assigner and supports cumulative window aggregate in WindowOperator.\nBrief change log\n\nAdd CumulativeWindowAssigner\nAdd cumulative window builder method in WindowOperatorBuilder\n\nVerifying this change\n\nAdd CumulativeWindowAssignerTest to test CumulativeWindowAssigner.\nAdd harness tests for cumulative window aggregate in WindowOperatorTest.\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-10-15T12:02:02Z", "url": "https://github.com/apache/flink/pull/13650", "merged": true, "mergeCommit": {"oid": "9423cf1cf2e7a96d5017e641e52d7acaabf39333"}, "closed": true, "closedAt": "2020-10-21T02:40:03Z", "author": {"login": "wuchong"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSwfrbgH2gAyNTA0MDQ5MjU0OjZmN2I4MTdjOGQ3ODUzMGYwYzllNjc0Y2RlMjViYjMxMWZlMDNkNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUkCfAgFqTUxMzI2NDM1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/6f7b817c8d78530f0c9e674cde25bb311fe03d57", "committedDate": "2020-10-15T11:57:55Z", "message": "[FLINK-19605][table-runtime-blink] Implement cumulative windowing for window aggregate operator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNDkyMDAy", "url": "https://github.com/apache/flink/pull/13650#pullrequestreview-511492002", "createdAt": "2020-10-19T07:48:13Z", "commit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo0ODoxM1rOHkBvnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1NjozMlrOHkCDBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUzOTM1OQ==", "bodyText": "If paneSize  always equals step, keep only step is enough, because we always have limitation size must be an integral multiple of step.", "url": "https://github.com/apache/flink/pull/13650#discussion_r507539359", "createdAt": "2020-10-19T07:48:13Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long size;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final long paneSize;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long size, long step, long offset, boolean isEventTime) {\n+\t\tif (size <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (size % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.size = size;\n+\t\tthis.step = step;\n+\t\tthis.offset = offset;\n+\t\tthis.isEventTime = isEventTime;\n+\t\tthis.paneSize = step;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MDM0Mw==", "bodyText": "Do we support size argument that is not 1 day ? Say 2 days or 3 days ?", "url": "https://github.com/apache/flink/pull/13650#discussion_r507540343", "createdAt": "2020-10-19T07:49:53Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long size;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final long paneSize;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long size, long step, long offset, boolean isEventTime) {\n+\t\tif (size <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (size % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.size = size;\n+\t\tthis.step = step;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MTYzMw==", "bodyText": "We should name it the maxSize because the window size is actually increasing.", "url": "https://github.com/apache/flink/pull/13650#discussion_r507541633", "createdAt": "2020-10-19T07:51:57Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long size;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final long paneSize;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long size, long step, long offset, boolean isEventTime) {\n+\t\tif (size <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (size % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.size = size;\n+\t\tthis.step = step;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MDM0Mw=="}, "originalCommit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NDMyNA==", "bodyText": "We may also need to add a test case for the late arrive data.", "url": "https://github.com/apache/flink/pull/13650#discussion_r507544324", "createdAt": "2020-10-19T07:56:32Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/window/WindowOperatorTest.java", "diffHunk": "@@ -289,6 +289,155 @@ public void testProcessingTimeSlidingWindows() throws Throwable {\n \t\ttestHarness.close();\n \t}\n \n+\t@Test\n+\tpublic void testEventTimeCumulativeWindows() throws Exception {\n+\t\tcloseCalled.set(0);\n+\n+\t\tWindowOperator operator = WindowOperatorBuilder\n+\t\t\t.builder()\n+\t\t\t.withInputFields(inputFieldTypes)\n+\t\t\t.cumulative(Duration.ofSeconds(3), Duration.ofSeconds(1))\n+\t\t\t.withEventTime(2)\n+\t\t\t.aggregateAndBuild(getTimeWindowAggFunction(), equaliser, accTypes, aggResultTypes, windowTypes);\n+\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(operator);\n+\n+\t\ttestHarness.open();\n+\n+\t\t// process elements\n+\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n+\n+\t\t// add elements out-of-order\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 2999L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 3000L));\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 20L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 0L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 999L));\n+\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1998L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1999L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1000L));\n+\n+\t\ttestHarness.processWatermark(new Watermark(999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 1000L, 999L)));\n+\t\texpectedOutput.add(new Watermark(999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(1999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 2000L, 1999L)));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 3L, 3L, 0L, 2000L, 1999L)));\n+\t\texpectedOutput.add(new Watermark(1999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(2999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 3000L, 2999L)));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 4L, 4L, 0L, 3000L, 2999L)));\n+\t\texpectedOutput.add(new Watermark(2999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\t\texpectedOutput.clear();\n+\n+\t\ttestHarness = createTestHarness(operator);\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processWatermark(new Watermark(3999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 4000L, 3999L)));\n+\t\texpectedOutput.add(new Watermark(3999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(4999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 5000L, 4999L)));\n+\t\texpectedOutput.add(new Watermark(4999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(5999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 6000L, 5999L)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26d7b65b3e795a9aa597269fc04a00d38ef1a1ad", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/26d7b65b3e795a9aa597269fc04a00d38ef1a1ad", "committedDate": "2020-10-20T04:15:43Z", "message": "address review comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzIzNjM3", "url": "https://github.com/apache/flink/pull/13650#pullrequestreview-512323637", "createdAt": "2020-10-20T04:33:30Z", "commit": {"oid": "26d7b65b3e795a9aa597269fc04a00d38ef1a1ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDozMzozMVrOHkqQww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDozMzozMVrOHkqQww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMzIwMw==", "bodyText": "size -> maxSize", "url": "https://github.com/apache/flink/pull/13650#discussion_r508203203", "createdAt": "2020-10-20T04:33:31Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long maxSize;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long maxSize, long step, long offset, boolean isEventTime) {\n+\t\tif (maxSize <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (maxSize % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.maxSize = maxSize;\n+\t\tthis.step = step;\n+\t\tthis.offset = offset;\n+\t\tthis.isEventTime = isEventTime;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TimeWindow> assignWindows(RowData element, long timestamp) {\n+\t\tList<TimeWindow> windows = new ArrayList<>();\n+\t\tlong start = TimeWindow.getWindowStartWithOffset(timestamp, offset, maxSize);\n+\t\tlong lastEnd = start + maxSize;\n+\t\tlong firstEnd = TimeWindow.getWindowStartWithOffset(timestamp, offset, step) + step;\n+\t\tfor (long end = firstEnd; end <= lastEnd; end += step) {\n+\t\t\twindows.add(new TimeWindow(start, end));\n+\t\t}\n+\t\treturn windows;\n+\t}\n+\n+\t@Override\n+\tpublic TimeWindow assignPane(Object element, long timestamp) {\n+\t\tlong start = TimeWindow.getWindowStartWithOffset(timestamp, offset, step);\n+\t\treturn new TimeWindow(start, start + step);\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<TimeWindow> splitIntoPanes(TimeWindow window) {\n+\t\treturn new PanesIterable(window.getStart(), window.getEnd(), step);\n+\t}\n+\n+\t@Override\n+\tpublic TimeWindow getLastWindow(TimeWindow pane) {\n+\t\tlong windowStart = TimeWindow.getWindowStartWithOffset(pane.getStart(), offset, maxSize);\n+\t\t// the last window is the max size window\n+\t\treturn new TimeWindow(windowStart, windowStart + maxSize);\n+\t}\n+\n+\t@Override\n+\tpublic TypeSerializer<TimeWindow> getWindowSerializer(ExecutionConfig executionConfig) {\n+\t\treturn new TimeWindow.Serializer();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEventTime() {\n+\t\treturn isEventTime;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"CumulativeWindow(\" + maxSize + \", \" + step + \")\";\n+\t}\n+\n+\tprivate static class PanesIterable implements IterableIterator<TimeWindow> {\n+\n+\t\tprivate final long paneSize;\n+\t\tprivate final long windowEnd;\n+\t\tprivate long paneStart;\n+\t\tprivate long paneEnd;\n+\n+\t\tPanesIterable(long windowStart, long windowEnd, long paneSize) {\n+\t\t\tthis.windowEnd = windowEnd;\n+\t\t\tthis.paneSize = paneSize;\n+\t\t\tthis.paneStart = windowStart;\n+\t\t\tthis.paneEnd = windowStart + paneSize;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn paneEnd <= windowEnd;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic TimeWindow next() {\n+\t\t\tTimeWindow window = new TimeWindow(paneStart, paneEnd);\n+\t\t\tpaneStart += paneSize;\n+\t\t\tpaneEnd += paneSize;\n+\t\t\treturn window;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Iterator<TimeWindow> iterator() {\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Utilities\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Creates a new {@link CumulativeWindowAssigner} that assigns\n+\t * elements to cumulative time windows based on the element timestamp.\n+\t *\n+\t * @param size  The max size of the generated windows.\n+\t * @param step The step interval for window size to increase of the generated windows.\n+\t * @return The time policy.\n+\t */\n+\tpublic static CumulativeWindowAssigner of(Duration size, Duration step) {\n+\t\treturn new CumulativeWindowAssigner(size.toMillis(), step.toMillis(), 0, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26d7b65b3e795a9aa597269fc04a00d38ef1a1ad"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cd041a86351096a1cea72f0ef2b8a20c021c339", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/2cd041a86351096a1cea72f0ef2b8a20c021c339", "committedDate": "2020-10-20T15:50:18Z", "message": "size -> maxSize"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjY0MzU3", "url": "https://github.com/apache/flink/pull/13650#pullrequestreview-513264357", "createdAt": "2020-10-21T02:35:01Z", "commit": {"oid": "2cd041a86351096a1cea72f0ef2b8a20c021c339"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3307, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}