{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwOTA4OTc1", "number": 11247, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDozNDoxNVrODjmitA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDozNDoxNVrODjmitA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjU4MjI4OnYy", "diffSide": "RIGHT", "path": "flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDozNDoxNVrOFvgSKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDozNDoxNVrOFvgSKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1NjMyOA==", "bodyText": "Please add a comment that parallelStream executes the consumer in a separate thread pool.\nAt a glance this context can easily appear as a no-op if you miss that parallelStream is used and what the semantics of it are.", "url": "https://github.com/apache/flink/pull/11247#discussion_r385356328", "createdAt": "2020-02-27T20:34:15Z", "author": {"login": "zentol"}, "path": "flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java", "diffHunk": "@@ -1095,18 +1096,21 @@ private void resetAvailableTransactionalIdsPool(Collection<String> transactional\n \t// ----------------------------------- Utilities --------------------------\n \n \tprivate void abortTransactions(final Set<String> transactionalIds) {\n+\t\tfinal ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n \t\ttransactionalIds.parallelStream().forEach(transactionalId -> {\n-\t\t\t// don't mess with the original configuration or any other properties of the\n-\t\t\t// original object\n-\t\t\t// -> create an internal kafka producer on our own and do not rely on\n-\t\t\t//    initTransactionalProducer().\n-\t\t\tfinal Properties myConfig = new Properties();\n-\t\t\tmyConfig.putAll(producerConfig);\n-\t\t\tinitTransactionalProducerConfig(myConfig, transactionalId);\n-\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> kafkaProducer =\n-\t\t\t\t\tnew FlinkKafkaInternalProducer<>(myConfig)) {\n-\t\t\t\t// it suffices to call initTransactions - this will abort any lingering transactions\n-\t\t\t\tkafkaProducer.initTransactions();\n+\t\t\ttry (TemporaryClassLoaderContext ignored = TemporaryClassLoaderContext.of(classLoader)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff5293a8f39aaef7a457e9720f7174e1982a928d"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 931, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}