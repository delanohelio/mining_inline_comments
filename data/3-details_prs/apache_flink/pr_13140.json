{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3Mzc2Njk1", "number": 13140, "title": "[FLINK-18884][python] Add chaining strategy and slot sharing group in\u2026", "bodyText": "What is the purpose of the change\nAdd start_new_chain(), disable_chaining() and slot_sharing_group() interfaces for Python DataStream API.\nBrief change log\nAdded the following interfaces for Python DataStream API:\n\nstart_new_chain()\ndisable_chaining()\nslot_sharing_group()\n\nVerifying this change\nThis change has test cases covered by test_chaining_strategy() and test_slot_sharing_group() in test_data_stream.py\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): ( no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): ( no)\nThe serializers: (no)\nThe runtime per-record code paths (performance sensitive): (no)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (no)\nThe S3 file system connector: (no)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (no)\nIf yes, how is the feature documented? ( not documented)", "createdAt": "2020-08-13T13:13:23Z", "url": "https://github.com/apache/flink/pull/13140", "merged": true, "mergeCommit": {"oid": "d3aa4f326d76dd214ca73252b8bdf3e63a497a3e"}, "closed": true, "closedAt": "2020-08-14T10:01:02Z", "author": {"login": "shuiqiangchen"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-rUu4gFqTQ2NzI3MTM1MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-u2iDgFqTQ2NzM0MTc4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjcxMzUw", "url": "https://github.com/apache/flink/pull/13140#pullrequestreview-467271350", "createdAt": "2020-08-14T02:37:02Z", "commit": {"oid": "95d62f551c4f2215fca8982bddaccde0d0238ef0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjozNzowM1rOHAllDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjozNzowM1rOHAllDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3Nzc0Mg==", "bodyText": "set parallelism on this source ds is useless since the parallelism of from_collection would always be one.", "url": "https://github.com/apache/flink/pull/13140#discussion_r470377742", "createdAt": "2020-08-14T02:37:03Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/datastream/tests/test_data_stream.py", "diffHunk": "@@ -322,6 +323,86 @@ def test_keyed_stream_partitioning(self):\n         with self.assertRaises(Exception):\n             keyed_stream.forward()\n \n+    def test_slot_sharing_group(self):\n+        source_operator_name = 'collection source'\n+        map_operator_name = 'map_operator'\n+        slot_sharing_group_1 = 'slot_sharing_group_1'\n+        slot_sharing_group_2 = 'slot_sharing_group_2'\n+        ds_1 = self.env.from_collection([1, 2, 3]).name(source_operator_name)\n+        ds_1.slot_sharing_group(slot_sharing_group_1).map(lambda x: x + 1).set_parallelism(3)\\\n+            .name(map_operator_name).slot_sharing_group(slot_sharing_group_2)\\\n+            .add_sink(self.test_sink)\n+\n+        j_generated_stream_graph = self.env._j_stream_execution_environment \\\n+            .getStreamGraph(\"test start new_chain\", True)\n+\n+        j_stream_nodes = list(j_generated_stream_graph.getStreamNodes().toArray())\n+        for j_stream_node in j_stream_nodes:\n+            if j_stream_node.getOperatorName() == source_operator_name:\n+                self.assertEqual(j_stream_node.getSlotSharingGroup(), slot_sharing_group_1)\n+            elif j_stream_node.getOperatorName() == map_operator_name:\n+                self.assertEqual(j_stream_node.getSlotSharingGroup(), slot_sharing_group_2)\n+\n+    def test_chaining_strategy(self):\n+        chained_operator_name = \"map_operator_1\"\n+        chained_operator_name_1 = \"map_operator_2\"\n+\n+        ds = self.env.from_collection([1, 2, 3])\n+        ds.set_parallelism(2).map(lambda x: x).set_parallelism(2)\\\n+            .name(chained_operator_name).map(lambda x: x).set_parallelism(2)\\\n+            .name(chained_operator_name_1).add_sink(self.test_sink)\n+\n+        def assert_chainable(j_stream_graph, expected_upstream_chainable,\n+                             expected_downstream_chainable):\n+            j_stream_nodes = list(j_stream_graph.getStreamNodes().toArray())\n+            for j_stream_node in j_stream_nodes:\n+                if j_stream_node.getOperatorName() == chained_operator_name:\n+                    JStreamingJobGraphGenerator = get_gateway().jvm \\\n+                        .org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator\n+\n+                    j_in_stream_edge = j_stream_node.getInEdges().get(0)\n+                    upstream_chainable = JStreamingJobGraphGenerator.isChainable(j_in_stream_edge,\n+                                                                                 j_stream_graph)\n+                    self.assertEqual(expected_upstream_chainable, upstream_chainable)\n+\n+                    j_out_stream_edge = j_stream_node.getOutEdges().get(0)\n+                    downstream_chainable = JStreamingJobGraphGenerator.isChainable(\n+                        j_out_stream_edge, j_stream_graph)\n+                    self.assertEqual(expected_downstream_chainable, downstream_chainable)\n+\n+        # The map_operator_1 has the same parallelism with source operator and map_operator_2, and\n+        # ship_strategy for collection source and map_operator_1 is FORWARD, so the map_operator_1\n+        # can be chained with collection source and map_operator_2.\n+        j_generated_stream_graph = self.env._j_stream_execution_environment\\\n+            .getStreamGraph(\"test start new_chain\", True)\n+        assert_chainable(j_generated_stream_graph, True, True)\n+\n+        ds = self.env.from_collection([1, 2, 3])\n+        # Start a new chain for map_operator_1\n+        ds.set_parallelism(2).map(lambda x: x).set_parallelism(2) \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95d62f551c4f2215fca8982bddaccde0d0238ef0"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "135dfe91c0e02ef1ec7c20b956997f9117a4e40f", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/135dfe91c0e02ef1ec7c20b956997f9117a4e40f", "committedDate": "2020-08-14T03:27:07Z", "message": "[FLINK-18884][python] Add chaining strategy and slot sharing group interfaces for Python DataStream API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8312a9ef18d77d9ca2080133c3cc54714de36ed", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/f8312a9ef18d77d9ca2080133c3cc54714de36ed", "committedDate": "2020-08-14T03:27:07Z", "message": "[FLINK-18884][python] Resolve spelling errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc8ddc039efdf3720bfaa29e2bff86df4ea2e346", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/cc8ddc039efdf3720bfaa29e2bff86df4ea2e346", "committedDate": "2020-08-14T04:07:29Z", "message": "[FLINK-18884][python] fix the bug of from_collection by force it to be non-parallel, optimize test case for chaining strategy."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95d62f551c4f2215fca8982bddaccde0d0238ef0", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/95d62f551c4f2215fca8982bddaccde0d0238ef0", "committedDate": "2020-08-13T16:04:42Z", "message": "[FLINK-18884][python] Resolve spelling errors."}, "afterCommit": {"oid": "cc8ddc039efdf3720bfaa29e2bff86df4ea2e346", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/cc8ddc039efdf3720bfaa29e2bff86df4ea2e346", "committedDate": "2020-08-14T04:07:29Z", "message": "[FLINK-18884][python] fix the bug of from_collection by force it to be non-parallel, optimize test case for chaining strategy."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzM3Nzc3", "url": "https://github.com/apache/flink/pull/13140#pullrequestreview-467337777", "createdAt": "2020-08-14T06:35:16Z", "commit": {"oid": "cc8ddc039efdf3720bfaa29e2bff86df4ea2e346"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjozNToxNlrOHApLUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjozNToxNlrOHApLUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNjY4OQ==", "bodyText": "Update comments here.", "url": "https://github.com/apache/flink/pull/13140#discussion_r470436689", "createdAt": "2020-08-14T06:35:16Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/datastream/tests/test_data_stream.py", "diffHunk": "@@ -322,6 +322,88 @@ def test_keyed_stream_partitioning(self):\n         with self.assertRaises(Exception):\n             keyed_stream.forward()\n \n+    def test_slot_sharing_group(self):\n+        source_operator_name = 'collection source'\n+        map_operator_name = 'map_operator'\n+        slot_sharing_group_1 = 'slot_sharing_group_1'\n+        slot_sharing_group_2 = 'slot_sharing_group_2'\n+        ds_1 = self.env.from_collection([1, 2, 3]).name(source_operator_name)\n+        ds_1.slot_sharing_group(slot_sharing_group_1).map(lambda x: x + 1).set_parallelism(3)\\\n+            .name(map_operator_name).slot_sharing_group(slot_sharing_group_2)\\\n+            .add_sink(self.test_sink)\n+\n+        j_generated_stream_graph = self.env._j_stream_execution_environment \\\n+            .getStreamGraph(\"test start new_chain\", True)\n+\n+        j_stream_nodes = list(j_generated_stream_graph.getStreamNodes().toArray())\n+        for j_stream_node in j_stream_nodes:\n+            if j_stream_node.getOperatorName() == source_operator_name:\n+                self.assertEqual(j_stream_node.getSlotSharingGroup(), slot_sharing_group_1)\n+            elif j_stream_node.getOperatorName() == map_operator_name:\n+                self.assertEqual(j_stream_node.getSlotSharingGroup(), slot_sharing_group_2)\n+\n+    def test_chaining_strategy(self):\n+        chained_operator_name_0 = \"map_operator_0\"\n+        chained_operator_name_1 = \"map_operator_1\"\n+        chained_operator_name_2 = \"map_operator_2\"\n+\n+        ds = self.env.from_collection([1, 2, 3])\n+        ds.map(lambda x: x).set_parallelism(2).name(chained_operator_name_0)\\\n+            .map(lambda x: x).set_parallelism(2).name(chained_operator_name_1)\\\n+            .map(lambda x: x).set_parallelism(2).name(chained_operator_name_2)\\\n+            .add_sink(self.test_sink)\n+\n+        def assert_chainable(j_stream_graph, expected_upstream_chainable,\n+                             expected_downstream_chainable):\n+            j_stream_nodes = list(j_stream_graph.getStreamNodes().toArray())\n+            for j_stream_node in j_stream_nodes:\n+                if j_stream_node.getOperatorName() == chained_operator_name_1:\n+                    JStreamingJobGraphGenerator = get_gateway().jvm \\\n+                        .org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator\n+\n+                    j_in_stream_edge = j_stream_node.getInEdges().get(0)\n+                    upstream_chainable = JStreamingJobGraphGenerator.isChainable(j_in_stream_edge,\n+                                                                                 j_stream_graph)\n+                    self.assertEqual(expected_upstream_chainable, upstream_chainable)\n+\n+                    j_out_stream_edge = j_stream_node.getOutEdges().get(0)\n+                    downstream_chainable = JStreamingJobGraphGenerator.isChainable(\n+                        j_out_stream_edge, j_stream_graph)\n+                    self.assertEqual(expected_downstream_chainable, downstream_chainable)\n+\n+        # The map_operator_1 has the same parallelism with source operator and map_operator_2, and\n+        # ship_strategy for collection source and map_operator_1 is FORWARD, so the map_operator_1\n+        # can be chained with collection source and map_operator_2.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ddc039efdf3720bfaa29e2bff86df4ea2e346"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39d40e77c1c2f6e34070366120a9594fe712548c", "author": {"user": {"login": "shuiqiangchen", "name": "Shuiqiang Chen"}}, "url": "https://github.com/apache/flink/commit/39d40e77c1c2f6e34070366120a9594fe712548c", "committedDate": "2020-08-14T06:42:03Z", "message": "[FLINK-18884][python] Update comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzQxNzgx", "url": "https://github.com/apache/flink/pull/13140#pullrequestreview-467341781", "createdAt": "2020-08-14T06:44:36Z", "commit": {"oid": "39d40e77c1c2f6e34070366120a9594fe712548c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4859, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}