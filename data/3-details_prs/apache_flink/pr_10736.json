{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NDk4MTUx", "number": 10736, "title": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "bodyText": "What is the purpose of the change\nWhen shutting down the cluster in standalone mode, the task manager is shutdown by emit SIG_TERM signal. In this case, the directories are cleaned up by the shutdown hooks. However, NettyShuffleEnvironment does not register shutdown hook normally, which causes the flink-netty-shuffle-* directories not  cleaned finally.\nTo fix this issue, we registered the corresponding shutdown hooks. To ensure the directories could be removed, the hook must be registered before creating the directories. Therefore, it is not suitable to register shutdown hook in NettyShuffleEnvironment. Instead, we chose to allow users to register shutdown hook for each FileChannelManagerImpl.\nBrief change log\n\n9430066 registered shutdown hook for FileChannelManagerImpl used in NettyShuffleEnvironment.\n\nVerifying this change\nThis change added tests and can be verified as follows:\n\nAdded test that validates that flink-netty-shuffle-* get cleared after task manager received SIG_TERM signals.\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): no\nThe public API, i.e., is any changed class annotated with @Public(Evolving): no\nThe serializers: no\nThe runtime per-record code paths (performance sensitive): no\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: no\nThe S3 file system connector: no\n\nDocumentation\n\nDoes this pull request introduce a new feature? no\nIf yes, how is the feature documented? not applicable", "createdAt": "2020-01-01T15:45:14Z", "url": "https://github.com/apache/flink/pull/10736", "merged": true, "mergeCommit": {"oid": "5036334ca00405cd4cdd5a798dca012bb3cc7bbf"}, "closed": true, "closedAt": "2020-02-04T03:54:00Z", "author": {"login": "gaoyunhaii"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2HKM1gBqjI5MTY1NzgwNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcAuSyPAFqTM1MjMxODc4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a6b51a57cbf23b054b3b20dd5dbb30a03b561ef", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/1a6b51a57cbf23b054b3b20dd5dbb30a03b561ef", "committedDate": "2020-01-01T15:09:20Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}, "afterCommit": {"oid": "72711436341661fa90f495a529b3cc616b8df7ec", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/72711436341661fa90f495a529b3cc616b8df7ec", "committedDate": "2020-01-01T15:47:01Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72711436341661fa90f495a529b3cc616b8df7ec", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/72711436341661fa90f495a529b3cc616b8df7ec", "committedDate": "2020-01-01T15:47:01Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}, "afterCommit": {"oid": "4b605068e32d3eb15a51f838ed29918d1224959a", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/4b605068e32d3eb15a51f838ed29918d1224959a", "committedDate": "2020-01-01T15:50:29Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b605068e32d3eb15a51f838ed29918d1224959a", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/4b605068e32d3eb15a51f838ed29918d1224959a", "committedDate": "2020-01-01T15:50:29Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}, "afterCommit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/9430066683a67318f9685de8a58904972c5dbaca", "committedDate": "2020-01-02T02:19:31Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5MTg3OTE4", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-339187918", "createdAt": "2020-01-07T11:46:19Z", "commit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMTo0NjoxOVrOFa3N8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMTo0NjoxOVrOFa3N8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxMTk4NQ==", "bodyText": "Can we always add the shutdown hook to remove the argument deleteOnShutdown?", "url": "https://github.com/apache/flink/pull/10736#discussion_r363711985", "createdAt": "2020-01-07T11:46:19Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -51,12 +52,30 @@\n \t/** The number of the next path to use. */\n \tprivate volatile int nextPath;\n \n+\tprivate final String prefix;\n+\n+\tprivate final Thread shutdownHook;\n+\n \tpublic FileChannelManagerImpl(String[] tempDirs, String prefix) {\n+\t\tthis(tempDirs, prefix, false);\n+\t}\n+\n+\tpublic FileChannelManagerImpl(String[] tempDirs, String prefix, boolean deleteOnShutdown) {\n \t\tcheckNotNull(tempDirs, \"The temporary directories must not be null.\");\n \t\tcheckArgument(tempDirs.length > 0, \"The temporary directories must not be empty.\");\n \n \t\tthis.random = new Random();\n \t\tthis.nextPath = 0;\n+\t\tthis.prefix = prefix;\n+\n+\t\tif (deleteOnShutdown) {\n+\t\t\tshutdownHook = ShutdownHookUtil.addShutdownHook(this, String.format(\"%s-%s\", getClass().getSimpleName(), prefix), LOG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjU4MDY5", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-341658069", "createdAt": "2020-01-13T06:52:26Z", "commit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1MjoyNlrOFcuQ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1MjoyNlrOFcuQ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MjQ0NA==", "bodyText": "If the shutdown hook only supports the following systems, maybe it is better to not fail for other systems, i mean this test can be ignored directly instead of failing.", "url": "https://github.com/apache/flink/pull/10736#discussion_r365662444", "createdAt": "2020-01-13T06:52:26Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjU5MDI2", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-341659026", "createdAt": "2020-01-13T06:56:46Z", "commit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1Njo0NlrOFcuUAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1Njo0NlrOFcuUAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzIzNA==", "bodyText": "It is too heavy-height to start the cluster besides the preparation of above configuration and writer. We can construct the FileChannelManagerImpl via TestJvmProcess directly for simple. Actually we only want to verify that the new added shutdown hook to FileChannelManagerImpl work correctly, no matter which component covers it.", "url": "https://github.com/apache/flink/pull/10736#discussion_r365663234", "createdAt": "2020-01-13T06:56:46Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile confDir = temporaryFolder.newFolder();\n+\t\tFile confFile = new File(confDir + \"/flink-conf.yaml\");\n+\n+\t\tFile taskManagerTmpDir = temporaryFolder.newFolder();\n+\n+\t\tConfiguration config = new Configuration();\n+\t\tconfig.setString(JobManagerOptions.ADDRESS, \"localhost\");\n+\t\tconfig.setString(RestOptions.BIND_PORT, \"0\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_MODE, \"zookeeper\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());\n+\t\tconfig.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getAbsolutePath());\n+\t\tconfig.setString(CoreOptions.TMP_DIRS, taskManagerTmpDir.getAbsolutePath());\n+\t\tconfig.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, \"4m\");\n+\t\tconfig.setInteger(NettyShuffleEnvironmentOptions.NETWORK_NUM_BUFFERS, 100);\n+\t\tconfig.setString(TaskManagerOptions.TOTAL_FLINK_MEMORY, \"512m\");\n+\n+\t\ttry (FileOutputStream fos = new FileOutputStream(confFile);\n+\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos))) {\n+\t\t\tfor (Map.Entry<String, String> e : config.toMap().entrySet()) {\n+\t\t\t\twriter.write(e.getKey());\n+\t\t\t\twriter.write(\": \");\n+\t\t\t\twriter.write(e.getValue());\n+\t\t\t\twriter.newLine();\n+\t\t\t}\n+\n+\t\t\twriter.flush();\n+\t\t}\n+\n+\t\tTaskManagerProcess taskManagerProcess = null;\n+\n+\t\ttry (final StandaloneSessionClusterEntrypoint clusterEntrypoint = new StandaloneSessionClusterEntrypoint(config)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjU5Mzcw", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-341659370", "createdAt": "2020-01-13T06:58:13Z", "commit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1ODoxNFrOFcuVDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo1ODoxNFrOFcuVDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzUwMw==", "bodyText": "we should add a finally part to cleanup the FileChannelManagerImpl as the bottom line. In case this test fails unexpected, we still do not leak any files.", "url": "https://github.com/apache/flink/pull/10736#discussion_r365663503", "createdAt": "2020-01-13T06:58:14Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile confDir = temporaryFolder.newFolder();\n+\t\tFile confFile = new File(confDir + \"/flink-conf.yaml\");\n+\n+\t\tFile taskManagerTmpDir = temporaryFolder.newFolder();\n+\n+\t\tConfiguration config = new Configuration();\n+\t\tconfig.setString(JobManagerOptions.ADDRESS, \"localhost\");\n+\t\tconfig.setString(RestOptions.BIND_PORT, \"0\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_MODE, \"zookeeper\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());\n+\t\tconfig.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getAbsolutePath());\n+\t\tconfig.setString(CoreOptions.TMP_DIRS, taskManagerTmpDir.getAbsolutePath());\n+\t\tconfig.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, \"4m\");\n+\t\tconfig.setInteger(NettyShuffleEnvironmentOptions.NETWORK_NUM_BUFFERS, 100);\n+\t\tconfig.setString(TaskManagerOptions.TOTAL_FLINK_MEMORY, \"512m\");\n+\n+\t\ttry (FileOutputStream fos = new FileOutputStream(confFile);\n+\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos))) {\n+\t\t\tfor (Map.Entry<String, String> e : config.toMap().entrySet()) {\n+\t\t\t\twriter.write(e.getKey());\n+\t\t\t\twriter.write(\": \");\n+\t\t\t\twriter.write(e.getValue());\n+\t\t\t\twriter.newLine();\n+\t\t\t}\n+\n+\t\t\twriter.flush();\n+\t\t}\n+\n+\t\tTaskManagerProcess taskManagerProcess = null;\n+\n+\t\ttry (final StandaloneSessionClusterEntrypoint clusterEntrypoint = new StandaloneSessionClusterEntrypoint(config)) {\n+\t\t\tString javaCommand = getJavaCommandPath();\n+\t\t\tif (javaCommand == null) {\n+\t\t\t\tfail(\"Could not find java executable.\");\n+\t\t\t}\n+\n+\t\t\tclusterEntrypoint.startCluster();\n+\n+\t\t\ttaskManagerProcess = new TaskManagerProcess(javaCommand, confDir.getAbsolutePath());\n+\t\t\ttaskManagerProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\tFile[] nettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\n+\t\t\twhile (nettyShuffleTmpFiles.length == 0 && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t\tnettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\t\t\t}\n+\n+\t\t\tif (nettyShuffleTmpFiles.length == 0) {\n+\t\t\t\tfail(\"The TaskManager process does not create shuffle directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + taskManagerProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + taskManagerProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (taskManagerProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (taskManagerProcess.isAlive()) {\n+\t\t\t\tfail(\"The TaskManager process does not terminate in time, its output is: \\n\" + taskManagerProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tnettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\t\t\tassertEquals(\"The TaskManager does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + taskManagerProcess.getProcessOutput(),\n+\t\t\t\t\t0, nettyShuffleTmpFiles.length);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjU5NzY2", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-341659766", "createdAt": "2020-01-13T07:00:04Z", "commit": {"oid": "9430066683a67318f9685de8a58904972c5dbaca"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14bfdb988a1dab03b8631ecea03284b82e7f78f1", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/14bfdb988a1dab03b8631ecea03284b82e7f78f1", "committedDate": "2020-01-14T02:44:14Z", "message": "Addressing comments"}, "afterCommit": {"oid": "2185007c824d21817356c9dfb9c9e09846e27f7e", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/2185007c824d21817356c9dfb9c9e09846e27f7e", "committedDate": "2020-01-14T02:50:29Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2185007c824d21817356c9dfb9c9e09846e27f7e", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/2185007c824d21817356c9dfb9c9e09846e27f7e", "committedDate": "2020-01-14T02:50:29Z", "message": "Addressing comments"}, "afterCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/d7ab35b18c5964b837be1d52611623d7c271dc99", "committedDate": "2020-01-14T03:07:42Z", "message": "Addressing comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjAwODE4", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345200818", "createdAt": "2020-01-20T10:11:14Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxMToxNVrOFfZSng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxMToxNVrOFfZSng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NDU0Mg==", "bodyText": "nit: it already was -> it was already", "url": "https://github.com/apache/flink/pull/10736#discussion_r368464542", "createdAt": "2020-01-20T10:11:15Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -99,10 +123,17 @@ public Enumerator createChannelEnumerator() {\n \t */\n \t@Override\n \tpublic void close() throws Exception {\n+\t\t// Marks shut down and exit if it already was shut down.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjA0MzE0", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345204314", "createdAt": "2020-01-20T10:16:49Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxNjo1MFrOFfZdwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxNjo1MFrOFfZdwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NzM5Mg==", "bodyText": "Extend TestLogger for better tracking.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368467392", "createdAt": "2020-01-20T10:16:50Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjA1MDM4", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345205038", "createdAt": "2020-01-20T10:18:01Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxODowMVrOFfZf7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoxODowMVrOFfZf7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2Nzk1MA==", "bodyText": "better to add an empty line before this import.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368467950", "createdAt": "2020-01-20T10:18:01Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjA5NTg1", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345209585", "createdAt": "2020-01-20T10:25:28Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoyNToyOFrOFfZuWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoyNToyOFrOFfZuWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MTY0Mg==", "bodyText": "I guess this part is reductant because the javaCommand is actually not used below?", "url": "https://github.com/apache/flink/pull/10736#discussion_r368471642", "createdAt": "2020-01-20T10:25:28Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjEyNzY0", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345212764", "createdAt": "2020-01-20T10:30:33Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDozMDozM1rOFfZ4Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDozMDozM1rOFfZ4Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3NDEyMw==", "bodyText": "Make this creation out of try clause, then we do not need to check whether it is null in finally clause.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368474123", "createdAt": "2020-01-20T10:30:33Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjMwMzA5", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345230309", "createdAt": "2020-01-20T11:00:30Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowMDozMFrOFfauMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowMDozMFrOFfauMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4Nzk4Nw==", "bodyText": "It is better to give some comment explanations here why we need callerHasHook for testing. E.g. we want to verify the case that both the upper component and its internal FileChannelManagerImpl have the shutdown hook in practice like IOManager.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368487987", "createdAt": "2020-01-20T11:00:30Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjMyMTI0", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345232124", "createdAt": "2020-01-20T11:03:40Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowMzo0MFrOFfaztQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowMzo0MFrOFfaztQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTM5Nw==", "bodyText": "Can we still refer to the TEST_TIMEOUT for waiting before failure? Actually 50s is too long for this test I guess.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489397", "createdAt": "2020-01-20T11:03:40Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Single main process what we can be killed.\n+\t\t\tnew File(couldKillSignalFilePath).createNewFile();\n+\n+\t\t\t// Waits till get killed. If we have not killed in time, make sure we exit finally.\n+\t\t\t// Meanwhile, the test will fail due to process not terminated in time.\n+\t\t\tThread.sleep(5 * TEST_TIMEOUT.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjMyNTAx", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345232501", "createdAt": "2020-01-20T11:04:22Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowNDoyMlrOFfa00A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowNDoyMlrOFfa00A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTY4MA==", "bodyText": "We should make this test fail if entering the exit(1)?", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489680", "createdAt": "2020-01-20T11:04:22Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Single main process what we can be killed.\n+\t\t\tnew File(couldKillSignalFilePath).createNewFile();\n+\n+\t\t\t// Waits till get killed. If we have not killed in time, make sure we exit finally.\n+\t\t\t// Meanwhile, the test will fail due to process not terminated in time.\n+\t\t\tThread.sleep(5 * TEST_TIMEOUT.toMillis());\n+\t\t\tSystem.exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjMyODE5", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345232819", "createdAt": "2020-01-20T11:04:55Z", "commit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowNDo1NVrOFfa1tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTowNDo1NVrOFfa1tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTkxMQ==", "bodyText": "can be package private and remove the throws Exception", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489911", "createdAt": "2020-01-20T11:04:55Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjA2MTgz", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345606183", "createdAt": "2020-01-21T02:32:05Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjozMjowNVrOFfs-qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjozMjowNVrOFfs-qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NzExNA==", "bodyText": "I think we should give some comments for the reason of atomic here, which is for the case of multiple shutdown hooks.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368787114", "createdAt": "2020-01-21T02:32:05Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -51,12 +54,27 @@\n \t/** The number of the next path to use. */\n \tprivate volatile int nextPath;\n \n+\t/** Prefix of the temporary directories to create */\n+\tprivate final String prefix;\n+\n+\t/** Flag to signify that the file channel manager has been shut down already. */\n+\tprivate final AtomicBoolean isShutdown = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjA3OTgz", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345607983", "createdAt": "2020-01-21T02:40:27Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjo0MDoyN1rOFftE7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjo0MDoyN1rOFftE7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxOA==", "bodyText": "Can we check via fileChannelDir.list().length == 0 to avoid relying on COULD_KILL_SIGNAL_FILE? If so we can get ride of it completely and only rely on the original FileChannelManagerImpl.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368788718", "createdAt": "2020-01-21T02:40:27Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjExNzUy", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345611752", "createdAt": "2020-01-21T02:57:24Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjo1NzoyNFrOFftRlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMjo1NzoyNFrOFftRlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTk1Nw==", "bodyText": "we can also remove this part if making use of TestJvmProcess.waitForMarkerFile() as mentioned above.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368791957", "createdAt": "2020-01-21T02:57:24Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjEyNTY1", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345612565", "createdAt": "2020-01-21T03:01:00Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzowMTowMVrOFftUWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzowMTowMVrOFftUWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MjY2NQ==", "bodyText": "Use assertFalse(\"\", fileChannelManagerTestProcess.isAlive()) for simple.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368792665", "createdAt": "2020-01-21T03:01:01Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjEzNzM1", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345613735", "createdAt": "2020-01-21T03:07:04Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzowNzowNVrOFftYYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzowNzowNVrOFftYYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MzY5Nw==", "bodyText": "also use assertFalse for simple", "url": "https://github.com/apache/flink/pull/10736#discussion_r368793697", "createdAt": "2020-01-21T03:07:05Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjE0NTIz", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345614523", "createdAt": "2020-01-21T03:10:54Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxMDo1NFrOFftbCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxMDo1NFrOFftbCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDM3Nw==", "bodyText": "COULD_KILL_SIGNAL_FILE -> SIGNAL_FILE_FOR_KILLING, and give some comments for what it is used for.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368794377", "createdAt": "2020-01-21T03:10:54Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjE0OTcy", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345614972", "createdAt": "2020-01-21T03:13:20Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxMzoyMFrOFftcoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxMzoyMFrOFftcoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDc4NA==", "bodyText": "Singles -> Signals\nSignals the main process to execute the kill action.", "url": "https://github.com/apache/flink/pull/10736#discussion_r368794784", "createdAt": "2020-01-21T03:13:20Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tFileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\t// Verifies the case that both FileChannelManager and its upper component\n+\t\t\t\t// have registered shutdown hooks, like in IOManager.\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Singles main process what we can be killed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjE1NjU4", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345615658", "createdAt": "2020-01-21T03:16:18Z", "commit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxNjoxOFrOFftexQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMzoxNjoxOFrOFftexQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NTMzMw==", "bodyText": "public -> private", "url": "https://github.com/apache/flink/pull/10736#discussion_r368795333", "createdAt": "2020-01-21T03:16:18Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tFileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzU0ODY3", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345754867", "createdAt": "2020-01-21T10:00:37Z", "commit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDowMDozOFrOFf0QoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDowMDozOFrOFf0QoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjQwMA==", "bodyText": "exit -> exits", "url": "https://github.com/apache/flink/pull/10736#discussion_r368906400", "createdAt": "2020-01-21T10:00:38Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -99,10 +126,17 @@ public Enumerator createChannelEnumerator() {\n \t */\n \t@Override\n \tpublic void close() throws Exception {\n+\t\t// Marks shut down and exit if it has already shut down.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzY2ODk5", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345766899", "createdAt": "2020-01-21T10:19:09Z", "commit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDoxOTowOVrOFf01Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDoxOTowOVrOFf01Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxNTcxNQ==", "bodyText": "<tt> callerHasHook </tt>", "url": "https://github.com/apache/flink/pull/10736#discussion_r368915715", "createdAt": "2020-01-21T10:19:09Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\t/**\n+\t * Marker file indicating the test process is ready to be killed. We could not simply kill the process\n+\t * after FileChannelManager has created temporary files since we also need to ensure the caller has\n+\t * also registered the shutdown hook if callerHasHook is true.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzcwMDk2", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-345770096", "createdAt": "2020-01-21T10:24:13Z", "commit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDoyNDoxNFrOFf0-mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDoyNDoxNFrOFf0-mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxODE3MQ==", "bodyText": "couldKillSignalFilePath -> signalFilePath", "url": "https://github.com/apache/flink/pull/10736#discussion_r368918171", "createdAt": "2020-01-21T10:24:14Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\t/**\n+\t * Marker file indicating the test process is ready to be killed. We could not simply kill the process\n+\t * after FileChannelManager has created temporary files since we also need to ensure the caller has\n+\t * also registered the shutdown hook if callerHasHook is true.\n+\t */\n+\tprivate static final String SIGNAL_FILE_FOR_KILLING = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\t\tFile signalFile = new File(FilenameUtils.concat(signalDir.getAbsolutePath(), SIGNAL_FILE_FOR_KILLING));\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tsignalFile.getAbsolutePath());\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till the process has created temporary files and registered the corresponding shutdown hooks.\n+\t\t\tTestJvmProcess.waitForMarkerFile(signalFile, TEST_TIMEOUT.toMillis());\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tassertFalse(\"The file channel manager test process does not terminate in time, its output is: \\n\"\n+\t\t\t\t\t\t+ fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileChannelManagerTestProcess.isAlive());\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertFalse(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3104fe46714388247df22b5372e5c3c134834646"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aae9d5a92c2ad581af35152876996020eb368f7", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/6aae9d5a92c2ad581af35152876996020eb368f7", "committedDate": "2020-02-03T10:38:03Z", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31899d557907c3ae2dd78d079517cc91153c5201", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/31899d557907c3ae2dd78d079517cc91153c5201", "committedDate": "2020-02-03T10:38:03Z", "message": "Addressing comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "075c84fe6c165ecec90c0b4abb12460b8e717281", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/075c84fe6c165ecec90c0b4abb12460b8e717281", "committedDate": "2020-02-03T10:38:03Z", "message": "Address the comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3008621f341037ed1cf1d5fd67ccedac2359a54f", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/3008621f341037ed1cf1d5fd67ccedac2359a54f", "committedDate": "2020-02-03T10:38:03Z", "message": "Address the comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c5e0c9d33f8cd3f44c06168890ec1313ebd6007", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/6c5e0c9d33f8cd3f44c06168890ec1313ebd6007", "committedDate": "2020-02-03T10:38:03Z", "message": "Address more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "158dd43ee9cd107d7def34fef064946b00b4570d", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/158dd43ee9cd107d7def34fef064946b00b4570d", "committedDate": "2020-02-03T10:50:33Z", "message": "Fix the import orders"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d935ac02c5e5f53566225df738862226a7e50aa1", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/d935ac02c5e5f53566225df738862226a7e50aa1", "committedDate": "2020-01-21T15:32:55Z", "message": "Address more comments"}, "afterCommit": {"oid": "158dd43ee9cd107d7def34fef064946b00b4570d", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/158dd43ee9cd107d7def34fef064946b00b4570d", "committedDate": "2020-02-03T10:50:33Z", "message": "Fix the import orders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a20895d3ac0e5fd3eb1f4fd3c665519bc15ae803", "author": {"user": null}, "url": "https://github.com/apache/flink/commit/a20895d3ac0e5fd3eb1f4fd3c665519bc15ae803", "committedDate": "2020-02-03T14:24:17Z", "message": "Remove dependency of FileNameUtils"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMzE4Nzg3", "url": "https://github.com/apache/flink/pull/10736#pullrequestreview-352318787", "createdAt": "2020-02-03T15:02:14Z", "commit": {"oid": "a20895d3ac0e5fd3eb1f4fd3c665519bc15ae803"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4871, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}