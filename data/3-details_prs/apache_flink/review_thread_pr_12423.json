{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1ODI5MDE5", "number": 12423, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NToyOVrOECMOXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODozNDoxNFrOEEMmIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzMyODk0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NToyOVrOGefwhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDo1NVrOGf0eqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDc4OQ==", "bodyText": "Maybe, just:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal StateLocationRetriever stateLocationRetriever = new ExecutionVertexStateLocationRetriever(this::getExecutionVertex);\n          \n          \n            \n            \t\tfinal StateLocationRetriever stateLocationRetriever = executionVertexId -> getExecutionVertex(executionVertexId).getPreferredLocationBasedOnState();", "url": "https://github.com/apache/flink/pull/12423#discussion_r434630789", "createdAt": "2020-06-03T14:55:29Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java", "diffHunk": "@@ -229,7 +229,9 @@ public SchedulerBase(\n \t\tthis.executionGraph = createAndRestoreExecutionGraph(jobManagerJobMetricGroup, checkNotNull(shuffleMaster), checkNotNull(partitionTracker));\n \t\tthis.schedulingTopology = executionGraph.getSchedulingTopology();\n \n-\t\tthis.inputsLocationsRetriever = new ExecutionGraphToInputsLocationsRetrieverAdapter(executionGraph);\n+\t\tfinal StateLocationRetriever stateLocationRetriever = new ExecutionVertexStateLocationRetriever(this::getExecutionVertex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NjM2OA==", "bodyText": "ok.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435876368", "createdAt": "2020-06-05T12:04:55Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java", "diffHunk": "@@ -229,7 +229,9 @@ public SchedulerBase(\n \t\tthis.executionGraph = createAndRestoreExecutionGraph(jobManagerJobMetricGroup, checkNotNull(shuffleMaster), checkNotNull(partitionTracker));\n \t\tthis.schedulingTopology = executionGraph.getSchedulingTopology();\n \n-\t\tthis.inputsLocationsRetriever = new ExecutionGraphToInputsLocationsRetrieverAdapter(executionGraph);\n+\t\tfinal StateLocationRetriever stateLocationRetriever = new ExecutionVertexStateLocationRetriever(this::getExecutionVertex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDc4OQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODg1Nw==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018857", "createdAt": "2020-06-05T16:04:55Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java", "diffHunk": "@@ -229,7 +229,9 @@ public SchedulerBase(\n \t\tthis.executionGraph = createAndRestoreExecutionGraph(jobManagerJobMetricGroup, checkNotNull(shuffleMaster), checkNotNull(partitionTracker));\n \t\tthis.schedulingTopology = executionGraph.getSchedulingTopology();\n \n-\t\tthis.inputsLocationsRetriever = new ExecutionGraphToInputsLocationsRetrieverAdapter(executionGraph);\n+\t\tfinal StateLocationRetriever stateLocationRetriever = new ExecutionVertexStateLocationRetriever(this::getExecutionVertex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDc4OQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzU3MzQ4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/PreferredLocationsRetriever.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTo0OTozN1rOGeiLsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDo0N1rOGf0eRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY3MDUxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public interface PreferredLocationsRetriever {\n          \n          \n            \n            @FunctionalInterface\n          \n          \n            \n            public interface PreferredLocationsRetriever {", "url": "https://github.com/apache/flink/pull/12423#discussion_r434670512", "createdAt": "2020-06-03T15:49:37Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/PreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Component to retrieve the preferred locations of an execution vertex.\n+ */\n+public interface PreferredLocationsRetriever {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MTUxNQ==", "bodyText": "ok.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435871515", "createdAt": "2020-06-05T11:55:21Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/PreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Component to retrieve the preferred locations of an execution vertex.\n+ */\n+public interface PreferredLocationsRetriever {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY3MDUxMg=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODc1Ng==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018756", "createdAt": "2020-06-05T16:04:47Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/PreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Component to retrieve the preferred locations of an execution vertex.\n+ */\n+public interface PreferredLocationsRetriever {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY3MDUxMg=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzY0NTA2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjowMzoyMFrOGei3Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDo0MFrOGf0eAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MTYwMw==", "bodyText": "I do not quite understand why we need this static, not private method getPreferredLocationsBasedOnInputs  at the end.\nCould tests not be written against public interface method?", "url": "https://github.com/apache/flink/pull/12423#discussion_r434681603", "createdAt": "2020-06-03T16:03:20Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMjEyOA==", "bodyText": "May bad to have directly moved these code from DefaultExecutionSlotAllocator.\nWill take a look to see how to rewrite these tests.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435902128", "createdAt": "2020-06-05T12:55:26Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MTYwMw=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODY4OQ==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018689", "createdAt": "2020-06-05T16:04:40Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MTYwMw=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzY1MDQyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjowNDowN1rOGei6Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDoyN1rOGf0diA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjM5OA==", "bodyText": "we clear this collection at the end of each iteration.\nmaybe it should go inside?", "url": "https://github.com/apache/flink/pull/12423#discussion_r434682398", "createdAt": "2020-06-03T16:04:07Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NTgzMw==", "bodyText": "yeah we can do it.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435875833", "createdAt": "2020-06-05T12:03:46Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjM5OA=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODU2OA==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018568", "createdAt": "2020-06-05T16:04:27Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjM5OA=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzY1Mzg3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjowNDozOVrOGei8Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDoyMlrOGf0dYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjkxNA==", "bodyText": "Could this be a separate method?\nprivate Collection<CompletableFuture<TaskManagerLocation>> getInputLocationFutures(\n    Set<ExecutionVertexID> producersToIgnore, \n    Collection<ExecutionVertexID> producers)", "url": "https://github.com/apache/flink/pull/12423#discussion_r434682914", "createdAt": "2020-06-03T16:04:39Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();\n+\n+\t\tfinal Collection<Collection<ExecutionVertexID>> allProducers =\n+\t\t\tinputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);\n+\t\tfor (Collection<ExecutionVertexID> producers : allProducers) {\n+\n+\t\t\tfor (ExecutionVertexID producer : producers) {\n+\t\t\t\tfinal Optional<CompletableFuture<TaskManagerLocation>> optionalLocationFuture;\n+\t\t\t\tif (!producersToIgnore.contains(producer)) {\n+\t\t\t\t\toptionalLocationFuture = inputsLocationsRetriever.getTaskManagerLocation(producer);\n+\t\t\t\t} else {\n+\t\t\t\t\toptionalLocationFuture = Optional.empty();\n+\t\t\t\t}\n+\t\t\t\toptionalLocationFuture.ifPresent(locationsFutures::add);\n+\t\t\t\t// If the parallelism is large, wait for all futures coming back may cost a long time.\n+\t\t\t\tif (locationsFutures.size() > MAX_DISTINCT_LOCATIONS_TO_CONSIDER) {\n+\t\t\t\t\tlocationsFutures.clear();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDczNA==", "bodyText": "Sure. it's good to have.\nI think we can also have a separate method for location combination.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435890734", "createdAt": "2020-06-05T12:33:51Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();\n+\n+\t\tfinal Collection<Collection<ExecutionVertexID>> allProducers =\n+\t\t\tinputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);\n+\t\tfor (Collection<ExecutionVertexID> producers : allProducers) {\n+\n+\t\t\tfor (ExecutionVertexID producer : producers) {\n+\t\t\t\tfinal Optional<CompletableFuture<TaskManagerLocation>> optionalLocationFuture;\n+\t\t\t\tif (!producersToIgnore.contains(producer)) {\n+\t\t\t\t\toptionalLocationFuture = inputsLocationsRetriever.getTaskManagerLocation(producer);\n+\t\t\t\t} else {\n+\t\t\t\t\toptionalLocationFuture = Optional.empty();\n+\t\t\t\t}\n+\t\t\t\toptionalLocationFuture.ifPresent(locationsFutures::add);\n+\t\t\t\t// If the parallelism is large, wait for all futures coming back may cost a long time.\n+\t\t\t\tif (locationsFutures.size() > MAX_DISTINCT_LOCATIONS_TO_CONSIDER) {\n+\t\t\t\t\tlocationsFutures.clear();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjkxNA=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODUyOQ==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018529", "createdAt": "2020-06-05T16:04:22Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tCompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tCompletableFuture.completedFuture(Collections.emptyList());\n+\n+\t\tfinal Collection<CompletableFuture<TaskManagerLocation>> locationsFutures = new ArrayList<>();\n+\n+\t\tfinal Collection<Collection<ExecutionVertexID>> allProducers =\n+\t\t\tinputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);\n+\t\tfor (Collection<ExecutionVertexID> producers : allProducers) {\n+\n+\t\t\tfor (ExecutionVertexID producer : producers) {\n+\t\t\t\tfinal Optional<CompletableFuture<TaskManagerLocation>> optionalLocationFuture;\n+\t\t\t\tif (!producersToIgnore.contains(producer)) {\n+\t\t\t\t\toptionalLocationFuture = inputsLocationsRetriever.getTaskManagerLocation(producer);\n+\t\t\t\t} else {\n+\t\t\t\t\toptionalLocationFuture = Optional.empty();\n+\t\t\t\t}\n+\t\t\t\toptionalLocationFuture.ifPresent(locationsFutures::add);\n+\t\t\t\t// If the parallelism is large, wait for all futures coming back may cost a long time.\n+\t\t\t\tif (locationsFutures.size() > MAX_DISTINCT_LOCATIONS_TO_CONSIDER) {\n+\t\t\t\t\tlocationsFutures.clear();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjkxNA=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzY3NDE3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjowODo0M1rOGejIdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowNzozNlrOGfr3Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4NjA3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n          \n          \n            \n            \t\t\tfinal Collection<ExecutionVertexID> producersToIgnore,", "url": "https://github.com/apache/flink/pull/12423#discussion_r434686071", "createdAt": "2020-06-03T16:08:43Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NzY1OQ==", "bodyText": "I think requiring a set is better to ensure fast contains check with predictable complexity O(1).", "url": "https://github.com/apache/flink/pull/12423#discussion_r435877659", "createdAt": "2020-06-05T12:07:36Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.executiongraph.ExecutionVertex.MAX_DISTINCT_LOCATIONS_TO_CONSIDER;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link PreferredLocationsRetriever}.\n+ * Locations based on state will be returned if exist.\n+ * Otherwise locations based on inputs will be returned.\n+ */\n+public class DefaultPreferredLocationsRetriever implements PreferredLocationsRetriever {\n+\n+\tprivate final StateLocationRetriever stateLocationRetriever;\n+\n+\tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n+\n+\tDefaultPreferredLocationsRetriever(\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\n+\t\tthis.stateLocationRetriever = checkNotNull(stateLocationRetriever);\n+\t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocations(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore) {\n+\n+\t\tcheckNotNull(executionVertexId);\n+\t\tcheckNotNull(producersToIgnore);\n+\n+\t\tfinal Collection<TaskManagerLocation> preferredLocationsBasedOnState =\n+\t\t\tgetPreferredLocationsBasedOnState(executionVertexId, stateLocationRetriever);\n+\t\tif (!preferredLocationsBasedOnState.isEmpty()) {\n+\t\t\treturn CompletableFuture.completedFuture(preferredLocationsBasedOnState);\n+\t\t}\n+\n+\t\treturn getPreferredLocationsBasedOnInputs(executionVertexId, producersToIgnore, inputsLocationsRetriever);\n+\t}\n+\n+\tprivate static Collection<TaskManagerLocation> getPreferredLocationsBasedOnState(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal StateLocationRetriever stateLocationRetriever) {\n+\n+\t\treturn stateLocationRetriever.getStateLocation(executionVertexId)\n+\t\t\t.map(Collections::singleton)\n+\t\t\t.orElse(Collections.emptySet());\n+\t}\n+\n+\t/**\n+\t * Gets the location preferences of the execution, as determined by the locations\n+\t * of the predecessors from which it receives input data.\n+\t * If there are more than {@link ExecutionVertex#MAX_DISTINCT_LOCATIONS_TO_CONSIDER} different locations of source data,\n+\t * or neither the sources have not been started nor will be started with the execution together,\n+\t * this method returns an empty collection to indicate no location preference.\n+\t *\n+\t * @return The preferred locations based in input streams, or an empty iterable,\n+\t *         if there is no input-based preference.\n+\t */\n+\tstatic CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n+\t\t\tfinal ExecutionVertexID executionVertexId,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4NjA3MQ=="}, "originalCommit": {"oid": "12baef7860f623166396fd8085542f46da92415b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzcwNjY2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionVertexSchedulingRequirements.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjoxNjo1MVrOGejdZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNDowMFrOGf0cjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MTQyOA==", "bodyText": "withPreferredLocations and this.preferredLocations can be also removed", "url": "https://github.com/apache/flink/pull/12423#discussion_r434691428", "createdAt": "2020-06-03T16:16:51Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionVertexSchedulingRequirements.java", "diffHunk": "@@ -169,8 +161,7 @@ public ExecutionVertexSchedulingRequirements build() {\n \t\t\t\ttaskResourceProfile,\n \t\t\t\tphysicalSlotResourceProfile,\n \t\t\t\tslotSharingGroupId,\n-\t\t\t\tcoLocationConstraint,\n-\t\t\t\tpreferredLocations);\n+\t\t\t\tcoLocationConstraint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODMxOA==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436018318", "createdAt": "2020-06-05T16:04:00Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionVertexSchedulingRequirements.java", "diffHunk": "@@ -169,8 +161,7 @@ public ExecutionVertexSchedulingRequirements build() {\n \t\t\t\ttaskResourceProfile,\n \t\t\t\tphysicalSlotResourceProfile,\n \t\t\t\tslotSharingGroupId,\n-\t\t\t\tcoLocationConstraint,\n-\t\t\t\tpreferredLocations);\n+\t\t\t\tcoLocationConstraint);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MTQyOA=="}, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzkyMjU3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoxMzozNFrOGeloyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0ODowMVrOGftHCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNzExNQ==", "bodyText": "do we need this method calculatePreferredLocations?", "url": "https://github.com/apache/flink/pull/12423#discussion_r434727115", "createdAt": "2020-06-03T17:13:34Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -105,22 +104,11 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\t/**\n-\t * Calculates the preferred locations for an execution.\n-\t * It will first try to use preferred locations based on state,\n-\t * if null, will use the preferred locations based on inputs.\n-\t */\n-\tprotected static CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODQ0Nw==", "bodyText": "I think it's good to have to allow subclasses to not be aware of the way to retrieve preferred locations.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435878447", "createdAt": "2020-06-05T12:09:29Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -105,22 +104,11 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\t/**\n-\t * Calculates the preferred locations for an execution.\n-\t * It will first try to use preferred locations based on state,\n-\t * if null, will use the preferred locations based on inputs.\n-\t */\n-\tprotected static CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNzExNQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NzM0NQ==", "bodyText": "Alright, then I believe preferredLocationsRetriever and pendingSlotAssignments fields can be private. Also the whole AbstractExecutionSlotAllocator can be package private and its protected constructor/methods. Any reason to keep them not package private?", "url": "https://github.com/apache/flink/pull/12423#discussion_r435887345", "createdAt": "2020-06-05T12:27:15Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -105,22 +104,11 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\t/**\n-\t * Calculates the preferred locations for an execution.\n-\t * It will first try to use preferred locations based on state,\n-\t * if null, will use the preferred locations based on inputs.\n-\t */\n-\tprotected static CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNzExNQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjM1Ng==", "bodyText": "Yeah we can make it package private.\nIt is my oversight to make it public.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435896356", "createdAt": "2020-06-05T12:44:42Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -105,22 +104,11 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\t/**\n-\t * Calculates the preferred locations for an execution.\n-\t * It will first try to use preferred locations based on state,\n-\t * if null, will use the preferred locations based on inputs.\n-\t */\n-\tprotected static CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNzExNQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5ODEyMQ==", "bodyText": "This comment would be addressed in #12256 since I will rebase #12256 on this PR.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435898121", "createdAt": "2020-06-05T12:48:01Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -105,22 +104,11 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\t/**\n-\t * Calculates the preferred locations for an execution.\n-\t * It will first try to use preferred locations based on state,\n-\t * if null, will use the preferred locations based on inputs.\n-\t */\n-\tprotected static CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNzExNQ=="}, "originalCommit": {"oid": "cec2647b2ec7c33383fb0dc6010772572272b44c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTEyNTY2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoyMzo1NVrOGfsVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjoyMzoxM1rOGf1FiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NTQ4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n          \n          \n            \n            \t\texecutionVertexIds.forEach(this::cancel);\n          \n          \n            \n                    pendingSlotAssignments.keySet().forEach(this::cancel);\n          \n      \n    \n    \n  \n\nAny particular reason to use list?", "url": "https://github.com/apache/flink/pull/12423#discussion_r435885480", "createdAt": "2020-06-05T12:23:55Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+public abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\t/**\n+\t * Store the uncompleted slot assignments.\n+\t */\n+\tprotected final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprotected final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tpublic AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Void> stop() {\n+\t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n+\t\texecutionVertexIds.forEach(this::cancel);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NTIwMQ==", "bodyText": "I think not. These code were moved without a careful check.\nBut maybe we can just remove the ExecutionSlotAllocator#stop() method given that it is never used in production.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435895201", "createdAt": "2020-06-05T12:42:36Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+public abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\t/**\n+\t * Store the uncompleted slot assignments.\n+\t */\n+\tprotected final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprotected final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tpublic AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Void> stop() {\n+\t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n+\t\texecutionVertexIds.forEach(this::cancel);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NTQ4MA=="}, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkzNTE0MQ==", "bodyText": "Indeed, it looks like we could change the existing hook for tests getNumberOfPendingSlotAssignments -> getPendingSlotAssignments.", "url": "https://github.com/apache/flink/pull/12423#discussion_r435935141", "createdAt": "2020-06-05T13:52:07Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+public abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\t/**\n+\t * Store the uncompleted slot assignments.\n+\t */\n+\tprotected final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprotected final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tpublic AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Void> stop() {\n+\t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n+\t\texecutionVertexIds.forEach(this::cancel);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NTQ4MA=="}, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDM0Mg==", "bodyText": "ExecutionSlotAllocator#stop() is removed via hotfix 7a2dfb6", "url": "https://github.com/apache/flink/pull/12423#discussion_r436024342", "createdAt": "2020-06-05T16:14:54Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+public abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\t/**\n+\t * Store the uncompleted slot assignments.\n+\t */\n+\tprotected final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprotected final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tpublic AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Void> stop() {\n+\t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n+\t\texecutionVertexIds.forEach(this::cancel);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NTQ4MA=="}, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyODgwOA==", "bodyText": "I will make the change \"getNumberOfPendingSlotAssignments -> getPendingSlotAssignments\" in #12256 when introducing AbstractExecutionSlotAllocator.\nIt would be good for verifying the existence of a given assignment.", "url": "https://github.com/apache/flink/pull/12423#discussion_r436028808", "createdAt": "2020-06-05T16:23:13Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+public abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\t/**\n+\t * Store the uncompleted slot assignments.\n+\t */\n+\tprotected final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprotected final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tpublic AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Void> stop() {\n+\t\tfinal List<ExecutionVertexID> executionVertexIds = new ArrayList<>(pendingSlotAssignments.keySet());\n+\t\texecutionVertexIds.forEach(this::cancel);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NTQ4MA=="}, "originalCommit": {"oid": "362a6480b17c1133aae420e09518b08482edf7e7"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODM0MTE1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODoyODoyOFrOGhqcFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMDoyNzowN1rOGhuu_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MTUwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(\n          \n          \n            \n            \t\tfinal PreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(", "url": "https://github.com/apache/flink/pull/12423#discussion_r437951508", "createdAt": "2020-06-10T08:28:28Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests {@link DefaultPreferredLocationsRetriever}.\n+ */\n+public class DefaultPreferredLocationsRetrieverTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStateLocationsWillBeReturnedIfExist() {\n+\t\tfinal TaskManagerLocation stateLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n+\t\t\tnew TestingInputsLocationsRetriever.Builder();\n+\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tlocationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = locationRetrieverBuilder.build();\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\n+\t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b6149593a3c9e41ab8e0c2f276edfa4420bc5d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjE0Mw==", "bodyText": "Also in other tests", "url": "https://github.com/apache/flink/pull/12423#discussion_r437952143", "createdAt": "2020-06-10T08:29:31Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests {@link DefaultPreferredLocationsRetriever}.\n+ */\n+public class DefaultPreferredLocationsRetrieverTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStateLocationsWillBeReturnedIfExist() {\n+\t\tfinal TaskManagerLocation stateLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n+\t\t\tnew TestingInputsLocationsRetriever.Builder();\n+\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tlocationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = locationRetrieverBuilder.build();\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\n+\t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MTUwOA=="}, "originalCommit": {"oid": "04b6149593a3c9e41ab8e0c2f276edfa4420bc5d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAyMTg4Ng==", "bodyText": "done.", "url": "https://github.com/apache/flink/pull/12423#discussion_r438021886", "createdAt": "2020-06-10T10:27:07Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests {@link DefaultPreferredLocationsRetriever}.\n+ */\n+public class DefaultPreferredLocationsRetrieverTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStateLocationsWillBeReturnedIfExist() {\n+\t\tfinal TaskManagerLocation stateLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n+\t\t\tnew TestingInputsLocationsRetriever.Builder();\n+\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tlocationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = locationRetrieverBuilder.build();\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\n+\t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MTUwOA=="}, "originalCommit": {"oid": "04b6149593a3c9e41ab8e0c2f276edfa4420bc5d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODM2MTMxOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODozNDoxNFrOGhqpVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMDoxOToyMlrOGhufGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NDkwMQ==", "bodyText": "Should we also assert that it contains only stateLocation even if producer got a location?", "url": "https://github.com/apache/flink/pull/12423#discussion_r437954901", "createdAt": "2020-06-10T08:34:14Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests {@link DefaultPreferredLocationsRetriever}.\n+ */\n+public class DefaultPreferredLocationsRetrieverTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStateLocationsWillBeReturnedIfExist() {\n+\t\tfinal TaskManagerLocation stateLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n+\t\t\tnew TestingInputsLocationsRetriever.Builder();\n+\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tlocationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = locationRetrieverBuilder.build();\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\n+\t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(\n+\t\t\tid -> Optional.of(stateLocation),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tlocationsRetriever.getPreferredLocations(consumerId, Collections.emptySet());\n+\n+\t\tassertThat(preferredLocations.getNow(null), contains(stateLocation));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b6149593a3c9e41ab8e0c2f276edfa4420bc5d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNzgxOA==", "bodyText": "The contains matcher means it only contains elements of the given collection, in the given order.\nThe name is a bit confusing and I also misunderstood it many times.", "url": "https://github.com/apache/flink/pull/12423#discussion_r438017818", "createdAt": "2020-06-10T10:19:22Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests {@link DefaultPreferredLocationsRetriever}.\n+ */\n+public class DefaultPreferredLocationsRetrieverTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStateLocationsWillBeReturnedIfExist() {\n+\t\tfinal TaskManagerLocation stateLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n+\t\t\tnew TestingInputsLocationsRetriever.Builder();\n+\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tlocationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = locationRetrieverBuilder.build();\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\n+\t\tfinal DefaultPreferredLocationsRetriever locationsRetriever = new DefaultPreferredLocationsRetriever(\n+\t\t\tid -> Optional.of(stateLocation),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n+\t\t\tlocationsRetriever.getPreferredLocations(consumerId, Collections.emptySet());\n+\n+\t\tassertThat(preferredLocations.getNow(null), contains(stateLocation));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NDkwMQ=="}, "originalCommit": {"oid": "04b6149593a3c9e41ab8e0c2f276edfa4420bc5d"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4401, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}