{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2ODM5NTA5", "number": 11382, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNToxM1rODntgwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNTo0MTo1OVrODnuBew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTY2NzIwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNToxM1rOF13ZMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNToxM1rOF13ZMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyNjQxOA==", "bodyText": "nit: I guess we do not need this annotation. It can not be defined as private even if no tests.", "url": "https://github.com/apache/flink/pull/11382#discussion_r392026418", "createdAt": "2020-03-13T04:35:13Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.fs.CloseableRegistry;\n+import org.apache.flink.core.fs.FileSystemSafetyNet;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFinalizer;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFutures;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * This runnable executes the asynchronous parts of all involved backend snapshots for the subtask.\n+ */\n+@VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55525e050ada84dcd0e1ea935dffe3b7f09faa42"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTY2NzU3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNToyN1rOF13ZZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNToyN1rOF13ZZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyNjQ2OA==", "bodyText": "nit: remove this for consistency.", "url": "https://github.com/apache/flink/pull/11382#discussion_r392026468", "createdAt": "2020-03-13T04:35:27Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.fs.CloseableRegistry;\n+import org.apache.flink.core.fs.FileSystemSafetyNet;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFinalizer;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFutures;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * This runnable executes the asynchronous parts of all involved backend snapshots for the subtask.\n+ */\n+@VisibleForTesting\n+final class AsyncCheckpointRunnable implements Runnable, Closeable {\n+\n+\tprivate final String taskName;\n+\tprivate final CloseableRegistry closeableRegistry;\n+\tprivate final Environment taskEnvironment;\n+\n+\tprivate enum AsyncCheckpointState {\n+\t\tRUNNING,\n+\t\tDISCARDED,\n+\t\tCOMPLETED\n+\t}\n+\n+\tprivate final AsyncExceptionHandler asyncExceptionHandler;\n+\tprivate final Map<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress;\n+\tprivate final CheckpointMetaData checkpointMetaData;\n+\tprivate final CheckpointMetrics checkpointMetrics;\n+\tprivate final long asyncStartNanos;\n+\tprivate final AtomicReference<AsyncCheckpointState> asyncCheckpointState = new AtomicReference<>(AsyncCheckpointState.RUNNING);\n+\n+\tAsyncCheckpointRunnable(\n+\t\t\tMap<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress,\n+\t\t\tCheckpointMetaData checkpointMetaData,\n+\t\t\tCheckpointMetrics checkpointMetrics,\n+\t\t\tlong asyncStartNanos,\n+\t\t\tString taskName,\n+\t\t\tCloseableRegistry closeableRegistry,\n+\t\t\tEnvironment taskEnvironment,\n+\t\t\tAsyncExceptionHandler asyncExceptionHandler) {\n+\n+\t\tthis.operatorSnapshotsInProgress = checkNotNull(operatorSnapshotsInProgress);\n+\t\tthis.checkpointMetaData = checkNotNull(checkpointMetaData);\n+\t\tthis.checkpointMetrics = checkNotNull(checkpointMetrics);\n+\t\tthis.asyncStartNanos = asyncStartNanos;\n+\t\tthis.taskName = checkNotNull(taskName);\n+\t\tthis.closeableRegistry = checkNotNull(closeableRegistry);\n+\t\tthis.taskEnvironment = checkNotNull(taskEnvironment);\n+\t\tthis.asyncExceptionHandler = checkNotNull(asyncExceptionHandler);\n+\t}\n+\n+\t@Override\n+\tpublic void run() {\n+\t\tFileSystemSafetyNet.initializeSafetyNetForThread();\n+\t\ttry {\n+\t\t\tcloseableRegistry.registerCloseable(this);\n+\n+\t\t\tTaskStateSnapshot jobManagerTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\t\t\tTaskStateSnapshot localTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\n+\t\t\tfor (Map.Entry<OperatorID, OperatorSnapshotFutures> entry : operatorSnapshotsInProgress.entrySet()) {\n+\n+\t\t\t\tOperatorID operatorID = entry.getKey();\n+\t\t\t\tOperatorSnapshotFutures snapshotInProgress = entry.getValue();\n+\n+\t\t\t\t// finalize the async part of all by executing all snapshot runnables\n+\t\t\t\tOperatorSnapshotFinalizer finalizedSnapshots =\n+\t\t\t\t\tnew OperatorSnapshotFinalizer(snapshotInProgress);\n+\n+\t\t\t\tjobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getJobManagerOwnedState());\n+\n+\t\t\t\tlocalTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getTaskLocalState());\n+\t\t\t}\n+\n+\t\t\tfinal long asyncEndNanos = System.nanoTime();\n+\t\t\tfinal long asyncDurationMillis = (asyncEndNanos - asyncStartNanos) / 1_000_000L;\n+\n+\t\t\tcheckpointMetrics.setAsyncDurationMillis(asyncDurationMillis);\n+\n+\t\t\tif (asyncCheckpointState.compareAndSet(AsyncCheckpointState.RUNNING, AsyncCheckpointState.COMPLETED)) {\n+\n+\t\t\t\treportCompletedSnapshotStates(\n+\t\t\t\t\tjobManagerTaskOperatorSubtaskStates,\n+\t\t\t\t\tlocalTaskOperatorSubtaskStates,\n+\t\t\t\t\tasyncDurationMillis);\n+\n+\t\t\t} else {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed because it was closed before.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId());\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tif (StreamTask.LOG.isDebugEnabled()) {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId(),\n+\t\t\t\t\te);\n+\t\t\t}\n+\t\t\thandleExecutionException(e);\n+\t\t} finally {\n+\t\t\tcloseableRegistry.unregisterCloseable(this);\n+\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n+\t\t}\n+\t}\n+\n+\tprivate void reportCompletedSnapshotStates(\n+\t\tTaskStateSnapshot acknowledgedTaskStateSnapshot,\n+\t\tTaskStateSnapshot localTaskStateSnapshot,\n+\t\tlong asyncDurationMillis) {\n+\n+\t\tboolean hasAckState = acknowledgedTaskStateSnapshot.hasState();\n+\t\tboolean hasLocalState = localTaskStateSnapshot.hasState();\n+\n+\t\tPreconditions.checkState(hasAckState || !hasLocalState,\n+\t\t\t\"Found cached state but no corresponding primary state is reported to the job \" +\n+\t\t\t\t\"manager. This indicates a problem.\");\n+\n+\t\t// we signal stateless tasks by reporting null, so that there are no attempts to assign empty state\n+\t\t// to stateless tasks on restore. This enables simple job modifications that only concern\n+\t\t// stateless without the need to assign them uids to match their (always empty) states.\n+\t\tthis.taskEnvironment.getTaskStateManager().reportTaskStateSnapshots(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55525e050ada84dcd0e1ea935dffe3b7f09faa42"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTY2ODI3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CheckpointingOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNTo1MVrOF13ZxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNTo1MVrOF13ZxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyNjU2NQ==", "bodyText": "Also checkNotNull for other arguments?", "url": "https://github.com/apache/flink/pull/11382#discussion_r392026565", "createdAt": "2020-03-13T04:35:51Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CheckpointingOperation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.core.fs.CloseableRegistry;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.runtime.state.CheckpointStreamFactory;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFutures;\n+import org.apache.flink.streaming.api.operators.StreamOperator;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+\n+final class CheckpointingOperation {\n+\n+\tstatic void execute(\n+\t\t\tCheckpointMetaData checkpointMetaData,\n+\t\t\tCheckpointOptions checkpointOptions,\n+\t\t\tCheckpointMetrics checkpointMetrics,\n+\t\t\tCheckpointStreamFactory storageLocation,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tString taskName,\n+\t\t\tCloseableRegistry closeableRegistry,\n+\t\t\tExecutorService threadPool,\n+\t\t\tEnvironment environment,\n+\t\t\tAsyncExceptionHandler asyncExceptionHandler) throws Exception {\n+\n+\t\tPreconditions.checkNotNull(checkpointMetaData);\n+\t\tPreconditions.checkNotNull(checkpointOptions);\n+\t\tPreconditions.checkNotNull(checkpointMetrics);\n+\t\tPreconditions.checkNotNull(storageLocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55525e050ada84dcd0e1ea935dffe3b7f09faa42"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTY2ODUwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNjowMVrOF13Z5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNjowMVrOF13Z5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyNjU5Ng==", "bodyText": "nit: also make checkpointMetaData in separate line?", "url": "https://github.com/apache/flink/pull/11382#discussion_r392026596", "createdAt": "2020-03-13T04:36:01Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -928,14 +919,16 @@ private void checkpointState(\n \t\t\t\tcheckpointMetaData.getCheckpointId(),\n \t\t\t\tcheckpointOptions.getTargetLocation());\n \n-\t\tCheckpointingOperation checkpointingOperation = new CheckpointingOperation(\n-\t\t\tthis,\n-\t\t\tcheckpointMetaData,\n+\t\tCheckpointingOperation.execute(checkpointMetaData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55525e050ada84dcd0e1ea935dffe3b7f09faa42"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTY3MDIxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/LocalStateForwardingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNzozMlrOF13a5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDozNzozMlrOF13a5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyNjg1NA==", "bodyText": "nit: split line for every field.", "url": "https://github.com/apache/flink/pull/11382#discussion_r392026854", "createdAt": "2020-03-13T04:37:32Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/LocalStateForwardingTest.java", "diffHunk": "@@ -105,13 +105,12 @@ public void testReportingFromSnapshotToTaskStateManager() {\n \t\tOperatorID operatorID = new OperatorID();\n \t\tsnapshots.put(operatorID, osFuture);\n \n-\t\tStreamTask.AsyncCheckpointRunnable checkpointRunnable =\n-\t\t\tnew StreamTask.AsyncCheckpointRunnable(\n-\t\t\t\ttestStreamTask,\n+\t\tAsyncCheckpointRunnable checkpointRunnable =\n+\t\t\tnew AsyncCheckpointRunnable(\n \t\t\t\tsnapshots,\n \t\t\t\tcheckpointMetaData,\n \t\t\t\tcheckpointMetrics,\n-\t\t\t\t0L);\n+\t\t\t\t0L, testStreamTask.getName(), testStreamTask.getCancelables(), testStreamTask.getEnvironment(), testStreamTask);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55525e050ada84dcd0e1ea935dffe3b7f09faa42"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTc1MDk5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNTo0MTo1OVrOF14L2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODoyNTozNVrOF17Exg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAzOTM4Ng==", "bodyText": "Shall we pass the logger from outside instead of expose it as public/(default)?", "url": "https://github.com/apache/flink/pull/11382#discussion_r392039386", "createdAt": "2020-03-13T05:41:59Z", "author": {"login": "tisonkun"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.core.fs.CloseableRegistry;\n+import org.apache.flink.core.fs.FileSystemSafetyNet;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFinalizer;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFutures;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * This runnable executes the asynchronous parts of all involved backend snapshots for the subtask.\n+ */\n+final class AsyncCheckpointRunnable implements Runnable, Closeable {\n+\n+\tprivate final String taskName;\n+\tprivate final CloseableRegistry closeableRegistry;\n+\tprivate final Environment taskEnvironment;\n+\n+\tprivate enum AsyncCheckpointState {\n+\t\tRUNNING,\n+\t\tDISCARDED,\n+\t\tCOMPLETED\n+\t}\n+\n+\tprivate final AsyncExceptionHandler asyncExceptionHandler;\n+\tprivate final Map<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress;\n+\tprivate final CheckpointMetaData checkpointMetaData;\n+\tprivate final CheckpointMetrics checkpointMetrics;\n+\tprivate final long asyncStartNanos;\n+\tprivate final AtomicReference<AsyncCheckpointState> asyncCheckpointState = new AtomicReference<>(AsyncCheckpointState.RUNNING);\n+\n+\tAsyncCheckpointRunnable(\n+\t\t\tMap<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress,\n+\t\t\tCheckpointMetaData checkpointMetaData,\n+\t\t\tCheckpointMetrics checkpointMetrics,\n+\t\t\tlong asyncStartNanos,\n+\t\t\tString taskName,\n+\t\t\tCloseableRegistry closeableRegistry,\n+\t\t\tEnvironment taskEnvironment,\n+\t\t\tAsyncExceptionHandler asyncExceptionHandler) {\n+\n+\t\tthis.operatorSnapshotsInProgress = checkNotNull(operatorSnapshotsInProgress);\n+\t\tthis.checkpointMetaData = checkNotNull(checkpointMetaData);\n+\t\tthis.checkpointMetrics = checkNotNull(checkpointMetrics);\n+\t\tthis.asyncStartNanos = asyncStartNanos;\n+\t\tthis.taskName = checkNotNull(taskName);\n+\t\tthis.closeableRegistry = checkNotNull(closeableRegistry);\n+\t\tthis.taskEnvironment = checkNotNull(taskEnvironment);\n+\t\tthis.asyncExceptionHandler = checkNotNull(asyncExceptionHandler);\n+\t}\n+\n+\t@Override\n+\tpublic void run() {\n+\t\tFileSystemSafetyNet.initializeSafetyNetForThread();\n+\t\ttry {\n+\t\t\tcloseableRegistry.registerCloseable(this);\n+\n+\t\t\tTaskStateSnapshot jobManagerTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\t\t\tTaskStateSnapshot localTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\n+\t\t\tfor (Map.Entry<OperatorID, OperatorSnapshotFutures> entry : operatorSnapshotsInProgress.entrySet()) {\n+\n+\t\t\t\tOperatorID operatorID = entry.getKey();\n+\t\t\t\tOperatorSnapshotFutures snapshotInProgress = entry.getValue();\n+\n+\t\t\t\t// finalize the async part of all by executing all snapshot runnables\n+\t\t\t\tOperatorSnapshotFinalizer finalizedSnapshots =\n+\t\t\t\t\tnew OperatorSnapshotFinalizer(snapshotInProgress);\n+\n+\t\t\t\tjobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getJobManagerOwnedState());\n+\n+\t\t\t\tlocalTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getTaskLocalState());\n+\t\t\t}\n+\n+\t\t\tfinal long asyncEndNanos = System.nanoTime();\n+\t\t\tfinal long asyncDurationMillis = (asyncEndNanos - asyncStartNanos) / 1_000_000L;\n+\n+\t\t\tcheckpointMetrics.setAsyncDurationMillis(asyncDurationMillis);\n+\n+\t\t\tif (asyncCheckpointState.compareAndSet(AsyncCheckpointState.RUNNING, AsyncCheckpointState.COMPLETED)) {\n+\n+\t\t\t\treportCompletedSnapshotStates(\n+\t\t\t\t\tjobManagerTaskOperatorSubtaskStates,\n+\t\t\t\t\tlocalTaskOperatorSubtaskStates,\n+\t\t\t\t\tasyncDurationMillis);\n+\n+\t\t\t} else {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed because it was closed before.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId());\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tif (StreamTask.LOG.isDebugEnabled()) {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId(),\n+\t\t\t\t\te);\n+\t\t\t}\n+\t\t\thandleExecutionException(e);\n+\t\t} finally {\n+\t\t\tcloseableRegistry.unregisterCloseable(this);\n+\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n+\t\t}\n+\t}\n+\n+\tprivate void reportCompletedSnapshotStates(\n+\t\tTaskStateSnapshot acknowledgedTaskStateSnapshot,\n+\t\tTaskStateSnapshot localTaskStateSnapshot,\n+\t\tlong asyncDurationMillis) {\n+\n+\t\tboolean hasAckState = acknowledgedTaskStateSnapshot.hasState();\n+\t\tboolean hasLocalState = localTaskStateSnapshot.hasState();\n+\n+\t\tPreconditions.checkState(hasAckState || !hasLocalState,\n+\t\t\t\"Found cached state but no corresponding primary state is reported to the job \" +\n+\t\t\t\t\"manager. This indicates a problem.\");\n+\n+\t\t// we signal stateless tasks by reporting null, so that there are no attempts to assign empty state\n+\t\t// to stateless tasks on restore. This enables simple job modifications that only concern\n+\t\t// stateless without the need to assign them uids to match their (always empty) states.\n+\t\ttaskEnvironment.getTaskStateManager().reportTaskStateSnapshots(\n+\t\t\tcheckpointMetaData,\n+\t\t\tcheckpointMetrics,\n+\t\t\thasAckState ? acknowledgedTaskStateSnapshot : null,\n+\t\t\thasLocalState ? localTaskStateSnapshot : null);\n+\n+\t\tStreamTask.LOG.debug(\"{} - finished asynchronous part of checkpoint {}. Asynchronous duration: {} ms\",\n+\t\t\ttaskName, checkpointMetaData.getCheckpointId(), asyncDurationMillis);\n+\n+\t\tStreamTask.LOG.trace(\"{} - reported the following states in snapshot for checkpoint {}: {}.\",\n+\t\t\ttaskName, checkpointMetaData.getCheckpointId(), acknowledgedTaskStateSnapshot);\n+\t}\n+\n+\tprivate void handleExecutionException(Exception e) {\n+\n+\t\tboolean didCleanup = false;\n+\t\tAsyncCheckpointState currentState = asyncCheckpointState.get();\n+\n+\t\twhile (AsyncCheckpointState.DISCARDED != currentState) {\n+\n+\t\t\tif (asyncCheckpointState.compareAndSet(currentState, AsyncCheckpointState.DISCARDED)) {\n+\n+\t\t\t\tdidCleanup = true;\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tcleanup();\n+\t\t\t\t} catch (Exception cleanupException) {\n+\t\t\t\t\te.addSuppressed(cleanupException);\n+\t\t\t\t}\n+\n+\t\t\t\tException checkpointException = new Exception(\n+\t\t\t\t\t\"Could not materialize checkpoint \" + checkpointMetaData.getCheckpointId() + \" for operator \" +\n+\t\t\t\t\t\ttaskName + '.',\n+\t\t\t\t\te);\n+\n+\t\t\t\t// We only report the exception for the original cause of fail and cleanup.\n+\t\t\t\t// Otherwise this followup exception could race the original exception in failing the task.\n+\t\t\t\ttry {\n+\t\t\t\t\ttaskEnvironment.declineCheckpoint(checkpointMetaData.getCheckpointId(), checkpointException);\n+\t\t\t\t} catch (Exception unhandled) {\n+\t\t\t\t\tAsynchronousException asyncException = new AsynchronousException(unhandled);\n+\t\t\t\t\tasyncExceptionHandler.handleAsyncException(\"Failure in asynchronous checkpoint materialization\", asyncException);\n+\t\t\t\t}\n+\n+\t\t\t\tcurrentState = AsyncCheckpointState.DISCARDED;\n+\t\t\t} else {\n+\t\t\t\tcurrentState = asyncCheckpointState.get();\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!didCleanup) {\n+\t\t\tStreamTask.LOG.trace(\"Caught followup exception from a failed checkpoint thread. This can be ignored.\", e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tif (asyncCheckpointState.compareAndSet(AsyncCheckpointState.RUNNING, AsyncCheckpointState.DISCARDED)) {\n+\n+\t\t\ttry {\n+\t\t\t\tcleanup();\n+\t\t\t} catch (Exception cleanupException) {\n+\t\t\t\tStreamTask.LOG.warn(\"Could not properly clean up the async checkpoint runnable.\", cleanupException);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlogFailedCleanupAttempt();\n+\t\t}\n+\t}\n+\n+\tprivate void cleanup() throws Exception {\n+\t\tStreamTask.LOG.debug(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "823cf79209f3ee0b6a38f9a185cdd5e506f3c6ea"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4NjcyNg==", "bodyText": "It's already exposed for the other classes but yes, it's better not to use it.\nI'll change it to a private logger.", "url": "https://github.com/apache/flink/pull/11382#discussion_r392086726", "createdAt": "2020-03-13T08:25:35Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnable.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.tasks;\n+\n+import org.apache.flink.core.fs.CloseableRegistry;\n+import org.apache.flink.core.fs.FileSystemSafetyNet;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFinalizer;\n+import org.apache.flink.streaming.api.operators.OperatorSnapshotFutures;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * This runnable executes the asynchronous parts of all involved backend snapshots for the subtask.\n+ */\n+final class AsyncCheckpointRunnable implements Runnable, Closeable {\n+\n+\tprivate final String taskName;\n+\tprivate final CloseableRegistry closeableRegistry;\n+\tprivate final Environment taskEnvironment;\n+\n+\tprivate enum AsyncCheckpointState {\n+\t\tRUNNING,\n+\t\tDISCARDED,\n+\t\tCOMPLETED\n+\t}\n+\n+\tprivate final AsyncExceptionHandler asyncExceptionHandler;\n+\tprivate final Map<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress;\n+\tprivate final CheckpointMetaData checkpointMetaData;\n+\tprivate final CheckpointMetrics checkpointMetrics;\n+\tprivate final long asyncStartNanos;\n+\tprivate final AtomicReference<AsyncCheckpointState> asyncCheckpointState = new AtomicReference<>(AsyncCheckpointState.RUNNING);\n+\n+\tAsyncCheckpointRunnable(\n+\t\t\tMap<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress,\n+\t\t\tCheckpointMetaData checkpointMetaData,\n+\t\t\tCheckpointMetrics checkpointMetrics,\n+\t\t\tlong asyncStartNanos,\n+\t\t\tString taskName,\n+\t\t\tCloseableRegistry closeableRegistry,\n+\t\t\tEnvironment taskEnvironment,\n+\t\t\tAsyncExceptionHandler asyncExceptionHandler) {\n+\n+\t\tthis.operatorSnapshotsInProgress = checkNotNull(operatorSnapshotsInProgress);\n+\t\tthis.checkpointMetaData = checkNotNull(checkpointMetaData);\n+\t\tthis.checkpointMetrics = checkNotNull(checkpointMetrics);\n+\t\tthis.asyncStartNanos = asyncStartNanos;\n+\t\tthis.taskName = checkNotNull(taskName);\n+\t\tthis.closeableRegistry = checkNotNull(closeableRegistry);\n+\t\tthis.taskEnvironment = checkNotNull(taskEnvironment);\n+\t\tthis.asyncExceptionHandler = checkNotNull(asyncExceptionHandler);\n+\t}\n+\n+\t@Override\n+\tpublic void run() {\n+\t\tFileSystemSafetyNet.initializeSafetyNetForThread();\n+\t\ttry {\n+\t\t\tcloseableRegistry.registerCloseable(this);\n+\n+\t\t\tTaskStateSnapshot jobManagerTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\t\t\tTaskStateSnapshot localTaskOperatorSubtaskStates = new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n+\n+\t\t\tfor (Map.Entry<OperatorID, OperatorSnapshotFutures> entry : operatorSnapshotsInProgress.entrySet()) {\n+\n+\t\t\t\tOperatorID operatorID = entry.getKey();\n+\t\t\t\tOperatorSnapshotFutures snapshotInProgress = entry.getValue();\n+\n+\t\t\t\t// finalize the async part of all by executing all snapshot runnables\n+\t\t\t\tOperatorSnapshotFinalizer finalizedSnapshots =\n+\t\t\t\t\tnew OperatorSnapshotFinalizer(snapshotInProgress);\n+\n+\t\t\t\tjobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getJobManagerOwnedState());\n+\n+\t\t\t\tlocalTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n+\t\t\t\t\toperatorID,\n+\t\t\t\t\tfinalizedSnapshots.getTaskLocalState());\n+\t\t\t}\n+\n+\t\t\tfinal long asyncEndNanos = System.nanoTime();\n+\t\t\tfinal long asyncDurationMillis = (asyncEndNanos - asyncStartNanos) / 1_000_000L;\n+\n+\t\t\tcheckpointMetrics.setAsyncDurationMillis(asyncDurationMillis);\n+\n+\t\t\tif (asyncCheckpointState.compareAndSet(AsyncCheckpointState.RUNNING, AsyncCheckpointState.COMPLETED)) {\n+\n+\t\t\t\treportCompletedSnapshotStates(\n+\t\t\t\t\tjobManagerTaskOperatorSubtaskStates,\n+\t\t\t\t\tlocalTaskOperatorSubtaskStates,\n+\t\t\t\t\tasyncDurationMillis);\n+\n+\t\t\t} else {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed because it was closed before.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId());\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tif (StreamTask.LOG.isDebugEnabled()) {\n+\t\t\t\tStreamTask.LOG.debug(\"{} - asynchronous part of checkpoint {} could not be completed.\",\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tcheckpointMetaData.getCheckpointId(),\n+\t\t\t\t\te);\n+\t\t\t}\n+\t\t\thandleExecutionException(e);\n+\t\t} finally {\n+\t\t\tcloseableRegistry.unregisterCloseable(this);\n+\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n+\t\t}\n+\t}\n+\n+\tprivate void reportCompletedSnapshotStates(\n+\t\tTaskStateSnapshot acknowledgedTaskStateSnapshot,\n+\t\tTaskStateSnapshot localTaskStateSnapshot,\n+\t\tlong asyncDurationMillis) {\n+\n+\t\tboolean hasAckState = acknowledgedTaskStateSnapshot.hasState();\n+\t\tboolean hasLocalState = localTaskStateSnapshot.hasState();\n+\n+\t\tPreconditions.checkState(hasAckState || !hasLocalState,\n+\t\t\t\"Found cached state but no corresponding primary state is reported to the job \" +\n+\t\t\t\t\"manager. This indicates a problem.\");\n+\n+\t\t// we signal stateless tasks by reporting null, so that there are no attempts to assign empty state\n+\t\t// to stateless tasks on restore. This enables simple job modifications that only concern\n+\t\t// stateless without the need to assign them uids to match their (always empty) states.\n+\t\ttaskEnvironment.getTaskStateManager().reportTaskStateSnapshots(\n+\t\t\tcheckpointMetaData,\n+\t\t\tcheckpointMetrics,\n+\t\t\thasAckState ? acknowledgedTaskStateSnapshot : null,\n+\t\t\thasLocalState ? localTaskStateSnapshot : null);\n+\n+\t\tStreamTask.LOG.debug(\"{} - finished asynchronous part of checkpoint {}. Asynchronous duration: {} ms\",\n+\t\t\ttaskName, checkpointMetaData.getCheckpointId(), asyncDurationMillis);\n+\n+\t\tStreamTask.LOG.trace(\"{} - reported the following states in snapshot for checkpoint {}: {}.\",\n+\t\t\ttaskName, checkpointMetaData.getCheckpointId(), acknowledgedTaskStateSnapshot);\n+\t}\n+\n+\tprivate void handleExecutionException(Exception e) {\n+\n+\t\tboolean didCleanup = false;\n+\t\tAsyncCheckpointState currentState = asyncCheckpointState.get();\n+\n+\t\twhile (AsyncCheckpointState.DISCARDED != currentState) {\n+\n+\t\t\tif (asyncCheckpointState.compareAndSet(currentState, AsyncCheckpointState.DISCARDED)) {\n+\n+\t\t\t\tdidCleanup = true;\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tcleanup();\n+\t\t\t\t} catch (Exception cleanupException) {\n+\t\t\t\t\te.addSuppressed(cleanupException);\n+\t\t\t\t}\n+\n+\t\t\t\tException checkpointException = new Exception(\n+\t\t\t\t\t\"Could not materialize checkpoint \" + checkpointMetaData.getCheckpointId() + \" for operator \" +\n+\t\t\t\t\t\ttaskName + '.',\n+\t\t\t\t\te);\n+\n+\t\t\t\t// We only report the exception for the original cause of fail and cleanup.\n+\t\t\t\t// Otherwise this followup exception could race the original exception in failing the task.\n+\t\t\t\ttry {\n+\t\t\t\t\ttaskEnvironment.declineCheckpoint(checkpointMetaData.getCheckpointId(), checkpointException);\n+\t\t\t\t} catch (Exception unhandled) {\n+\t\t\t\t\tAsynchronousException asyncException = new AsynchronousException(unhandled);\n+\t\t\t\t\tasyncExceptionHandler.handleAsyncException(\"Failure in asynchronous checkpoint materialization\", asyncException);\n+\t\t\t\t}\n+\n+\t\t\t\tcurrentState = AsyncCheckpointState.DISCARDED;\n+\t\t\t} else {\n+\t\t\t\tcurrentState = asyncCheckpointState.get();\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!didCleanup) {\n+\t\t\tStreamTask.LOG.trace(\"Caught followup exception from a failed checkpoint thread. This can be ignored.\", e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tif (asyncCheckpointState.compareAndSet(AsyncCheckpointState.RUNNING, AsyncCheckpointState.DISCARDED)) {\n+\n+\t\t\ttry {\n+\t\t\t\tcleanup();\n+\t\t\t} catch (Exception cleanupException) {\n+\t\t\t\tStreamTask.LOG.warn(\"Could not properly clean up the async checkpoint runnable.\", cleanupException);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlogFailedCleanupAttempt();\n+\t\t}\n+\t}\n+\n+\tprivate void cleanup() throws Exception {\n+\t\tStreamTask.LOG.debug(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAzOTM4Ng=="}, "originalCommit": {"oid": "823cf79209f3ee0b6a38f9a185cdd5e506f3c6ea"}, "originalPosition": 223}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 762, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}