{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0Nzk0NzQw", "number": 13508, "title": "[FLINK-19308][coordination] Add SlotTracker ", "bodyText": "Adds the SlotTracker, a component of the declarative slot manager that tracks task executor slots.\nThis PR contains a few preparatory commits:\n\nThe (Slot)State is now a top-level class, because we are about to add a new kind of slot data structure (trimmed down version of TaskManagerSlot), and it would be good to re-use this enum.\nAdd a default implementation for TaskManagerSlotInformation#isMatchingRequirement; this method is fairly uninteresting and no implementation should require a different one. Mostly added so we don't have to duplicate code for the new slot implementation.\nAdd TaskExecutorConnection to TaskManagerSlotInformation: The TaskManagerSlotInformation is an abstraction over slots, but was lacking a crucial piece to allow the slot manager to operate solely on these information objects. With the TaskExecutorConnection added to the interface the slot implementations can now be a fully hidden from the slot manager.\n\nFinally, onto the main commit:\nDeclarativeTaskManagerSlot: Contains the information necessary for allocating the slot, and a state machine. It is a heavily trimmed down version of the TaskManagerSlot for the declarative resource management. Most notable it is not aware of pending slots (which leaks details for how task executors are allocated) nor allocation futures (which leaks details for how slots are assigned and how the RPC system works).\nFurthermore it enforces a strict slot life-cycle:\nFREE -> Pending -> Allocated -> FREE\n                |> FREE\n\nSlotStatusUpdateListener: A listener interface for slot status notifications, send out by the SlotTracker. This only includes changes in slot states; there are no notifications for added/removed slots (due to there being no need for it). This interface will be used by the slot manager to keep multiple data-structures up to date, including (but not limited to) the ResourceTracker (FLINK-19307) and TaskExecutorAllocater(FLINK-19309).\nSlotTracker: Tracks slots and their state, the main purposes being to tell which slots are free and informing other components about status updates. It is informed by the slot manager whenever slots are added/removed or when the state of a slot changes, be it either due to the slot manager initiating slot allocations or the task executor reporting about the slot statuses. This component is generally not aware of task executors however, essentially acting as a pool of slots.\nThere are 2 code paths for status updates:\n\nthe slot manager executes state transitions when starting/finishing/cancelling slot allocated. These transitions must follow the strict life-cycle of the DeclarativeTaskManagerSlot (any failure to do is is likely a bug)\nthe task executor report the status of all slots, which are treated as the source of truth. On a high-level these transitions may be illegal (e.g., a slot tracked as FREE being reported as allocated). Such transitions reconciled with the currently tracked state by the SlotStatusStateReconciler in the DefaultSlotTracker.", "createdAt": "2020-09-29T12:30:40Z", "url": "https://github.com/apache/flink/pull/13508", "merged": true, "mergeCommit": {"oid": "d196b396c685e0c7de207b283acf34de078fdf43"}, "closed": true, "closedAt": "2020-10-06T14:16:06Z", "author": {"login": "zentol"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNlS7ogH2gAyNDk0Nzk0NzQwOjJkOTNmYjQ1NDgxMDI3YzNiNjg2MzUzZWUzMTVkN2QyZTU2ODc2NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP5EPNgBqjM4NDU2OTc2MTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2d93fb45481027c3b686353ee315d7d2e5687666", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/2d93fb45481027c3b686353ee315d7d2e5687666", "committedDate": "2020-09-29T10:05:25Z", "message": "[FLINK-19308][coordination] (Slot)State as top-level class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "200ab7a50f03dec0fe7bdbe2ca8e358ac59c5494", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/200ab7a50f03dec0fe7bdbe2ca8e358ac59c5494", "committedDate": "2020-09-29T10:05:25Z", "message": "[FLINK-19308][coordination] Add default TMSlotInformation#isMatchingRequirement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0118a55e59ad2362af363ee9dd0132d6bbcb6fd8", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/0118a55e59ad2362af363ee9dd0132d6bbcb6fd8", "committedDate": "2020-09-29T10:05:26Z", "message": "[FLINK-19308][coordination] Add TEConnection to TMSlotInformation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwOTYyNDA1", "url": "https://github.com/apache/flink/pull/13508#pullrequestreview-500962405", "createdAt": "2020-10-02T08:49:06Z", "commit": {"oid": "7e7e625020d95393f6ba8473cf40ba6773fc08e5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwODo0OTowN1rOHbl6mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwODo0OTowN1rOHbl6mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5NDgwOQ==", "bodyText": "it would be a lot nicer for testing if listeners could be registered after the tracker was created; it would make it easier to inject a custom tracker into the slot manager.", "url": "https://github.com/apache/flink/pull/13508#discussion_r498694809", "createdAt": "2020-10-02T08:49:07Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Default SlotTracker implementation.\n+ */\n+class DefaultSlotTracker implements SlotTracker {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultSlotTracker.class);\n+\n+\t/**\n+\t * Map for all registered slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> slots = new HashMap<>();\n+\n+\t/**\n+\t * Index of all currently free slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> freeSlots = new LinkedHashMap<>();\n+\n+\tprivate final SlotStatusUpdateListener slotStatusUpdateListener;\n+\n+\tprivate final SlotStatusStateReconciler slotStatusStateReconciler = new SlotStatusStateReconciler(this::transitionSlotToFree, this::transitionSlotToPending, this::transitionSlotToAllocated);\n+\n+\tpublic DefaultSlotTracker(SlotStatusUpdateListener slotStatusUpdateListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7e625020d95393f6ba8473cf40ba6773fc08e5"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDI2NzE2", "url": "https://github.com/apache/flink/pull/13508#pullrequestreview-502026716", "createdAt": "2020-10-05T12:56:50Z", "commit": {"oid": "bc7dd7cf9f5876dbd7b99b9f1860647448418577"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMjo1Njo1MVrOHcbyRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzoxMzozNVrOHccbaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NzQxMw==", "bodyText": "Does it make a difference whether slotStatusUpdateListener.notifySlotStatusChange is called before effectuating the state change on slot? I am asking because transitionSlotToPending and transitionSlotToFree do it in the different order.", "url": "https://github.com/apache/flink/pull/13508#discussion_r499577413", "createdAt": "2020-10-05T12:56:51Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Default SlotTracker implementation.\n+ */\n+class DefaultSlotTracker implements SlotTracker {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultSlotTracker.class);\n+\n+\t/**\n+\t * Map for all registered slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> slots = new HashMap<>();\n+\n+\t/**\n+\t * Index of all currently free slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> freeSlots = new LinkedHashMap<>();\n+\n+\tprivate final SlotStatusUpdateListener slotStatusUpdateListener;\n+\n+\tprivate final SlotStatusStateReconciler slotStatusStateReconciler = new SlotStatusStateReconciler(this::transitionSlotToFree, this::transitionSlotToPending, this::transitionSlotToAllocated);\n+\n+\tpublic DefaultSlotTracker(SlotStatusUpdateListener slotStatusUpdateListener) {\n+\t\tthis.slotStatusUpdateListener = Preconditions.checkNotNull(slotStatusUpdateListener);\n+\t}\n+\n+\t@Override\n+\tpublic void addSlot(\n+\t\tSlotID slotId,\n+\t\tResourceProfile resourceProfile,\n+\t\tTaskExecutorConnection taskManagerConnection,\n+\t\t@Nullable JobID assignedJob) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tPreconditions.checkNotNull(taskManagerConnection);\n+\n+\t\tif (slots.containsKey(slotId)) {\n+\t\t\t// remove the old slot first\n+\t\t\tLOG.debug(\"A slot was added with an already tracked slot ID {}. Removing previous entry.\", slotId);\n+\t\t\tremoveSlot(slotId);\n+\t\t}\n+\n+\t\tDeclarativeTaskManagerSlot slot = new DeclarativeTaskManagerSlot(slotId, resourceProfile, taskManagerConnection);\n+\t\tslots.put(slotId, slot);\n+\t\tfreeSlots.put(slotId, slot);\n+\t\tslotStatusStateReconciler.executeStateTransition(slot, assignedJob);\n+\t}\n+\n+\t@Override\n+\tpublic void removeSlots(Iterable<SlotID> slotsToRemove) {\n+\t\tPreconditions.checkNotNull(slotsToRemove);\n+\n+\t\tfor (SlotID slotId : slotsToRemove) {\n+\t\t\tremoveSlot(slotId);\n+\t\t}\n+\t}\n+\n+\tprivate void removeSlot(SlotID slotId) {\n+\t\tDeclarativeTaskManagerSlot slot = slots.remove(slotId);\n+\n+\t\tif (slot != null) {\n+\t\t\tif (slot.getState() != SlotState.FREE) {\n+\t\t\t\ttransitionSlotToFree(slot);\n+\t\t\t}\n+\t\t\tfreeSlots.remove(slotId);\n+\t\t} else {\n+\t\t\tLOG.debug(\"There was no slot registered with slot id {}.\", slotId);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// ResourceManager slot status API - optimistically trigger transitions, but they may not represent true state on task executors\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void notifyFree(SlotID slotId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\ttransitionSlotToFree(slots.get(slotId));\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAllocationStart(SlotID slotId, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\ttransitionSlotToPending(slots.get(slotId), jobId);\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAllocationComplete(SlotID slotId, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\ttransitionSlotToAllocated(slots.get(slotId), jobId);\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// TaskExecutor slot status API - acts as source of truth\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void notifySlotStatus(Iterable<SlotStatus> slotStatuses) {\n+\t\tPreconditions.checkNotNull(slotStatuses);\n+\t\tfor (SlotStatus slotStatus : slotStatuses) {\n+\t\t\tslotStatusStateReconciler.executeStateTransition(slots.get(slotStatus.getSlotID()), slotStatus.getJobID());\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Core state transitions\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void transitionSlotToFree(DeclarativeTaskManagerSlot slot) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() != SlotState.FREE);\n+\n+\t\t// remember the slots current job and state for the notification, as this information will be cleared from\n+\t\t// the slot upon freeing\n+\t\tfinal JobID jobId = slot.getJobId();\n+\t\tfinal SlotState state = slot.getState();\n+\n+\t\tslot.freeSlot();\n+\t\tfreeSlots.put(slot.getSlotId(), slot);\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, state, SlotState.FREE, jobId);\n+\t}\n+\n+\tprivate void transitionSlotToPending(DeclarativeTaskManagerSlot slot, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() == SlotState.FREE);\n+\n+\t\tslot.startAllocation(jobId);\n+\t\tfreeSlots.remove(slot.getSlotId());\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, SlotState.FREE, SlotState.PENDING, jobId);\n+\t}\n+\n+\tprivate void transitionSlotToAllocated(DeclarativeTaskManagerSlot slot, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() == SlotState.PENDING);\n+\t\tPreconditions.checkState(jobId.equals(slot.getJobId()));\n+\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, SlotState.PENDING, SlotState.ALLOCATED, jobId);\n+\t\tslot.completeAllocation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7dd7cf9f5876dbd7b99b9f1860647448418577"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTQ4NQ==", "bodyText": "maybe spell out what the initial behaviour is. For someone not having written this code, this might not be obvious.", "url": "https://github.com/apache/flink/pull/13508#discussion_r499579485", "createdAt": "2020-10-05T12:59:52Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTrackerTest.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Queue;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DefaultSlotTracker}.\n+ */\n+public class DefaultSlotTrackerTest extends TestLogger {\n+\n+\tprivate static final TaskExecutorConnection TASK_EXECUTOR_CONNECTION = new TaskExecutorConnection(\n+\t\tResourceID.generate(),\n+\t\tnew TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway());\n+\n+\tprivate static final JobID jobId = new JobID();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7dd7cf9f5876dbd7b99b9f1860647448418577"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzE3Mg==", "bodyText": "I think I would split these blocks into separate test methods.", "url": "https://github.com/apache/flink/pull/13508#discussion_r499583172", "createdAt": "2020-10-05T13:05:47Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTrackerTest.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Queue;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DefaultSlotTracker}.\n+ */\n+public class DefaultSlotTrackerTest extends TestLogger {\n+\n+\tprivate static final TaskExecutorConnection TASK_EXECUTOR_CONNECTION = new TaskExecutorConnection(\n+\t\tResourceID.generate(),\n+\t\tnew TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway());\n+\n+\tprivate static final JobID jobId = new JobID();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotAddition() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\tassertThat(tracker.getFreeSlots(), containsInAnyOrder(Arrays.asList(infoWithSlotId(slotId1), infoWithSlotId(slotId2))));\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotRemoval() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tDefaultSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\t\tSlotID slotId3 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 2);\n+\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId3, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId2, jobId);\n+\t\ttracker.notifyAllocationStart(slotId3, jobId);\n+\t\ttracker.notifyAllocationComplete(slotId3, jobId);\n+\n+\t\t// the transitions to this point are not relevant for this test\n+\t\tstateTransitions.clear();\n+\t\t// we now have 1 slot in each slot state (free, pending, allocated)\n+\t\t// it should be possible to remove slots regardless of their state\n+\t\ttracker.removeSlots(Arrays.asList(slotId1, slotId2, slotId3));\n+\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(tracker.areMapsEmpty(), is(true));\n+\n+\t\tassertThat(stateTransitions, containsInAnyOrder(\n+\t\t\tnew SlotStateTransition(slotId2, SlotState.PENDING, SlotState.FREE, jobId),\n+\t\t\tnew SlotStateTransition(slotId3, SlotState.ALLOCATED, SlotState.FREE, jobId)\n+\t\t));\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCompletion() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.FREE, SlotState.PENDING, jobId)));\n+\n+\t\ttracker.notifyAllocationComplete(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.PENDING, SlotState.ALLOCATED, jobId)));\n+\n+\t\ttracker.notifyFree(slotId);\n+\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId)));\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.ALLOCATED, SlotState.FREE, jobId)));\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCompletionForDifferentJobThrowsIllegalStateException() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, new JobID());\n+\t\ttry {\n+\t\t\ttracker.notifyAllocationComplete(slotId, new JobID());\n+\t\t\tfail(\"Allocations must not be completed for a different job ID.\");\n+\t\t} catch (IllegalStateException expected) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCancellation() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.FREE, SlotState.PENDING, jobId)));\n+\n+\t\ttracker.notifyFree(slotId);\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId)));\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.PENDING, SlotState.FREE, jobId)));\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotStatusProcessing() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\t\tSlotID slotId3 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 2);\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId3, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, jobId);\n+\n+\t\tassertThat(tracker.getFreeSlots(), containsInAnyOrder(Arrays.asList(infoWithSlotId(slotId1), infoWithSlotId(slotId2))));\n+\n+\t\t// move slot2 to PENDING\n+\t\ttracker.notifyAllocationStart(slotId2, jobId);\n+\n+\t\ttracker.notifySlotStatus(Arrays.asList(\n+\t\t\tnew SlotStatus(slotId1, ResourceProfile.ANY, jobId, new AllocationID()),\n+\t\t\tnew SlotStatus(slotId2, ResourceProfile.ANY, null, new AllocationID()),\n+\t\t\tnew SlotStatus(slotId3, ResourceProfile.ANY, null, new AllocationID())));\n+\n+\t\t// slot1 should now be allocated; slot2 should continue to be in a pending state; slot3 should be freed\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId3)));\n+\n+\t\t// if slot2 is not in a pending state, this will fail with an exception\n+\t\ttracker.notifyAllocationComplete(slotId2, jobId);\n+\t}\n+\n+\t/**\n+\t * Tests all state transitions that could (or should not) occur due to a slot status update. This test only checks\n+\t * the target state and job ID for state transitions, because the slot ID is not interesting and the slot state\n+\t * is not *actually* being updated. We assume the reconciler locks in a set of transitions given a source and target\n+\t * state, without worrying about the correctness of intermediate steps (because it shouldn't; and it would be a bit\n+\t * annoying to setup).\n+\t */\n+\t@Test\n+\tpublic void testSlotStatusReconciliation() {\n+\t\tJobID jobId1 = new JobID();\n+\t\tJobID jobId2 = new JobID();\n+\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\n+\t\tDefaultSlotTracker.SlotStatusStateReconciler reconciler = new DefaultSlotTracker.SlotStatusStateReconciler(\n+\t\t\tslot -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.FREE, slot.getJobId())),\n+\t\t\t(slot, jobID) -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.PENDING, jobID)),\n+\t\t\t(slot, jobID) -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.ALLOCATED, jobID)));\n+\n+\t\t{// free slot\n+\t\t\tDeclarativeTaskManagerSlot slot = new DeclarativeTaskManagerSlot(new SlotID(ResourceID.generate(), 0), ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION);\n+\n+\t\t\treconciler.executeStateTransition(slot, null);\n+\t\t\tassertThat(stateTransitions, empty());\n+\n+\t\t\treconciler.executeStateTransition(slot, jobId1);\n+\t\t\tassertThat(stateTransitions.remove(), is(transitionWithTargetStateForJob(SlotState.PENDING, jobId1)));\n+\t\t\tassertThat(stateTransitions.remove(), is(transitionWithTargetStateForJob(SlotState.ALLOCATED, jobId1)));\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7dd7cf9f5876dbd7b99b9f1860647448418577"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NjM1MA==", "bodyText": "Do we know why this test is untable?", "url": "https://github.com/apache/flink/pull/13508#discussion_r499586350", "createdAt": "2020-10-05T13:11:04Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java", "diffHunk": "@@ -343,6 +344,7 @@ public void testRunningJobsRegistryCleanup() throws Exception {\n \t * before a new job with the same {@link JobID} is started.\n \t */\n \t@Test\n+\t@Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7e625020d95393f6ba8473cf40ba6773fc08e5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4Nzk0NA==", "bodyText": "Is it because now we need to introduce a factory to introduce a custom tracker into the SlotManager?", "url": "https://github.com/apache/flink/pull/13508#discussion_r499587944", "createdAt": "2020-10-05T13:13:35Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Default SlotTracker implementation.\n+ */\n+class DefaultSlotTracker implements SlotTracker {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultSlotTracker.class);\n+\n+\t/**\n+\t * Map for all registered slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> slots = new HashMap<>();\n+\n+\t/**\n+\t * Index of all currently free slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> freeSlots = new LinkedHashMap<>();\n+\n+\tprivate final SlotStatusUpdateListener slotStatusUpdateListener;\n+\n+\tprivate final SlotStatusStateReconciler slotStatusStateReconciler = new SlotStatusStateReconciler(this::transitionSlotToFree, this::transitionSlotToPending, this::transitionSlotToAllocated);\n+\n+\tpublic DefaultSlotTracker(SlotStatusUpdateListener slotStatusUpdateListener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5NDgwOQ=="}, "originalCommit": {"oid": "7e7e625020d95393f6ba8473cf40ba6773fc08e5"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTc3NDAw", "url": "https://github.com/apache/flink/pull/13508#pullrequestreview-502977400", "createdAt": "2020-10-06T13:43:46Z", "commit": {"oid": "7bad74a7405f33d6ed8fd9ba7e9741be89406658"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad2d4b6441c8842a107b71782cb7bee18b583942", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/ad2d4b6441c8842a107b71782cb7bee18b583942", "committedDate": "2020-10-06T14:15:04Z", "message": "[FLINK-19308][coordination] Add SlotTracker"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7bad74a7405f33d6ed8fd9ba7e9741be89406658", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/7bad74a7405f33d6ed8fd9ba7e9741be89406658", "committedDate": "2020-10-06T09:00:30Z", "message": "listeners registered after construction; test notification order"}, "afterCommit": {"oid": "ad2d4b6441c8842a107b71782cb7bee18b583942", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/ad2d4b6441c8842a107b71782cb7bee18b583942", "committedDate": "2020-10-06T14:15:04Z", "message": "[FLINK-19308][coordination] Add SlotTracker"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3506, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}