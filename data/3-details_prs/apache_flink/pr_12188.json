{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4OTIwOTMz", "number": 12188, "title": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser", "bodyText": "What is the purpose of the change\n*currently, all statements in sql client are parsed via regex matching, which has many limitations, such as it can't handle comments. To avoid that limitations, we should try best to use sql parser to parse a statement. There are many statement can't be handle by sql parser, such as: set, reset. So they are still handle through regex matching.\nstatements handled through regex matching:\nquit, exit, clear, help, desc, explain, set, reset source, show modules\nstatements handled through sql parser:\nshow catalogs, show databases, show tables, show functions, use catalog, use, describe, explain plan for, select, insert, DDLs*\nBrief change log\n\nSqlCommandParser parses a statement via sql parse, and then via regex matching\n\nVerifying this change\nThis change added tests and can be verified as follows:\n\nextended SqlCommandParserTest to verify all cases\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-05-16T05:58:18Z", "url": "https://github.com/apache/flink/pull/12188", "merged": true, "mergeCommit": {"oid": "1c810e412bda53958f57f9e13d85e5a149baacba"}, "closed": true, "closedAt": "2020-05-19T10:39:40Z", "author": {"login": "godfreyhe"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchwQ2jABqjMzNDMyNTk2MzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABciyEGFAFqTQxNDMxODY1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c78d306e0f3495d64334c03d35308b2bbe231630", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/c78d306e0f3495d64334c03d35308b2bbe231630", "committedDate": "2020-05-16T05:21:33Z", "message": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser"}, "afterCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "committedDate": "2020-05-16T05:58:59Z", "message": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDU5OTI0", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-413059924", "createdAt": "2020-05-16T08:41:57Z", "commit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODo0MTo1N1rOGWZIKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODo1ODo0NFrOGWZNjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzU0NQ==", "bodyText": "Mark both operands as nullable.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426133545", "createdAt": "2020-05-16T08:41:57Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -194,6 +283,11 @@ private SqlCommandParser() {\n \t\tpublic final Pattern pattern;\n \t\tpublic final Function<String[], Optional<String[]>> operandConverter;\n \n+\t\tSqlCommand() {\n+\t\t\tthis.pattern = null;\n+\t\t\tthis.operandConverter = null;\n+\t\t}\n+\n \t\tSqlCommand(String matchingRegex, Function<String[], Optional<String[]>> operandConverter) {\n \t\t\tthis.pattern = Pattern.compile(matchingRegex, DEFAULT_PATTERN_FLAGS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzY4MQ==", "bodyText": "We should use equals instead of != to compare the operands.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426133681", "createdAt": "2020-05-16T08:43:32Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -207,6 +301,10 @@ public String toString() {\n \t\tpublic boolean hasOperands() {\n \t\t\treturn operandConverter != NO_OPERANDS;\n \t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDAzMQ==", "bodyText": "Move the whole if else block to a single class named OperationToSqlCommandConverter ? We also need to add tests for the mapping.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134031", "createdAt": "2020-05-16T08:47:10Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParserFunction, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t}\n+\n+\t\t// parse statement via regex match\n \t\tfor (SqlCommand cmd : SqlCommand.values()) {\n-\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n-\t\t\tif (matcher.matches()) {\n-\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n-\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n-\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\tif (cmd.hasRegexPattern()) {\n+\t\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n+\t\t\t\tif (matcher.matches()) {\n+\t\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n+\t\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n+\t\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn cmd.operandConverter.apply(groups)\n+\t\t\t\t\t\t\t.map((operands) -> {\n+\t\t\t\t\t\t\t\tString[] newOperands = operands;\n+\t\t\t\t\t\t\t\tif (cmd == SqlCommand.EXPLAIN) {\n+\t\t\t\t\t\t\t\t\t// convert `explain xx` to `explain plan for xx`\n+\t\t\t\t\t\t\t\t\tnewOperands = new String[] { \"EXPLAIN PLAN FOR \" + operands[0] };\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\treturn new SqlCommandCall(cmd, newOperands);\n+\t\t\t\t\t\t\t});\n \t\t\t\t}\n-\t\t\t\treturn cmd.operandConverter.apply(groups)\n-\t\t\t\t\t.map((operands) -> new SqlCommandCall(cmd, operands));\n \t\t\t}\n \t\t}\n \t\treturn Optional.empty();\n \t}\n \n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(\n+\t\t\tFunction<String, List<Operation>> sqlParserFunction, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParserFunction.apply(stmt);\n+\t\t} catch (SqlExecutionException e) {\n+\t\t\tif (e.getCause() instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDE5OA==", "bodyText": "It is hacky to support a non-common syntax and replace it silently, i think support EXPLAIN PLAN FOR is enough.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134198", "createdAt": "2020-05-16T08:49:11Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParserFunction, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t}\n+\n+\t\t// parse statement via regex match\n \t\tfor (SqlCommand cmd : SqlCommand.values()) {\n-\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n-\t\t\tif (matcher.matches()) {\n-\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n-\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n-\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\tif (cmd.hasRegexPattern()) {\n+\t\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n+\t\t\t\tif (matcher.matches()) {\n+\t\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n+\t\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n+\t\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn cmd.operandConverter.apply(groups)\n+\t\t\t\t\t\t\t.map((operands) -> {\n+\t\t\t\t\t\t\t\tString[] newOperands = operands;\n+\t\t\t\t\t\t\t\tif (cmd == SqlCommand.EXPLAIN) {\n+\t\t\t\t\t\t\t\t\t// convert `explain xx` to `explain plan for xx`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDc4OA==", "bodyText": "How about we just split 2 methods parseByExecutor and parseByCli, parse a function here seems weird, because the first operand of the sqlParserFunction  is just the stmt.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134788", "createdAt": "2020-05-16T08:56:38Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDkyNA==", "bodyText": "It's a ParserUtils but why we register table there ?", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134924", "createdAt": "2020-05-16T08:58:44Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/utils/ParserUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.client.cli.utils;\n+\n+import org.apache.flink.table.api.EnvironmentSettings;\n+import org.apache.flink.table.api.TableEnvironment;\n+import org.apache.flink.table.api.internal.TableEnvironmentInternal;\n+import org.apache.flink.table.client.gateway.SqlExecutionException;\n+import org.apache.flink.table.operations.Operation;\n+\n+import java.util.List;\n+\n+/**\n+ * An utility class that provides abilities to parse sql statements.\n+ */\n+public class ParserUtils {\n+\n+\tprivate static final TableEnvironment tableEnv = TableEnvironment.create(EnvironmentSettings.newInstance().build());\n+\n+\tstatic {\n+\t\ttableEnv.executeSql(\"create table MyTable (a int, b bigint, c varchar(32)) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");\n+\t\ttableEnv.executeSql(\"create table MyOtherTable (a int, b bigint) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjMwNDA5", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-413230409", "createdAt": "2020-05-18T01:54:13Z", "commit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1NDoxNFrOGWldqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1NDoxNFrOGWldqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTY1Ng==", "bodyText": "return Optional.empty(); directly.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426335656", "createdAt": "2020-05-18T01:54:14Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,24 +61,130 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Parser sqlParser, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParser, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t} else {\n+\t\t\treturn parseByRegexMatching(stmt);\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(Parser sqlParser, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParser.parse(stmt);\n+\t\t} catch (Throwable e) {\n+\t\t\tif (e instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow new SqlExecutionException(\"Invalidate SQL statement.\", e);\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };\n+\t\t} else if (operation instanceof UseDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.USE;\n+\t\t\tUseDatabaseOperation op = ((UseDatabaseOperation) operation);\n+\t\t\toperands = new String[] { String.format(\"`%s`.`%s`\", op.getCatalogName(), op.getDatabaseName()) };\n+\t\t} else if (operation instanceof ShowCatalogsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_CATALOGS;\n+\t\t} else if (operation instanceof ShowDatabasesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_DATABASES;\n+\t\t} else if (operation instanceof ShowTablesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_TABLES;\n+\t\t} else if (operation instanceof ShowFunctionsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_FUNCTIONS;\n+\t\t} else if (operation instanceof ExplainOperation) {\n+\t\t\tcmd = SqlCommand.EXPLAIN;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DescribeTableOperation) {\n+\t\t\tcmd = SqlCommand.DESCRIBE;\n+\t\t\toperands = new String[] { ((DescribeTableOperation) operation).getSqlIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof QueryOperation) {\n+\t\t\tcmd = SqlCommand.SELECT;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else {\n+\t\t\tcmd = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjMwNTM3", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-413230537", "createdAt": "2020-05-18T01:54:55Z", "commit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1NDo1NVrOGWleFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1NDo1NVrOGWleFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTc2Nw==", "bodyText": "Most of the operations has the same operands new String[] { stmt }; can we merge the handling of them ?", "url": "https://github.com/apache/flink/pull/12188#discussion_r426335767", "createdAt": "2020-05-18T01:54:55Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,24 +61,130 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Parser sqlParser, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParser, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t} else {\n+\t\t\treturn parseByRegexMatching(stmt);\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(Parser sqlParser, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParser.parse(stmt);\n+\t\t} catch (Throwable e) {\n+\t\t\tif (e instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow new SqlExecutionException(\"Invalidate SQL statement.\", e);\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };\n+\t\t} else if (operation instanceof UseDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.USE;\n+\t\t\tUseDatabaseOperation op = ((UseDatabaseOperation) operation);\n+\t\t\toperands = new String[] { String.format(\"`%s`.`%s`\", op.getCatalogName(), op.getDatabaseName()) };\n+\t\t} else if (operation instanceof ShowCatalogsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_CATALOGS;\n+\t\t} else if (operation instanceof ShowDatabasesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_DATABASES;\n+\t\t} else if (operation instanceof ShowTablesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_TABLES;\n+\t\t} else if (operation instanceof ShowFunctionsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_FUNCTIONS;\n+\t\t} else if (operation instanceof ExplainOperation) {\n+\t\t\tcmd = SqlCommand.EXPLAIN;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DescribeTableOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjMzMzQw", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-413233340", "createdAt": "2020-05-18T02:09:02Z", "commit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjowOTowMlrOGWlnMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjowOTo1NFrOGWlnvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODA5OQ==", "bodyText": "Can invoke registerTable(String createTableStmt) instead.", "url": "https://github.com/apache/flink/pull/12188#discussion_r426338099", "createdAt": "2020-05-18T02:09:02Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/utils/SqlParserHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.client.cli.utils;\n+\n+import org.apache.flink.table.api.EnvironmentSettings;\n+import org.apache.flink.table.api.TableEnvironment;\n+import org.apache.flink.table.api.internal.TableEnvironmentInternal;\n+import org.apache.flink.table.delegation.Parser;\n+\n+/**\n+ * An utility class that provides pre-prepared tables and sql parser.\n+ */\n+public class SqlParserHelper {\n+\t// return the sql parser instance hold by this table evn.\n+\tprivate final TableEnvironment tableEnv;\n+\n+\tpublic SqlParserHelper() {\n+\t\ttableEnv = TableEnvironment.create(EnvironmentSettings.newInstance().build());\n+\t}\n+\n+\t/**\n+\t * prepare some tables for testing.\n+\t */\n+\tpublic void registerTables() {\n+\t\ttableEnv.executeSql(\"create table MyTable (a int, b bigint, c varchar(32)) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODIzOA==", "bodyText": "Why drop the SELEC completion test ?", "url": "https://github.com/apache/flink/pull/12188#discussion_r426338238", "createdAt": "2020-05-18T02:09:54Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/CliClientTest.java", "diffHunk": "@@ -90,9 +92,9 @@ public void testFailedUpdateSubmission() throws Exception {\n \n \t@Test\n \tpublic void testSqlCompletion() throws IOException {\n-\t\tverifySqlCompletion(\"\", 0, Arrays.asList(\"SELECT\", \"QUIT;\", \"RESET;\"), Collections.emptyList());\n-\t\tverifySqlCompletion(\"SELEC\", 5, Collections.singletonList(\"SELECT\"), Collections.singletonList(\"QUIT;\"));\n-\t\tverifySqlCompletion(\"SELE\", 0, Collections.singletonList(\"SELECT\"), Collections.singletonList(\"QUIT;\"));\n+\t\tverifySqlCompletion(\"\", 0, Arrays.asList(\"SOURCE\", \"QUIT;\", \"RESET;\"), Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNDAzNjk4", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-413403698", "createdAt": "2020-05-18T09:03:53Z", "commit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec741956533afdfa34f6876b0a0d7c346c3f5db5", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/ec741956533afdfa34f6876b0a0d7c346c3f5db5", "committedDate": "2020-05-18T13:19:27Z", "message": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daa6a5f09c11116a555969b31e9e594eaf91ae30", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/daa6a5f09c11116a555969b31e9e594eaf91ae30", "committedDate": "2020-05-18T13:23:30Z", "message": "address danny's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5426fe3fa668e07dfe99c7b12aac678a2549bb3d", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/5426fe3fa668e07dfe99c7b12aac678a2549bb3d", "committedDate": "2020-05-18T13:23:34Z", "message": "fix checkstyle error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aae4f45fd18320222d790dffcda117e02cb64e5e", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/aae4f45fd18320222d790dffcda117e02cb64e5e", "committedDate": "2020-05-18T13:58:42Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48e61b51442e40d0de50c315a9850aae80c4396b", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/48e61b51442e40d0de50c315a9850aae80c4396b", "committedDate": "2020-05-17T10:19:50Z", "message": "fix checkstyle error"}, "afterCommit": {"oid": "aae4f45fd18320222d790dffcda117e02cb64e5e", "author": {"user": {"login": "godfreyhe", "name": "godfrey he"}}, "url": "https://github.com/apache/flink/commit/aae4f45fd18320222d790dffcda117e02cb64e5e", "committedDate": "2020-05-18T13:58:42Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MzE4NjU1", "url": "https://github.com/apache/flink/pull/12188#pullrequestreview-414318655", "createdAt": "2020-05-19T10:39:14Z", "commit": {"oid": "aae4f45fd18320222d790dffcda117e02cb64e5e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4110, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}