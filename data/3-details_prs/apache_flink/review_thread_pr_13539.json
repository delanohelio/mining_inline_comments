{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3Mzk5NjE5", "number": 13539, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo1MTozOFrOEqLk7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzowODozOVrOEqL2YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjY1MzI1OnYy", "diffSide": "LEFT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo1MTozOFrOHcPfiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMjozNlrOHcSWTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NjAxMQ==", "bodyText": "Did you remove awaitTermination and close calls?", "url": "https://github.com/apache/flink/pull/13539#discussion_r499376011", "createdAt": "2020-10-05T06:51:38Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -217,15 +221,11 @@ public void testConcurrentReadStateAndProcessAndClose() throws Exception {\n \t\t\t\t}\n \t\t\t};\n \n-\t\t\tsubmitTasksAndWaitForResults(executor, new Callable[] {closeTask, readRecoveredStateTask, processStateTask});\n-\t\t} finally {\n-\t\t\texecutor.shutdown();\n+\t\t\texecutor.invokeAll(Arrays.asList(closeTask, readRecoveredStateTask, processStateTask));\n+\n \t\t\t// wait until the internal channel state recover task finishes\n-\t\t\texecutor.awaitTermination(60, TimeUnit.SECONDS);\n \t\t\tassertEquals(totalBuffers, environment.getNetworkBufferPool().getNumberOfAvailableMemorySegments());\n \t\t\tassertTrue(inputGate.getCloseFuture().isDone());\n-\n-\t\t\tenvironment.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fafbd875e938ead5b538bbc1e500472f1a58c1"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMjc5OA==", "bodyText": "close is called by the Closer.\nshutdown + awaitTermination is simply the wrong method. invokeAll is doing what was intended. Could be an extra commit. However, it should then probably be done on all 10 places that use submitTasksAndWaitForResults.", "url": "https://github.com/apache/flink/pull/13539#discussion_r499422798", "createdAt": "2020-10-05T08:22:36Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -217,15 +221,11 @@ public void testConcurrentReadStateAndProcessAndClose() throws Exception {\n \t\t\t\t}\n \t\t\t};\n \n-\t\t\tsubmitTasksAndWaitForResults(executor, new Callable[] {closeTask, readRecoveredStateTask, processStateTask});\n-\t\t} finally {\n-\t\t\texecutor.shutdown();\n+\t\t\texecutor.invokeAll(Arrays.asList(closeTask, readRecoveredStateTask, processStateTask));\n+\n \t\t\t// wait until the internal channel state recover task finishes\n-\t\t\texecutor.awaitTermination(60, TimeUnit.SECONDS);\n \t\t\tassertEquals(totalBuffers, environment.getNetworkBufferPool().getNumberOfAvailableMemorySegments());\n \t\t\tassertTrue(inputGate.getCloseFuture().isDone());\n-\n-\t\t\tenvironment.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NjAxMQ=="}, "originalCommit": {"oid": "f4fafbd875e938ead5b538bbc1e500472f1a58c1"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjY1NjQzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo1Mjo1MFrOHcPhYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMzowM1rOHcSXSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NjQ4Mw==", "bodyText": "Change first commit message to:\n\n[FLINK-19027][test][network] Ensure SingleInputGateTest does not swallow exceptions during cleanup.\n\n?", "url": "https://github.com/apache/flink/pull/13539#discussion_r499376483", "createdAt": "2020-10-05T06:52:50Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -59,26 +59,27 @@\n import org.apache.flink.runtime.shuffle.ShuffleDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fafbd875e938ead5b538bbc1e500472f1a58c1"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzA1MA==", "bodyText": "I didn't even know that double-tags are a thing. :p", "url": "https://github.com/apache/flink/pull/13539#discussion_r499423050", "createdAt": "2020-10-05T08:23:03Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -59,26 +59,27 @@\n import org.apache.flink.runtime.shuffle.ShuffleDescriptor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NjQ4Mw=="}, "originalCommit": {"oid": "f4fafbd875e938ead5b538bbc1e500472f1a58c1"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjY3Mjg3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo1OToxMVrOHcPrOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyNDo1OFrOHcSbgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3OTAwMQ==", "bodyText": "Why is this change relevant to the fix? Could you add some explanation to the commit message?", "url": "https://github.com/apache/flink/pull/13539#discussion_r499379001", "createdAt": "2020-10-05T06:59:11Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -247,7 +248,18 @@ public void setup() throws IOException {\n \t}\n \n \t@Override\n-\tpublic CompletableFuture<?> readRecoveredState(ExecutorService executor, ChannelStateReader reader) {\n+\tpublic CompletableFuture<?> readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException {\n+\t\tsynchronized (requestLock) {\n+\t\t\tif (closeFuture.isDone()) {\n+\t\t\t\treturn FutureUtils.completedVoidFuture();\n+\t\t\t}\n+\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\tif (inputChannel instanceof RemoteRecoveredInputChannel) {\n+\t\t\t\t\t((RemoteRecoveredInputChannel) inputChannel).assignExclusiveSegments();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81a54f6daa2ab03d404ec53a32f7c2ece7ce56cd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNDEyOA==", "bodyText": "I'll add. In short, the #number of required buffers is now higher than a few tests (and possibly production setups) assume. Without the lazy initialization, you cannot simulate backpressure in a few scenarios as easily.", "url": "https://github.com/apache/flink/pull/13539#discussion_r499424128", "createdAt": "2020-10-05T08:24:58Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -247,7 +248,18 @@ public void setup() throws IOException {\n \t}\n \n \t@Override\n-\tpublic CompletableFuture<?> readRecoveredState(ExecutorService executor, ChannelStateReader reader) {\n+\tpublic CompletableFuture<?> readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException {\n+\t\tsynchronized (requestLock) {\n+\t\t\tif (closeFuture.isDone()) {\n+\t\t\t\treturn FutureUtils.completedVoidFuture();\n+\t\t\t}\n+\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\tif (inputChannel instanceof RemoteRecoveredInputChannel) {\n+\t\t\t\t\t((RemoteRecoveredInputChannel) inputChannel).assignExclusiveSegments();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3OTAwMQ=="}, "originalCommit": {"oid": "81a54f6daa2ab03d404ec53a32f7c2ece7ce56cd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjY5NzkyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalRecoveredInputChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzowODozOVrOHcP50g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyODowMFrOHcSifA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM4MjczOA==", "bodyText": "I'm not sure if I understand this bug and the fix. Why is allocating exclusive buffers for LocalRecoveredInputChannel fixing the problem? Isn't it just reducing the window for the live lock to happen? What if downstream tasks are scheduled with a significant delay (exclusive buffers assignment happens after upstream tasks already acquired lot's of buffers).\nIn other words, Isn't this a semi fix for this bug https://issues.apache.org/jira/browse/FLINK-13203", "url": "https://github.com/apache/flink/pull/13539#discussion_r499382738", "createdAt": "2020-10-05T07:08:39Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalRecoveredInputChannel.java", "diffHunk": "@@ -42,8 +42,17 @@\n \t\t\tTaskEventPublisher taskEventPublisher,\n \t\t\tint initialBackOff,\n \t\t\tint maxBackoff,\n+\t\t\tint networkBuffersPerChannel,\n \t\t\tInputChannelMetrics metrics) {\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, metrics.getNumBytesInLocalCounter(), metrics.getNumBuffersInLocalCounter());\n+\t\tsuper(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d024a2f9e35958173143b16457bee0ae4acf4c7c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNTkxNg==", "bodyText": "Hm you are right, it doesn't solve it completely after having read the ticket. However, without a solution for FLINK-13203, there will also not be a real solution here.\nOn the other hand, it's inherently wrong to treat local and remote channels differently during recovery (they even share the same implementation). So this commit is still fixing the issue in a best effort manner and certainly helps to improve build stability, which is an improvement of its own.", "url": "https://github.com/apache/flink/pull/13539#discussion_r499425916", "createdAt": "2020-10-05T08:28:00Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalRecoveredInputChannel.java", "diffHunk": "@@ -42,8 +42,17 @@\n \t\t\tTaskEventPublisher taskEventPublisher,\n \t\t\tint initialBackOff,\n \t\t\tint maxBackoff,\n+\t\t\tint networkBuffersPerChannel,\n \t\t\tInputChannelMetrics metrics) {\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, metrics.getNumBytesInLocalCounter(), metrics.getNumBuffersInLocalCounter());\n+\t\tsuper(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM4MjczOA=="}, "originalCommit": {"oid": "d024a2f9e35958173143b16457bee0ae4acf4c7c"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 223, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}