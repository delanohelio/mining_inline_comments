{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5MTE2NjAz", "number": 13029, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMjo1NzowMVrOET6bjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMDoxMFrOEU6gHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzE1NzI0OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMjo1NzowMVrOG56dyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozMToxMlrOG5-zGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTkxNA==", "bodyText": "existt => exist", "url": "https://github.com/apache/flink/pull/13029#discussion_r463379914", "createdAt": "2020-07-31T02:57:01Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MDkwNQ==", "bodyText": "Thank you! I will revise it.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463450905", "createdAt": "2020-07-31T07:31:12Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTkxNA=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzE2Mjg4OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMzowMDo1MVrOG56g-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozMjowOFrOG5-0jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MDczMQ==", "bodyText": "We don't have case classes in PyFlink.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463380731", "createdAt": "2020-07-31T03:00:51Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MTI3OA==", "bodyText": "Yes, I will remove it.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463451278", "createdAt": "2020-07-31T07:32:08Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MDczMQ=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzE3MDcxOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMzowNjoyM1rOG56lnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozMjozNlrOG5-1TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MTkxOQ==", "bodyText": "Add type hint: def is_basic_type(self) -> bool:. Same for other methods.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463381919", "createdAt": "2020-07-31T03:06:23Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MTQ2OQ==", "bodyText": "Ok, it's good to add type hints.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463451469", "createdAt": "2020-07-31T07:32:36Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MTkxOQ=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzE3MzI5OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMzowODoyM1rOG56nGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozNzowMlrOG5-8Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MjI5Ng==", "bodyText": "We can remove this line. Tuple type is supported in Python originally. We should not simply copy Java comments.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463382296", "createdAt": "2020-07-31T03:08:23Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MzIyMw==", "bodyText": "Sure, there should be differences between java and python comments.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463453223", "createdAt": "2020-07-31T07:37:02Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MjI5Ng=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzE3OTIzOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMzoxMjoyMlrOG56qjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozNzoyMVrOG5-8qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MzE4Mw==", "bodyText": "composite types", "url": "https://github.com/apache/flink/pull/13029#discussion_r463383183", "createdAt": "2020-07-31T03:12:22Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self):\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self):\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composit types).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MzM1NA==", "bodyText": "Thank you! I'll revise it.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463453354", "createdAt": "2020-07-31T07:37:21Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self):\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self):\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composit types).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM4MzE4Mw=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzI1Mzc3OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDowNDoyMlrOG57U1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzozNzo1OVrOG5-9mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM5NDAwNA==", "bodyText": "Decimal should exist in BasicTypeInfo together with BIG_INT_TYPE_INFO. The decimal type info in DataStream is different from table. The precision and scale are not fixed, i.e., not be specified during initialization.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463394004", "createdAt": "2020-07-31T04:04:22Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self):\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self):\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composit types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self):\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self):\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self):\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self):\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self):\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self):\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INSTANT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INSTANT_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class LocalTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for Java LocalDate/LocalTime/LocalDateTime.\n+    \"\"\"\n+\n+    @staticmethod\n+    def LOCAL_DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_DATE)\n+\n+    @staticmethod\n+    def LOCAL_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_TIME)\n+\n+    @staticmethod\n+    def LOCAL_DATE_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo\n+            .LOCAL_DATE_TIME)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo())\n+\n+\n+class BigDecimalTypeInfo(WrapperTypeInfo):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MzU5NA==", "bodyText": "Yes, I'll remove it.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463453594", "createdAt": "2020-07-31T07:37:59Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,576 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self):\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self):\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composit types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self):\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self):\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self):\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self):\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self):\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self):\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INSTANT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INSTANT_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class LocalTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for Java LocalDate/LocalTime/LocalDateTime.\n+    \"\"\"\n+\n+    @staticmethod\n+    def LOCAL_DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_DATE)\n+\n+    @staticmethod\n+    def LOCAL_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_TIME)\n+\n+    @staticmethod\n+    def LOCAL_DATE_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo\n+            .LOCAL_DATE_TIME)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo())\n+\n+\n+class BigDecimalTypeInfo(WrapperTypeInfo):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM5NDAwNA=="}, "originalCommit": {"oid": "3d89fc037c6cf7b1dfe19514ff831af4a4d33b50"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzYwMjgxOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzoxODoxMVrOG5-evA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzoxODoxMVrOG5-evA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0NTY5Mg==", "bodyText": "Remove these types for now.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463445692", "createdAt": "2020-07-31T07:18:11Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,561 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually existt.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples and case classes represent as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self):\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self):\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+        Tuple types are subclasses of the Java API tuples.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self):\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self):\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composit types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self):\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self):\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self):\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self):\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self):\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self):\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+    @staticmethod\n+    def INSTANT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INSTANT_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class LocalTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for Java LocalDate/LocalTime/LocalDateTime.\n+    \"\"\"\n+\n+    @staticmethod\n+    def LOCAL_DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_DATE)\n+\n+    @staticmethod\n+    def LOCAL_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo.LOCAL_TIME)\n+\n+    @staticmethod\n+    def LOCAL_DATE_TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.LocalTimeTypeInfo\n+            .LOCAL_DATE_TIME)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo())\n+\n+\n+class BigDecimalTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    Type Information for BigDecimal. This type includes `precision` and `scale`.\n+    \"\"\"\n+\n+    def __init__(self, precision, scale):\n+        j_type_info = get_gateway().jvm \\\n+            .org.apache.flink.table.runtime.typeutils.BigDecimalTypeInfo(precision, scale)\n+        super(BigDecimalTypeInfo, self).__init__(j_typeinfo=j_type_info)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types, field_names=None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self):\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name):\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self):\n+        return self.types\n+\n+    def __eq__(self, other):\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self):\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self):\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self):\n+        return self.types\n+\n+    def __eq__(self, other):\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self):\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self):\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    LOCAL_DATE = LocalTimeTypeInfo.LOCAL_DATE\n+    LOCAL_TIME = LocalTimeTypeInfo.LOCAL_TIME\n+    LOCAL_DATE_TIME = LocalTimeTypeInfo.LOCAL_DATE_TIME\n+\n+    INSTANT = BasicTypeInfo.INSTANT_TYPE_INFO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39f5be60dc81c30f0cbbfb4e219722cbdd52ea21"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzYxNDgwOnYy", "diffSide": "RIGHT", "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzoyMzowNFrOG5-l4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzo0OTo0MVrOG5_QuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0NzUyMA==", "bodyText": "Make it a Singleton, similar to BasicTypeInfo in which provides a static final instance.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463447520", "createdAt": "2020-07-31T07:23:04Z", "author": {"login": "hequn8128"}, "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.datastream.typeinfo.python;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.array.BytePrimitiveArraySerializer;\n+\n+/**\n+ * A PickledByteArrayTypeInfo indicates that the data of this type is a generated primitive byte\n+ * array by pickle.\n+ */\n+public class PickledByteArrayTypeInfo extends TypeInformation<byte[]> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39f5be60dc81c30f0cbbfb4e219722cbdd52ea21"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1ODQ4OA==", "bodyText": "Ok, making it singleton is better.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463458488", "createdAt": "2020-07-31T07:49:41Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.datastream.typeinfo.python;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.array.BytePrimitiveArraySerializer;\n+\n+/**\n+ * A PickledByteArrayTypeInfo indicates that the data of this type is a generated primitive byte\n+ * array by pickle.\n+ */\n+public class PickledByteArrayTypeInfo extends TypeInformation<byte[]> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0NzUyMA=="}, "originalCommit": {"oid": "39f5be60dc81c30f0cbbfb4e219722cbdd52ea21"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzczNjY4OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODowNzoxMFrOG5_vpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODowNzoxMFrOG5_vpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ2NjQwNQ==", "bodyText": "Add type hint.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463466405", "createdAt": "2020-07-31T08:07:10Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc3ODg3OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTowMlrOG6AI6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTowMlrOG6AI6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3Mjg3Mw==", "bodyText": "Private method. Rename to _from_java_type.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463472873", "createdAt": "2020-07-31T08:21:02Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types. A row itself must not be\n+        null.\n+\n+        :param types: the types of the row fields, e.g., Types.String(), Types.INT()\n+        \"\"\"\n+        return RowTypeInfo(types)\n+\n+    @staticmethod\n+    def ROW_NAMED(names, types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types and with given names. A row\n+        must not be null.\n+\n+        :param names: array of field names.\n+        :param types: array of field types.\n+        \"\"\"\n+        return RowTypeInfo(types, names)\n+\n+    @staticmethod\n+    def TUPLE(types):\n+        \"\"\"\n+        Returns type information for Tuple with fields of the given types. A Tuple itself must not\n+        be null.\n+\n+        :param types: array of field types.\n+        \"\"\"\n+        return TupleTypeInfo(types)\n+\n+    @staticmethod\n+    def PRIMITIVE_ARRAY(element_type):\n+        \"\"\"\n+        Returns type information for arrays of primitive type (such as byte[]). The array must not\n+        be null.\n+\n+        :param element_type element type of the array (e.g. Types.BOOLEAN(), Types.INT(),\n+        Types.DOUBLE())\n+        \"\"\"\n+        if element_type == Types.BOOLEAN():\n+            return PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.BYTE():\n+            return PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.SHORT():\n+            return PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.INT():\n+            return PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.LONG():\n+            return PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.FLOAT():\n+            return PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.DOUBLE():\n+            return PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.CHAR():\n+            return PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO()\n+        else:\n+            raise TypeError(\"Invalid element type for a primitive array.\")\n+\n+\n+def from_java_type(j_type_info: JavaObject) -> TypeInformation:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc3OTcwOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMToyMFrOG6AJfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMToyMFrOG6AJfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3MzAyMA==", "bodyText": "Private method. Rename to _is_instance_of.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463473020", "createdAt": "2020-07-31T08:21:20Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types. A row itself must not be\n+        null.\n+\n+        :param types: the types of the row fields, e.g., Types.String(), Types.INT()\n+        \"\"\"\n+        return RowTypeInfo(types)\n+\n+    @staticmethod\n+    def ROW_NAMED(names, types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types and with given names. A row\n+        must not be null.\n+\n+        :param names: array of field names.\n+        :param types: array of field types.\n+        \"\"\"\n+        return RowTypeInfo(types, names)\n+\n+    @staticmethod\n+    def TUPLE(types):\n+        \"\"\"\n+        Returns type information for Tuple with fields of the given types. A Tuple itself must not\n+        be null.\n+\n+        :param types: array of field types.\n+        \"\"\"\n+        return TupleTypeInfo(types)\n+\n+    @staticmethod\n+    def PRIMITIVE_ARRAY(element_type):\n+        \"\"\"\n+        Returns type information for arrays of primitive type (such as byte[]). The array must not\n+        be null.\n+\n+        :param element_type element type of the array (e.g. Types.BOOLEAN(), Types.INT(),\n+        Types.DOUBLE())\n+        \"\"\"\n+        if element_type == Types.BOOLEAN():\n+            return PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.BYTE():\n+            return PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.SHORT():\n+            return PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.INT():\n+            return PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.LONG():\n+            return PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.FLOAT():\n+            return PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.DOUBLE():\n+            return PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO()\n+        elif element_type == Types.CHAR():\n+            return PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO()\n+        else:\n+            raise TypeError(\"Invalid element type for a primitive array.\")\n+\n+\n+def from_java_type(j_type_info: JavaObject) -> TypeInformation:\n+    gateway = get_gateway()\n+    JBasicTypeInfo = gateway.jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo\n+\n+    if is_instance_of(j_type_info, JBasicTypeInfo.STRING_TYPE_INFO):\n+        return Types.STRING()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.BOOLEAN_TYPE_INFO):\n+        return Types.BOOLEAN()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.BYTE_TYPE_INFO):\n+        return Types.BYTE()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.SHORT_TYPE_INFO):\n+        return Types.SHORT()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.INT_TYPE_INFO):\n+        return Types.INT()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.LONG_TYPE_INFO):\n+        return Types.LONG()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.FLOAT_TYPE_INFO):\n+        return Types.FLOAT()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.DOUBLE_TYPE_INFO):\n+        return Types.DOUBLE()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.CHAR_TYPE_INFO):\n+        return Types.CHAR()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.BIG_INT_TYPE_INFO):\n+        return Types.BIG_INT()\n+    elif is_instance_of(j_type_info, JBasicTypeInfo.BIG_DEC_TYPE_INFO):\n+        return Types.BIG_DEC()\n+\n+    JSqlTimeTypeInfo = gateway.jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo\n+    if is_instance_of(j_type_info, JSqlTimeTypeInfo.DATE):\n+        return Types.SQL_DATE()\n+    elif is_instance_of(j_type_info, JSqlTimeTypeInfo.TIME):\n+        return Types.SQL_TIME()\n+    elif is_instance_of(j_type_info, JSqlTimeTypeInfo.TIMESTAMP):\n+        return Types.SQL_TIMESTAMP()\n+\n+    JPrimitiveArrayTypeInfo = gateway.jvm.org.apache.flink.api.common.typeinfo \\\n+        .PrimitiveArrayTypeInfo\n+\n+    if is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.BOOLEAN())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.BYTE())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.SHORT())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.INT())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.LONG())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.FLOAT())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.DOUBLE())\n+    elif is_instance_of(j_type_info, JPrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO):\n+        return Types.PRIMITIVE_ARRAY(Types.CHAR())\n+\n+    JPickledBytesTypeInfo = gateway.jvm \\\n+        .org.apache.flink.datastream.typeinfo.python.PickledByteArrayTypeInfo\\\n+        .PICKLED_BYTE_ARRAY_TYPE_INFO\n+    if is_instance_of(j_type_info, JPickledBytesTypeInfo):\n+        return Types.PICKLED_BYTE_ARRAY()\n+\n+    JRowTypeInfo = gateway.jvm.org.apache.flink.api.java.typeutils.RowTypeInfo\n+    if is_instance_of(j_type_info, JRowTypeInfo):\n+        j_row_field_names = j_type_info.getFieldNames()\n+        j_row_field_types = j_type_info.getFieldTypes()\n+        row_field_types = [from_java_type(j_row_field_type) for j_row_field_type in\n+                           j_row_field_types]\n+        return Types.ROW_NAMED(j_row_field_names, row_field_types)\n+\n+    raise TypeError(\"The java type info: %s is not supported in PyFlink currently.\" % j_type_info)\n+\n+\n+def is_instance_of(java_object: JavaObject, java_type: Union[JavaObject, JavaClass]) -> bool:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 503}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc4MTI4OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTo0OVrOG6AKhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTo0OVrOG6AKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3MzI4NQ==", "bodyText": "Add type hint", "url": "https://github.com/apache/flink/pull/13029#discussion_r463473285", "createdAt": "2020-07-31T08:21:49Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc4MTUxOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTo1NlrOG6AKtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMTo1NlrOG6AKtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3MzMzMg==", "bodyText": "Add type hint", "url": "https://github.com/apache/flink/pull/13029#discussion_r463473332", "createdAt": "2020-07-31T08:21:56Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types. A row itself must not be\n+        null.\n+\n+        :param types: the types of the row fields, e.g., Types.String(), Types.INT()\n+        \"\"\"\n+        return RowTypeInfo(types)\n+\n+    @staticmethod\n+    def ROW_NAMED(names, types):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 382}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc4MTc2OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMjowMFrOG6AK3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMjowMFrOG6AK3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3MzM3NA==", "bodyText": "Add type hint", "url": "https://github.com/apache/flink/pull/13029#discussion_r463473374", "createdAt": "2020-07-31T08:22:00Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types. A row itself must not be\n+        null.\n+\n+        :param types: the types of the row fields, e.g., Types.String(), Types.INT()\n+        \"\"\"\n+        return RowTypeInfo(types)\n+\n+    @staticmethod\n+    def ROW_NAMED(names, types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types and with given names. A row\n+        must not be null.\n+\n+        :param names: array of field names.\n+        :param types: array of field types.\n+        \"\"\"\n+        return RowTypeInfo(types, names)\n+\n+    @staticmethod\n+    def TUPLE(types):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mzc4MjEyOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMjowNlrOG6ALEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyMjowNlrOG6ALEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3MzQyNg==", "bodyText": "Add type hint", "url": "https://github.com/apache/flink/pull/13029#discussion_r463473426", "createdAt": "2020-07-31T08:22:06Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,508 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:\n+        return self._j_typeinfo.getTotalFields()\n+\n+    def get_java_type_info(self) -> JavaObject:\n+        return self._j_typeinfo\n+\n+    def __eq__(self, o) -> bool:\n+        if type(o) is type(self):\n+            return self._j_typeinfo.equals(o._j_typeinfo)\n+        else:\n+            return False\n+\n+    def __hash__(self) -> int:\n+        return hash(self._j_typeinfo)\n+\n+\n+class BasicTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    Type information for primitive types (int, long, double, byte, ...), String, BigInteger,\n+    and BigDecimal.\n+    \"\"\"\n+\n+    @staticmethod\n+    def STRING_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm\n+                               .org.apache.flink.api.common.typeinfo.BasicTypeInfo.STRING_TYPE_INFO)\n+\n+    @staticmethod\n+    def BOOLEAN_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BOOLEAN_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BYTE_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.SHORT_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.LONG_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.FLOAT_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.CHAR_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_INT_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_INT_TYPE_INFO)\n+\n+    @staticmethod\n+    def BIG_DEC_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.BasicTypeInfo.BIG_DEC_TYPE_INFO)\n+\n+\n+class SqlTimeTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    SqlTimeTypeInfo enables users to get Sql Time TypeInfo.\n+    \"\"\"\n+\n+    @staticmethod\n+    def DATE():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.DATE)\n+\n+    @staticmethod\n+    def TIME():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIME)\n+\n+    @staticmethod\n+    def TIMESTAMP():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo.TIMESTAMP)\n+\n+\n+class PrimitiveArrayTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A TypeInformation for arrays of primitive types (int, long, double, ...).\n+    Supports the creation of dedicated efficient serializers for these types.\n+    \"\"\"\n+\n+    @staticmethod\n+    def BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def BYTE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def SHORT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def INT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def LONG_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def FLOAT_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+    @staticmethod\n+    def CHAR_PRIMITIVE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo\n+            .PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO)\n+\n+\n+class PickledBytesTypeInfo(TypeInformation, ABC):\n+    \"\"\"\n+    A PickledBytesTypeInfo indicates the data is a primitive byte array generated by pickle\n+    serializer.\n+    \"\"\"\n+\n+    @staticmethod\n+    def PICKLED_BYTE_ARRAY_TYPE_INFO():\n+        return WrapperTypeInfo(get_gateway().jvm.org.apache.flink.datastream.typeinfo.python\n+                               .PickledByteArrayTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO)\n+\n+\n+class RowTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Row.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation], field_names: List[str] = None):\n+        self.types = types\n+        self.field_names = field_names\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        if field_names is None:\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array)\n+        else:\n+            j_names_array = get_gateway().new_array(get_gateway().jvm.java.lang.String,\n+                                                    len(field_names))\n+            for i in range(len(field_names)):\n+                j_names_array[i] = field_names[i]\n+            self._j_typeinfo = get_gateway().jvm.org.apache.flink.api.java.typeutils.RowTypeInfo(\n+                self.j_types_array, j_names_array)\n+        super(RowTypeInfo, self).__init__(self._j_typeinfo)\n+\n+    def get_field_names(self) -> List[str]:\n+        j_field_names = self._j_typeinfo.getFieldNames()\n+        field_names = [name for name in j_field_names]\n+        return field_names\n+\n+    def get_field_index(self, field_name) -> int:\n+        return self._j_typeinfo.getFieldIndex(field_name)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class TupleTypeInfo(WrapperTypeInfo):\n+    \"\"\"\n+    TypeInformation for Tuple.\n+    \"\"\"\n+\n+    def __init__(self, types: List[TypeInformation]):\n+        self.types = types\n+        self.j_types_array = get_gateway().new_array(\n+            get_gateway().jvm.org.apache.flink.api.common.typeinfo.TypeInformation, len(types))\n+\n+        for i in range(len(types)):\n+            self.j_types_array[i] = types[i].get_java_type_info()\n+\n+        self._j_typeinfo = get_gateway().jvm \\\n+            .org.apache.flink.api.java.typeutils.TupleTypeInfo(self.j_types_array)\n+\n+    def get_field_types(self) -> List[TypeInformation]:\n+        return self.types\n+\n+    def __eq__(self, other) -> bool:\n+        return self._j_typeinfo.equals(other._j_typeinfo)\n+\n+    def __hash__(self) -> int:\n+        return self._j_typeinfo.hashCode()\n+\n+    def __str__(self) -> str:\n+        return self._j_typeinfo.toString()\n+\n+\n+class Types(object):\n+    \"\"\"\n+    This class gives access to the type information of the most common types for which Flink has\n+    built-in serializers and comparators.\n+    \"\"\"\n+\n+    STRING = BasicTypeInfo.STRING_TYPE_INFO\n+    BYTE = BasicTypeInfo.BYTE_TYPE_INFO\n+    BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO\n+    SHORT = BasicTypeInfo.SHORT_TYPE_INFO\n+    INT = BasicTypeInfo.INT_TYPE_INFO\n+    LONG = BasicTypeInfo.LONG_TYPE_INFO\n+    FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO\n+    DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO\n+    CHAR = BasicTypeInfo.CHAR_TYPE_INFO\n+    BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO\n+    BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO\n+\n+    SQL_DATE = SqlTimeTypeInfo.DATE\n+    SQL_TIME = SqlTimeTypeInfo.TIME\n+    SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP\n+\n+    PICKLED_BYTE_ARRAY = PickledBytesTypeInfo.PICKLED_BYTE_ARRAY_TYPE_INFO\n+\n+    @staticmethod\n+    def ROW(types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types. A row itself must not be\n+        null.\n+\n+        :param types: the types of the row fields, e.g., Types.String(), Types.INT()\n+        \"\"\"\n+        return RowTypeInfo(types)\n+\n+    @staticmethod\n+    def ROW_NAMED(names, types):\n+        \"\"\"\n+        Returns type information for Row with fields of the given types and with given names. A row\n+        must not be null.\n+\n+        :param names: array of field names.\n+        :param types: array of field types.\n+        \"\"\"\n+        return RowTypeInfo(types, names)\n+\n+    @staticmethod\n+    def TUPLE(types):\n+        \"\"\"\n+        Returns type information for Tuple with fields of the given types. A Tuple itself must not\n+        be null.\n+\n+        :param types: array of field types.\n+        \"\"\"\n+        return TupleTypeInfo(types)\n+\n+    @staticmethod\n+    def PRIMITIVE_ARRAY(element_type):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 403}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzgwMTU2OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyODozN1rOG6AW1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyODozN1rOG6AW1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3NjQzOA==", "bodyText": "Add tests to cover TupleTypeInfo and methods in Types(Types.ROW(), Types.ROW_NAMED, etc).", "url": "https://github.com/apache/flink/pull/13029#discussion_r463476438", "createdAt": "2020-07-31T08:28:37Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,63 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo\n+\n+\n+class TypeInfoTests(unittest.TestCase):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzgwNjI1OnYy", "diffSide": "RIGHT", "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyOTo1OVrOG6AZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyOTo1OVrOG6AZhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3NzEyNQ==", "bodyText": "Remove the blank line.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463477125", "createdAt": "2020-07-31T08:29:59Z", "author": {"login": "hequn8128"}, "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.datastream.typeinfo.python;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.array.BytePrimitiveArraySerializer;\n+\n+/**\n+ * A PickledByteArrayTypeInfo indicates that the data of this type is a generated primitive byte\n+ * array by pickle.\n+ */\n+public class PickledByteArrayTypeInfo extends TypeInformation<byte[]> {\n+\n+\tpublic static final PickledByteArrayTypeInfo PICKLED_BYTE_ARRAY_TYPE_INFO = new PickledByteArrayTypeInfo();\n+\n+\t@Override\n+\tpublic boolean isBasicType() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isTupleType() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic int getArity() {\n+\t\treturn 1;\n+\t}\n+\n+\t@Override\n+\tpublic int getTotalFields() {\n+\t\treturn 1;\n+\t}\n+\n+\t@Override\n+\tpublic Class<byte[]> getTypeClass() {\n+\t\treturn byte[].class;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isKeyType() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic TypeSerializer<byte[]> createSerializer(ExecutionConfig config) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzgxMDgxOnYy", "diffSide": "RIGHT", "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODozMToyNFrOG6AcWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODozMToyNFrOG6AcWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3Nzg1MQ==", "bodyText": "Make the constructor protected.", "url": "https://github.com/apache/flink/pull/13029#discussion_r463477851", "createdAt": "2020-07-31T08:31:24Z", "author": {"login": "hequn8128"}, "path": "flink-python/src/main/java/org/apache/flink/datastream/typeinfo/python/PickledByteArrayTypeInfo.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.datastream.typeinfo.python;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.array.BytePrimitiveArraySerializer;\n+\n+/**\n+ * A PickledByteArrayTypeInfo indicates that the data of this type is a generated primitive byte\n+ * array by pickle.\n+ */\n+public class PickledByteArrayTypeInfo extends TypeInformation<byte[]> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e004f9f8ebc001e7a8d63e39eb89f6b2b5cc431"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODcyNDE5OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMTo1Nzo0OVrOG6p8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMjozMjozMVrOG6qXbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1Nzc2OA==", "bodyText": "It is strange to return a string with Java for Python typeinfo. We need to regenerate the string for TupleTypeinfo.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464157768", "createdAt": "2020-08-03T01:57:49Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,118 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo, TupleTypeInfo, _from_java_type\n+\n+\n+class TypeInfoTests(unittest.TestCase):\n+\n+    def test_types(self):\n+        self.assertEqual(True, Types.BOOLEAN().is_basic_type())\n+        self.assertEqual(True, Types.BYTE().is_basic_type())\n+        self.assertEqual(True, Types.SHORT().is_basic_type())\n+        self.assertEqual(True, Types.INT().is_basic_type())\n+        self.assertEqual(True, Types.LONG().is_basic_type())\n+        self.assertEqual(True, Types.FLOAT().is_basic_type())\n+        self.assertEqual(True, Types.DOUBLE().is_basic_type())\n+        self.assertEqual(True, Types.CHAR().is_basic_type())\n+        self.assertEqual(True, Types.BIG_INT().is_basic_type())\n+        self.assertEqual(True, Types.BIG_DEC().is_basic_type())\n+        self.assertEqual(False, Types.PICKLED_BYTE_ARRAY().is_basic_type())\n+\n+        self.assertEqual(False, Types.STRING().is_tuple_type())\n+        self.assertEqual(1, Types.STRING().get_total_fields())\n+        self.assertEqual(1, Types.STRING().get_arity())\n+\n+        self.assertEqual(False, Types.SQL_DATE().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIME().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIMESTAMP().is_basic_type())\n+\n+    def test_row_type(self):\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['f0', 'f1'])\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']).get_field_names(), ['a', 'b'])\n+\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                 Types.STRING()], ['a', 'b']), True)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                Types.INT()],\n+                                                                ['a', 'b']), False)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']).__str__(), \"Row(a: String, b: String)\")\n+\n+        self.assertEqual(Types.ROW([Types.STRING(), Types.STRING()]),\n+                         RowTypeInfo([Types.STRING(), Types.STRING()]), True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['a', 'b'], True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_types(), [Types.STRING(), Types.STRING()], True)\n+\n+    def test_tuple_type(self):\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]), True)\n+\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]).__str__(),\n+                         \"Java Tuple2<String, Integer>\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d8d302ef214afc070f00d730d6c25c9509e3529"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE2NDcxNw==", "bodyText": "Yes, maybe we should not directly call to toString() of the java type info object.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464164717", "createdAt": "2020-08-03T02:32:31Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,118 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo, TupleTypeInfo, _from_java_type\n+\n+\n+class TypeInfoTests(unittest.TestCase):\n+\n+    def test_types(self):\n+        self.assertEqual(True, Types.BOOLEAN().is_basic_type())\n+        self.assertEqual(True, Types.BYTE().is_basic_type())\n+        self.assertEqual(True, Types.SHORT().is_basic_type())\n+        self.assertEqual(True, Types.INT().is_basic_type())\n+        self.assertEqual(True, Types.LONG().is_basic_type())\n+        self.assertEqual(True, Types.FLOAT().is_basic_type())\n+        self.assertEqual(True, Types.DOUBLE().is_basic_type())\n+        self.assertEqual(True, Types.CHAR().is_basic_type())\n+        self.assertEqual(True, Types.BIG_INT().is_basic_type())\n+        self.assertEqual(True, Types.BIG_DEC().is_basic_type())\n+        self.assertEqual(False, Types.PICKLED_BYTE_ARRAY().is_basic_type())\n+\n+        self.assertEqual(False, Types.STRING().is_tuple_type())\n+        self.assertEqual(1, Types.STRING().get_total_fields())\n+        self.assertEqual(1, Types.STRING().get_arity())\n+\n+        self.assertEqual(False, Types.SQL_DATE().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIME().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIMESTAMP().is_basic_type())\n+\n+    def test_row_type(self):\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['f0', 'f1'])\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']).get_field_names(), ['a', 'b'])\n+\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                 Types.STRING()], ['a', 'b']), True)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                Types.INT()],\n+                                                                ['a', 'b']), False)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']).__str__(), \"Row(a: String, b: String)\")\n+\n+        self.assertEqual(Types.ROW([Types.STRING(), Types.STRING()]),\n+                         RowTypeInfo([Types.STRING(), Types.STRING()]), True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['a', 'b'], True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_types(), [Types.STRING(), Types.STRING()], True)\n+\n+    def test_tuple_type(self):\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]), True)\n+\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]).__str__(),\n+                         \"Java Tuple2<String, Integer>\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1Nzc2OA=="}, "originalCommit": {"oid": "2d8d302ef214afc070f00d730d6c25c9509e3529"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODcyNjMyOnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMTo1OTozNlrOG6p9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMjozMTo1NVrOG6qXAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1ODA4Nw==", "bodyText": "Remove the useless empty lines.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464158087", "createdAt": "2020-08-03T01:59:36Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,118 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo, TupleTypeInfo, _from_java_type\n+\n+\n+class TypeInfoTests(unittest.TestCase):\n+\n+    def test_types(self):\n+        self.assertEqual(True, Types.BOOLEAN().is_basic_type())\n+        self.assertEqual(True, Types.BYTE().is_basic_type())\n+        self.assertEqual(True, Types.SHORT().is_basic_type())\n+        self.assertEqual(True, Types.INT().is_basic_type())\n+        self.assertEqual(True, Types.LONG().is_basic_type())\n+        self.assertEqual(True, Types.FLOAT().is_basic_type())\n+        self.assertEqual(True, Types.DOUBLE().is_basic_type())\n+        self.assertEqual(True, Types.CHAR().is_basic_type())\n+        self.assertEqual(True, Types.BIG_INT().is_basic_type())\n+        self.assertEqual(True, Types.BIG_DEC().is_basic_type())\n+        self.assertEqual(False, Types.PICKLED_BYTE_ARRAY().is_basic_type())\n+\n+        self.assertEqual(False, Types.STRING().is_tuple_type())\n+        self.assertEqual(1, Types.STRING().get_total_fields())\n+        self.assertEqual(1, Types.STRING().get_arity())\n+\n+        self.assertEqual(False, Types.SQL_DATE().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIME().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIMESTAMP().is_basic_type())\n+\n+    def test_row_type(self):\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['f0', 'f1'])\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']).get_field_names(), ['a', 'b'])\n+\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                 Types.STRING()], ['a', 'b']), True)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                Types.INT()],\n+                                                                ['a', 'b']), False)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']).__str__(), \"Row(a: String, b: String)\")\n+\n+        self.assertEqual(Types.ROW([Types.STRING(), Types.STRING()]),\n+                         RowTypeInfo([Types.STRING(), Types.STRING()]), True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['a', 'b'], True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_types(), [Types.STRING(), Types.STRING()], True)\n+\n+    def test_tuple_type(self):\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]), True)\n+\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]).__str__(),\n+                         \"Java Tuple2<String, Integer>\")\n+\n+        self.assertNotEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                            TupleTypeInfo([Types.STRING(), Types.BOOLEAN()]))\n+\n+        self.assertEqual(Types.TUPLE([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]))\n+\n+        self.assertEqual(Types.TUPLE([Types.STRING(), Types.INT()]).get_field_types(),\n+                         [Types.STRING(), Types.INT()])\n+\n+    def test_primitive_array_types(self):\n+        primitive_int_array_type_info = Types.PRIMITIVE_ARRAY(Types.INT())\n+        self.assertEqual(primitive_int_array_type_info.is_basic_type(), False)\n+\n+    def test_from_java_type(self):\n+        basic_int_type_info = Types.INT()\n+        self.assertEqual(basic_int_type_info,\n+                         _from_java_type(basic_int_type_info.get_java_type_info()))\n+\n+        row_type_info = Types.ROW([Types.INT(), Types.STRING()])\n+        self.assertEqual(row_type_info, _from_java_type(row_type_info.get_java_type_info()))\n+\n+        tuple_type_info = Types.TUPLE([Types.CHAR(), Types.INT()])\n+        self.assertEqual(tuple_type_info, _from_java_type(tuple_type_info.get_java_type_info()))\n+\n+        primitive_int_array_type_info = Types.PRIMITIVE_ARRAY(Types.INT())\n+        self.assertEqual(primitive_int_array_type_info,\n+                         _from_java_type(primitive_int_array_type_info.get_java_type_info()))\n+\n+        pickled_byte_array_type_info = Types.PICKLED_BYTE_ARRAY()\n+        self.assertEqual(pickled_byte_array_type_info,\n+                         _from_java_type(pickled_byte_array_type_info.get_java_type_info()))\n+\n+        sql_date_type_info = Types.SQL_DATE()\n+        self.assertEqual(sql_date_type_info,\n+                         _from_java_type(sql_date_type_info.get_java_type_info()))\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d8d302ef214afc070f00d730d6c25c9509e3529"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE2NDYwOQ==", "bodyText": "Thanks, I'll clean it.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464164609", "createdAt": "2020-08-03T02:31:55Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,118 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo, TupleTypeInfo, _from_java_type\n+\n+\n+class TypeInfoTests(unittest.TestCase):\n+\n+    def test_types(self):\n+        self.assertEqual(True, Types.BOOLEAN().is_basic_type())\n+        self.assertEqual(True, Types.BYTE().is_basic_type())\n+        self.assertEqual(True, Types.SHORT().is_basic_type())\n+        self.assertEqual(True, Types.INT().is_basic_type())\n+        self.assertEqual(True, Types.LONG().is_basic_type())\n+        self.assertEqual(True, Types.FLOAT().is_basic_type())\n+        self.assertEqual(True, Types.DOUBLE().is_basic_type())\n+        self.assertEqual(True, Types.CHAR().is_basic_type())\n+        self.assertEqual(True, Types.BIG_INT().is_basic_type())\n+        self.assertEqual(True, Types.BIG_DEC().is_basic_type())\n+        self.assertEqual(False, Types.PICKLED_BYTE_ARRAY().is_basic_type())\n+\n+        self.assertEqual(False, Types.STRING().is_tuple_type())\n+        self.assertEqual(1, Types.STRING().get_total_fields())\n+        self.assertEqual(1, Types.STRING().get_arity())\n+\n+        self.assertEqual(False, Types.SQL_DATE().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIME().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIMESTAMP().is_basic_type())\n+\n+    def test_row_type(self):\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['f0', 'f1'])\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']).get_field_names(), ['a', 'b'])\n+\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                 Types.STRING()], ['a', 'b']), True)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                Types.INT()],\n+                                                                ['a', 'b']), False)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']).__str__(), \"Row(a: String, b: String)\")\n+\n+        self.assertEqual(Types.ROW([Types.STRING(), Types.STRING()]),\n+                         RowTypeInfo([Types.STRING(), Types.STRING()]), True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['a', 'b'], True)\n+\n+        self.assertEqual(Types.ROW_NAMED(['a', 'b'], [Types.STRING(), Types.STRING()])\n+                         .get_field_types(), [Types.STRING(), Types.STRING()], True)\n+\n+    def test_tuple_type(self):\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]), True)\n+\n+        self.assertEqual(TupleTypeInfo([Types.STRING(), Types.INT()]).__str__(),\n+                         \"Java Tuple2<String, Integer>\")\n+\n+        self.assertNotEqual(TupleTypeInfo([Types.STRING(), Types.INT()]),\n+                            TupleTypeInfo([Types.STRING(), Types.BOOLEAN()]))\n+\n+        self.assertEqual(Types.TUPLE([Types.STRING(), Types.INT()]),\n+                         TupleTypeInfo([Types.STRING(), Types.INT()]))\n+\n+        self.assertEqual(Types.TUPLE([Types.STRING(), Types.INT()]).get_field_types(),\n+                         [Types.STRING(), Types.INT()])\n+\n+    def test_primitive_array_types(self):\n+        primitive_int_array_type_info = Types.PRIMITIVE_ARRAY(Types.INT())\n+        self.assertEqual(primitive_int_array_type_info.is_basic_type(), False)\n+\n+    def test_from_java_type(self):\n+        basic_int_type_info = Types.INT()\n+        self.assertEqual(basic_int_type_info,\n+                         _from_java_type(basic_int_type_info.get_java_type_info()))\n+\n+        row_type_info = Types.ROW([Types.INT(), Types.STRING()])\n+        self.assertEqual(row_type_info, _from_java_type(row_type_info.get_java_type_info()))\n+\n+        tuple_type_info = Types.TUPLE([Types.CHAR(), Types.INT()])\n+        self.assertEqual(tuple_type_info, _from_java_type(tuple_type_info.get_java_type_info()))\n+\n+        primitive_int_array_type_info = Types.PRIMITIVE_ARRAY(Types.INT())\n+        self.assertEqual(primitive_int_array_type_info,\n+                         _from_java_type(primitive_int_array_type_info.get_java_type_info()))\n+\n+        pickled_byte_array_type_info = Types.PICKLED_BYTE_ARRAY()\n+        self.assertEqual(pickled_byte_array_type_info,\n+                         _from_java_type(pickled_byte_array_type_info.get_java_type_info()))\n+\n+        sql_date_type_info = Types.SQL_DATE()\n+        self.assertEqual(sql_date_type_info,\n+                         _from_java_type(sql_date_type_info.get_java_type_info()))\n+\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1ODA4Nw=="}, "originalCommit": {"oid": "2d8d302ef214afc070f00d730d6c25c9509e3529"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODg1NjQ1OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMzozMTowM1rOG6rGlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMzozMTowM1rOG6rGlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3Njc4OQ==", "bodyText": "We should also print field name for row type info.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464176789", "createdAt": "2020-08-03T03:31:03Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/tests/test_typeinfo.py", "diffHunk": "@@ -0,0 +1,115 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+import unittest\n+\n+from pyflink.common.typeinfo import Types, RowTypeInfo, TupleTypeInfo, _from_java_type\n+\n+\n+class TypeInfoTests(unittest.TestCase):\n+\n+    def test_types(self):\n+        self.assertEqual(True, Types.BOOLEAN().is_basic_type())\n+        self.assertEqual(True, Types.BYTE().is_basic_type())\n+        self.assertEqual(True, Types.SHORT().is_basic_type())\n+        self.assertEqual(True, Types.INT().is_basic_type())\n+        self.assertEqual(True, Types.LONG().is_basic_type())\n+        self.assertEqual(True, Types.FLOAT().is_basic_type())\n+        self.assertEqual(True, Types.DOUBLE().is_basic_type())\n+        self.assertEqual(True, Types.CHAR().is_basic_type())\n+        self.assertEqual(True, Types.BIG_INT().is_basic_type())\n+        self.assertEqual(True, Types.BIG_DEC().is_basic_type())\n+        self.assertEqual(False, Types.PICKLED_BYTE_ARRAY().is_basic_type())\n+\n+        self.assertEqual(False, Types.STRING().is_tuple_type())\n+        self.assertEqual(1, Types.STRING().get_total_fields())\n+        self.assertEqual(1, Types.STRING().get_arity())\n+\n+        self.assertEqual(False, Types.SQL_DATE().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIME().is_basic_type())\n+        self.assertEqual(False, Types.SQL_TIMESTAMP().is_basic_type())\n+\n+    def test_row_type(self):\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()])\n+                         .get_field_names(), ['f0', 'f1'])\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']).get_field_names(), ['a', 'b'])\n+\n+        self.assertEqual(RowTypeInfo([Types.STRING(), Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                 Types.STRING()], ['a', 'b']), True)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']) == RowTypeInfo([Types.STRING(),\n+                                                                Types.INT()],\n+                                                                ['a', 'b']), False)\n+        self.assertEqual(RowTypeInfo([Types.STRING(),\n+                                      Types.STRING()],\n+                                     ['a', 'b']).__str__(), \"RowTypeInfo[String, String]\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc01ebcdb7d9e911b0c3f145867ad1bc90288b30"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY1MzE3OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTowOTo0OFrOG7X64w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxNTowNVrOG7YHDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTA3NQ==", "bodyText": "We can remove these methods since we don't need them now.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464911075", "createdAt": "2020-08-04T09:09:48Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,523 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7e94a339fb20d1cee374495d8d8c1ac0af3c7b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNDE5MA==", "bodyText": "Agree, I will remove them.", "url": "https://github.com/apache/flink/pull/13029#discussion_r464914190", "createdAt": "2020-08-04T09:15:05Z", "author": {"login": "shuiqiangchen"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,523 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTA3NQ=="}, "originalCommit": {"oid": "be7e94a339fb20d1cee374495d8d8c1ac0af3c7b"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY1NDY5OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/common/typeinfo.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMDoxMFrOG7X7zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMDoxMFrOG7X7zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTMxMQ==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13029#discussion_r464911311", "createdAt": "2020-08-04T09:10:10Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/common/typeinfo.py", "diffHunk": "@@ -0,0 +1,523 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+\n+from abc import ABC, abstractmethod\n+\n+from py4j.java_gateway import JavaClass, JavaObject\n+from typing import List, Union\n+\n+from pyflink.java_gateway import get_gateway\n+\n+\n+class TypeInformation(ABC):\n+    \"\"\"\n+    TypeInformation is the core class of Flink's type system. FLink requires a type information\n+    for all types that are used as input or return type of a user function. This type information\n+    class acts as the tool to generate serializers and comparators, and to perform semantic checks\n+    such as whether the fields that are used as join/grouping keys actually exist.\n+\n+    The type information also bridges between the programming languages object model and a logical\n+    flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields\n+    from a type are mapped to a separate fields in the flat schema and often, entire types are\n+    mapped to one field.. It is important to notice that the schema must hold for all instances of a\n+    type. For that reason, elements in lists and arrays are not assigned to individual fields, but\n+    the lists and arrays are considered to be one field in total, to account for different lengths\n+    in the arrays.\n+        a) Basic types are indivisible and are considered as a single field.\n+        b) Arrays and collections are one field.\n+        c) Tuples represents as many fields as the class has fields.\n+    To represent this properly, each type has an arity (the number of fields it contains directly),\n+    and a total number of fields (number of fields in the entire schema of this type, including\n+    nested types).\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_basic_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a basic type.\n+        Basic types are defined in BasicTypeInfo and are primitives, their boxing type, Strings ...\n+\n+        :return:  True, if this type information describes a basic type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def is_tuple_type(self) -> bool:\n+        \"\"\"\n+        Checks if this type information represents a Tuple type.\n+\n+        :return: True, if this type information describes a tuple type, false otherwise.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_arity(self) -> int:\n+        \"\"\"\n+        Gets the arity of this type - the number of fields without nesting.\n+\n+        :return: the number of fields in this type without nesting.\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_total_fields(self) -> int:\n+        \"\"\"\n+        Gets the number of logical fields in this type. This includes its nested and transitively\n+        nested fields, in the case of composite types.\n+        The total number of fields must be at lest 1.\n+\n+        :return: The number of fields in this type, including its sub-fields (for composite types).\n+        \"\"\"\n+        pass\n+\n+\n+class WrapperTypeInfo(TypeInformation):\n+    \"\"\"\n+    A wrapper class for java TypeInformation Objects.\n+    \"\"\"\n+\n+    def __init__(self, j_typeinfo):\n+        self._j_typeinfo = j_typeinfo\n+\n+    def is_basic_type(self) -> bool:\n+        return self._j_typeinfo.isBasicType()\n+\n+    def is_tuple_type(self) -> bool:\n+        return self._j_typeinfo.isTupleType()\n+\n+    def get_arity(self) -> int:\n+        return self._j_typeinfo.getArity()\n+\n+    def get_total_fields(self) -> int:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7e94a339fb20d1cee374495d8d8c1ac0af3c7b"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4891, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}