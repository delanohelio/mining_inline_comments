{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MDgxMzg5", "number": 12722, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0Mjo1NFrOEHdglg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMjoxN1rOEHo89A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjU4OTY2OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0Mjo1NFrOGm1S3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0Mjo1NFrOGm1S3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MjI1Mw==", "bodyText": "Hum, not sure I'd change this title, it might be more confusing than helpful. The sentence you have below is clarifying enough (\"Since Flink 1.11, checkpoints can be taken with or without alignment. In the\nfollowing, we describe aligned checkpoints first.\").", "url": "https://github.com/apache/flink/pull/12722#discussion_r443372253", "createdAt": "2020-06-22T07:42:54Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjU5NDg3OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0NDo0NlrOGm1WeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0NDo0NlrOGm1WeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzE3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The figure depicts how an operator handle unaligned checkpoint barriers:\n          \n          \n            \n            The figure depicts how an operator handles unaligned checkpoint barriers:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373177", "createdAt": "2020-06-22T07:44:46Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjU5NzIxOnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0NTozNlrOGm1YCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0NTozNlrOGm1YCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzU3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            as possible. It's especially suited for application with at least one slow \n          \n          \n            \n            as possible. It's especially suited for applications with at least one slow", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373576", "createdAt": "2020-06-22T07:45:36Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjYwODE3OnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0ODo1OVrOGm1e9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0OToxMlrOGm1fbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            high due to back-pressure. Then, checkpointing time becomes mostly\n          \n          \n            \n            high due to backpressure. Then, checkpointing time becomes mostly", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375348", "createdAt": "2020-06-22T07:48:59Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTQ2OA==", "bodyText": "Just for the sake of coherence.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375468", "createdAt": "2020-06-22T07:49:12Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjYxMjQzOnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo1MDoxNFrOGm1hrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo1MDoxNFrOGm1hrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NjA0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons.\n          \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443376044", "createdAt": "2020-06-22T07:50:14Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjYxODc4OnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo1MjoxNlrOGm1lsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo1MjoxNlrOGm1lsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NzA3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            checkpoints**, while window operators are safe to use. The work-around is to\n          \n          \n            \n            checkpoints**, while window operators are safe to use. The workaround is to", "url": "https://github.com/apache/flink/pull/12722#discussion_r443377072", "createdAt": "2020-06-22T07:52:16Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The work-around is to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjY2OTYxOnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODowNzo1MlrOGm2FTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo0Mzo1N1rOGm9FGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA==", "bodyText": "To my understanding, there are were papers: one by Lamport and one by DataArtisans.\nOne of the differences is that the former proposed to persist channel state, while the latter proposed alignment (I might be wrong).\nSo it's probably better to move reference to the paper by Lamport to Unaligned section and mention \"Flink\" paper in this Aligned section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443385164", "createdAt": "2020-06-22T08:07:52Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing\n \n The central part of Flink's fault tolerance mechanism is drawing consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5OTgwMA==", "bodyText": "Good question. I briefly looked at it and it seems as if you are right. I pinged @StephanEwen for clarification and he responded that it is indeed closer, but there are still some difference:\n\nFlink checkpoints start at sources, propagate through a DAG and persist in-flight as needed\nChandy-Lamport assumes no DAG, starts everywhere at the same time (think: RPC goes to every operators) and all operators log until they saw all markers.\n\nI'd probably leave the reference as is and add a clarifying line to unaligned section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443499800", "createdAt": "2020-06-22T11:43:57Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing\n \n The central part of Flink's fault tolerance mechanism is drawing consistent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjY4NTkxOnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoxMzowNlrOGm2PvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoxMzowNlrOGm2PvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NzgzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator reacts on the first barrier that is stored in input buffers.\n          \n          \n            \n            - The operator reacts on the first barrier that is stored in its input buffers.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443387836", "createdAt": "2020-06-22T08:13:06Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjcwNTAwOnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoxODo0OFrOGm2bpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoxODo0OFrOGm2bpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5MDg4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator marks all overtaken buffers, which are asynchronously stored in\n          \n          \n            \n              the state backend together with the other operator state.\n          \n          \n            \n            - The operator marks all overtaken records to be stored asynchronously and creates a snapshot of its own state.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443390884", "createdAt": "2020-06-22T08:18:48Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjcxNzQ5OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoyMjoyOVrOGm2jfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo1MjozNFrOGm9VvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA==", "bodyText": "It reads like a separate step (it's not, right?)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - It only briefly stops the processing of input to mark the buffers, forward \n          \n          \n            \n              the barrier and create the snapshot of the other state.\n          \n          \n            \n            Compared to aligned checkpoints, the operator doesn't need to suspend any of its inputs.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443392894", "createdAt": "2020-06-22T08:22:29Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDA2MA==", "bodyText": "Yes, I have removed the bullet and made it a summarizing sentence.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504060", "createdAt": "2020-06-22T11:52:34Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjcyMzY0OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoyNDoxM1rOGm2nXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoyNDoxM1rOGm2nXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mzg4NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/flink/pull/12722#discussion_r443393884", "createdAt": "2020-06-22T08:24:13Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O\n+to the state backends is the bottleneck. See the more in-depth discussion in \n+[ops]({% link ops/state/checkpoints.md %}#unaligned-checkpoints)\n+for other limitations.\n+\n+Note that savepoints will always be aligned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjczNDQ2OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoyNzowNFrOGm2uPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwODoyNDowOFrOGoIBbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA==", "bodyText": "Should we mention that this is an experimental feature?\nI think it should be a separate statement in the end of the section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443395644", "createdAt": "2020-06-22T08:27:04Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwMjQ3OQ==", "bodyText": "My understanding was that this document is rather an expanded glossary and talks about the concept and not the implementation. Thus, I'd leave the implementation state out of this place. The ops link will directly say that it's experimental in 1.11.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443502479", "createdAt": "2020-06-22T11:49:21Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTU3Mw==", "bodyText": "The page already goes quite deep into the details so I don't see why it shouldn't be mentioned here. Some users could benefit by ruling out the feature earlier if they are considering Flink or its configuration.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443835573", "createdAt": "2020-06-22T21:26:01Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNzY2MQ==", "bodyText": "Since we decided at a different point to drop the experimental label, I'd leave this section as is.", "url": "https://github.com/apache/flink/pull/12722#discussion_r444727661", "createdAt": "2020-06-24T08:24:08Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjgxOTI2OnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo1MDo0OVrOGm3juw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwODoyNzoxNlrOGoII3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - You cannot rescale from unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment\n          \n          \n            \n            - You cannot rescale or change job graph with unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409339", "createdAt": "2020-06-22T08:50:49Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDUwMg==", "bodyText": "Can you change the job graph with current checkpoints? I was always assuming that you need savepoints.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504502", "createdAt": "2020-06-22T11:53:25Z", "author": {"login": "AHeise"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYzMzM1MA==", "bodyText": "Hmm...the current Flink docs says that retained checkpoints:\n\ndo not support Flink specific features like rescaling.\n\n...and nothing about the job graph.\nBesides that, UC doesn't currently support Local recovery.\nEdit:\nLocal recovery limitation should probably be described in\nTuning Checkpoints section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443633350", "createdAt": "2020-06-22T15:13:36Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2Nzg1NQ==", "bodyText": "Yes technically but its incidental. The community hasn't made any backward compat guaruntees around that behavior.", "url": "https://github.com/apache/flink/pull/12722#discussion_r444467855", "createdAt": "2020-06-23T19:49:57Z", "author": {"login": "sjwiesman"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyOTU2Nw==", "bodyText": "I see, thanks.\nI think we can leave it as is then.", "url": "https://github.com/apache/flink/pull/12722#discussion_r444729567", "createdAt": "2020-06-24T08:27:16Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjgyMjg5OnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo1MTo1MVrOGm3mHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo1MTo1MVrOGm3mHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTk1MA==", "bodyText": "nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following shortcomings:\n          \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following limitations:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409950", "createdAt": "2020-06-22T08:51:51Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQzMTk4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/CheckpointConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNDowM1rOGnHVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDo0MToxNFrOGnQPbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Nzc1MQ==", "bodyText": "As it's stable on our builds, maybe we could label it more production ready?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443667751", "createdAt": "2020-06-22T16:04:03Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/CheckpointConfig.java", "diffHunk": "@@ -382,7 +382,7 @@ public void setPreferCheckpointForRecovery(boolean preferCheckpointForRecovery)\n \t}\n \n \t/**\n-\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure.\n+\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure (experimental).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd067ea54c9c6662329cea2c8715a173961d9fb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMzc0MQ==", "bodyText": "Then just leave out experimental and just link to limitations?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443813741", "createdAt": "2020-06-22T20:41:14Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/CheckpointConfig.java", "diffHunk": "@@ -382,7 +382,7 @@ public void setPreferCheckpointForRecovery(boolean preferCheckpointForRecovery)\n \t}\n \n \t/**\n-\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure.\n+\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure (experimental).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Nzc1MQ=="}, "originalCommit": {"oid": "bfd067ea54c9c6662329cea2c8715a173961d9fb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQzNzMyOnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNToxNVrOGnHYSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNToxNVrOGnHYSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2ODU1Mw==", "bodyText": "following section?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443668553", "createdAt": "2020-06-22T16:05:15Z", "author": {"login": "pnowojski"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -140,6 +140,8 @@ Keep in mind that everything to do with checkpointing can be done\n asynchronously. The checkpoint barriers don't travel in lock step and\n operations can asynchronously snapshot their state.\n \n+Since Flink 1.11, checkpoints can be taken with or without alignment. In the \n+following, we describe aligned checkpoints first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ0NDQ2OnYy", "diffSide": "RIGHT", "path": "docs/concepts/stateful-stream-processing.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNzowNlrOGnHc4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNzowNlrOGnHc4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2OTczMA==", "bodyText": "I/O pressure to state backends ->  I/O pressure, as it's not using state backends per se.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443669730", "createdAt": "2020-06-22T16:07:06Z", "author": {"login": "pnowojski"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,48 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+Note that this approach is actually closer to the [Chandy-Lamport algorithm\n+](http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf), but\n+Flink still inserts the barrier in the sources to avoid overloading the\n+checkpoint coordinator.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handles unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in its input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken records to be stored asynchronously and \n+  creates a snapshot of its own state.\n+ \n+Consequently, the operator only briefly stops the processing of input to mark\n+the buffers, forwards the barrier, and creates the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for applications with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ1MjMyOnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowOTowNVrOGnHhzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowOTowNVrOGnHhzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MDk5MA==", "bodyText": "We should mention here that aligned savepoints also can not happen concurrently to unaligned checkpoint", "url": "https://github.com/apache/flink/pull/12722#discussion_r443670990", "createdAt": "2020-06-22T16:09:05Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ1OTUwOnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMDo1NVrOGnHmQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDo0Mzo1OVrOGnQU3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MjEyOQ==", "bodyText": "I think this paragraph is a bit too strong. As far as I understand, it's not that the UC will produce incorrect result, just that some records during the reprocessing might not be accounted as late data, right?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672129", "createdAt": "2020-06-22T16:10:55Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons:\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The workaround is to\n+store the watermark in the operator state. If rescaling may occur, watermarks\n+should be stored per key-group in a union-state. We mostly likely will\n+implement this approach as a general solution (didn't make it into Flink \n+1.11.0).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNTEzMg==", "bodyText": "I can tone it done, but basically we are breaking with the old assumption that watermarks don't need to be stored at the operator because they are sent first.\nI'm especially referring to the OverITCases, which use a weird way to inject watermarks and logically should persist them. But now that I'm thinking about it, it's more a matter of the test setup itself.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443815132", "createdAt": "2020-06-22T20:43:59Z", "author": {"login": "AHeise"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons:\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The workaround is to\n+store the watermark in the operator state. If rescaling may occur, watermarks\n+should be stored per key-group in a union-state. We mostly likely will\n+implement this approach as a general solution (didn't make it into Flink \n+1.11.0).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MjEyOQ=="}, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ2NDUyOnYy", "diffSide": "RIGHT", "path": "docs/ops/state/checkpoints.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMjoxN1rOGnHpcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMjoxN1rOGnHpcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Mjk0NQ==", "bodyText": "I would also mention that flatMap operators can lead to unbounded spilled data.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672945", "createdAt": "2020-06-22T16:12:17Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4217, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}