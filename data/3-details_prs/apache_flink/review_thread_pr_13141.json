{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MzgwMzc3", "number": 13141, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNTo1NToyM1rOEYWI4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNTo1NToyM1rOEYWI4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzOTY0MDAxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/runtime/stream/table/TableSourceITCase.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNTo1NToyM1rOHAocog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNTo1NToyM1rOHAocog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyNDczOA==", "bodyText": "use new methods instead of depreacted methods\nuse DDL to register a table (StreamTableSourceScan path). registerTableSourceInternal is a hack way.\nWe may need to support parallelism property for the COLLECTION source (TestCollectionTableFactory).\n\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                val table = env.fromElements[String]()\n          \n          \n            \n                  .setParallelism(1)\n          \n          \n            \n                  .toTable(tEnv, 'a)\n          \n          \n            \n            \n          \n          \n            \n                tEnv.registerTable(\"MyTable1\", table)\n          \n          \n            \n                val parallelism = tEnv.scan(\"MyTable1\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .getParallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism)\n          \n          \n            \n            \n          \n          \n            \n                // test StreamTableSourceScan\n          \n          \n            \n                val tableSource = new StreamTableSource[String]() {\n          \n          \n            \n            \n          \n          \n            \n                  override def getDataStream(execEnv: JExecEnv): DataStream[String] = {\n          \n          \n            \n                    execEnv.fromElements[String](\"blabla\")\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  override def getTableSchema: TableSchema = {\n          \n          \n            \n                    new TableSchema(Array(\"a\"), Array(Types.STRING()))\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  override def getReturnType: TypeInformation[String] = {\n          \n          \n            \n                    Types.STRING()\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                tEnv.asInstanceOf[TableEnvironmentInternal].registerTableSourceInternal(\"MyTable2\", tableSource)\n          \n          \n            \n                val parallelism2 = tEnv.scan(\"MyTable2\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .getParallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism2)\n          \n          \n            \n               tEnv.createTemporaryView(\"MyTable1\", table)\n          \n          \n            \n                val parallelism = tEnv.from(\"MyTable1\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .parallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism)\n          \n          \n            \n            \n          \n          \n            \n                // test StreamTableSourceScan\n          \n          \n            \n                val createTableStmt =\n          \n          \n            \n                  \"\"\"\n          \n          \n            \n                    |CREATE TEMPORARY TABLE MyTable2 (\n          \n          \n            \n                    |  str varchar\n          \n          \n            \n                    |) with (\n          \n          \n            \n                    |  'connector' = 'COLLECTION',\n          \n          \n            \n                    |  'is-bounded' = 'false',\n          \n          \n            \n                    | 'parallelism' = '1'\n          \n          \n            \n                    |)\n          \n          \n            \n                  \"\"\".stripMargin\n          \n          \n            \n                tEnv.executeSql(createTableStmt)\n          \n          \n            \n            \n          \n          \n            \n                val parallelism2 = tEnv.from(\"MyTable2\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .parallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism2)", "url": "https://github.com/apache/flink/pull/13141#discussion_r470424738", "createdAt": "2020-08-14T05:55:23Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/runtime/stream/table/TableSourceITCase.scala", "diffHunk": "@@ -81,6 +81,51 @@ class TableSourceITCase extends AbstractTestBase {\n     // info.\n   }\n \n+  @Test\n+  def testStreamScanParallelism(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val settings = EnvironmentSettings.newInstance().useOldPlanner().build()\n+    val tEnv = StreamTableEnvironment.create(env, settings)\n+\n+    // set environment parallelism to 4\n+    env.setParallelism(4)\n+\n+    // test DataStreamScan\n+    val table = env.fromElements[String]()\n+      .setParallelism(1)\n+      .toTable(tEnv, 'a)\n+\n+    tEnv.registerTable(\"MyTable1\", table)\n+    val parallelism = tEnv.scan(\"MyTable1\")\n+      .toAppendStream[String]\n+      .getParallelism\n+\n+    assertEquals(1, parallelism)\n+\n+    // test StreamTableSourceScan\n+    val tableSource = new StreamTableSource[String]() {\n+\n+      override def getDataStream(execEnv: JExecEnv): DataStream[String] = {\n+        execEnv.fromElements[String](\"blabla\")\n+      }\n+\n+      override def getTableSchema: TableSchema = {\n+        new TableSchema(Array(\"a\"), Array(Types.STRING()))\n+      }\n+\n+      override def getReturnType: TypeInformation[String] = {\n+        Types.STRING()\n+      }\n+    }\n+\n+    tEnv.asInstanceOf[TableEnvironmentInternal].registerTableSourceInternal(\"MyTable2\", tableSource)\n+    val parallelism2 = tEnv.scan(\"MyTable2\")\n+      .toAppendStream[String]\n+      .getParallelism\n+\n+    assertEquals(1, parallelism2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed47271c426abff4426ccf2d0fd5858e6f3d8390"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 553, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}