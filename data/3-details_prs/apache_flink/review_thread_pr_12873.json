{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTAwNDUy", "number": 12873, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozNjo1OVrOEOkF2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Mzo0M1rOEPZ6-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzA2ODQwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozNjo1OVrOGxx_NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozNjo1OVrOGxx_NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MjQwNQ==", "bodyText": "nit: rename to topProjectInputIndices \uff1f", "url": "https://github.com/apache/flink/pull/12873#discussion_r454852405", "createdAt": "2020-07-15T07:36:59Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzA3MDA0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozNzoyNlrOGxyAHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozNzoyNlrOGxyAHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MjYzOQ==", "bodyText": "nit: rename to topFilterInputIndices", "url": "https://github.com/apache/flink/pull/12873#discussion_r454852639", "createdAt": "2020-07-15T07:37:26Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzA3MjczOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozODoxM1rOGxyBwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozODoxM1rOGxyBwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzA1Ng==", "bodyText": "nit: rename to  bottomProjectList", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853056", "createdAt": "2020-07-15T07:38:13Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzA3NDg0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozODo1M1rOGxyDDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozODo1M1rOGxyDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzM4OA==", "bodyText": "nit: put them just one line ?", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853388", "createdAt": "2020-07-15T07:38:53Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzA3NzAwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozOTozMVrOGxyESg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzozOTozMVrOGxyESg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzcwNg==", "bodyText": "nit: rename rexNode to project", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853706", "createdAt": "2020-07-15T07:39:31Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzEwNDc5OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0NzoyNFrOGxyVdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0NzoyNFrOGxyVdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODEwMw==", "bodyText": "combine topProjectRexNodesInputs and topFilterRexNodesInputs  into  one list, then this foreach can be removed", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858103", "createdAt": "2020-07-15T07:47:24Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {\n+        var nonDeterministicRexRefCnt = 0\n+        if (!RexUtil.isDeterministic(rexNode)) {\n+          topProjectRexNodesInputs.foreach(list => list.foreach(\n+            ref => if (ref == index) {\n+              nonDeterministicRexRefCnt += 1\n+            }))\n+          topFilterRexNodesInputs.foreach(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzEwNTkxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0Nzo0NlrOGxyWJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0Nzo0NlrOGxyWJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODI3OA==", "bodyText": "rename list to indices ?", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858278", "createdAt": "2020-07-15T07:47:46Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {\n+        var nonDeterministicRexRefCnt = 0\n+        if (!RexUtil.isDeterministic(rexNode)) {\n+          topProjectRexNodesInputs.foreach(list => list.foreach(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzEwNzc0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0ODoxNVrOGxyXNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo0ODoxNVrOGxyXNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODU0OQ==", "bodyText": "extract these logic into another method? and please update the javadoc", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858549", "createdAt": "2020-07-15T07:48:15Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzEyMjU1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo1MjozMFrOGxygRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo1MjozMFrOGxygRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MDg2OA==", "bodyText": "move this common line into setup method", "url": "https://github.com/apache/flink/pull/12873#discussion_r454860868", "createdAt": "2020-07-15T07:52:30Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "diffHunk": "@@ -82,4 +82,35 @@ class FlinkCalcMergeRuleTest extends TableTestBase {\n     val sqlQuery = \"SELECT a FROM (SELECT a FROM MyTable) t WHERE random_udf(a) > 10\"\n     util.verifyPlan(sqlQuery)\n   }\n+\n+  @Test\n+  def testCalcMergeWithNestedNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzEyNjE3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo1MzoyN1rOGxyiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzo1MzoyN1rOGxyiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MTQwNg==", "bodyText": "please add a case about: top filter references a bottom non-deterministic project", "url": "https://github.com/apache/flink/pull/12873#discussion_r454861406", "createdAt": "2020-07-15T07:53:27Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "diffHunk": "@@ -82,4 +82,35 @@ class FlinkCalcMergeRuleTest extends TableTestBase {\n     val sqlQuery = \"SELECT a FROM (SELECT a FROM MyTable) t WHERE random_udf(a) > 10\"\n     util.verifyPlan(sqlQuery)\n   }\n+\n+  @Test\n+  def testCalcMergeWithNestedNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT random_udf(a1) as a2 FROM (SELECT random_udf(a) as\" +\n+      \" a1, b FROM MyTable) t WHERE b > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithTopMultiNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT random_udf(a1) as a2, random_udf(a1) as a3 FROM\" +\n+      \" (SELECT random_udf(a) as a1, b FROM MyTable) t WHERE b > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithBottomMultiNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT a1, b2 FROM\" +\n+      \" (SELECT random_udf(a) as a1, random_udf(b) as b2, c FROM MyTable) t WHERE c > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithoutInnerNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT a, c FROM (SELECT a, random_udf(a) as a1, c FROM MyTable) t WHERE c > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d348328658445fbc11b8a310f8f0fbd163acf308"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTg3MzM0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo0NTo1NVrOGzGHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo0NTo1NVrOGzGHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMDcyNQ==", "bodyText": "This line should move out-of forall, otherwise the topProjectInputIndices will contain many topFilterInputIndicess if there is multiple non-deterministic expression in bottom project.", "url": "https://github.com/apache/flink/pull/12873#discussion_r456230725", "createdAt": "2020-07-17T05:45:55Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -61,36 +61,43 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n-    // topCalc's project fields and condition field.\n+    isMergeable(topCalc, bottomCalc)\n+  }\n+\n+  /**\n+   * Return two neighbouring [[Calc]] can merge into one [[Calc]] or not. If the two [[Calc]] can\n+   * merge into one, each non-deterministic [[RexNode]] of bottom [[Calc]] should appear at most\n+   * once in the project list and filter list of top [[Calc]].\n+   */\n+  private def isMergeable(topCalc: Calc, bottomCalc: Calc): Boolean = {\n+    val topProgram = topCalc.getProgram\n     val bottomProgram = bottomCalc.getProgram\n-    val topProjectRexNodesInputs = topProgram.getProjectList\n+    val topProjectInputIndices = topProgram.getProjectList\n       .map(r => topProgram.expandLocalRef(r))\n       .map(r => InputFinder.bits(r).toArray)\n \n-    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n-      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n-        .toArray\n+    val topFilterInputIndices = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition)).toArray\n     } else {\n       new Array[Int](0)\n     }\n \n-    val bottomRexList = bottomProgram.getProjectList\n+    val bottomProjectList = bottomProgram.getProjectList\n       .map(r => bottomProgram.expandLocalRef(r))\n       .toArray\n \n-    bottomRexList.zipWithIndex.forall {\n-      case (rexNode: RexNode, index: Int) => {\n+    bottomProjectList.zipWithIndex.forall {\n+      case (project: RexNode, index: Int) => {\n         var nonDeterministicRexRefCnt = 0\n-        if (!RexUtil.isDeterministic(rexNode)) {\n-          topProjectRexNodesInputs.foreach(list => list.foreach(\n-            ref => if (ref == index) {\n-              nonDeterministicRexRefCnt += 1\n-            }))\n-          topFilterRexNodesInputs.foreach(\n-            ref => if (ref == index) {\n-              nonDeterministicRexRefCnt += 1\n-            })\n+        if (!RexUtil.isDeterministic(project)) {\n+          topProjectInputIndices.add(topFilterInputIndices)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24c77b9c54d326b4f6b51a716669df85d6f59a3f"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTg4Nzk1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Mzo0M1rOGzGQCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Mzo0M1rOGzGQCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMjk3MA==", "bodyText": "topProjectInputIndices :+ topFilterInputIndices", "url": "https://github.com/apache/flink/pull/12873#discussion_r456232970", "createdAt": "2020-07-17T05:53:43Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -86,12 +88,14 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       .map(r => bottomProgram.expandLocalRef(r))\n       .toArray\n \n+    topProjectInputIndices.add(topFilterInputIndices)\n+    val topInputIndices = topProjectInputIndices", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a627186bdc24c604ae1d188921d3668c94c16c"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4186, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}