{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwNDkzMDc1", "number": 13331, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MDoxNFrOEvwmHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODowMjo0NVrOE1icxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTE0NzE4OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecDeduplicate.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MDoxNFrOHk6szw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MDoxNFrOHk6szw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3MjUyNw==", "bodyText": "You can use uniqueKeys .map(idx => inputFieldTypes(idx)) directly.", "url": "https://github.com/apache/flink/pull/13331#discussion_r508472527", "createdAt": "2020-10-20T12:50:14Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecDeduplicate.scala", "diffHunk": "@@ -102,44 +110,109 @@ class StreamExecDeduplicate(\n       .asInstanceOf[Transformation[RowData]]\n \n     val rowTypeInfo = inputTransform.getOutputType.asInstanceOf[InternalTypeInfo[RowData]]\n+    val inputFieldTypes = rowTypeInfo.toRowFieldTypes\n+    val keyFieldTypes = new Array[LogicalType](uniqueKeys.length)\n+    for (i <- 0 until uniqueKeys.length) {\n+      keyFieldTypes(i) = inputFieldTypes(uniqueKeys(i))\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a2d274bd70b8006c267be02ee48ee5b9def3bb"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTE2MTc0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecDeduplicate.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MzoxOVrOHk61gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MzoxOVrOHk61gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3NDc1NQ==", "bodyText": "Can we have 2 sub-class here ? One is for proctime another is for rowtime, in each class, we can have a method to return the row function getRowFunctction(isMiniBatchEnabled, keepLastRow).\nThere are too many if else branches here and it is hard to maintain.", "url": "https://github.com/apache/flink/pull/13331#discussion_r508474755", "createdAt": "2020-10-20T12:53:19Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecDeduplicate.scala", "diffHunk": "@@ -102,44 +110,109 @@ class StreamExecDeduplicate(\n       .asInstanceOf[Transformation[RowData]]\n \n     val rowTypeInfo = inputTransform.getOutputType.asInstanceOf[InternalTypeInfo[RowData]]\n+    val inputFieldTypes = rowTypeInfo.toRowFieldTypes\n+    val keyFieldTypes = new Array[LogicalType](uniqueKeys.length)\n+    for (i <- 0 until uniqueKeys.length) {\n+      keyFieldTypes(i) = inputFieldTypes(uniqueKeys(i))\n+    }\n+\n     val generateUpdateBefore = ChangelogPlanUtils.generateUpdateBefore(this)\n     val tableConfig = planner.getTableConfig\n     val generateInsert = tableConfig.getConfiguration\n       .getBoolean(TABLE_EXEC_INSERT_AND_UPDATE_AFTER_SENSITIVE)\n     val isMiniBatchEnabled = tableConfig.getConfiguration.getBoolean(\n       ExecutionConfigOptions.TABLE_EXEC_MINIBATCH_ENABLED)\n     val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n-    val operator = if (isMiniBatchEnabled) {\n-      val exeConfig = planner.getExecEnv.getConfig\n-      val rowSerializer = rowTypeInfo.createSerializer(exeConfig)\n+\n+    val rowtimeField = input.getRowType.getFieldList\n+      .filter(f => FlinkTypeFactory.isRowtimeIndicatorType(f.getType))\n+    val rowtimeIndex = if (isRowtime) {\n+      Preconditions.checkArgument(rowtimeField.nonEmpty)\n+      rowtimeField.get(0).getIndex\n+    } else {\n+      -1\n+    }\n+\n+    val miniBatchsize = if (isMiniBatchEnabled) {\n+      val size = tableConfig.getConfiguration.getLong(\n+        ExecutionConfigOptions.TABLE_EXEC_MINIBATCH_SIZE)\n+      Preconditions.checkArgument(size > 0)\n+      size\n+    } else {\n+      -1L\n+    }\n+    val exeConfig = planner.getExecEnv.getConfig\n+    val rowSerializer = rowTypeInfo.createSerializer(exeConfig)\n+\n+    val operator = if (isRowtime) {\n+      if(isMiniBatchEnabled) {\n+        val processFunction = if (keepLastRow) {\n+          new RowTimeMiniBatchDeduplicateKeepLastRowFunction(\n+            rowTypeInfo,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a2d274bd70b8006c267be02ee48ee5b9def3bb"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTE5Mzc2OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdHandlerTestBase.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMzowMDoyNlrOHk7JRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMzowMDoyNlrOHk7JRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3OTgxNQ==", "bodyText": "proctime => rowtime ?", "url": "https://github.com/apache/flink/pull/13331#discussion_r508479815", "createdAt": "2020-10-20T13:00:26Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdHandlerTestBase.scala", "diffHunk": "@@ -635,7 +635,25 @@ class FlinkRelMdHandlerTestBase {\n   //  select a, b, c, proctime\n   //  ROW_NUMBER() over (partition by b, c order by proctime desc) rn from TemporalTable3\n   // ) t where rn <= 1\n-  protected lazy val (streamDeduplicateFirstRow, streamDeduplicateLastRow) = {\n+  protected lazy val (streamProcTimeDeduplicateFirstRow, streamProcTimeDeduplicateLastRow) = {\n+    buildFirstRowAndLastRowDeduplicateNode(false)\n+  }\n+\n+  // equivalent SQL is\n+  // select a, b, c from (\n+  //  select a, b, c, rowtime\n+  //  ROW_NUMBER() over (partition by b order by rowtime) rn from TemporalTable3\n+  // ) t where rn <= 1\n+  //\n+  // select a, b, c from (\n+  //  select a, b, c, proctime\n+  //  ROW_NUMBER() over (partition by b, c order by rowtime desc) rn from TemporalTable3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a2d274bd70b8006c267be02ee48ee5b9def3bb"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI3MDE3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoyODo1OFrOHlY5ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoyODo1OFrOHlY5ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2NzI3NA==", "bodyText": "Do not need copy.", "url": "https://github.com/apache/flink/pull/13331#discussion_r508967274", "createdAt": "2020-10-21T03:28:58Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -93,6 +95,239 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last row,\n+\t * retracts previous element if needed.\n+\t *\n+\t * @param state state of function\n+\t * @param currentRow latest row received by deduplicate function\n+\t * @param serializer serializer to serialize the data\n+\t * @param out underlying collector\n+\t * @param rowtimeIndex index of row time field\n+\t * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert flag to gennerate INSERT message or not\n+\t */\n+\tstatic void processLastRowOnRowtime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tint rowtimeIndex,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData prevRow = state.value();\n+\t\tif (!isLastRow(prevRow, currentRow, rowtimeIndex)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tstate.update(currentRow);\n+\n+\t\t// store all needed data to state\n+\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\tif (prevRow == null) {\n+\t\t\t\t// the first row, send INSERT message\n+\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t} else {\n+\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\tRowData copyRow = serializer.copy(prevRow);\n+\t\t\t\t\tcopyRow.setRowKind(RowKind.UPDATE_BEFORE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a2d274bd70b8006c267be02ee48ee5b9def3bb"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI3MTMwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoyOToyMlrOHlY5_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoyOToyMlrOHlY5_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2NzQyMw==", "bodyText": "Can reuse the code in\nstatic void processLastRowOnRowtime(\n\t\t\tValueState<RowData> state,\n\t\t\tRowData currentRow,\n\t\t\tTypeSerializer<RowData> serializer,\n\t\t\tCollector<RowData> out,\n\t\t\tint rowtimeIndex,\n\t\t\tboolean generateUpdateBefore,\n\t\t\tboolean generateInsert)", "url": "https://github.com/apache/flink/pull/13331#discussion_r508967423", "createdAt": "2020-10-21T03:29:22Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -93,6 +95,239 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last row,\n+\t * retracts previous element if needed.\n+\t *\n+\t * @param state state of function\n+\t * @param currentRow latest row received by deduplicate function\n+\t * @param serializer serializer to serialize the data\n+\t * @param out underlying collector\n+\t * @param rowtimeIndex index of row time field\n+\t * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert flag to gennerate INSERT message or not\n+\t */\n+\tstatic void processLastRowOnRowtime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tint rowtimeIndex,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData prevRow = state.value();\n+\t\tif (!isLastRow(prevRow, currentRow, rowtimeIndex)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tstate.update(currentRow);\n+\n+\t\t// store all needed data to state\n+\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\tif (prevRow == null) {\n+\t\t\t\t// the first row, send INSERT message\n+\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t} else {\n+\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\tRowData copyRow = serializer.copy(prevRow);\n+\t\t\t\t\tcopyRow.setRowKind(RowKind.UPDATE_BEFORE);\n+\t\t\t\t\tout.collect(copyRow);\n+\t\t\t\t}\n+\t\t\t\tcurrentRow.setRowKind(RowKind.UPDATE_AFTER);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tcurrentRow.setRowKind(RowKind.UPDATE_AFTER);\n+\t\t\tout.collect(currentRow);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last row,\n+\t * retracts previous element if needed.\n+\t *\n+\t * @param state state of function\n+\t * @param bufferedRows latest rows received by deduplicate function\n+\t * @param serializer serializer to serialize the data\n+\t * @param out underlying collector\n+\t * @param rowtimeIndex index of row time field\n+\t * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert flag to gennerate INSERT message or not\n+\t */\n+\tstatic void processLastRowOnRowtime(\n+\t\tValueState<RowData> state,\n+\t\tList<RowData> bufferedRows,\n+\t\tTypeSerializer<RowData> serializer,\n+\t\tCollector<RowData> out,\n+\t\tint rowtimeIndex,\n+\t\tboolean generateUpdateBefore,\n+\t\tboolean generateInsert) throws Exception {\n+\n+\t\tif (bufferedRows == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tRowData prevRow = state.value();\n+\t\tfor (RowData currentRow: bufferedRows) {\n+\t\t\tcheckInsertOnly(currentRow);\n+\t\t\tif (!isLastRow(prevRow, currentRow, rowtimeIndex)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// store all needed data to state\n+\t\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\t\tif (prevRow == null) {\n+\t\t\t\t\t// the first row, send INSERT message\n+\t\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\t\tout.collect(currentRow);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\t\tRowData copyRow = serializer.copy(prevRow);\n+\t\t\t\t\t\tcopyRow.setRowKind(RowKind.UPDATE_BEFORE);\n+\t\t\t\t\t\tout.collect(copyRow);\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a2d274bd70b8006c267be02ee48ee5b9def3bb"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjI0NTcwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzozNDoyOVrOHrD71g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzozNDoyOVrOHrD71g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNTI4Ng==", "bodyText": "The code is almost same with processMiniBatchFirstRowOnRowtime, we can abstract the common code out here.", "url": "https://github.com/apache/flink/pull/13331#discussion_r514915286", "createdAt": "2020-10-30T07:34:29Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +149,226 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last row,\n+\t * retracts previous element if needed.\n+\t *\n+\t * @param state                state of function\n+\t * @param currentRow           latest row received by deduplicate function\n+\t * @param out                  underlying collector\n+\t * @param rowtimeIndex         index of row time field\n+\t * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert       flag to gennerate INSERT message or not\n+\t */\n+\tstatic void processLastRowOnRowtime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tint rowtimeIndex,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData prevRow = state.value();\n+\t\tif (!isLastRow(prevRow, currentRow, rowtimeIndex)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tstate.update(currentRow);\n+\n+\t\t// store all needed data to state\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tprevRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last row,\n+\t * retracts previous element if needed.\n+\t *\n+\t * @param state                state of function\n+\t * @param bufferedRows         latest rows received by deduplicate function\n+\t * @param serializer           serializer to serialize the data\n+\t * @param out                  underlying collector\n+\t * @param rowtimeIndex         index of row time field\n+\t * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert       flag to gennerate INSERT message or not\n+\t */\n+\tstatic void processMiniBatchLastRowOnRowtime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tint rowtimeIndex,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert) throws Exception {\n+\n+\t\tif (bufferedRows == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tRowData preRow = state.value();\n+\t\tfor (RowData currentRow : bufferedRows) {\n+\t\t\tcheckInsertOnly(currentRow);\n+\t\t\tif (!isLastRow(preRow, currentRow, rowtimeIndex)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3b2192b6cc216c691e833e40e52dfc64807e0a0"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjI0ODI3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateKeepFirstRowFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzozNTozM1rOHrD9SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzozNTozM1rOHrD9SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNTY1Nw==", "bodyText": "Both addInput and finishBundle can be moved to the base class.", "url": "https://github.com/apache/flink/pull/13331#discussion_r514915657", "createdAt": "2020-10-30T07:35:33Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateKeepFirstRowFunction.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.util.Collector;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.flink.table.runtime.operators.deduplicate.DeduplicateFunctionHelper.processMiniBatchFirstRowOnRowTime;\n+\n+/**\n+ * This function is used to get the first row for every key partition in miniBatch mode.\n+ */\n+public class RowTimeMiniBatchDeduplicateKeepFirstRowFunction\n+\t\textends MiniBatchDeduplicateFunctionBase<RowData, RowData, List<RowData>, RowData, RowData> {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate final int rowtimeIndex;\n+\tprivate final boolean generateUpdateBefore;\n+\tprivate final boolean generateInsert;\n+\n+\tpublic RowTimeMiniBatchDeduplicateKeepFirstRowFunction(\n+\t\t\tInternalTypeInfo<RowData> typeInfo,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tlong minRetentionTime,\n+\t\t\tint rowtimeIndex,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert) {\n+\t\tsuper(typeInfo, serializer, minRetentionTime);\n+\t\tthis.rowtimeIndex = rowtimeIndex;\n+\t\tthis.generateUpdateBefore = generateUpdateBefore;\n+\t\tthis.generateInsert = generateInsert;\n+\t}\n+\n+\t@Override\n+\tpublic List<RowData> addInput(@Nullable List<RowData> value, RowData input) throws Exception {\n+\t\tif (value == null) {\n+\t\t\tvalue = new ArrayList<>();\n+\t\t}\n+\t\tvalue.add(serializer.copy(input));\n+\t\treturn value;\n+\t}\n+\n+\t@Override\n+\tpublic void finishBundle(Map<RowData, List<RowData>> buffer, Collector<RowData> out) throws Exception {\n+\t\tfor (Map.Entry<RowData, List<RowData>> entry : buffer.entrySet()) {\n+\t\t\tRowData currentKey = entry.getKey();\n+\t\t\tList<RowData> bufferedRows = entry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3b2192b6cc216c691e833e40e52dfc64807e0a0"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQwODYxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowMDoyMFrOHr5iOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowMDoyMFrOHr5iOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MzQ2Nw==", "bodyText": "It is only used in RowTimeMiniBatchDeduplicateFunction. We don't need to put it in the util class.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515793467", "createdAt": "2020-11-02T08:00:20Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQxMDQyOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowMDo1NVrOHr5jRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODowMDo1NVrOHr5jRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MzczMg==", "bodyText": "I think bufferedRows would never be null, but maybe empty.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515793732", "createdAt": "2020-11-02T08:00:55Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\t\tif (bufferedRows == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQ0NjAwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzowM1rOHr54AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzowM1rOHr54AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5OTA0MA==", "bodyText": "It would be better to remove this serializer, as it is never used in the base class. It confuses what's this used for, and it's error-prone, becuase it's nullable.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515799040", "createdAt": "2020-11-02T08:13:03Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.state.StateTtlConfig;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.runtime.context.ExecutionContext;\n+import org.apache.flink.table.runtime.operators.bundle.MapBundleFunction;\n+\n+import static org.apache.flink.table.runtime.util.StateTtlConfigUtil.createTtlConfig;\n+\n+/**\n+ * Base class for miniBatch deduplicate function.\n+ * @param <T>   The type of the value in the state.\n+ * @param <K>   The type of the key in the bundle map.\n+ * @param <V>   The type of the value in the bundle map.\n+ * @param <IN>  Type of the input elements.\n+ * @param <OUT> Type of the returned elements.\n+ */\n+abstract class MiniBatchDeduplicateFunctionBase<T, K, V, IN, OUT> extends MapBundleFunction<K, V, IN, OUT> {\n+\n+\tprotected final TypeInformation<T> typeInfo;\n+\tprotected final TypeSerializer<OUT> serializer;\n+\tprotected final long minRetentionTime;\n+\t// state stores previous message under the key.\n+\tprotected ValueState<T> state;\n+\n+\tpublic MiniBatchDeduplicateFunctionBase(\n+\t\t\tTypeInformation<T> typeInfo,\n+\t\t\tTypeSerializer<OUT> serializer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQ0NjgwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzoxOVrOHr54gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzoxOVrOHr54gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5OTE3MQ==", "bodyText": "typeInfo -> stateType to be more specifically.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515799171", "createdAt": "2020-11-02T08:13:19Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.state.StateTtlConfig;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.runtime.context.ExecutionContext;\n+import org.apache.flink.table.runtime.operators.bundle.MapBundleFunction;\n+\n+import static org.apache.flink.table.runtime.util.StateTtlConfigUtil.createTtlConfig;\n+\n+/**\n+ * Base class for miniBatch deduplicate function.\n+ * @param <T>   The type of the value in the state.\n+ * @param <K>   The type of the key in the bundle map.\n+ * @param <V>   The type of the value in the bundle map.\n+ * @param <IN>  Type of the input elements.\n+ * @param <OUT> Type of the returned elements.\n+ */\n+abstract class MiniBatchDeduplicateFunctionBase<T, K, V, IN, OUT> extends MapBundleFunction<K, V, IN, OUT> {\n+\n+\tprotected final TypeInformation<T> typeInfo;\n+\tprotected final TypeSerializer<OUT> serializer;\n+\tprotected final long minRetentionTime;\n+\t// state stores previous message under the key.\n+\tprotected ValueState<T> state;\n+\n+\tpublic MiniBatchDeduplicateFunctionBase(\n+\t\t\tTypeInformation<T> typeInfo,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQ0ODQ3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzo1NFrOHr55jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxMzo1NFrOHr55jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5OTQzOA==", "bodyText": "Add serialVersionUID.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515799438", "createdAt": "2020-11-02T08:13:54Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/MiniBatchDeduplicateFunctionBase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.state.StateTtlConfig;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.runtime.context.ExecutionContext;\n+import org.apache.flink.table.runtime.operators.bundle.MapBundleFunction;\n+\n+import static org.apache.flink.table.runtime.util.StateTtlConfigUtil.createTtlConfig;\n+\n+/**\n+ * Base class for miniBatch deduplicate function.\n+ * @param <T>   The type of the value in the state.\n+ * @param <K>   The type of the key in the bundle map.\n+ * @param <V>   The type of the value in the bundle map.\n+ * @param <IN>  Type of the input elements.\n+ * @param <OUT> Type of the returned elements.\n+ */\n+abstract class MiniBatchDeduplicateFunctionBase<T, K, V, IN, OUT> extends MapBundleFunction<K, V, IN, OUT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQ2Mjk1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoxODozM1rOHr6CFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoyMzowNVrOHtR0tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwMTYyMA==", "bodyText": "Why we have to do a deep copy here?\nIf it is for not affecting the original preRow, we can set back RowKind after collecting preRow (non-minibatch mode also has this problem).", "url": "https://github.com/apache/flink/pull/13331#discussion_r515801620", "createdAt": "2020-11-02T08:18:33Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\t\tif (bufferedRows == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tRowData preRow = state.value();\n+\t\tfor (RowData currentRow : bufferedRows) {\n+\t\t\tcheckInsertOnly(currentRow);\n+\t\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tcollectRetractResult(\n+\t\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\t\tgenerateInsert,\n+\t\t\t\t\tpreRow,\n+\t\t\t\t\tcurrentRow,\n+\t\t\t\t\tout,\n+\t\t\t\t\tserializer\n+\t\t\t);\n+\t\t\tpreRow = currentRow;\n+\t\t}\n+\t\tstate.update(preRow);\n+\t}\n+\n+\tprivate static void collectRetractResult(\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tRowData preRow,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tTypeSerializer<RowData> serializer) {\n+\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\tif (preRow == null) {\n+\t\t\t\t// the first row, send INSERT message\n+\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t} else {\n+\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\tRowData copyRow;\n+\t\t\t\t\t// when miniBatch enabled, do a copy here, the serializer is not null\n+\t\t\t\t\tif (serializer != null) {\n+\t\t\t\t\t\tcopyRow = serializer.copy(preRow);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwODQzMw==", "bodyText": "If this copying can be removed, the implementations of collectRetractResult and processLastRowOnProcTime are totally the same. I feel that collectRetractResult is not suitable, because it not always generates retractions.\nWhat about combine them in the the following new method?\nstatic void updateDeduplicateResult(\n\t\t\tRowData currentRow,  // new row result of deduplicate under current key\n\t\t\tValueState<RowData> state, // the state stores the previous collected row under current key\n\t\t\tboolean generateUpdateBefore,           \n\t\t\tboolean generateInsert,\n\t\t\tCollector<RowData> out) throws Exception {", "url": "https://github.com/apache/flink/pull/13331#discussion_r515808433", "createdAt": "2020-11-02T08:31:51Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\t\tif (bufferedRows == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tRowData preRow = state.value();\n+\t\tfor (RowData currentRow : bufferedRows) {\n+\t\t\tcheckInsertOnly(currentRow);\n+\t\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tcollectRetractResult(\n+\t\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\t\tgenerateInsert,\n+\t\t\t\t\tpreRow,\n+\t\t\t\t\tcurrentRow,\n+\t\t\t\t\tout,\n+\t\t\t\t\tserializer\n+\t\t\t);\n+\t\t\tpreRow = currentRow;\n+\t\t}\n+\t\tstate.update(preRow);\n+\t}\n+\n+\tprivate static void collectRetractResult(\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tRowData preRow,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tTypeSerializer<RowData> serializer) {\n+\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\tif (preRow == null) {\n+\t\t\t\t// the first row, send INSERT message\n+\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t} else {\n+\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\tRowData copyRow;\n+\t\t\t\t\t// when miniBatch enabled, do a copy here, the serializer is not null\n+\t\t\t\t\tif (serializer != null) {\n+\t\t\t\t\t\tcopyRow = serializer.copy(preRow);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwMTYyMA=="}, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIzOTk5MQ==", "bodyText": "the state update logic is a little different, I skip this one", "url": "https://github.com/apache/flink/pull/13331#discussion_r517239991", "createdAt": "2020-11-04T10:23:05Z", "author": {"login": "leonardBang"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\t\tif (bufferedRows == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tRowData preRow = state.value();\n+\t\tfor (RowData currentRow : bufferedRows) {\n+\t\t\tcheckInsertOnly(currentRow);\n+\t\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tcollectRetractResult(\n+\t\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\t\tgenerateInsert,\n+\t\t\t\t\tpreRow,\n+\t\t\t\t\tcurrentRow,\n+\t\t\t\t\tout,\n+\t\t\t\t\tserializer\n+\t\t\t);\n+\t\t\tpreRow = currentRow;\n+\t\t}\n+\t\tstate.update(preRow);\n+\t}\n+\n+\tprivate static void collectRetractResult(\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tRowData preRow,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tTypeSerializer<RowData> serializer) {\n+\t\tif (generateUpdateBefore || generateInsert) {\n+\t\t\tif (preRow == null) {\n+\t\t\t\t// the first row, send INSERT message\n+\t\t\t\tcurrentRow.setRowKind(RowKind.INSERT);\n+\t\t\t\tout.collect(currentRow);\n+\t\t\t} else {\n+\t\t\t\tif (generateUpdateBefore) {\n+\t\t\t\t\tRowData copyRow;\n+\t\t\t\t\t// when miniBatch enabled, do a copy here, the serializer is not null\n+\t\t\t\t\tif (serializer != null) {\n+\t\t\t\t\t\tcopyRow = serializer.copy(preRow);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwMTYyMA=="}, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjUxNTk1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNDoyOVrOHr6hfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNDoyOVrOHr6hfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwOTY2Mg==", "bodyText": "If this method can be moved in RowTimeMiniBatchDeduplicateFunction,  I think we don't need the special DeduplicateOrderFunctionProvider parameter then, because we have keepLastRow flag.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515809662", "createdAt": "2020-11-02T08:34:29Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tRowData currentRow,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {\n+\n+\t\tcheckInsertOnly(currentRow);\n+\t\tRowData preRow = state.value();\n+\t\tif (!orderFunctionProvider.matches(preRow, currentRow)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcollectRetractResult(\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tpreRow,\n+\t\t\t\tcurrentRow,\n+\t\t\t\tout,\n+\t\t\t\tnull\n+\t\t);\n+\t\tstate.update(currentRow);\n+\t}\n+\n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param bufferedRows          latest row received by deduplicate function\n+\t * @param serializer            serializer to serialize the data\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void miniBatchDeduplicateOnRowTime(\n+\t\t\tValueState<RowData> state,\n+\t\t\tList<RowData> bufferedRows,\n+\t\t\tTypeSerializer<RowData> serializer,\n+\t\t\tCollector<RowData> out,\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tDeduplicateOrderFunctionProvider orderFunctionProvider) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjUxODE0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNTowNFrOHr6iqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNTowNFrOHr6iqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwOTk2MQ==", "bodyText": "ditto.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515809961", "createdAt": "2020-11-02T08:35:04Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/DeduplicateFunctionHelper.java", "diffHunk": "@@ -147,6 +150,148 @@ static void processFirstRow(\n \t\tout.collect(currentRow);\n \t}\n \n+\t/**\n+\t * Processes element to deduplicate on keys with row time semantic, sends current element if it is last\n+\t * or first row, retracts previous element if needed.\n+\t *\n+\t * @param state                 state of function\n+\t * @param currentRow            latest row received by deduplicate function\n+\t * @param out                   underlying collector\n+\t * @param generateUpdateBefore  flag to generate UPDATE_BEFORE message or not\n+\t * @param generateInsert        flag to gennerate INSERT message or not\n+\t * @param orderFunctionProvider provider that provides an order function to judge first or last\n+\t */\n+\tpublic static void deduplicateOnRowTime(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjUyODA5OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeDeduplicateFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNzo1NVrOHr6org==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODozNzo1NVrOHr6org==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgxMTUwMg==", "bodyText": "Miss @Test?", "url": "https://github.com/apache/flink/pull/13331#discussion_r515811502", "createdAt": "2020-11-02T08:37:55Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeDeduplicateFunctionTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.streaming.api.operators.KeyedProcessOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+\n+/**\n+ * Tests for {@link RowTimeDeduplicateFunction}.\n+ */\n+@RunWith(Parameterized.class)\n+public class RowTimeDeduplicateFunctionTest extends RowTimeDeduplicateFunctionTestBase {\n+\n+\tprivate final boolean generateUpdateBefore;\n+\tprivate final boolean generateInsert;\n+\n+\tpublic RowTimeDeduplicateFunctionTest(boolean generateUpdateBefore, boolean generateInsert) {\n+\t\tthis.generateUpdateBefore = generateUpdateBefore;\n+\t\tthis.generateInsert = generateInsert;\n+\t}\n+\n+\t@Test\n+\tpublic void testRowTimeDeduplicateKeepFirstRow() throws Exception {\n+\t\tfinal boolean keepLastRow = false;\n+\t\tRowTimeDeduplicateFunction func = new RowTimeDeduplicateFunction(\n+\t\t\t\tinputRowType,\n+\t\t\t\tminTtlTime.toMilliseconds(),\n+\t\t\t\trowTimeIndex,\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tkeepLastRow);\n+\t\tKeyedProcessOperator<RowData, RowData, RowData> operator = new KeyedProcessOperator<>(func);\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(operator);\n+\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 100L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 101L));\n+\n+\t\t// test 1: keep first row with row time\n+\t\ttestHarness.processWatermark(new Watermark(102));\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 1), testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\n+\t\ttestHarness = createTestHarness(operator);\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 300L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 301L));\n+\t\ttestHarness.processElement(insertRecord(\"key3\", 5, 299L));\n+\n+\t\t// test 2: load snapshot state\n+\t\ttestHarness.processWatermark(new Watermark(302));\n+\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 2), testHarness.getOutput());\n+\n+\t\t// test 3: expire the state\n+\t\ttestHarness.setStateTtlProcessingTime(minTtlTime.toMilliseconds() + 1);\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 400L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 401L));\n+\t\ttestHarness.processWatermark(402);\n+\n+\t\t// (\"key1\", 13, 99L) and (\"key2\", 11, 101L) had retired, thus output (\"key1\", 12, 200L),(\"key2\", 11, 201L)\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 3), testHarness.getOutput());\n+\t\ttestHarness.close();\n+\t}\n+\n+\tpublic void testRowTimeDeduplicateKeepLastRow() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjU0OTc0OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeDeduplicateFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODo0Mzo0NlrOHr61PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODo0Mzo0NlrOHr61PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgxNDcxNw==", "bodyText": "It's super hard to understand what the expect result is.\nI think if the result are different, then we shouldn't parameterize them into one test. We can follow the way of TemporalRowTimeJoinOperatorTest that resue the same test data in a common private method, but delcare differenet expected output in different test methods.\nBesides, I think we can't share the expected output for both minibatch and non-minibatch mode?", "url": "https://github.com/apache/flink/pull/13331#discussion_r515814717", "createdAt": "2020-11-02T08:43:46Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeDeduplicateFunctionTest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.streaming.api.operators.KeyedProcessOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+\n+/**\n+ * Tests for {@link RowTimeDeduplicateFunction}.\n+ */\n+@RunWith(Parameterized.class)\n+public class RowTimeDeduplicateFunctionTest extends RowTimeDeduplicateFunctionTestBase {\n+\n+\tprivate final boolean generateUpdateBefore;\n+\tprivate final boolean generateInsert;\n+\n+\tpublic RowTimeDeduplicateFunctionTest(boolean generateUpdateBefore, boolean generateInsert) {\n+\t\tthis.generateUpdateBefore = generateUpdateBefore;\n+\t\tthis.generateInsert = generateInsert;\n+\t}\n+\n+\t@Test\n+\tpublic void testRowTimeDeduplicateKeepFirstRow() throws Exception {\n+\t\tfinal boolean keepLastRow = false;\n+\t\tRowTimeDeduplicateFunction func = new RowTimeDeduplicateFunction(\n+\t\t\t\tinputRowType,\n+\t\t\t\tminTtlTime.toMilliseconds(),\n+\t\t\t\trowTimeIndex,\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\tkeepLastRow);\n+\t\tKeyedProcessOperator<RowData, RowData, RowData> operator = new KeyedProcessOperator<>(func);\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(operator);\n+\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 100L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 101L));\n+\n+\t\t// test 1: keep first row with row time\n+\t\ttestHarness.processWatermark(new Watermark(102));\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 1), testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\n+\t\ttestHarness = createTestHarness(operator);\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 300L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 301L));\n+\t\ttestHarness.processElement(insertRecord(\"key3\", 5, 299L));\n+\n+\t\t// test 2: load snapshot state\n+\t\ttestHarness.processWatermark(new Watermark(302));\n+\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 2), testHarness.getOutput());\n+\n+\t\t// test 3: expire the state\n+\t\ttestHarness.setStateTtlProcessingTime(minTtlTime.toMilliseconds() + 1);\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 400L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 401L));\n+\t\ttestHarness.processWatermark(402);\n+\n+\t\t// (\"key1\", 13, 99L) and (\"key2\", 11, 101L) had retired, thus output (\"key1\", 12, 200L),(\"key2\", 11, 201L)\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 3), testHarness.getOutput());\n+\t\ttestHarness.close();\n+\t}\n+\n+\tpublic void testRowTimeDeduplicateKeepLastRow() throws Exception {\n+\t\tfinal boolean keepLastRow = true;\n+\t\tRowTimeDeduplicateFunction func = new RowTimeDeduplicateFunction(\n+\t\t\t\tinputRowType,\n+\t\t\t\tminTtlTime.toMilliseconds(),\n+\t\t\t\trowTimeIndex,\n+\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\tgenerateInsert,\n+\t\t\t\ttrue);\n+\t\tKeyedProcessOperator<RowData, RowData, RowData> operator = new KeyedProcessOperator<>(func);\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(operator);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 100L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 101L));\n+\n+\t\t// test 1: keep last row with row time\n+\t\ttestHarness.processWatermark(new Watermark(102));\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 1), testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\n+\t\ttestHarness = createTestHarness(operator);\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 300L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 301L));\n+\t\ttestHarness.processElement(insertRecord(\"key3\", 5, 299L));\n+\n+\t\t// test 2: load snapshot state\n+\t\ttestHarness.processWatermark(new Watermark(302));\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 2), testHarness.getOutput());\n+\n+\t\t// test 3: expire the state\n+\t\ttestHarness.setStateTtlProcessingTime(minTtlTime.toMilliseconds() + 1);\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 400L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 401L));\n+\t\ttestHarness.processWatermark(402);\n+\n+\t\t// all state has expired, so the record (\"key1\", 12, 400L), (\"key2\", 12, 401L) will be INSERT message\n+\t\tassertor.assertOutputEqualsSorted(\"output wrong.\", getExpectOutput(keepLastRow, 3), testHarness.getOutput());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjU1OTg2OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/DeduplicateITCase.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODo0NjozNFrOHr67Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODo0NjozNFrOHr67Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgxNjIzOQ==", "bodyText": "If we want to verify the changelog result, I would suggest to use single parallelism and do not sort the result. Otherwise, we didn't actually test the changelog order. For example, it's hard to understand why -U is after +U in the above test.\nWe can also just verify the merged result and can use the default parallelism.", "url": "https://github.com/apache/flink/pull/13331#discussion_r515816239", "createdAt": "2020-11-02T08:46:34Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/DeduplicateITCase.scala", "diffHunk": "@@ -137,4 +152,93 @@ class DeduplicateITCase(miniBatch: MiniBatchMode, mode: StateBackendMode)\n     assertEquals(expected.sorted, sink.getRetractResults.sorted)\n   }\n \n+  @Test\n+  def testFirstRowOnRowtime(): Unit = {\n+    val t = env.fromCollection(rowtimeTestData)\n+      .assignTimestampsAndWatermarks(new RowtimeExtractor)\n+      .toTable(tEnv, 'a, 'b, 'c, 'rowtime.rowtime())\n+    tEnv.registerTable(\"T\", t)\n+    createSinkTable(\"rowtime_sink\")\n+\n+    val sql =\n+      \"\"\"\n+        |INSERT INTO rowtime_sink\n+        | SELECT a, b, c, rowtime\n+        | FROM (\n+        |   SELECT *,\n+        |     ROW_NUMBER() OVER (PARTITION BY a ORDER BY rowtime) as rowNum\n+        |   FROM T\n+        | )\n+        | WHERE rowNum = 1\n+      \"\"\".stripMargin\n+\n+    tEnv.executeSql(sql).await()\n+    val rawResult = TestValuesTableFactory.getRawResults(\"rowtime_sink\")\n+\n+    val expected = List(\n+      \"+I(1,1,Hi,1970-01-01T00:00:00.001)\",\n+      \"+I(2,3,I am fine.,1970-01-01T00:00:00.003)\",\n+      \"+I(3,5,Comment#2,1970-01-01T00:00:00.005)\",\n+      \"+I(4,4,Comment#3,1970-01-01T00:00:00.004)\",\n+      \"+U(3,4,Comment#2,1970-01-01T00:00:00.004)\",\n+      \"-U(3,5,Comment#2,1970-01-01T00:00:00.005)\")\n+    assertEquals(expected.sorted, rawResult.sorted)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fcea2d9a006b405865e558b2bdb07311b87c2a6"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTc0MjMyOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODowMjowOFrOHt3Wyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODowMjowOFrOHt3Wyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg1NDkyMg==", "bodyText": "nit: would be better to call RowTimeDeduplicateFunctionTest, minibatch is the parameter.", "url": "https://github.com/apache/flink/pull/13331#discussion_r517854922", "createdAt": "2020-11-05T08:02:08Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateFunctionTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.streaming.api.operators.KeyedProcessOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;\n+import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.bundle.KeyedMapBundleOperator;\n+import org.apache.flink.table.runtime.operators.bundle.trigger.CountBundleTrigger;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.table.runtime.util.BinaryRowDataKeySelector;\n+import org.apache.flink.table.runtime.util.GenericRowRecordSortComparator;\n+import org.apache.flink.table.runtime.util.RowDataHarnessAssertor;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+import org.apache.flink.types.RowKind;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.record;\n+\n+/**\n+ * Harness tests for {@link RowTimeDeduplicateFunction} and {@link RowTimeMiniBatchDeduplicateFunction}.\n+ */\n+@RunWith(Parameterized.class)\n+public class RowTimeMiniBatchDeduplicateFunctionTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3252a0d7e4481aebb849b2777ae544209cff1e8"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTc0NDA1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODowMjo0NVrOHt3X2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODowMjo0NVrOHt3X2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg1NTE5Mg==", "bodyText": "This adds duplicate result into the output.", "url": "https://github.com/apache/flink/pull/13331#discussion_r517855192", "createdAt": "2020-11-05T08:02:45Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeMiniBatchDeduplicateFunctionTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.deduplicate;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.streaming.api.operators.KeyedProcessOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;\n+import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.bundle.KeyedMapBundleOperator;\n+import org.apache.flink.table.runtime.operators.bundle.trigger.CountBundleTrigger;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.table.runtime.util.BinaryRowDataKeySelector;\n+import org.apache.flink.table.runtime.util.GenericRowRecordSortComparator;\n+import org.apache.flink.table.runtime.util.RowDataHarnessAssertor;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+import org.apache.flink.types.RowKind;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.record;\n+\n+/**\n+ * Harness tests for {@link RowTimeDeduplicateFunction} and {@link RowTimeMiniBatchDeduplicateFunction}.\n+ */\n+@RunWith(Parameterized.class)\n+public class RowTimeMiniBatchDeduplicateFunctionTest {\n+\n+\tprivate final long miniBatchSize = 4L;\n+\tprivate Time minTtlTime = Time.milliseconds(10);\n+\tprivate InternalTypeInfo inputRowType = InternalTypeInfo.ofFields(\n+\t\t\tnew VarCharType(VarCharType.MAX_LENGTH),\n+\t\t\tnew IntType(),\n+\t\t\tnew BigIntType());\n+\tprivate TypeSerializer<RowData> serializer = inputRowType.toSerializer();\n+\tprivate int rowTimeIndex = 2;\n+\tprivate int rowKeyIndex = 0;\n+\tprivate BinaryRowDataKeySelector rowKeySelector = new BinaryRowDataKeySelector(\n+\t\t\tnew int[]{rowKeyIndex},\n+\t\t\tinputRowType.toRowFieldTypes());\n+\tprivate RowDataHarnessAssertor assertor = new RowDataHarnessAssertor(\n+\t\t\tinputRowType.toRowFieldTypes(),\n+\t\t\tnew GenericRowRecordSortComparator(rowKeyIndex, inputRowType.toRowFieldTypes()[rowKeyIndex]));\n+\n+\tprivate final boolean miniBatchEnable;\n+\n+\tpublic RowTimeMiniBatchDeduplicateFunctionTest(boolean miniBacthEnable) {\n+\t\tthis.miniBatchEnable = miniBacthEnable;\n+\t}\n+\n+\t@Test\n+\tpublic void testRowTimeDeduplicateKeepFirstRow() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(new Watermark(102));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 12, 400L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 401L));\n+\t\texpectedOutput.add(new Watermark(402));\n+\n+\t\t// generateUpdateBefore: true, generateInsert: true\n+\t\ttestRowTimeDeduplicateKeepFirstRow(true, true, expectedOutput);\n+\n+\t\t// generateUpdateBefore: true, generateInsert: false\n+\t\ttestRowTimeDeduplicateKeepFirstRow(true, false, expectedOutput);\n+\n+\t\t// generateUpdateBefore: false, generateInsert: true\n+\t\ttestRowTimeDeduplicateKeepFirstRow(false, true, expectedOutput);\n+\n+\t\t// generateUpdateBefore: false, generateInsert: false\n+\t\texpectedOutput.clear();\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(new Watermark(102));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 400L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 401L));\n+\t\texpectedOutput.add(new Watermark(402));\n+\t\ttestRowTimeDeduplicateKeepFirstRow(false, false, expectedOutput);\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRowTimeDeduplicateKeepLastRow() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_BEFORE, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 100L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(new Watermark(102));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_BEFORE, \"key1\", 12, 100L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_BEFORE, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_BEFORE, \"key1\", 12, 100L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_BEFORE, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 12, 400L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 401L));\n+\t\texpectedOutput.add(new Watermark(402));\n+\n+\t\t// generateUpdateBefore: true, generateInsert: true\n+\t\ttestRowTimeDeduplicateKeepLastRow(true, true, expectedOutput);\n+\n+\t\t// generateUpdateBefore: true, generateInsert: false\n+\t\ttestRowTimeDeduplicateKeepLastRow(true, false, expectedOutput);\n+\n+\t\t// generateUpdateBefore: false, generateInsert: true\n+\t\texpectedOutput.clear();\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 100L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(new Watermark(102));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key1\", 12, 400L));\n+\t\texpectedOutput.add(record(RowKind.INSERT, \"key2\", 11, 401L));\n+\t\texpectedOutput.add(new Watermark(402));\n+\t\ttestRowTimeDeduplicateKeepLastRow(false, true, expectedOutput);\n+\n+\t\t// generateUpdateBefore: false, generateInsert: false\n+\t\texpectedOutput.clear();\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 13, 99L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 100L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 101L));\n+\t\texpectedOutput.add(new Watermark(102));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 300L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 301L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key3\", 5, 299L));\n+\t\texpectedOutput.add(new Watermark(302));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key1\", 12, 400L));\n+\t\texpectedOutput.add(record(RowKind.UPDATE_AFTER, \"key2\", 11, 401L));\n+\t\texpectedOutput.add(new Watermark(402));\n+\t\ttestRowTimeDeduplicateKeepLastRow(false, false, expectedOutput);\n+\t}\n+\n+\tprivate void testRowTimeDeduplicateKeepFirstRow(\n+\t\t\tboolean generateUpdateBefore,\n+\t\t\tboolean generateInsert,\n+\t\t\tList<Object> expectedOutput) throws Exception {\n+\t\tfinal boolean keepLastRow = false;\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness;\n+\t\tKeyedMapBundleOperator<RowData, RowData, RowData, RowData> keyedMapBundleOperator = null;\n+\t\tKeyedProcessOperator keyedProcessOperator = null;\n+\t\tif (miniBatchEnable) {\n+\t\t\tRowTimeMiniBatchDeduplicateFunction func = new RowTimeMiniBatchDeduplicateFunction(\n+\t\t\t\t\tinputRowType,\n+\t\t\t\t\tserializer,\n+\t\t\t\t\tminTtlTime.toMilliseconds(),\n+\t\t\t\t\trowTimeIndex,\n+\t\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\t\tgenerateInsert,\n+\t\t\t\t\tkeepLastRow);\n+\t\t\tCountBundleTrigger trigger = new CountBundleTrigger<RowData>(miniBatchSize);\n+\t\t\tkeyedMapBundleOperator = new KeyedMapBundleOperator(func, trigger);\n+\t\t\ttestHarness = createTestHarness(keyedMapBundleOperator);\n+\t\t} else {\n+\t\t\tRowTimeDeduplicateFunction func = new RowTimeDeduplicateFunction(\n+\t\t\t\t\tinputRowType,\n+\t\t\t\t\tminTtlTime.toMilliseconds(),\n+\t\t\t\t\trowTimeIndex,\n+\t\t\t\t\tgenerateUpdateBefore,\n+\t\t\t\t\tgenerateInsert,\n+\t\t\t\t\tkeepLastRow);\n+\t\t\tkeyedProcessOperator = new KeyedProcessOperator<>(func);\n+\t\t\ttestHarness = createTestHarness(keyedProcessOperator);\n+\t\t}\n+\n+\t\tList<Object> actualOutput = new ArrayList<>();\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 13, 99L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 100L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 101L));\n+\n+\t\t// test 1: keep first row with row time\n+\t\ttestHarness.processWatermark(new Watermark(102));\n+\t\tactualOutput.addAll(testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\n+\t\tif (miniBatchEnable) {\n+\t\t\ttestHarness = createTestHarness(keyedMapBundleOperator);\n+\t\t} else {\n+\t\t\ttestHarness = createTestHarness(keyedProcessOperator);\n+\t\t}\n+\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 12, 300L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 11, 301L));\n+\t\ttestHarness.processElement(insertRecord(\"key3\", 5, 299L));\n+\n+\t\t// test 2:  load snapshot state\n+\t\ttestHarness.processWatermark(new Watermark(302));\n+\t\tactualOutput.addAll(testHarness.getOutput());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3252a0d7e4481aebb849b2777ae544209cff1e8"}, "originalPosition": 252}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 434, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}