{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MzExNDgx", "number": 12375, "title": "[FLINK-17017][runtime] Implements bulk allocation for physical slots", "bodyText": "What is the purpose of the change\nThis PR introduces a BulkSlotProvider which supports bulk slot allocation. In this way we are able to check whether the resource requirements of a slot request bulk can be fulfilled at the same time.\nBrief change log\n\nEnabled to set and get whether a physical slot will be occupied indefinitely\nIntroduced BulkSlotProvider and its default implementation\n\nVerifying this change\n\nAdded AllocatedSlotOccupationTest\nAdded BulkSlotAllocationTest\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-05-28T07:49:38Z", "url": "https://github.com/apache/flink/pull/12375", "merged": true, "mergeCommit": {"oid": "9aee0c0fb2121207bfdd7f824b61ff079b8ff884"}, "closed": true, "closedAt": "2020-06-11T15:05:28Z", "author": {"login": "zhuzhurk"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclpCWIgBqjMzODE1MzY1MDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqLMsFgBqjM0MzMzOTI2ODc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a545c4292f3acca73373884af65ec8b485045845", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a545c4292f3acca73373884af65ec8b485045845", "committedDate": "2020-05-28T07:38:44Z", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "4fe765587c0423b2d29d5dde946b94edff79398b", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/4fe765587c0423b2d29d5dde946b94edff79398b", "committedDate": "2020-05-28T07:49:08Z", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4fe765587c0423b2d29d5dde946b94edff79398b", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/4fe765587c0423b2d29d5dde946b94edff79398b", "committedDate": "2020-05-28T07:49:08Z", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "c0483c6347992b8c4412da489b5584879834c396", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/c0483c6347992b8c4412da489b5584879834c396", "committedDate": "2020-05-28T08:14:33Z", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a758c3a88a0a6cc2e0b183b20a17fe618f8cbbb9", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a758c3a88a0a6cc2e0b183b20a17fe618f8cbbb9", "committedDate": "2020-05-28T16:51:45Z", "message": "[FLINK-17017][runtime] Disable individual slot request timeout check on bulk slot allocation"}, "afterCommit": {"oid": "395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "committedDate": "2020-05-29T03:38:04Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "committedDate": "2020-05-29T03:38:04Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}, "afterCommit": {"oid": "40df0ed6d44b0e9cd11faa7707490045b48151b0", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/40df0ed6d44b0e9cd11faa7707490045b48151b0", "committedDate": "2020-06-01T08:22:18Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMDM2NjEw", "url": "https://github.com/apache/flink/pull/12375#pullrequestreview-420036610", "createdAt": "2020-05-28T12:00:04Z", "commit": {"oid": "c0483c6347992b8c4412da489b5584879834c396"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToxMjowNFrOGb59MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDozMDoxNVrOGd0gdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNDI4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class PhysicalSlotRequestBulk {\n          \n          \n            \n            class PhysicalSlotRequestBulk {", "url": "https://github.com/apache/flink/pull/12375#discussion_r431914289", "createdAt": "2020-05-28T15:12:04Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0483c6347992b8c4412da489b5584879834c396"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNzYxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class BulkSlotAllocationTest extends TestLogger {\n          \n          \n            \n            public class BulkSlotProviderImplTest extends TestLogger {", "url": "https://github.com/apache/flink/pull/12375#discussion_r431917615", "createdAt": "2020-05-28T15:16:35Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotAllocationTest.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.AllocatedSlotOccupationTest.allocateSingleLogicalSlotFromPhysicalSlot;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests whether bulk slot allocation works correctly.\n+ */\n+public class BulkSlotAllocationTest extends TestLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0483c6347992b8c4412da489b5584879834c396"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyOTgyMA==", "bodyText": "can this be a separate test?", "url": "https://github.com/apache/flink/pull/12375#discussion_r431929820", "createdAt": "2020-05-28T15:33:09Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tbulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkTracking() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(true));\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(clock.relativeTimeMillis()));\n+\n+\t\tbulkTracker.untrack(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testUnfulfillableTimestampWillNotBeOverriddenByFollowingUnfulfillableTimestamp() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tfinal long unfulfillableSince = clock.relativeTimeMillis();\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(unfulfillableSince));\n+\n+\t\tclock.advanceTime(456, TimeUnit.MILLISECONDS);\n+\t\tbulkTracker.markBulkUnfulfillable(bulk, clock.relativeTimeMillis());\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(unfulfillableSince));\n+\n+\t\tbulkTracker.markBulkFulfillable(bulk);\n+\t\tbulkTracker.markBulkUnfulfillable(bulk, clock.relativeTimeMillis());\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(clock.relativeTimeMillis()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0483c6347992b8c4412da489b5584879834c396"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MjA4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n          \n          \n            \n            \t\tassertThat(physicalSlot.willBeOccupiedIndefinitely(), is(true));\n          \n      \n    \n    \n  \n\nalso in other places", "url": "https://github.com/apache/flink/pull/12375#discussion_r431942080", "createdAt": "2020-05-28T15:50:39Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation state of {@link AllocatedSlot} is correctly.\n+ */\n+public class AllocatedSlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4f7f62d23744dd58ceb0e0018a03b39a8ba556a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0OTY5OA==", "bodyText": "nit: We have this logic in some places in production as well.\nMaybe, this could factored out into SingleLogicalSlot#allocateFromPhysicalSlot?", "url": "https://github.com/apache/flink/pull/12375#discussion_r433749698", "createdAt": "2020-06-02T09:39:05Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation state of {@link AllocatedSlot} is correctly.\n+ */\n+public class AllocatedSlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\t@Test\n+\tpublic void testSingleTaskNotOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, false);\n+\n+\t\tassertFalse(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate static PhysicalSlot createPhysicalSlot() {\n+\t\treturn new AllocatedSlot(\n+\t\t\tnew AllocationID(),\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\t0,\n+\t\t\tResourceProfile.ANY,\n+\t\t\tnew SimpleAckingTaskManagerGateway());\n+\t}\n+\n+\tstatic LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal PhysicalSlot physicalSlot,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely) {\n+\n+\t\treturn allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tnew SlotRequestId(),\n+\t\t\tphysicalSlot,\n+\t\t\tnew TestingSlotOwner(),\n+\t\t\tslotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tstatic LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df0ed6d44b0e9cd11faa7707490045b48151b0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NzQyNg==", "bodyText": "What do you think about BulkSlotProviderImpl#createWithSystemClock()?", "url": "https://github.com/apache/flink/pull/12375#discussion_r433787426", "createdAt": "2020-06-02T10:50:57Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA==", "bodyText": "Generally, making methods VisibleForTesting looks like we have one more concern to test internally.\nCould we factor out this concern to test separately?\nWhat if we create a PhysicalSlotRequestBulkTracker(requests, slotPool) for each bulk by merging it with PhysicalSlotRequestBulk?\nor PhysicalSlotRequestBulk could have the unfulfillableSinceTimestamp internally.\nNot sure, why we need the existing PhysicalSlotRequestBulkTracker for all bulk timestamps.\nAll methods here, related to timeout/fulfilablity check, could also go into the PhysicalSlotRequestBulkTracker.\nBulkSlotProviderImpl could schedule PhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout for each bulk.\nPhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout could return FINISHED/FULFILLABLE/TIMEOUT.\nThen PhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout could be tested separately.", "url": "https://github.com/apache/flink/pull/12375#discussion_r433801368", "createdAt": "2020-06-02T11:19:44Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis(slotSelectionStrategy, slotPool, SystemClock.getInstance());\n+\t}\n+\n+\t@VisibleForTesting\n+\tBulkSlotProviderImpl(\n+\t\t\tfinal SlotSelectionStrategy slotSelectionStrategy,\n+\t\t\tfinal SlotPool slotPool,\n+\t\t\tfinal Clock clock) {\n+\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\t\tthis.clock = checkNotNull(clock);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlotWithoutTimeout(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\t!physicalSlotRequest.willSlotBeOccupiedIndefinitely());\n+\t\t}\n+\n+\t\treturn slotFuture.thenApply(physicalSlot -> new PhysicalSlotRequest.Result(slotRequestId, physicalSlot));\n+\t}\n+\n+\tprivate Optional<PhysicalSlot> tryAllocateFromAvailable(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\n+\t\tfinal Collection<SlotSelectionStrategy.SlotInfoAndResources> slotInfoList =\n+\t\t\tslotPool.getAvailableSlotsInformation()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(SlotSelectionStrategy.SlotInfoAndResources::fromSingleSlot)\n+\t\t\t\t.collect(Collectors.toList());\n+\n+\t\tfinal Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n+\t\t\tslotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);\n+\n+\t\treturn selectedAvailableSlot.flatMap(\n+\t\t\tslotInfoAndLocality -> slotPool.allocateAvailableSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tslotInfoAndLocality.getSlotInfo().getAllocationId())\n+\t\t);\n+\t}\n+\n+\tprivate void schedulePendingRequestBulkTimeoutCheck(\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.schedule(() -> {\n+\t\t\tif (!checkPhysicalSlotRequestBulkTimeout(slotRequestBulk, timeout)) {\n+\t\t\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\t\t\t}\n+\t\t}, timeout.getSize(), timeout.getUnit());\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n+\t * @return true if the slot request bulk is done or timed out, otherwise false\n+\t */\n+\t@VisibleForTesting\n+\tprotected boolean checkPhysicalSlotRequestBulkTimeout(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTY3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid markRequestFulfilled(final SlotRequestId slotRequestId, final AllocationID allocationID) {\n          \n          \n            \n            \tvoid fulfillPendingSlotRequest(final SlotRequestId slotRequestId, final AllocationID allocationID) {", "url": "https://github.com/apache/flink/pull/12375#discussion_r433801679", "createdAt": "2020-06-02T11:20:22Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {\n+\n+\tprivate final Map<SlotRequestId, ResourceProfile> pendingRequests;\n+\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests = new HashMap<>();\n+\n+\tPhysicalSlotRequestBulk(final Collection<PhysicalSlotRequest> physicalSlotRequests) {\n+\t\tthis.pendingRequests = physicalSlotRequests.stream()\n+\t\t\t.collect(Collectors.toMap(\n+\t\t\t\tPhysicalSlotRequest::getSlotRequestId,\n+\t\t\t\tr -> r.getSlotProfile().getPhysicalSlotResourceProfile()));\n+\t}\n+\n+\tvoid markRequestFulfilled(final SlotRequestId slotRequestId, final AllocationID allocationID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw==", "bodyText": "Maybe, SlotProvider could just extend BulkSlotProvider?", "url": "https://github.com/apache/flink/pull/12375#discussion_r433805767", "createdAt": "2020-06-02T11:28:31Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotProvider.java", "diffHunk": "@@ -91,6 +92,20 @@\n \t\t\tallocationTimeout);\n \t}\n \n+\t/**\n+\t * Allocates a bulk of physical slots. The allocation will be completed\n+\t * normally only when all the requests are fulfilled.\n+\t *\n+\t * @param physicalSlotRequests requests for physical slots\n+\t * @param timeout indicating how long it is accepted that the slot requests can be unfulfillable\n+\t * @return future of the results of slot requests\n+\t */\n+\tdefault CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df0ed6d44b0e9cd11faa7707490045b48151b0"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tdisableBatchSlotTimeoutCheck();\n          \n          \n            \n            \t\tbatchSlotTimeoutCheckEnabled = false;\n          \n      \n    \n    \n  \n\ndo we need a method for this?", "url": "https://github.com/apache/flink/pull/12375#discussion_r433909499", "createdAt": "2020-06-02T14:13:08Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -447,12 +452,40 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \n \t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n \n+\t\tcheckState(batchSlotTimeoutCheckEnabled, \"batch slot timeout check is disabled unexpectedly.\");\n+\n \t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n \n \t\treturn requestNewAllocatedSlotInternal(pendingRequest)\n \t\t\t.thenApply(Function.identity());\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlotWithoutTimeout(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal ResourceProfile resourceProfile,\n+\t\t\tfinal boolean isBatchRequest) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\t// a slot pool can serve either this kind of request or requestNewAllocatedBatchSlot(...), never both\n+\t\tdisableBatchSlotTimeoutCheck();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "991e7d77e2e35e51f4f2784cb64bddacf50eff4f"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ==", "bodyText": "I am wondering whether it would be more clear just to add  disableBatchSlotTimeoutCheck explicitly to the public interface.\nWe could also make timeout Nullable in requestNewAllocatedSlot then FutureUtils.orTimeout can be conditional in requestNewAllocatedSlot.\nThe we do not need requestNewAllocatedSlotWithoutTimeout and make any assumptions in it about batchSlotTimeoutCheckEnabled.", "url": "https://github.com/apache/flink/pull/12375#discussion_r433918851", "createdAt": "2020-06-02T14:25:49Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -447,12 +452,40 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \n \t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n \n+\t\tcheckState(batchSlotTimeoutCheckEnabled, \"batch slot timeout check is disabled unexpectedly.\");\n+\n \t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n \n \t\treturn requestNewAllocatedSlotInternal(pendingRequest)\n \t\t\t.thenApply(Function.identity());\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlotWithoutTimeout(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "991e7d77e2e35e51f4f2784cb64bddacf50eff4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw==", "bodyText": "maybe no immediate action now, but I find it quite hard to judge about failures in SlotPoolImpl , especially for bulk allocation.\nWith this new concept of fulfil-ability, maybe we should simplify SlotPoolImpl and let BulkSlotProviderImpl judge about how to interpret external request failures and when to fulfil the requests, it could be a follow-up.\nWe might want to note that new slot allocation has failed but there are often chances that the pending request can be fulfilled by allocated slots.", "url": "https://github.com/apache/flink/pull/12375#discussion_r433922167", "createdAt": "2020-06-02T14:30:15Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis(slotSelectionStrategy, slotPool, SystemClock.getInstance());\n+\t}\n+\n+\t@VisibleForTesting\n+\tBulkSlotProviderImpl(\n+\t\t\tfinal SlotSelectionStrategy slotSelectionStrategy,\n+\t\t\tfinal SlotPool slotPool,\n+\t\t\tfinal Clock clock) {\n+\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\t\tthis.clock = checkNotNull(clock);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlotWithoutTimeout(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d"}, "originalPosition": 139}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3371da5790134088bffa988c5a837c34d5d9a443", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/3371da5790134088bffa988c5a837c34d5d9a443", "committedDate": "2020-06-03T08:41:31Z", "message": "Fixup! [FLINK-17017][runtime] Enable to get whether a physical slot will be occupied indefinitely"}, "afterCommit": {"oid": "35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "committedDate": "2020-06-04T11:57:56Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "committedDate": "2020-06-04T11:57:56Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}, "afterCommit": {"oid": "98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "committedDate": "2020-06-05T10:22:29Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "committedDate": "2020-06-05T10:22:29Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}, "afterCommit": {"oid": "cd3fc98c034fdc61235d9109c05b4f55d7423746", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/cd3fc98c034fdc61235d9109c05b4f55d7423746", "committedDate": "2020-06-05T10:42:43Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff97aeedb303fe540ebb3728ed280de414606978", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/ff97aeedb303fe540ebb3728ed280de414606978", "committedDate": "2020-06-05T10:59:51Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks\n\nFix method documentation"}, "afterCommit": {"oid": "a8902557952ea70746d27e88a392c74724784605", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a8902557952ea70746d27e88a392c74724784605", "committedDate": "2020-06-05T16:49:11Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Nzg4NzYx", "url": "https://github.com/apache/flink/pull/12375#pullrequestreview-427788761", "createdAt": "2020-06-10T07:39:11Z", "commit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzozOToxMlrOGhokGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODoxMDoxOVrOGhpu4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw==", "bodyText": "nit: maybe one more method slotFuture = requestNewSlot(willSlotBeOccupiedIndefinitely, slotRequestId, resourceProfile)?", "url": "https://github.com/apache/flink/pull/12375#discussion_r437920793", "createdAt": "2020-06-10T07:39:12Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(\n+\t\t\tthis::getAllSlotInfos,\n+\t\t\tSystemClock.getInstance());\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic void cancelSlotRequest(SlotRequestId slotRequestId, Throwable cause) {\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tslotPool.releaseSlot(slotRequestId, cause);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\tnull);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjI2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n          \n          \n            \n            \t * Check the slot request bulk and timeout its requests if it has been unfulfillable for too long.", "url": "https://github.com/apache/flink/pull/12375#discussion_r437926267", "createdAt": "2020-06-10T07:46:56Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjQwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n          \n          \n            \n            \t * @param slotRequestTimeout indicates how long a pending request can be unfulfillable", "url": "https://github.com/apache/flink/pull/12375#discussion_r437926403", "createdAt": "2020-06-10T07:47:06Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTM2MQ==", "bodyText": "Why do we need to expose isSlotRequestBulkFulfillable?\nCould we not test the same with checkPhysicalSlotRequestBulkTimeout and e.g. PhysicalSlotRequestBulk.isFulfillable?", "url": "https://github.com/apache/flink/pull/12375#discussion_r437935361", "createdAt": "2020-06-10T08:02:29Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n+\t * @return result of the check, indicating the bulk is fulfilled, still pending, or timed out\n+\t */\n+\tTimeoutCheckResult checkPhysicalSlotRequestBulkTimeout(\n+\t\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\t\tfinal Time slotRequestTimeout) {\n+\n+\t\tcheckState(isTracked(slotRequestBulk));\n+\n+\t\tif (slotRequestBulk.getPendingRequests().isEmpty()) {\n+\t\t\treturn TimeoutCheckResult.FULFILLED;\n+\t\t}\n+\n+\t\tfinal boolean fulfillable = isSlotRequestBulkFulfillable(slotRequestBulk, slotsRetriever);\n+\t\tif (fulfillable) {\n+\t\t\tslotRequestBulk.markFulfillable();\n+\t\t} else {\n+\t\t\tfinal long currentTimestamp = clock.relativeTimeMillis();\n+\n+\t\t\tslotRequestBulk.markUnfulfillable(currentTimestamp);\n+\n+\t\t\tfinal long unfulfillableSince = slotRequestBulk.getUnfulfillableSince();\n+\t\t\tif (unfulfillableSince + slotRequestTimeout.toMilliseconds() <= currentTimestamp) {\n+\t\t\t\treturn TimeoutCheckResult.TIMEOUT;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn TimeoutCheckResult.PENDING;\n+\t}\n+\n+\t/**\n+\t * Returns whether the given bulk of slot requests are possible to be fulfilled at the same time\n+\t * with all the reusable slots in the slot pool. A reusable slot means the slot is available or\n+\t * will not be occupied indefinitely.\n+\t *\n+\t * @param slotRequestBulk bulk of slot requests to check\n+\t * @param slotsRetriever supplies slots to be used for the fulfill-ability check\n+\t * @return true if the slot requests are possible to be fulfilled, otherwise false\n+\t */\n+\t@VisibleForTesting\n+\tstatic boolean isSlotRequestBulkFulfillable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA==", "bodyText": "Not sure I understand why we need slotRequestBulks/track/untrack/isTracked.\nLooks only for tests. Can we remove it?", "url": "https://github.com/apache/flink/pull/12375#discussion_r437936600", "createdAt": "2020-06-10T08:04:48Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzOTkzOQ==", "bodyText": "I thought we could actually move timeoutSlotRequestBulk/getAllSlotInfos and pass slotPool to PhysicalSlotRequestBulkTracker. Would this simplify multithreading in tests?\nFor multithreading, we would only need to check whether BulkSlotProviderImpl properly schedules checkPhysicalSlotRequestBulkTimeout.", "url": "https://github.com/apache/flink/pull/12375#discussion_r437939939", "createdAt": "2020-06-10T08:10:19Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(\n+\t\t\tthis::getAllSlotInfos,\n+\t\t\tSystemClock.getInstance());\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic void cancelSlotRequest(SlotRequestId slotRequestId, Throwable cause) {\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tslotPool.releaseSlot(slotRequestId, cause);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\tnull);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile);\n+\t\t}\n+\n+\t\treturn slotFuture.thenApply(physicalSlot -> new PhysicalSlotRequest.Result(slotRequestId, physicalSlot));\n+\t}\n+\n+\tprivate Optional<PhysicalSlot> tryAllocateFromAvailable(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\n+\t\tfinal Collection<SlotSelectionStrategy.SlotInfoAndResources> slotInfoList =\n+\t\t\tslotPool.getAvailableSlotsInformation()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(SlotSelectionStrategy.SlotInfoAndResources::fromSingleSlot)\n+\t\t\t\t.collect(Collectors.toList());\n+\n+\t\tfinal Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n+\t\t\tslotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);\n+\n+\t\treturn selectedAvailableSlot.flatMap(\n+\t\t\tslotInfoAndLocality -> slotPool.allocateAvailableSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tslotInfoAndLocality.getSlotInfo().getAllocationId())\n+\t\t);\n+\t}\n+\n+\tprivate void schedulePendingRequestBulkTimeoutCheck(\n+\t\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.schedule(() -> {\n+\t\t\tfinal PhysicalSlotRequestBulkTracker.TimeoutCheckResult result =\n+\t\t\t\tslotRequestBulkTracker.checkPhysicalSlotRequestBulkTimeout(slotRequestBulk, timeout);\n+\n+\t\t\tswitch (result) {\n+\t\t\t\tcase PENDING:\n+\t\t\t\t\t//re-schedule the timeout check\n+\t\t\t\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase TIMEOUT:\n+\t\t\t\t\ttimeoutSlotRequestBulk(slotRequestBulk);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault: // no action to take\n+\t\t\t}\n+\t\t}, timeout.getSize(), timeout.getUnit());\n+\t}\n+\n+\tprivate void timeoutSlotRequestBulk(final PhysicalSlotRequestBulk slotRequestBulk) {\n+\t\tfinal Exception cause = new TimeoutException(\"Slot request bulk is not fulfillable!\");\n+\t\t// pending requests must be canceled first otherwise they might be fulfilled by\n+\t\t// allocated slots released from this bulk\n+\t\tfor (SlotRequestId slotRequestId : slotRequestBulk.getPendingRequests().keySet()) {\n+\t\t\tcancelSlotRequest(slotRequestId, cause);\n+\t\t}\n+\t\tfor (SlotRequestId slotRequestId : slotRequestBulk.getFulfilledRequests().keySet()) {\n+\t\t\tcancelSlotRequest(slotRequestId, cause);\n+\t\t}\n+\t}\n+\n+\tprivate Set<SlotInfo> getAllSlotInfos() {\n+\t\treturn Stream\n+\t\t\t.concat(\n+\t\t\t\tslotPool.getAvailableSlotsInformation().stream(),\n+\t\t\t\tslotPool.getAllocatedSlotsInformation().stream())\n+\t\t\t.collect(Collectors.toSet());\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04"}, "originalPosition": 203}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af7d4926ee8bb041713feeed10770147509d2db8", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/af7d4926ee8bb041713feeed10770147509d2db8", "committedDate": "2020-06-10T10:13:05Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "committedDate": "2020-06-11T01:16:31Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "committedDate": "2020-06-11T01:16:31Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "b4e5423c675bdba622a953af780487ac2031b5a9", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/b4e5423c675bdba622a953af780487ac2031b5a9", "committedDate": "2020-06-11T03:15:59Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4e5423c675bdba622a953af780487ac2031b5a9", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/b4e5423c675bdba622a953af780487ac2031b5a9", "committedDate": "2020-06-11T03:15:59Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "d3f81cb67e5924bfc9d3e7bbba25af281e6b3102", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/d3f81cb67e5924bfc9d3e7bbba25af281e6b3102", "committedDate": "2020-06-11T03:27:55Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NzI4MDI4", "url": "https://github.com/apache/flink/pull/12375#pullrequestreview-428728028", "createdAt": "2020-06-11T09:07:07Z", "commit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTowNzowN1rOGiU6Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOToxNjozNFrOGiVN6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0NzMxMQ==", "bodyText": "Can slotOwner be a local variable?", "url": "https://github.com/apache/flink/pull/12375#discussion_r438647311", "createdAt": "2020-06-11T09:07:07Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImplTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link BulkSlotProviderImpl}.\n+ */\n+public class BulkSlotProviderImplTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(1000L);\n+\n+\tprivate static ScheduledExecutorService singleThreadScheduledExecutorService;\n+\n+\tprivate static ComponentMainThreadExecutor mainThreadExecutor;\n+\n+\tprivate TestingSlotPoolImpl slotPool;\n+\n+\tprivate BulkSlotProviderImpl bulkSlotProvider;\n+\n+\tprivate TestingSlotOwner slotOwner;\n+\n+\tprivate ManualClock clock;\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\tsingleThreadScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+\t\tmainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forSingleThreadExecutor(singleThreadScheduledExecutorService);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void teardownClass() {\n+\t\tif (singleThreadScheduledExecutorService != null) {\n+\t\t\tsingleThreadScheduledExecutorService.shutdownNow();\n+\t\t}\n+\t}\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tclock = new ManualClock();\n+\n+\t\tslotPool = new SlotPoolBuilder(mainThreadExecutor).build();\n+\n+\t\tbulkSlotProvider = new BulkSlotProviderImpl(LocationPreferenceSlotSelectionStrategy.createDefault(), slotPool);\n+\t\tbulkSlotProvider.start(mainThreadExecutor);\n+\n+\t\tslotOwner = new TestingSlotOwner();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDE5MA==", "bodyText": "Could this be a private helper method Exception  allocateSlotsAndWaitForTimeout() to deduplicate with other tests?\nprivate Exception allocateSlotsAndWaitForTimeout() {\n\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n\t\t\tcreatePhysicalSlotRequest(),\n\t\t\tcreatePhysicalSlotRequest());\n\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n\n\t\taddSlotToSlotPool();\n\n\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n\n\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n\n\t\ttry {\n\t\t\t// wait util the requests timed out\n\t\t\tslotFutures.get();\n\t\t} catch (Exception e) {\n\t\t\t// expected\n\t\t\treturn e;\n\t\t}\n\t\tfail(\"Expected that the slot futures time out.\");\n\t\treturn new Exception(\"Unexpected\");\n\t}", "url": "https://github.com/apache/flink/pull/12375#discussion_r438650190", "createdAt": "2020-06-11T09:12:29Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImplTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link BulkSlotProviderImpl}.\n+ */\n+public class BulkSlotProviderImplTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(1000L);\n+\n+\tprivate static ScheduledExecutorService singleThreadScheduledExecutorService;\n+\n+\tprivate static ComponentMainThreadExecutor mainThreadExecutor;\n+\n+\tprivate TestingSlotPoolImpl slotPool;\n+\n+\tprivate BulkSlotProviderImpl bulkSlotProvider;\n+\n+\tprivate TestingSlotOwner slotOwner;\n+\n+\tprivate ManualClock clock;\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\tsingleThreadScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+\t\tmainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forSingleThreadExecutor(singleThreadScheduledExecutorService);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void teardownClass() {\n+\t\tif (singleThreadScheduledExecutorService != null) {\n+\t\t\tsingleThreadScheduledExecutorService.shutdownNow();\n+\t\t}\n+\t}\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tclock = new ManualClock();\n+\n+\t\tslotPool = new SlotPoolBuilder(mainThreadExecutor).build();\n+\n+\t\tbulkSlotProvider = new BulkSlotProviderImpl(LocationPreferenceSlotSelectionStrategy.createDefault(), slotPool);\n+\t\tbulkSlotProvider.start(mainThreadExecutor);\n+\n+\t\tslotOwner = new TestingSlotOwner();\n+\t\tslotOwner.setReturnAllocatedSlotConsumer(\n+\t\t\tlogicalSlot ->\n+\t\t\t\tslotPool.releaseSlot(\n+\t\t\t\t\tlogicalSlot.getSlotRequestId(),\n+\t\t\t\t\tnew FlinkException(\"Slot is being returned to the SlotPool.\")));\n+\t}\n+\n+\t@After\n+\tpublic void teardown() {\n+\t\tCompletableFuture.runAsync(() -> slotPool.close(), mainThreadExecutor).join();\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationFulfilledWithAvailableSlots() throws Exception {\n+\t\tfinal PhysicalSlotRequest request1 = createPhysicalSlotRequest();\n+\t\tfinal PhysicalSlotRequest request2 = createPhysicalSlotRequest();\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(request1, request2);\n+\n+\t\taddSlotToSlotPool();\n+\t\taddSlotToSlotPool();\n+\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\tfinal Collection<PhysicalSlotRequest.Result> results = slotFutures.get(TIMEOUT.getSize(), TIMEOUT.getUnit());\n+\t\tfinal Collection<SlotRequestId> resultRequestIds = results.stream()\n+\t\t\t.map(PhysicalSlotRequest.Result::getSlotRequestId)\n+\t\t\t.collect(Collectors.toList());\n+\n+\t\tassertThat(resultRequestIds, containsInAnyOrder(request1.getSlotRequestId(), request2.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationFulfilledWithNewSlots() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotFutures.isDone(), is(false));\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotFutures.isDone(), is(true));\n+\t\tassertThat(slotFutures.isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationTimeoutsIfUnfulfillable() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n+\n+\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n+\n+\t\ttry {\n+\t\t\t// wait util the requests timed out\n+\t\t\tslotFutures.get();\n+\t\t\tfail(\"Expected that the slot futures time out.\");\n+\t\t} catch (Exception e) {\n+\t\t\tfinal Optional<Throwable> cause = ExceptionUtils.findThrowableWithMessage(\n+\t\t\t\te,\n+\t\t\t\t\"Slot request bulk is not fulfillable!\");\n+\t\t\tassertThat(cause.isPresent(), is(true));\n+\t\t\tassertThat(cause.get(), instanceOf(TimeoutException.class));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedBulkSlotAllocationReleasesAllocatedSlot() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n+\n+\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n+\n+\t\ttry {\n+\t\t\t// wait util the requests timed out\n+\t\t\tslotFutures.get();\n+\t\t\tfail(\"Expected that the slot futures time out.\");\n+\t\t} catch (Exception e) {\n+\t\t\t// expected\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Arrays.asList(request));\n          \n          \n            \n            \t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.singletonList(request));", "url": "https://github.com/apache/flink/pull/12375#discussion_r438650919", "createdAt": "2020-06-11T09:13:46Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\tprivate Set<PhysicalSlot> slots;\n+\n+\tprivate Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tslots = new HashSet<>();\n+\t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());\n+\t\tbulkTracker = new PhysicalSlotRequestBulkTracker(slotsRetriever, clock);\n+\t}\n+\n+\t@Test\n+\tpublic void testTrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(true));\n+\t\tassertThat(bulk.getUnfulfillableSince(), is(clock.relativeTimeMillis()));\n+\t}\n+\n+\t@Test\n+\tpublic void testUntrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tbulkTracker.track(bulk);\n+\t\tbulkTracker.untrack(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkFulfilledOnCheck() {\n+\t\tfinal PhysicalSlotRequest request = createPhysicalSlotRequest();\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Arrays.asList(request));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MTg2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate ManualClock clock = new ManualClock();\n          \n          \n            \n            \tprivate final ManualClock clock = new ManualClock();", "url": "https://github.com/apache/flink/pull/12375#discussion_r438651868", "createdAt": "2020-06-11T09:15:34Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MjE3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());\n          \n          \n            \n            \t\tslotsRetriever = () -> new HashSet<>(slots);", "url": "https://github.com/apache/flink/pull/12375#discussion_r438652171", "createdAt": "2020-06-11T09:16:07Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\tprivate Set<PhysicalSlot> slots;\n+\n+\tprivate Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tslots = new HashSet<>();\n+\t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MjM5Mw==", "bodyText": "Also other places", "url": "https://github.com/apache/flink/pull/12375#discussion_r438652393", "createdAt": "2020-06-11T09:16:34Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\tprivate Set<PhysicalSlot> slots;\n+\n+\tprivate Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tslots = new HashSet<>();\n+\t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());\n+\t\tbulkTracker = new PhysicalSlotRequestBulkTracker(slotsRetriever, clock);\n+\t}\n+\n+\t@Test\n+\tpublic void testTrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(true));\n+\t\tassertThat(bulk.getUnfulfillableSince(), is(clock.relativeTimeMillis()));\n+\t}\n+\n+\t@Test\n+\tpublic void testUntrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tbulkTracker.track(bulk);\n+\t\tbulkTracker.untrack(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkFulfilledOnCheck() {\n+\t\tfinal PhysicalSlotRequest request = createPhysicalSlotRequest();\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Arrays.asList(request));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ=="}, "originalCommit": {"oid": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d523391334dc2997456daf500db5f1ffdd96e441", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/d523391334dc2997456daf500db5f1ffdd96e441", "committedDate": "2020-06-11T09:53:10Z", "message": "[hotfix] Fix checkstyle violations in AllocatedSlot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c61b135c655d84b7cc34f446a19bd486b4a61cf", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/0c61b135c655d84b7cc34f446a19bd486b4a61cf", "committedDate": "2020-06-11T09:53:11Z", "message": "[hotfix][runtime] Set root cause to pending request released exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01f1e1b1e91a6be933e9dc5279c4e48cc7cce6a8", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/01f1e1b1e91a6be933e9dc5279c4e48cc7cce6a8", "committedDate": "2020-06-11T09:53:11Z", "message": "[FLINK-17017][runtime] Allow to set whether a physical slot payload will occupy the slot indefinitely"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec95b8db6f13165f72364b1798e3722875a10fe6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/ec95b8db6f13165f72364b1798e3722875a10fe6", "committedDate": "2020-06-11T09:53:11Z", "message": "[FLINK-17017][runtime] Add SingleLogicalSlot#allocateFromPhysicalSlot(\u2026) for physical slot assignment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2a403dd330545f874bc4e38e0968841ca08b00c", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f2a403dd330545f874bc4e38e0968841ca08b00c", "committedDate": "2020-06-11T09:53:11Z", "message": "[FLINK-17017][runtime] Enable to get whether a physical slot will be occupied indefinitely"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f8b757e5f186921b1358809b6d4f544ab43bb6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a1f8b757e5f186921b1358809b6d4f544ab43bb6", "committedDate": "2020-06-11T09:53:12Z", "message": "[FLINK-17017][runtime] Enable to get allocated slots information of a slot pool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfafa9d4646349ffd02e51ac0d10911663831fb9", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/dfafa9d4646349ffd02e51ac0d10911663831fb9", "committedDate": "2020-06-11T09:53:12Z", "message": "[FLINK-17017][runtime] Allow to disable batch slot request timeout check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c2a90b7f59616d93f77c973042e372e53116dd2", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/7c2a90b7f59616d93f77c973042e372e53116dd2", "committedDate": "2020-06-11T09:53:12Z", "message": "[FLINK-17017][runtime] Allow nullable timeout for streaming slot request in slot pool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d21d8dd0aa2dc37abc6fad0d61d6e5b5a34b17", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/c0d21d8dd0aa2dc37abc6fad0d61d6e5b5a34b17", "committedDate": "2020-06-11T09:53:12Z", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdf970c21e07f96589b85949ea7b697ac5c64c36", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/bdf970c21e07f96589b85949ea7b697ac5c64c36", "committedDate": "2020-06-11T09:53:13Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b12e3c8ed75c7c2e12add43e6b9fb6dcd79ce51c", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/b12e3c8ed75c7c2e12add43e6b9fb6dcd79ce51c", "committedDate": "2020-06-11T09:46:06Z", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks"}, "afterCommit": {"oid": "bdf970c21e07f96589b85949ea7b697ac5c64c36", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/bdf970c21e07f96589b85949ea7b697ac5c64c36", "committedDate": "2020-06-11T09:53:13Z", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4528, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}