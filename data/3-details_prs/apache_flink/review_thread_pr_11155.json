{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NjcwMjA5", "number": 11155, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNDowN1rODhwoFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNTo1NjoyMFrODiN7ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI2MjkzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNDowN1rOFsrLgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNDowN1rOFsrLgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTEyMQ==", "bodyText": "nit: one more indentation for distinguishing with the below core codes.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382389121", "createdAt": "2020-02-21T04:14:07Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI2NTE4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNTo0NFrOFsrM5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNTo0NFrOFsrM5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTQ3Ng==", "bodyText": "nit: We can make it a separate class to void this class too long. Also rename it SingleInputGateBenchmarkFactory.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382389476", "createdAt": "2020-02-21T04:15:44Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI2NjI3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNjoyOFrOFsrNfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNjoyOFrOFsrNfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTYzMQ==", "bodyText": "Make all these fields as protected in parent SingleInputGateFactory for simple.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382389631", "createdAt": "2020-02-21T04:16:28Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI3MDE3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoyMDowOFrOFsrP9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNjozOTowM1rOFtWsdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA==", "bodyText": "Why we need to override this method? I guess that the original partitionId while constructing the SingleInputGate is valid.\nSame issue for the below remote channel.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382390260", "createdAt": "2020-02-21T04:20:08Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNDcwOA==", "bodyText": "These channels consume the same result partition so with the same partition id. However, In SingleInputGate, IntermediateResultPartitionID is used as key of channel map, that is, SingleInputGate assumes that there is never two channels consume one result partition. See setInputChannel method in SingleInputGate.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382404708", "createdAt": "2020-02-21T05:33:04Z", "author": {"login": "wsry"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ0MzIyMA==", "bodyText": "I get the point and it makes me a bit torn whether this way is reasonable to go.\nWe hacked two internal infos (ResultPartitionID and subpartitionIndex) of SingleInputGate and InputChannel. I wonder it might make the benchmark very fragile in future. I mean if there are any changes related to these infos inside gate and channel, then it might bring unexpected behaviors for benchmark, because the internal logics would still access the previous inconsistent infos.\nI need to think it through then.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382443220", "createdAt": "2020-02-21T08:03:42Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5MDI2MA==", "bodyText": "I have some basic thoughts for the concerns of ResultPartitionID and subpartitionIndex.\nThe baseline is that we can not break the existing rules that ResultPartitionID is different for every input channel but subpartitionIndex is same for all.\n\n\nResultPartitionID: We can pass a desired value directly while constructing the InputChannel instance instead of getting it from NettyShuffleDescriptor now. Although it is still not consistent between NettyShuffleDescriptor and InputChannel, it becomes consistent in all the places inside channel, and we also avoid hacking the override method of getPartitionId in TestRemoteInputChannel below.\n\n\nsubpartitionIndex: We can keep it same as now. Although we can also maintain this info in the InputChannel layer as did above, then we can also pass the desired subpartition index while constructing the InputChannel to further void hack requestSubpartition method. But considering it is same for all the channels in normal case, so it might be more reasonable to maintain it in gate layer as now.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383090260", "createdAt": "2020-02-24T05:28:44Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5MDgxNg==", "bodyText": "In addition, while reviewing the current usage of InputChannel#getPartitionId, I find it is mainly used for generating AddCredit message. But the ResultPartitionID was actually not used for upstream side in practice.\nSo I prefer to remove this field from AddCredit message, which can further reduce the message size from current 52 bytes to 20 bytes.\n@pnowojski do you have other concerns for removing it? If not, i would create a separate ticket for this issue.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383090816", "createdAt": "2020-02-24T05:33:05Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwMjA1OQ==", "bodyText": "I forgot the case of requesting partition via ResultPartitionID, so the above option for ResultPartitionID is invalid.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383102059", "createdAt": "2020-02-24T06:39:01Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwMjA3MQ==", "bodyText": "I forgot the case of requesting partition via ResultPartitionID, so the above option for ResultPartitionID is invalid.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383102071", "createdAt": "2020-02-24T06:39:03Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDI2MA=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI3MzE5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoyMjo0MlrOFsrRxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNzoxMToyOVrOFstfVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDcyNw==", "bodyText": "In addition, we might also need to override the method of retriggerSubpartitionRequest, in case this process might be used to cause invalid subpartitionIndex future.\nSame issue for the below remote channel.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382390727", "createdAt": "2020-02-21T04:22:42Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDM2Mw==", "bodyText": "Can we always call createResultPartitionWriter before call createReceiver, which means the result partitions are always registered before requested. Current implementation can guarantee that. I am saying this because I need to override more than one method and also need do some refactor to support retriggerSubpartitionRequest.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382414363", "createdAt": "2020-02-21T06:19:41Z", "author": {"login": "wsry"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDcyNw=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNjk2Ng==", "bodyText": "I add a comment to the createReceiver method.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382426966", "createdAt": "2020-02-21T07:11:29Z", "author": {"login": "wsry"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,\n+\t\t\t\t@Nonnull NettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\t\t@Nonnull ConnectionManager connectionManager,\n+\t\t\t\t@Nonnull ResultPartitionManager partitionManager,\n+\t\t\t\t@Nonnull TaskEventPublisher taskEventPublisher,\n+\t\t\t\t@Nonnull NetworkBufferPool networkBufferPool) {\n+\t\t\tsuper(\n+\t\t\t\ttaskExecutorResourceId,\n+\t\t\t\tnetworkConfig,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tnetworkBufferPool);\n+\t\t\tthis.networkBufferPool = networkBufferPool;\n+\t\t\tthis.taskEventPublisher = taskEventPublisher;\n+\t\t\tthis.partitionManager = partitionManager;\n+\t\t\tthis.connectionManager = connectionManager;\n+\t\t\tthis.partitionRequestMaxBackoff = networkConfig.partitionRequestMaxBackoff();\n+\t\t\tthis.partitionRequestInitialBackoff = networkConfig.partitionRequestInitialBackoff();\n+\t\t\tthis.taskExecutorResourceId = taskExecutorResourceId;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tpartitionManager,\n+\t\t\t\t\ttaskEventPublisher,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics);\n+\t\t\t} else {\n+\t\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\t\tinputGate,\n+\t\t\t\t\tindex,\n+\t\t\t\t\tpartitionId,\n+\t\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\t\tconnectionManager,\n+\t\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\t\tmetrics,\n+\t\t\t\t\tnetworkBufferPool);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MDcyNw=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI5NzM3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo0MToxMlrOFsrfug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo0MToxMlrOFsrfug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NDI5OA==", "bodyText": "I am a bit torn for the connectionIndex value. If we use channelIndex as the value, it would create 1000 connections in theory if there are 1000 subpartitions in writer. I a bit prefer to use gateIndex instead to create less connections.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382394298", "createdAt": "2020-02-21T04:41:12Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -238,18 +252,19 @@ private InputGate createInputGate(TaskManagerLocation senderLocation) throws Exc\n \n \tprivate InputGateDeploymentDescriptor createInputGateDeploymentDescriptor(\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint consumedSubpartitionIndex,\n+\t\t\tint gateIndex,\n \t\t\tResourceID localLocation) {\n \n-\t\tfinal ShuffleDescriptor[] channelDescriptors = Arrays.stream(partitionIds)\n-\t\t\t.map(partitionId ->\n-\t\t\t\tcreateShuffleDescriptor(localMode, partitionId, localLocation, senderLocation, consumedSubpartitionIndex))\n-\t\t\t.toArray(ShuffleDescriptor[]::new);\n+\t\tfinal ShuffleDescriptor[] channelDescriptors = new ShuffleDescriptor[channels];\n+\t\tfor (int channelIndex = 0; channelIndex < channels; ++channelIndex) {\n+\t\t\tchannelDescriptors[channelIndex] = createShuffleDescriptor(\n+\t\t\t\tlocalMode, partitionIds[gateIndex], localLocation, senderLocation, channelIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzI5OTQ3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo0Mjo0NFrOFsrg9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo0Mjo0NFrOFsrg9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NDYxMg==", "bodyText": "no need change, we can still reference the parent SingleInputGateFactory", "url": "https://github.com/apache/flink/pull/11155#discussion_r382394612", "createdAt": "2020-02-21T04:42:44Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -84,7 +98,7 @@\n \n \tprivate int dataPort;\n \n-\tprivate SingleInputGateFactory gateFactory;\n+\tprivate TestSingleInputGateFactory gateFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzMwNDg5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo0NjoyNlrOFsrj8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjozNzoyNFrOFss95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NTM3OQ==", "bodyText": "nit: Not really necessary change, because it does not provide any rich informations than the class name.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382395379", "createdAt": "2020-02-21T04:46:26Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java", "diffHunk": "@@ -243,7 +244,10 @@ private InputChannel createKnownInputChannel(\n \t\treturn () -> bufferPoolFactory.createBufferPool(0, floatingNetworkBuffersPerGate);\n \t}\n \n-\tprivate static class ChannelStatistics {\n+\t/**\n+\t * Statistics of input channels.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxODQwNg==", "bodyText": "The comment is only for style checking. Changing the class from package private to protected fails the style checking.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382418406", "createdAt": "2020-02-21T06:37:24Z", "author": {"login": "wsry"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java", "diffHunk": "@@ -243,7 +244,10 @@ private InputChannel createKnownInputChannel(\n \t\treturn () -> bufferPoolFactory.createBufferPool(0, floatingNetworkBuffersPerGate);\n \t}\n \n-\tprivate static class ChannelStatistics {\n+\t/**\n+\t * Statistics of input channels.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NTM3OQ=="}, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzMxNjg0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1NToyN1rOFsrrJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1NToyN1rOFsrrJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzIyMQ==", "bodyText": "We should adjust the descriptions a bit. typo costume\nE.g. A benchmark-specific input gate factory which overrides the respective methods of creating {@link RemotInputChannel} and {@link LocalInputChannel} for requesting specific subpartition.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382397221", "createdAt": "2020-02-21T04:55:27Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzMyMzA4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1OTo0OFrOFsrurg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1OTo0OFrOFsrurg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODEyNg==", "bodyText": "I guess it is not necessary to add this annotation which only indicates for private change.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382398126", "createdAt": "2020-02-21T04:59:48Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -95,7 +96,8 @@ public LocalInputChannel(\n \t// ------------------------------------------------------------------------\n \n \t@Override\n-\tvoid requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t@VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzMzMjc3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTowNjowNlrOFsrz0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTowNjowNlrOFsrz0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTQ0MQ==", "bodyText": "nit: I am a bit torn for @Nonnull with arguments. I know we did it in some cases before like SingleInputGateFactory.\nIn common sense we still consider them as Nonnull w/o this annotation. And we only need to emphasis the Nullable case to add the annotation.\nIn another aspect, it seems not very consistent in this class because other constructors do not have it.", "url": "https://github.com/apache/flink/pull/11155#discussion_r382399441", "createdAt": "2020-02-21T05:06:06Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -272,11 +287,161 @@ private static ShuffleDescriptor createShuffleDescriptor(\n \t\t\tResultPartitionID resultPartitionID,\n \t\t\tResourceID location,\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint channel) {\n+\t\t\tint connectionIndex) {\n \t\tfinal NettyShuffleDescriptorBuilder builder = NettyShuffleDescriptorBuilder.newBuilder()\n \t\t\t.setId(resultPartitionID)\n \t\t\t.setProducerInfoFromTaskManagerLocation(senderLocation)\n-\t\t\t.setConnectionIndex(channel);\n+\t\t\t.setConnectionIndex(connectionIndex);\n \t\treturn localMode ? builder.setProducerLocation(location).buildLocal() : builder.buildRemote();\n \t}\n+\n+\t/**\n+\t * A {@link SingleInputGateFactory} which replaces the default {@link RemoteInputChannel} and\n+\t * {@link LocalInputChannel} implementation with costume ones.\n+\t */\n+\tprivate static class TestSingleInputGateFactory extends SingleInputGateFactory {\n+\n+\t\tprivate final ResourceID taskExecutorResourceId;\n+\t\tprivate final int partitionRequestInitialBackoff;\n+\t\tprivate final int partitionRequestMaxBackoff;\n+\t\tprivate final ConnectionManager connectionManager;\n+\t\tprivate final ResultPartitionManager partitionManager;\n+\t\tprivate final TaskEventPublisher taskEventPublisher;\n+\t\tprivate final NetworkBufferPool networkBufferPool;\n+\n+\t\tpublic TestSingleInputGateFactory(\n+\t\t\t\t@Nonnull ResourceID taskExecutorResourceId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21b36d4fadd73af33edb4fabc7da9d93c2f2d55c"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzYxMTE5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODowMDowMVrOFsuZzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODowMDowMVrOFsuZzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ0MTkzMw==", "bodyText": "Please copy PR description into the commit message and once you have some expected benchmark results, please include them in the commit message as well :)\nCould you also explain in both places, how are you solving the problem? Maybe something along those lines:\n\nBefore this change, in network benchmark (for example 1000 channels benchmark with 4 record writers) StreamNetworkBenchmarkEnvironment#createInputGate was creating 1000 input gates with 4 input channels each, which doesn't make much sense. This commit is changing that to a single receiver with 4 input gates, with 1000 channels each.\nIt is achieved by providing testing implementations of InputChannels, which are using channel index for requesting subpartitions from ResultPartition, instead of subpartition index. Thanks to that, we can connect single ResultPartition with N subpartitions, to a single instance of InputGate with 1000 channels.\n\n?", "url": "https://github.com/apache/flink/pull/11155#discussion_r382441933", "createdAt": "2020-02-21T08:00:01Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -95,7 +95,7 @@ public LocalInputChannel(\n \t// ------------------------------------------------------------------------", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzYzMzA5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODoxMDowM1rOFsunGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODoxMDowM1rOFsunGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ0NTMzNg==", "bodyText": "This is always zero, as it's being ignored by Test***InputChannel classes, right?\nIf so, maybe add a comment explaining that?", "url": "https://github.com/apache/flink/pull/11155#discussion_r382445336", "createdAt": "2020-02-21T08:10:03Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -238,18 +241,19 @@ private InputGate createInputGate(TaskManagerLocation senderLocation) throws Exc\n \n \tprivate InputGateDeploymentDescriptor createInputGateDeploymentDescriptor(\n \t\t\tTaskManagerLocation senderLocation,\n-\t\t\tint consumedSubpartitionIndex,\n+\t\t\tint gateIndex,\n \t\t\tResourceID localLocation) {\n \n-\t\tfinal ShuffleDescriptor[] channelDescriptors = Arrays.stream(partitionIds)\n-\t\t\t.map(partitionId ->\n-\t\t\t\tcreateShuffleDescriptor(localMode, partitionId, localLocation, senderLocation, consumedSubpartitionIndex))\n-\t\t\t.toArray(ShuffleDescriptor[]::new);\n+\t\tfinal ShuffleDescriptor[] channelDescriptors = new ShuffleDescriptor[channels];\n+\t\tfor (int channelIndex = 0; channelIndex < channels; ++channelIndex) {\n+\t\t\tchannelDescriptors[channelIndex] = createShuffleDescriptor(\n+\t\t\t\tlocalMode, partitionIds[gateIndex], localLocation, senderLocation, gateIndex);\n+\t\t}\n \n \t\treturn new InputGateDeploymentDescriptor(\n \t\t\tdataSetID,\n \t\t\tResultPartitionType.PIPELINED_BOUNDED,\n-\t\t\tconsumedSubpartitionIndex,\n+\t\t\t0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MTk2OTU3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNDoyMDo0NVrOFtVbRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNDoyMDo0NVrOFtVbRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4MTI4Ng==", "bodyText": "nit: might supplement the reason why we should guarantee this.\nE.g. Otherwise it might cause unexpected behaviors when {@link PartitionNotFoundException} happens in {@link TestRemoteInputChannel}.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383081286", "createdAt": "2020-02-24T04:20:45Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/StreamNetworkBenchmarkEnvironment.java", "diffHunk": "@@ -158,6 +157,10 @@ public void tearDown() {\n \t\tsuppressExceptions(receiverEnv::close);\n \t}\n \n+\t/**\n+\t * Note: It should be guaranteed that {@link #createResultPartitionWriter(int)} has been called before\n+\t * creating the receiver.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjAxODkyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNToxMzo1MlrOFtV2tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNToxMzo1MlrOFtV2tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODMxMQ==", "bodyText": "nit: it is better to give some explanations why we need to override this method, otherwise it is not very easy understood by others.", "url": "https://github.com/apache/flink/pull/11155#discussion_r383088311", "createdAt": "2020-02-24T05:13:52Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io.benchmark;\n+\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.io.network.ConnectionID;\n+import org.apache.flink.runtime.io.network.ConnectionManager;\n+import org.apache.flink.runtime.io.network.TaskEventPublisher;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.metrics.InputChannelMetrics;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionManager;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.RemoteInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateFactory;\n+import org.apache.flink.runtime.shuffle.NettyShuffleDescriptor;\n+import org.apache.flink.runtime.taskmanager.NettyShuffleEnvironmentConfiguration;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A benchmark-specific input gate factory which overrides the respective methods of creating\n+ * {@link RemoteInputChannel} and {@link LocalInputChannel} for requesting specific subpartitions.\n+ */\n+public class SingleInputGateBenchmarkFactory extends SingleInputGateFactory {\n+\n+\tpublic SingleInputGateBenchmarkFactory(\n+\t\t\tResourceID taskExecutorResourceId,\n+\t\t\tNettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\tConnectionManager connectionManager,\n+\t\t\tResultPartitionManager partitionManager,\n+\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\tNetworkBufferPool networkBufferPool) {\n+\t\tsuper(\n+\t\t\ttaskExecutorResourceId,\n+\t\t\tnetworkConfig,\n+\t\t\tconnectionManager,\n+\t\t\tpartitionManager,\n+\t\t\ttaskEventPublisher,\n+\t\t\tnetworkBufferPool);\n+\t}\n+\n+\t@Override\n+\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tSingleInputGateFactory.ChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t} else {\n+\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics,\n+\t\t\t\tnetworkBufferPool);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {\n+\t\t\treturn newPartitionID;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link RemoteInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestRemoteInputChannel extends RemoteInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestRemoteInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tConnectionID connectionId,\n+\t\t\t\tConnectionManager connectionManager,\n+\t\t\t\tint initialBackOff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics,\n+\t\t\t\tMemorySegmentProvider memorySegmentProvider) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tconnectionId,\n+\t\t\t\tconnectionManager,\n+\t\t\t\tinitialBackOff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics,\n+\t\t\t\tmemorySegmentProvider);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjA2NDUzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNTo1NjowNVrOFtWPyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNTo1NjowNVrOFtWPyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5NDczMA==", "bodyText": "nit : final", "url": "https://github.com/apache/flink/pull/11155#discussion_r383094730", "createdAt": "2020-02-24T05:56:05Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io.benchmark;\n+\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.io.network.ConnectionID;\n+import org.apache.flink.runtime.io.network.ConnectionManager;\n+import org.apache.flink.runtime.io.network.TaskEventPublisher;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.metrics.InputChannelMetrics;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionManager;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.RemoteInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateFactory;\n+import org.apache.flink.runtime.shuffle.NettyShuffleDescriptor;\n+import org.apache.flink.runtime.taskmanager.NettyShuffleEnvironmentConfiguration;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A benchmark-specific input gate factory which overrides the respective methods of creating\n+ * {@link RemoteInputChannel} and {@link LocalInputChannel} for requesting specific subpartitions.\n+ */\n+public class SingleInputGateBenchmarkFactory extends SingleInputGateFactory {\n+\n+\tpublic SingleInputGateBenchmarkFactory(\n+\t\t\tResourceID taskExecutorResourceId,\n+\t\t\tNettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\tConnectionManager connectionManager,\n+\t\t\tResultPartitionManager partitionManager,\n+\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\tNetworkBufferPool networkBufferPool) {\n+\t\tsuper(\n+\t\t\ttaskExecutorResourceId,\n+\t\t\tnetworkConfig,\n+\t\t\tconnectionManager,\n+\t\t\tpartitionManager,\n+\t\t\ttaskEventPublisher,\n+\t\t\tnetworkBufferPool);\n+\t}\n+\n+\t@Override\n+\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tSingleInputGateFactory.ChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t} else {\n+\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics,\n+\t\t\t\tnetworkBufferPool);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjA2NDY3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNTo1NjoyMFrOFtWP4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNTo1NjoyMFrOFtWP4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5NDc1NA==", "bodyText": "nit: final", "url": "https://github.com/apache/flink/pull/11155#discussion_r383094754", "createdAt": "2020-02-24T05:56:20Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/benchmark/SingleInputGateBenchmarkFactory.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io.benchmark;\n+\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.io.network.ConnectionID;\n+import org.apache.flink.runtime.io.network.ConnectionManager;\n+import org.apache.flink.runtime.io.network.TaskEventPublisher;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.metrics.InputChannelMetrics;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionManager;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.RemoteInputChannel;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateFactory;\n+import org.apache.flink.runtime.shuffle.NettyShuffleDescriptor;\n+import org.apache.flink.runtime.taskmanager.NettyShuffleEnvironmentConfiguration;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A benchmark-specific input gate factory which overrides the respective methods of creating\n+ * {@link RemoteInputChannel} and {@link LocalInputChannel} for requesting specific subpartitions.\n+ */\n+public class SingleInputGateBenchmarkFactory extends SingleInputGateFactory {\n+\n+\tpublic SingleInputGateBenchmarkFactory(\n+\t\t\tResourceID taskExecutorResourceId,\n+\t\t\tNettyShuffleEnvironmentConfiguration networkConfig,\n+\t\t\tConnectionManager connectionManager,\n+\t\t\tResultPartitionManager partitionManager,\n+\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\tNetworkBufferPool networkBufferPool) {\n+\t\tsuper(\n+\t\t\ttaskExecutorResourceId,\n+\t\t\tnetworkConfig,\n+\t\t\tconnectionManager,\n+\t\t\tpartitionManager,\n+\t\t\ttaskEventPublisher,\n+\t\t\tnetworkBufferPool);\n+\t}\n+\n+\t@Override\n+\tprotected InputChannel createKnownInputChannel(\n+\t\t\tSingleInputGate inputGate,\n+\t\t\tint index,\n+\t\t\tNettyShuffleDescriptor inputChannelDescriptor,\n+\t\t\tSingleInputGateFactory.ChannelStatistics channelStatistics,\n+\t\t\tInputChannelMetrics metrics) {\n+\t\tResultPartitionID partitionId = inputChannelDescriptor.getResultPartitionID();\n+\t\tif (inputChannelDescriptor.isLocalTo(taskExecutorResourceId)) {\n+\t\t\treturn new TestLocalInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t} else {\n+\t\t\treturn new TestRemoteInputChannel(\n+\t\t\t\tinputGate,\n+\t\t\t\tindex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tinputChannelDescriptor.getConnectionId(),\n+\t\t\t\tconnectionManager,\n+\t\t\t\tpartitionRequestInitialBackoff,\n+\t\t\t\tpartitionRequestMaxBackoff,\n+\t\t\t\tmetrics,\n+\t\t\t\tnetworkBufferPool);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link LocalInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestLocalInputChannel extends LocalInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();\n+\n+\t\tpublic TestLocalInputChannel(\n+\t\t\t\tSingleInputGate inputGate,\n+\t\t\t\tint channelIndex,\n+\t\t\t\tResultPartitionID partitionId,\n+\t\t\t\tResultPartitionManager partitionManager,\n+\t\t\t\tTaskEventPublisher taskEventPublisher,\n+\t\t\t\tint initialBackoff,\n+\t\t\t\tint maxBackoff,\n+\t\t\t\tInputChannelMetrics metrics) {\n+\t\t\tsuper(\n+\t\t\t\tinputGate,\n+\t\t\t\tchannelIndex,\n+\t\t\t\tpartitionId,\n+\t\t\t\tpartitionManager,\n+\t\t\t\ttaskEventPublisher,\n+\t\t\t\tinitialBackoff,\n+\t\t\t\tmaxBackoff,\n+\t\t\t\tmetrics);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\t\t\tsuper.requestSubpartition(channelIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResultPartitionID getPartitionId() {\n+\t\t\treturn newPartitionID;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link RemoteInputChannel} which ignores the given subpartition index and uses channel index\n+\t * instead when requesting subpartition.\n+\t */\n+\tprivate static class TestRemoteInputChannel extends RemoteInputChannel {\n+\n+\t\tprivate ResultPartitionID newPartitionID = new ResultPartitionID();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe5e3d33d372b15e15cc52171ea8c3844c02ef9"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 974, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}