{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NTYyODgz", "number": 11543, "title": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF", "bodyText": "What is the purpose of the change\nThis pull request add supports for Counter, Gauge, Meter, Distribution metric type for Python UDF.\nBrief change log\n\nAdds Counter, Gauge, Meter, Distribution metric interface for Python.\nRegister metrics from Python to Java.\n\nVerifying this change\nThis change added tests and can be verified as follows:\n\nAdd tests in test_metric.py to verify the metric for Python.\nAdd FlinkMetricContainerTest to verify metric paser and registration for Java.\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (no)\nThe serializers: (no)\nThe runtime per-record code paths (performance sensitive): (no)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (no)\nThe S3 file system connector: (no)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes)\nIf yes, how is the feature documented? (PythonDocs)", "createdAt": "2020-03-27T05:41:50Z", "url": "https://github.com/apache/flink/pull/11543", "merged": true, "mergeCommit": {"oid": "ea1d15c95cb7039be4374b7e7a9963003713ac28"}, "closed": true, "closedAt": "2020-03-30T08:23:43Z", "author": {"login": "hequn8128"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRrLihgBqjMxNzExOTc1OTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSqJuKgFqTM4MzYyODY2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd01ad835fabf33de968810666e9b97b494e7c60", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/fd01ad835fabf33de968810666e9b97b494e7c60", "committedDate": "2020-03-27T05:33:05Z", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF"}, "afterCommit": {"oid": "61e53d4800400c4b3b9f9a2aef9938e26034370f", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/61e53d4800400c4b3b9f9a2aef9938e26034370f", "committedDate": "2020-03-27T07:00:55Z", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "committedDate": "2020-03-27T08:03:32Z", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61e53d4800400c4b3b9f9a2aef9938e26034370f", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/61e53d4800400c4b3b9f9a2aef9938e26034370f", "committedDate": "2020-03-27T07:00:55Z", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF"}, "afterCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "committedDate": "2020-03-27T08:03:32Z", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyODg2MzQ1", "url": "https://github.com/apache/flink/pull/11543#pullrequestreview-382886345", "createdAt": "2020-03-27T14:04:14Z", "commit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDowNjoxNlrOF8ypYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTozNjozNlrOF82n_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4ODY3NA==", "bodyText": "Is it necessary to expose this method to users?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399288674", "createdAt": "2020-03-27T14:06:16Z", "author": {"login": "dianfu"}, "path": "flink-python/pyflink/metrics/metricbase.py", "diffHunk": "@@ -76,3 +107,97 @@ def add_group(self, name: str, extra: str = None) -> 'MetricGroup':\n         else:\n             return self._add_group(name, MetricGroupType.key)\\\n                 ._add_group(extra, MetricGroupType.value)\n+\n+    def counter(self, name: str) -> 'Counter':\n+        from apache_beam.metrics.metric import Metrics\n+        return Counter(Metrics.counter(self._get_namespace(), name))\n+\n+    def gauge(self, name: str, obj: Callable[[], int]) -> None:\n+        from apache_beam.metrics.metric import Metrics\n+        self._flink_gauge[name] = obj\n+        self._beam_gauge[name] = Metrics.gauge(self._get_namespace(), name)\n+\n+    def meter(self, name: str, time_span_in_seconds: int = 60) -> 'Meter':\n+        from apache_beam.metrics.metric import Metrics\n+        # There is no meter type in Beam, use counter to implement meter\n+        return Meter(\n+            Metrics.counter(self._get_namespace(time_span_in_seconds), name),\n+            time_span_in_seconds)\n+\n+    def distribution(self, name: str) -> 'Distribution':\n+        from apache_beam.metrics.metric import Metrics\n+        return Distribution(Metrics.distribution(self._get_namespace(), name))\n+\n+    def _get_metric_group_names_and_types(self) -> ([], []):\n+        if self._name is None:\n+            return [], []\n+        else:\n+            names, types = self._parent._get_metric_group_names_and_types()\n+            names.append(self._name)\n+            types.append(str(self._metric_group_type))\n+            return names, types\n+\n+    def _get_namespace(self, time=None) -> str:\n+        (names, metric_group_type) = self._get_metric_group_names_and_types()\n+        names.extend(metric_group_type)\n+        if time is not None:\n+            names.append(str(time))\n+        return json.dumps(names)\n+\n+\n+class Metric(object):\n+    \"\"\"Base interface of a metric object.\"\"\"\n+    pass\n+\n+\n+class Counter(Metric):\n+    \"\"\"Counter metric interface. Allows a count to be incremented/decremented\n+    during pipeline execution.\"\"\"\n+\n+    def __init__(self, inner_counter):\n+        self._inner_counter = inner_counter\n+\n+    def inc(self, n=1):\n+        self._inner_counter.inc(n)\n+\n+    def dec(self, n=1):\n+        self.inc(-n)\n+\n+    def get_count(self):\n+        from apache_beam.metrics.execution import MetricsEnvironment\n+        container = MetricsEnvironment.current_container()\n+        return container.get_counter(self._inner_counter.metric_name).get_cumulative()\n+\n+\n+class Distribution(Metric):\n+    \"\"\"Distribution Metric interface.\n+\n+    Allows statistics about the distribution of a variable to be collected during\n+    pipeline execution.\"\"\"\n+\n+    def __init__(self, inner_distribution):\n+        self._inner_distribution = inner_distribution\n+\n+    def update(self, value):\n+        self._inner_distribution.update(value)\n+\n+\n+class Meter(Metric):\n+    \"\"\"Meter Metric interface.\n+\n+    Metric for measuring throughput.\"\"\"\n+\n+    def __init__(self, inner_counter, time_span_in_seconds=60):\n+        self._inner_counter = inner_counter\n+        self._time_span_in_seconds = time_span_in_seconds\n+\n+    def make_event(self, value=1):\n+        self._inner_counter.inc(value)\n+\n+    def get_time_span_in_seconds(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwMjg3NA==", "bodyText": "The parenthese could be removed", "url": "https://github.com/apache/flink/pull/11543#discussion_r399302874", "createdAt": "2020-03-27T14:26:32Z", "author": {"login": "dianfu"}, "path": "flink-python/pyflink/metrics/metricbase.py", "diffHunk": "@@ -76,3 +107,97 @@ def add_group(self, name: str, extra: str = None) -> 'MetricGroup':\n         else:\n             return self._add_group(name, MetricGroupType.key)\\\n                 ._add_group(extra, MetricGroupType.value)\n+\n+    def counter(self, name: str) -> 'Counter':\n+        from apache_beam.metrics.metric import Metrics\n+        return Counter(Metrics.counter(self._get_namespace(), name))\n+\n+    def gauge(self, name: str, obj: Callable[[], int]) -> None:\n+        from apache_beam.metrics.metric import Metrics\n+        self._flink_gauge[name] = obj\n+        self._beam_gauge[name] = Metrics.gauge(self._get_namespace(), name)\n+\n+    def meter(self, name: str, time_span_in_seconds: int = 60) -> 'Meter':\n+        from apache_beam.metrics.metric import Metrics\n+        # There is no meter type in Beam, use counter to implement meter\n+        return Meter(\n+            Metrics.counter(self._get_namespace(time_span_in_seconds), name),\n+            time_span_in_seconds)\n+\n+    def distribution(self, name: str) -> 'Distribution':\n+        from apache_beam.metrics.metric import Metrics\n+        return Distribution(Metrics.distribution(self._get_namespace(), name))\n+\n+    def _get_metric_group_names_and_types(self) -> ([], []):\n+        if self._name is None:\n+            return [], []\n+        else:\n+            names, types = self._parent._get_metric_group_names_and_types()\n+            names.append(self._name)\n+            types.append(str(self._metric_group_type))\n+            return names, types\n+\n+    def _get_namespace(self, time=None) -> str:\n+        (names, metric_group_type) = self._get_metric_group_names_and_types()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxMjM5OQ==", "bodyText": "An alternative solution is set _base_metric_group as None when metrics is not enabled.", "url": "https://github.com/apache/flink/pull/11543#discussion_r399312399", "createdAt": "2020-03-27T14:39:25Z", "author": {"login": "dianfu"}, "path": "flink-python/pyflink/table/udf.py", "diffHunk": "@@ -39,6 +39,9 @@ def __init__(self, base_metric_group):\n         self._base_metric_group = base_metric_group\n \n     def get_metric_group(self) -> MetricGroup:\n+        if not self._base_metric_group._metric_enabled:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxODUyMQ==", "bodyText": "remove this line and set it in the following RuntimeException?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399318521", "createdAt": "2020-03-27T14:47:36Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyNjM3Mw==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/11543#discussion_r399326373", "createdAt": "2020-03-27T14:58:13Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzMDMwMg==", "bodyText": "Change to the following then it will only lookup the map once:\ncounter = flinkCounterCache.get(flinkMetricIdentifier);\nif (counter == null) {\nXXX\n}", "url": "https://github.com/apache/flink/pull/11543#discussion_r399330302", "createdAt": "2020-03-27T15:03:23Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNzMxNw==", "bodyText": "Use global import?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399337317", "createdAt": "2020-03-27T15:13:22Z", "author": {"login": "dianfu"}, "path": "flink-python/pyflink/metrics/metricbase.py", "diffHunk": "@@ -76,3 +107,97 @@ def add_group(self, name: str, extra: str = None) -> 'MetricGroup':\n         else:\n             return self._add_group(name, MetricGroupType.key)\\\n                 ._add_group(extra, MetricGroupType.value)\n+\n+    def counter(self, name: str) -> 'Counter':\n+        from apache_beam.metrics.metric import Metrics\n+        return Counter(Metrics.counter(self._get_namespace(), name))\n+\n+    def gauge(self, name: str, obj: Callable[[], int]) -> None:\n+        from apache_beam.metrics.metric import Metrics\n+        self._flink_gauge[name] = obj\n+        self._beam_gauge[name] = Metrics.gauge(self._get_namespace(), name)\n+\n+    def meter(self, name: str, time_span_in_seconds: int = 60) -> 'Meter':\n+        from apache_beam.metrics.metric import Metrics\n+        # There is no meter type in Beam, use counter to implement meter\n+        return Meter(\n+            Metrics.counter(self._get_namespace(time_span_in_seconds), name),\n+            time_span_in_seconds)\n+\n+    def distribution(self, name: str) -> 'Distribution':\n+        from apache_beam.metrics.metric import Metrics\n+        return Distribution(Metrics.distribution(self._get_namespace(), name))\n+\n+    def _get_metric_group_names_and_types(self) -> ([], []):\n+        if self._name is None:\n+            return [], []\n+        else:\n+            names, types = self._parent._get_metric_group_names_and_types()\n+            names.append(self._name)\n+            types.append(str(self._metric_group_type))\n+            return names, types\n+\n+    def _get_namespace(self, time=None) -> str:\n+        (names, metric_group_type) = self._get_metric_group_names_and_types()\n+        names.extend(metric_group_type)\n+        if time is not None:\n+            names.append(str(time))\n+        return json.dumps(names)\n+\n+\n+class Metric(object):\n+    \"\"\"Base interface of a metric object.\"\"\"\n+    pass\n+\n+\n+class Counter(Metric):\n+    \"\"\"Counter metric interface. Allows a count to be incremented/decremented\n+    during pipeline execution.\"\"\"\n+\n+    def __init__(self, inner_counter):\n+        self._inner_counter = inner_counter\n+\n+    def inc(self, n=1):\n+        self._inner_counter.inc(n)\n+\n+    def dec(self, n=1):\n+        self.inc(-n)\n+\n+    def get_count(self):\n+        from apache_beam.metrics.execution import MetricsEnvironment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0NDY5Nw==", "bodyText": "this#flinkCounterCache -> #flinkCounterCache", "url": "https://github.com/apache/flink/pull/11543#discussion_r399344697", "createdAt": "2020-03-27T15:23:38Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0ODEzNQ==", "bodyText": "Integer.valueOf -> Integer.parseInt", "url": "https://github.com/apache/flink/pull/11543#discussion_r399348135", "createdAt": "2020-03-27T15:28:27Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MTExNg==", "bodyText": "private?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399351116", "createdAt": "2020-03-27T15:32:43Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tthrow new RuntimeException(String.format(\"Parse namespace[%s] error. \", metricName.getNamespace()));\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic String getFlinkMetricIdentifierString(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tList<String> results = scopeComponents.subList(0, scopeComponents.size() / 2);\n+\t\tresults.add(metricName.getName());\n+\t\treturn String.join(METRIC_KEY_SEPARATOR, results);\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic MetricGroup registerMetricGroup(MetricKey metricKey, MetricGroup metricGroup) {\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tint size = scopeComponents.size();\n+\t\tList<String> metricGroupNames = scopeComponents.subList(0, size / 2);\n+\t\tList<String> metricGroupTypes = scopeComponents.subList(size / 2, size);\n+\t\tfor (int i = 0; i < metricGroupNames.size(); ++i) {\n+\t\t\tif (metricGroupTypes.get(i).equals(\"MetricGroupType.generic\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(metricGroupNames.get(i));\n+\t\t\t} else if (metricGroupTypes.get(i).equals(\"MetricGroupType.key\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(\n+\t\t\t\t\tmetricGroupNames.get(i),\n+\t\t\t\t\tmetricGroupNames.get(++i));\n+\t\t\t}\n+\t\t}\n+\t\treturn metricGroup;\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link DistributionResult}.\n+\t */\n+\tpublic static class FlinkDistributionGauge implements Gauge<DistributionResult> {\n+\n+\t\tDistributionResult data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MTIzOQ==", "bodyText": "private?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399351239", "createdAt": "2020-03-27T15:32:51Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tthrow new RuntimeException(String.format(\"Parse namespace[%s] error. \", metricName.getNamespace()));\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic String getFlinkMetricIdentifierString(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tList<String> results = scopeComponents.subList(0, scopeComponents.size() / 2);\n+\t\tresults.add(metricName.getName());\n+\t\treturn String.join(METRIC_KEY_SEPARATOR, results);\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic MetricGroup registerMetricGroup(MetricKey metricKey, MetricGroup metricGroup) {\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tint size = scopeComponents.size();\n+\t\tList<String> metricGroupNames = scopeComponents.subList(0, size / 2);\n+\t\tList<String> metricGroupTypes = scopeComponents.subList(size / 2, size);\n+\t\tfor (int i = 0; i < metricGroupNames.size(); ++i) {\n+\t\t\tif (metricGroupTypes.get(i).equals(\"MetricGroupType.generic\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(metricGroupNames.get(i));\n+\t\t\t} else if (metricGroupTypes.get(i).equals(\"MetricGroupType.key\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(\n+\t\t\t\t\tmetricGroupNames.get(i),\n+\t\t\t\t\tmetricGroupNames.get(++i));\n+\t\t\t}\n+\t\t}\n+\t\treturn metricGroup;\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link DistributionResult}.\n+\t */\n+\tpublic static class FlinkDistributionGauge implements Gauge<DistributionResult> {\n+\n+\t\tDistributionResult data;\n+\n+\t\tFlinkDistributionGauge(DistributionResult data) {\n+\t\t\tthis.data = data;\n+\t\t}\n+\n+\t\tvoid update(DistributionResult data) {\n+\t\t\tthis.data = data;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DistributionResult getValue() {\n+\t\t\treturn data;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link GaugeResult}.\n+\t */\n+\tpublic static class FlinkGauge implements Gauge<Long> {\n+\n+\t\tGaugeResult data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MzIyMg==", "bodyText": "private?", "url": "https://github.com/apache/flink/pull/11543#discussion_r399353222", "createdAt": "2020-03-27T15:35:40Z", "author": {"login": "dianfu"}, "path": "flink-python/src/test/java/org/apache/flink/python/metric/FlinkMetricContainerTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.python.metric;\n+\n+import org.apache.flink.api.common.functions.RuntimeContext;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.MetricRegistry;\n+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;\n+import org.apache.flink.runtime.metrics.groups.GenericMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.MetricGroupTest;\n+\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi;\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.construction.BeamUrns;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.SimpleMonitoringInfoBuilder;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link FlinkMetricContainer}.\n+ */\n+public class FlinkMetricContainerTest {\n+\n+\t@Mock\n+\tprivate RuntimeContext runtimeContext;\n+\t@Mock\n+\tprivate MetricGroup metricGroup;\n+\n+\tFlinkMetricContainer container;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1Mzg1NA==", "bodyText": "The throws could be removed", "url": "https://github.com/apache/flink/pull/11543#discussion_r399353854", "createdAt": "2020-03-27T15:36:36Z", "author": {"login": "dianfu"}, "path": "flink-python/src/test/java/org/apache/flink/python/metric/FlinkMetricContainerTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.python.metric;\n+\n+import org.apache.flink.api.common.functions.RuntimeContext;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.MetricRegistry;\n+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;\n+import org.apache.flink.runtime.metrics.groups.GenericMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.MetricGroupTest;\n+\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi;\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.construction.BeamUrns;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.SimpleMonitoringInfoBuilder;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link FlinkMetricContainer}.\n+ */\n+public class FlinkMetricContainerTest {\n+\n+\t@Mock\n+\tprivate RuntimeContext runtimeContext;\n+\t@Mock\n+\tprivate MetricGroup metricGroup;\n+\n+\tFlinkMetricContainer container;\n+\n+\tprivate static final String GAUGE_URN =\n+\t\tBeamUrns.getUrn(MetricsApi.MonitoringInfoTypeUrns.Enum.LATEST_INT64_TYPE);\n+\n+\tprivate static final List<String> DEFAULT_SCOPE_COMPONENTS = Arrays.asList(\n+\t\t\"key\",\n+\t\t\"value\",\n+\t\t\"MetricGroupType.key\",\n+\t\t\"MetricGroupType.value\");\n+\n+\tprivate static final String DEFAULT_NAMESPACE =\n+\t\t\"[\\\"key\\\", \\\"value\\\", \\\"MetricGroupType.key\\\", \\\"MetricGroupType.value\\\"]\";\n+\n+\t@Before\n+\tpublic void beforeTest() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\twhen(runtimeContext.getMetricGroup()).thenReturn(metricGroup);\n+\t\twhen(metricGroup.addGroup(any(), any())).thenReturn(metricGroup);\n+\t\twhen(metricGroup.addGroup(any())).thenReturn(metricGroup);\n+\t\tcontainer = new FlinkMetricContainer(runtimeContext.getMetricGroup());\n+\t}\n+\n+\t@Test\n+\tpublic void testGetNameSpaceArray() throws JsonProcessingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b4566191e46ade55d78c10ab3102e075e969f4d", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/8b4566191e46ade55d78c10ab3102e075e969f4d", "committedDate": "2020-03-29T11:39:04Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc76b91c0b79817117f1b796ea461126ad16e0a", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/1bc76b91c0b79817117f1b796ea461126ad16e0a", "committedDate": "2020-03-30T04:04:18Z", "message": "update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb31a07d5c8e76efaf0cf3ad525bf913b731cce6", "author": {"user": {"login": "hequn8128", "name": "Hequn Cheng"}}, "url": "https://github.com/apache/flink/commit/cb31a07d5c8e76efaf0cf3ad525bf913b731cce6", "committedDate": "2020-03-30T06:03:58Z", "message": "remove useless import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNjI4NjY5", "url": "https://github.com/apache/flink/pull/11543#pullrequestreview-383628669", "createdAt": "2020-03-30T08:23:21Z", "commit": {"oid": "cb31a07d5c8e76efaf0cf3ad525bf913b731cce6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2636, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}