{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzI1OTk3", "number": 12140, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowODo0MlrOD8ULWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxNToyOVrOD8UPWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcxNzM3OnYy", "diffSide": "RIGHT", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFormatFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowODo0M1rOGVLX3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowODo0M1rOGVLX3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTYxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t.withDescription(\"Optional flag to skip fields and rows with parse errors instead of failing;\\n\"\n          \n          \n            \n            \t\t\t\t\t+ \"fields are set to null in case of errors\");\n          \n          \n            \n            \t\t\t.withDescription(\"Optional flag to skip fields and rows with parse errors instead of failing, \"\n          \n          \n            \n            \t\t\t\t\t+ \"fields are set to null in case of errors. Default is false.\");", "url": "https://github.com/apache/flink/pull/12140#discussion_r424859613", "createdAt": "2020-05-14T04:08:43Z", "author": {"login": "wuchong"}, "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFormatFactory.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.serialization.DeserializationSchema;\n+import org.apache.flink.api.common.serialization.SerializationSchema;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.configuration.ConfigOption;\n+import org.apache.flink.configuration.ConfigOptions;\n+import org.apache.flink.configuration.ReadableConfig;\n+import org.apache.flink.table.api.ValidationException;\n+import org.apache.flink.table.connector.ChangelogMode;\n+import org.apache.flink.table.connector.format.ScanFormat;\n+import org.apache.flink.table.connector.format.SinkFormat;\n+import org.apache.flink.table.connector.sink.DynamicTableSink;\n+import org.apache.flink.table.connector.source.ScanTableSource;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.DeserializationFormatFactory;\n+import org.apache.flink.table.factories.DynamicTableFactory;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.factories.SerializationFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.RowType;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Table format factory for providing configured instances of JSON to RowData\n+ * {@link SerializationSchema} and {@link DeserializationSchema}.\n+ */\n+public class JsonFormatFactory implements\n+\t\tDeserializationFormatFactory,\n+\t\tSerializationFormatFactory {\n+\n+\tpublic static final String IDENTIFIER = \"json\";\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Options\n+\t// ------------------------------------------------------------------------\n+\n+\tprivate static final ConfigOption<Boolean> FAIL_ON_MISSING_FIELD = ConfigOptions\n+\t\t\t.key(\"fail-on-missing-field\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false)\n+\t\t\t.withDescription(\"Optional flag to specify whether to fail if a field is missing or not, false by default\");\n+\n+\tprivate static final ConfigOption<Boolean> IGNORE_PARSE_ERRORS = ConfigOptions\n+\t\t\t.key(\"ignore-parse-errors\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false)\n+\t\t\t.withDescription(\"Optional flag to skip fields and rows with parse errors instead of failing;\\n\"\n+\t\t\t\t\t+ \"fields are set to null in case of errors\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75b40a20b360133a128d0b2cfbc9a6754980bbdc"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcyMDQzOnYy", "diffSide": "RIGHT", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFormatFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxMDo0MlrOGVLZpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxMDo0MlrOGVLZpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDA3MQ==", "bodyText": "Can be simplified to :\nboolean failOnMissingField = tableOptions.get(FAIL_ON_MISSING_FIELD);\nboolean ignoreParseErrors = tableOptions.get(IGNORE_PARSE_ERRORS);", "url": "https://github.com/apache/flink/pull/12140#discussion_r424860071", "createdAt": "2020-05-14T04:10:42Z", "author": {"login": "wuchong"}, "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFormatFactory.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.serialization.DeserializationSchema;\n+import org.apache.flink.api.common.serialization.SerializationSchema;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.configuration.ConfigOption;\n+import org.apache.flink.configuration.ConfigOptions;\n+import org.apache.flink.configuration.ReadableConfig;\n+import org.apache.flink.table.api.ValidationException;\n+import org.apache.flink.table.connector.ChangelogMode;\n+import org.apache.flink.table.connector.format.ScanFormat;\n+import org.apache.flink.table.connector.format.SinkFormat;\n+import org.apache.flink.table.connector.sink.DynamicTableSink;\n+import org.apache.flink.table.connector.source.ScanTableSource;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.DeserializationFormatFactory;\n+import org.apache.flink.table.factories.DynamicTableFactory;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.factories.SerializationFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.RowType;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Table format factory for providing configured instances of JSON to RowData\n+ * {@link SerializationSchema} and {@link DeserializationSchema}.\n+ */\n+public class JsonFormatFactory implements\n+\t\tDeserializationFormatFactory,\n+\t\tSerializationFormatFactory {\n+\n+\tpublic static final String IDENTIFIER = \"json\";\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Options\n+\t// ------------------------------------------------------------------------\n+\n+\tprivate static final ConfigOption<Boolean> FAIL_ON_MISSING_FIELD = ConfigOptions\n+\t\t\t.key(\"fail-on-missing-field\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false)\n+\t\t\t.withDescription(\"Optional flag to specify whether to fail if a field is missing or not, false by default\");\n+\n+\tprivate static final ConfigOption<Boolean> IGNORE_PARSE_ERRORS = ConfigOptions\n+\t\t\t.key(\"ignore-parse-errors\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false)\n+\t\t\t.withDescription(\"Optional flag to skip fields and rows with parse errors instead of failing;\\n\"\n+\t\t\t\t\t+ \"fields are set to null in case of errors\");\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic ScanFormat<DeserializationSchema<RowData>> createScanFormat(\n+\t\t\tDynamicTableFactory.Context context,\n+\t\t\tReadableConfig formatOptions) {\n+\t\tFactoryUtil.validateFactoryOptions(this, formatOptions);\n+\t\tvalidateFormatOptions(formatOptions);\n+\n+\t\tfinal boolean failOnMissingField = formatOptions.get(FAIL_ON_MISSING_FIELD);\n+\t\tfinal boolean ignoreParseErrors = formatOptions.get(IGNORE_PARSE_ERRORS);\n+\n+\t\treturn new ScanFormat<DeserializationSchema<RowData>>() {\n+\t\t\t@Override\n+\t\t\tpublic DeserializationSchema<RowData> createScanFormat(\n+\t\t\t\t\tScanTableSource.Context scanContext,\n+\t\t\t\t\tDataType producedDataType) {\n+\t\t\t\tfinal RowType rowType = (RowType) producedDataType.getLogicalType();\n+\t\t\t\tfinal TypeInformation<RowData> rowDataTypeInfo =\n+\t\t\t\t\t\t(TypeInformation<RowData>) scanContext.createTypeInformation(producedDataType);\n+\t\t\t\treturn new JsonRowDataDeserializationSchema(\n+\t\t\t\t\t\trowType,\n+\t\t\t\t\t\trowDataTypeInfo,\n+\t\t\t\t\t\tfailOnMissingField,\n+\t\t\t\t\t\tignoreParseErrors);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic ChangelogMode getChangelogMode() {\n+\t\t\t\treturn ChangelogMode.insertOnly();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Override\n+\tpublic SinkFormat<SerializationSchema<RowData>> createSinkFormat(\n+\t\t\tDynamicTableFactory.Context context,\n+\t\t\tReadableConfig formatOptions) {\n+\t\tFactoryUtil.validateFactoryOptions(this, formatOptions);\n+\n+\t\treturn new SinkFormat<SerializationSchema<RowData>>() {\n+\t\t\t@Override\n+\t\t\tpublic SerializationSchema<RowData> createSinkFormat(\n+\t\t\t\t\tDynamicTableSink.Context context,\n+\t\t\t\t\tDataType consumedDataType) {\n+\t\t\t\tfinal RowType rowType = (RowType) consumedDataType.getLogicalType();\n+\t\t\t\treturn new JsonRowDataSerializationSchema(rowType);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic ChangelogMode getChangelogMode() {\n+\t\t\t\treturn ChangelogMode.insertOnly();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t@Override\n+\tpublic String factoryIdentifier() {\n+\t\treturn IDENTIFIER;\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> requiredOptions() {\n+\t\treturn Collections.emptySet();\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> optionalOptions() {\n+\t\tSet<ConfigOption<?>> options = new HashSet<>();\n+\t\toptions.add(FAIL_ON_MISSING_FIELD);\n+\t\toptions.add(IGNORE_PARSE_ERRORS);\n+\t\treturn options;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Validation\n+\t// ------------------------------------------------------------------------\n+\n+\tprivate void validateFormatOptions(ReadableConfig tableOptions) {\n+\t\tboolean failOnMissingField = tableOptions.getOptional(FAIL_ON_MISSING_FIELD)\n+\t\t\t\t.orElse(false);\n+\t\tboolean ignoreParseErrors = tableOptions.getOptional(IGNORE_PARSE_ERRORS)\n+\t\t\t\t.orElse(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75b40a20b360133a128d0b2cfbc9a6754980bbdc"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcyNzYxOnYy", "diffSide": "RIGHT", "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/JsonFormatFactoryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxNToyOVrOGVLd_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoyODo0M1rOGVLp-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MTE4Mw==", "bodyText": "Could you use the same validation as above? I think we will introduce some new options for json seriliazation soon.", "url": "https://github.com/apache/flink/pull/12140#discussion_r424861183", "createdAt": "2020-05-14T04:15:29Z", "author": {"login": "wuchong"}, "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/JsonFormatFactoryTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.serialization.DeserializationSchema;\n+import org.apache.flink.api.common.serialization.SerializationSchema;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.api.ValidationException;\n+import org.apache.flink.table.catalog.CatalogTableImpl;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.connector.sink.DynamicTableSink;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.factories.TestDynamicTableFactory;\n+import org.apache.flink.table.runtime.connector.sink.SinkRuntimeProviderContext;\n+import org.apache.flink.table.runtime.connector.source.ScanRuntimeProviderContext;\n+import org.apache.flink.table.runtime.typeutils.RowDataTypeInfo;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import static org.apache.flink.util.CoreMatchers.containsCause;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JsonFormatFactory}.\n+ */\n+public class JsonFormatFactoryTest extends TestLogger {\n+\t@Rule\n+\tpublic ExpectedException thrown = ExpectedException.none();\n+\n+\tprivate static final TableSchema SCHEMA = TableSchema.builder()\n+\t\t\t.field(\"field1\", DataTypes.BOOLEAN())\n+\t\t\t.field(\"field2\", DataTypes.INT())\n+\t\t\t.build();\n+\n+\tprivate static final RowType ROW_TYPE = (RowType) SCHEMA.toRowDataType().getLogicalType();\n+\n+\t@Test\n+\tpublic void testSeDeSchema() {\n+\t\tfinal Map<String, String> tableOptions = getAllOptions();\n+\n+\t\ttestSchemaSerializationSchema(tableOptions);\n+\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t@Test\n+\tpublic void testFailOnMissingField() {\n+\t\tfinal Map<String, String> tableOptions = getModifyOptions(\n+\t\t\t\toptions -> options.put(\"json.fail-on-missing-field\", \"true\"));\n+\n+\t\tthrown.expect(ValidationException.class);\n+\t\tthrown.expect(containsCause(new ValidationException(\"fail-on-missing-field and ignore-parse-errors shouldn't both be true.\")));\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t@Test\n+\tpublic void testInvalidOptionForIgnoreParseErrors() {\n+\t\tfinal Map<String, String> tableOptions = getModifyOptions(\n+\t\t\t\toptions -> options.put(\"json.ignore-parse-errors\", \"abc\"));\n+\n+\t\tthrown.expect(ValidationException.class);\n+\t\tthrown.expect(containsCause(new IllegalArgumentException(\"Unrecognized option for boolean: abc. Expected either true or false(case insensitive)\")));\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Utilities\n+\t// ------------------------------------------------------------------------\n+\n+\tprivate void testSchemaDeserializationSchema(Map<String, String> options) {\n+\t\tfinal JsonRowDataDeserializationSchema expectedDeser =\n+\t\t\t\tnew JsonRowDataDeserializationSchema(\n+\t\t\t\t\t\tROW_TYPE,\n+\t\t\t\t\t\tnew RowDataTypeInfo(ROW_TYPE),\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\ttrue);\n+\n+\t\tfinal DynamicTableSource actualSource = createTableSource(options);\n+\t\tassert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock;\n+\t\tTestDynamicTableFactory.DynamicTableSourceMock scanSourceMock =\n+\t\t\t\t(TestDynamicTableFactory.DynamicTableSourceMock) actualSource;\n+\n+\t\tDeserializationSchema<RowData> actualDeser = scanSourceMock.sourceValueFormat\n+\t\t\t\t.createScanFormat(\n+\t\t\t\t\t\tScanRuntimeProviderContext.INSTANCE,\n+\t\t\t\t\t\tSCHEMA.toRowDataType());\n+\n+\t\tassertEquals(expectedDeser, actualDeser);\n+\t}\n+\n+\tprivate void testSchemaSerializationSchema(Map<String, String> options) {\n+\t\tfinal DynamicTableSink actualSink = createTableSink(options);\n+\t\tassert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock;\n+\t\tTestDynamicTableFactory.DynamicTableSinkMock sinkMock =\n+\t\t\t\t(TestDynamicTableFactory.DynamicTableSinkMock) actualSink;\n+\n+\t\tSerializationSchema<RowData> actualSer = sinkMock.sinkValueFormat\n+\t\t\t\t.createSinkFormat(\n+\t\t\t\t\t\tnew SinkRuntimeProviderContext(false),\n+\t\t\t\t\t\tSCHEMA.toRowDataType());\n+\n+\t\tassertThat(actualSer, instanceOf(JsonRowDataSerializationSchema.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75b40a20b360133a128d0b2cfbc9a6754980bbdc"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NDI1MQ==", "bodyText": "Would add equals and hashcode for the serialization schema.", "url": "https://github.com/apache/flink/pull/12140#discussion_r424864251", "createdAt": "2020-05-14T04:28:43Z", "author": {"login": "danny0405"}, "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/JsonFormatFactoryTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.serialization.DeserializationSchema;\n+import org.apache.flink.api.common.serialization.SerializationSchema;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.api.ValidationException;\n+import org.apache.flink.table.catalog.CatalogTableImpl;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.connector.sink.DynamicTableSink;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.factories.TestDynamicTableFactory;\n+import org.apache.flink.table.runtime.connector.sink.SinkRuntimeProviderContext;\n+import org.apache.flink.table.runtime.connector.source.ScanRuntimeProviderContext;\n+import org.apache.flink.table.runtime.typeutils.RowDataTypeInfo;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import static org.apache.flink.util.CoreMatchers.containsCause;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JsonFormatFactory}.\n+ */\n+public class JsonFormatFactoryTest extends TestLogger {\n+\t@Rule\n+\tpublic ExpectedException thrown = ExpectedException.none();\n+\n+\tprivate static final TableSchema SCHEMA = TableSchema.builder()\n+\t\t\t.field(\"field1\", DataTypes.BOOLEAN())\n+\t\t\t.field(\"field2\", DataTypes.INT())\n+\t\t\t.build();\n+\n+\tprivate static final RowType ROW_TYPE = (RowType) SCHEMA.toRowDataType().getLogicalType();\n+\n+\t@Test\n+\tpublic void testSeDeSchema() {\n+\t\tfinal Map<String, String> tableOptions = getAllOptions();\n+\n+\t\ttestSchemaSerializationSchema(tableOptions);\n+\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t@Test\n+\tpublic void testFailOnMissingField() {\n+\t\tfinal Map<String, String> tableOptions = getModifyOptions(\n+\t\t\t\toptions -> options.put(\"json.fail-on-missing-field\", \"true\"));\n+\n+\t\tthrown.expect(ValidationException.class);\n+\t\tthrown.expect(containsCause(new ValidationException(\"fail-on-missing-field and ignore-parse-errors shouldn't both be true.\")));\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t@Test\n+\tpublic void testInvalidOptionForIgnoreParseErrors() {\n+\t\tfinal Map<String, String> tableOptions = getModifyOptions(\n+\t\t\t\toptions -> options.put(\"json.ignore-parse-errors\", \"abc\"));\n+\n+\t\tthrown.expect(ValidationException.class);\n+\t\tthrown.expect(containsCause(new IllegalArgumentException(\"Unrecognized option for boolean: abc. Expected either true or false(case insensitive)\")));\n+\t\ttestSchemaDeserializationSchema(tableOptions);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Utilities\n+\t// ------------------------------------------------------------------------\n+\n+\tprivate void testSchemaDeserializationSchema(Map<String, String> options) {\n+\t\tfinal JsonRowDataDeserializationSchema expectedDeser =\n+\t\t\t\tnew JsonRowDataDeserializationSchema(\n+\t\t\t\t\t\tROW_TYPE,\n+\t\t\t\t\t\tnew RowDataTypeInfo(ROW_TYPE),\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\ttrue);\n+\n+\t\tfinal DynamicTableSource actualSource = createTableSource(options);\n+\t\tassert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock;\n+\t\tTestDynamicTableFactory.DynamicTableSourceMock scanSourceMock =\n+\t\t\t\t(TestDynamicTableFactory.DynamicTableSourceMock) actualSource;\n+\n+\t\tDeserializationSchema<RowData> actualDeser = scanSourceMock.sourceValueFormat\n+\t\t\t\t.createScanFormat(\n+\t\t\t\t\t\tScanRuntimeProviderContext.INSTANCE,\n+\t\t\t\t\t\tSCHEMA.toRowDataType());\n+\n+\t\tassertEquals(expectedDeser, actualDeser);\n+\t}\n+\n+\tprivate void testSchemaSerializationSchema(Map<String, String> options) {\n+\t\tfinal DynamicTableSink actualSink = createTableSink(options);\n+\t\tassert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock;\n+\t\tTestDynamicTableFactory.DynamicTableSinkMock sinkMock =\n+\t\t\t\t(TestDynamicTableFactory.DynamicTableSinkMock) actualSink;\n+\n+\t\tSerializationSchema<RowData> actualSer = sinkMock.sinkValueFormat\n+\t\t\t\t.createSinkFormat(\n+\t\t\t\t\t\tnew SinkRuntimeProviderContext(false),\n+\t\t\t\t\t\tSCHEMA.toRowDataType());\n+\n+\t\tassertThat(actualSer, instanceOf(JsonRowDataSerializationSchema.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MTE4Mw=="}, "originalCommit": {"oid": "75b40a20b360133a128d0b2cfbc9a6754980bbdc"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1314, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}