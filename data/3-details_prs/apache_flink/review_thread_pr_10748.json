{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NjYwNjg2", "number": 10748, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODowOTo0MFrODVglvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo0MTo0NFrODY21WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjIzODgwNjM5OnYy", "diffSide": "RIGHT", "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODowOTo0MFrOFZxl0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMTo1MjowNFrOFZ-nYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MTIxOA==", "bodyText": "I think we missed host and port here.", "url": "https://github.com/apache/flink/pull/10748#discussion_r362571218", "createdAt": "2020-01-02T18:09:40Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc4NDYxMA==", "bodyText": "yes I did, happened while cleaning up the history...", "url": "https://github.com/apache/flink/pull/10748#discussion_r362784610", "createdAt": "2020-01-03T11:52:04Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MTIxOA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjIzODgyMjU1OnYy", "diffSide": "RIGHT", "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoxNzoxOVrOFZxvUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQxMzowMDoxN1rOFadEKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA==", "bodyText": "I think we should better include containingClass to compare when calling ExistingOption#equals so that these two ExistingOptions are really identical.", "url": "https://github.com/apache/flink/pull/10748#discussion_r362573650", "createdAt": "2020-01-02T18:17:19Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc4ODc4NQ==", "bodyText": "That would violate our definition of begin well-defined; from the javadocs:\nno 2 options exist for the same key with different descriptions/default values\nThe organization into separate classes that we have is only for developer convenience and readability only; it does not (and must not) have any semantics attached to it. Hence the containing class doesn't matter.\nThe reason for this is simplicity; we don't have to worry about\n\noptions clashing in their default value, which is difficult to document in a good way and can lead to subtle issues when de-duplicating options\noptions clashing in their description, which is also difficult to document and usually leads to stale documentation at one place\noptions clashing in their type, which may result in a component being unusable when used in conjunction with another\nusers not being able to configure distinct values per option", "url": "https://github.com/apache/flink/pull/10748#discussion_r362788785", "createdAt": "2020-01-03T12:12:01Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA0MjY4OQ==", "bodyText": "If some developers happen to create the same config key in different classes, I\u2018m afraid there exists some risk that user configure that key in flink-conf.yaml but taken effect by another unexpected class.\nBy the way, after introducing data type for config option, we did not include that field to compare in duplication check, and this is certainly out of scope of this PR.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363042689", "createdAt": "2020-01-04T16:11:38Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA1NDg4Nw==", "bodyText": "If some developers happen to create the same config key in different classes, I\u2018m afraid there exists some risk that user configure that key in flink-conf.yaml but taken effect by another unexpected class.\n\nThat's exactly what the current implementation is preventing.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363054887", "createdAt": "2020-01-04T20:59:03Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MDM1Ng==", "bodyText": "Would you please kindly explain whether the scenario below is legal in Flink?\nWe define two config option named as a.b.c with the same default value and description in different options files (e.g in CheckpointingOptions and RocksDBOptions). Current ConfigOptionsDocsCompletenessITCase would still pass successfully.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363090356", "createdAt": "2020-01-05T12:37:09Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMTc2MA==", "bodyText": "ah, so that's the case you were asking about.\nThat's legal. IIRC, when we introduced the generator we actually had an option that was mirroring another one. One could also argue that logically, if code-structure must not have semantics, duplication of code must be allowed.\nHowever, it seems unlikely that 2 options are being created for which they\n\nshare a key\nhave an exactly matching description (supposedly written in isolation from each other)\nare semantically so aligned that the key/description are still meaningful\nyet are semantically so different that the accidental configuration can cause problems.\n\nOverall I think this is mostly a theoretical issue due to us usually providing a component context via the key; to take your example, all RocksDBOptions have rocksdb in their key, with the inverse rightfully being the case for the CheckpointingOptions.\nNote that in any case the behavior in this regard isn't different between master and this PR.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363101760", "createdAt": "2020-01-05T16:00:11Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzI3NzUzNg==", "bodyText": "It is also not really the responsibility of this test to forbid this; which is apparent when you consider that whether you de-duplicate the option or not, the contents of the documentation remain the same.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363277536", "createdAt": "2020-01-06T12:41:20Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzI4MzQ5OA==", "bodyText": "Thanks for your interpretation, I still reserve my judgment on this problem and I agree this should be out of scope of this PR since this problem has been existed for a while.", "url": "https://github.com/apache/flink/pull/10748#discussion_r363283498", "createdAt": "2020-01-06T13:00:17Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA=="}, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NjUyOTkzOnYy", "diffSide": "RIGHT", "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNjoxMDoxNFrOFcYwEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNzo1MTo0NVrOFdganQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwOTk2OQ==", "bodyText": "I think we won't fail if we have a DocumentedOption which has no corresponding ExistingOption since we are only looking whether there is a DocumentedOption for every ExistingOption.", "url": "https://github.com/apache/flink/pull/10748#discussion_r365309969", "createdAt": "2020-01-10T16:10:14Z", "author": {"login": "tillrohrmann"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,105 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t\t\"host\",\n+\t\t\"port\"\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {\n+\t\t\t\t\t// we allow multiple instances of ConfigOptions with the same key if they are identical\n+\t\t\t\t\treturn option1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow duplicateHandler.apply(option1, option2);\n+\t\t\t\t}\n+\t\t\t}));\n+\t}\n+\n+\tprivate static void compareDocumentedAndExistingOptions(Map<String, List<DocumentedOption>> documentedOptions, Map<String, List<ExistingOption>> existingOptions) {\n \t\tfinal Collection<String> problems = new ArrayList<>(0);\n \n \t\t// first check that all existing options are properly documented\n-\t\texistingOptions.forEach((key, supposedState) -> {\n-\t\t\tDocumentedOption documentedState = documentedOptions.remove(key);\n-\n-\t\t\t// if nothing matches the docs for this option are up-to-date\n-\t\t\tif (documentedState == null) {\n-\t\t\t\t// option is not documented at all\n-\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t} else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {\n-\t\t\t\t// default is outdated\n-\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue + \" Actual: \" + documentedState.defaultValue);\n-\t\t\t} else if (!supposedState.description.equals(documentedState.description)) {\n-\t\t\t\t// description is outdated\n-\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated.\");\n+\t\texistingOptions.forEach((key, supposedStates) -> {\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\n+\t\t\tfor (ExistingOption supposedState : supposedStates) {\n+\t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n+\t\t\t\t\t// option is not documented at all\n+\t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n+\t\t\t\t\t// default is outdated\n+\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n+\t\t\t\t\t// description is outdated\n+\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated.\");\n+\t\t\t\t} else {\n+\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUzNjkzOQ==", "bodyText": "That is checked just below this block by verifying that the set of documented options (effectively the set of unmatched options) is empty.", "url": "https://github.com/apache/flink/pull/10748#discussion_r365536939", "createdAt": "2020-01-11T19:06:51Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,105 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t\t\"host\",\n+\t\t\"port\"\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {\n+\t\t\t\t\t// we allow multiple instances of ConfigOptions with the same key if they are identical\n+\t\t\t\t\treturn option1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow duplicateHandler.apply(option1, option2);\n+\t\t\t\t}\n+\t\t\t}));\n+\t}\n+\n+\tprivate static void compareDocumentedAndExistingOptions(Map<String, List<DocumentedOption>> documentedOptions, Map<String, List<ExistingOption>> existingOptions) {\n \t\tfinal Collection<String> problems = new ArrayList<>(0);\n \n \t\t// first check that all existing options are properly documented\n-\t\texistingOptions.forEach((key, supposedState) -> {\n-\t\t\tDocumentedOption documentedState = documentedOptions.remove(key);\n-\n-\t\t\t// if nothing matches the docs for this option are up-to-date\n-\t\t\tif (documentedState == null) {\n-\t\t\t\t// option is not documented at all\n-\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t} else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {\n-\t\t\t\t// default is outdated\n-\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue + \" Actual: \" + documentedState.defaultValue);\n-\t\t\t} else if (!supposedState.description.equals(documentedState.description)) {\n-\t\t\t\t// description is outdated\n-\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated.\");\n+\t\texistingOptions.forEach((key, supposedStates) -> {\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\n+\t\t\tfor (ExistingOption supposedState : supposedStates) {\n+\t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n+\t\t\t\t\t// option is not documented at all\n+\t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n+\t\t\t\t\t// default is outdated\n+\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n+\t\t\t\t\t// description is outdated\n+\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated.\");\n+\t\t\t\t} else {\n+\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwOTk2OQ=="}, "originalCommit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUzNjk5OA==", "bodyText": "However, something that could indeed slip through if there are say, 3 documented options with key X, but only 2 existing options with that key.", "url": "https://github.com/apache/flink/pull/10748#discussion_r365536998", "createdAt": "2020-01-11T19:08:27Z", "author": {"login": "zentol"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,105 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t\t\"host\",\n+\t\t\"port\"\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {\n+\t\t\t\t\t// we allow multiple instances of ConfigOptions with the same key if they are identical\n+\t\t\t\t\treturn option1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow duplicateHandler.apply(option1, option2);\n+\t\t\t\t}\n+\t\t\t}));\n+\t}\n+\n+\tprivate static void compareDocumentedAndExistingOptions(Map<String, List<DocumentedOption>> documentedOptions, Map<String, List<ExistingOption>> existingOptions) {\n \t\tfinal Collection<String> problems = new ArrayList<>(0);\n \n \t\t// first check that all existing options are properly documented\n-\t\texistingOptions.forEach((key, supposedState) -> {\n-\t\t\tDocumentedOption documentedState = documentedOptions.remove(key);\n-\n-\t\t\t// if nothing matches the docs for this option are up-to-date\n-\t\t\tif (documentedState == null) {\n-\t\t\t\t// option is not documented at all\n-\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t} else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {\n-\t\t\t\t// default is outdated\n-\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue + \" Actual: \" + documentedState.defaultValue);\n-\t\t\t} else if (!supposedState.description.equals(documentedState.description)) {\n-\t\t\t\t// description is outdated\n-\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated.\");\n+\t\texistingOptions.forEach((key, supposedStates) -> {\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\n+\t\t\tfor (ExistingOption supposedState : supposedStates) {\n+\t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n+\t\t\t\t\t// option is not documented at all\n+\t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n+\t\t\t\t\t// default is outdated\n+\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n+\t\t\t\t\t// description is outdated\n+\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated.\");\n+\t\t\t\t} else {\n+\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwOTk2OQ=="}, "originalCommit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ4NDEyNQ==", "bodyText": "Yes, this is what I meant.", "url": "https://github.com/apache/flink/pull/10748#discussion_r366484125", "createdAt": "2020-01-14T17:51:45Z", "author": {"login": "tillrohrmann"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,105 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t\t\"host\",\n+\t\t\"port\"\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {\n+\t\t\t\t\t// we allow multiple instances of ConfigOptions with the same key if they are identical\n+\t\t\t\t\treturn option1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow duplicateHandler.apply(option1, option2);\n+\t\t\t\t}\n+\t\t\t}));\n+\t}\n+\n+\tprivate static void compareDocumentedAndExistingOptions(Map<String, List<DocumentedOption>> documentedOptions, Map<String, List<ExistingOption>> existingOptions) {\n \t\tfinal Collection<String> problems = new ArrayList<>(0);\n \n \t\t// first check that all existing options are properly documented\n-\t\texistingOptions.forEach((key, supposedState) -> {\n-\t\t\tDocumentedOption documentedState = documentedOptions.remove(key);\n-\n-\t\t\t// if nothing matches the docs for this option are up-to-date\n-\t\t\tif (documentedState == null) {\n-\t\t\t\t// option is not documented at all\n-\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t} else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {\n-\t\t\t\t// default is outdated\n-\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue + \" Actual: \" + documentedState.defaultValue);\n-\t\t\t} else if (!supposedState.description.equals(documentedState.description)) {\n-\t\t\t\t// description is outdated\n-\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated.\");\n+\t\texistingOptions.forEach((key, supposedStates) -> {\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\n+\t\t\tfor (ExistingOption supposedState : supposedStates) {\n+\t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n+\t\t\t\t\t// option is not documented at all\n+\t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n+\t\t\t\t\t// default is outdated\n+\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n+\t\t\t\t\t// description is outdated\n+\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated.\");\n+\t\t\t\t} else {\n+\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwOTk2OQ=="}, "originalCommit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzkwODA4OnYy", "diffSide": "RIGHT", "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo0MTo0NFrOFe88XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo0MTo0NFrOFe88XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDA5Mg==", "bodyText": "I'm not sure whether I completely understand this logic here. Can't it happen that we have two options where one fulfills the default value and the other fulfills the description? In this case we would remove the second option and not report any problems even though both of them should cause a problem.", "url": "https://github.com/apache/flink/pull/10748#discussion_r368000092", "createdAt": "2020-01-17T15:41:44Z", "author": {"login": "tillrohrmann"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -139,22 +139,42 @@ private static void compareDocumentedAndExistingOptions(Map<String, List<Documen\n \n \t\t// first check that all existing options are properly documented\n \t\texistingOptions.forEach((key, supposedStates) -> {\n-\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.get(key);\n \n \t\t\tfor (ExistingOption supposedState : supposedStates) {\n \t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n \t\t\t\t\t// option is not documented at all\n \t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n-\t\t\t\t\t// default is outdated\n-\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n-\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n-\t\t\t\t\t// description is outdated\n-\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\t\" is outdated.\");\n \t\t\t\t} else {\n-\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t\tfinal Iterator<DocumentedOption> candidates = documentedState.iterator();\n+\n+\t\t\t\t\tboolean matchingDefaultFound = false;\n+\t\t\t\t\tboolean matchingDescriptionFound = false;\n+\t\t\t\t\twhile (candidates.hasNext()) {\n+\t\t\t\t\t\tDocumentedOption candidate = candidates.next();\n+\t\t\t\t\t\tif (supposedState.defaultValue.equals(candidate.defaultValue)) {\n+\t\t\t\t\t\t\tmatchingDefaultFound = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (supposedState.description.equals(candidate.description)) {\n+\t\t\t\t\t\t\tmatchingDescriptionFound = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (matchingDefaultFound && matchingDescriptionFound) {\n+\t\t\t\t\t\t\t// option is properly documented\n+\t\t\t\t\t\t\tcandidates.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5506fe0e1f2a24a3c5c71eeaf33077b8f4571358"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1269, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}