{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MDQyMzQy", "number": 10763, "title": "[FLINK-14200][table] Fix NPE for Temporal Table Function Join when left side is a query instead of a source", "bodyText": "What is the purpose of the change\nFix NPE when left input is a query (e.g. a filter/project/temporal join) in temporal table function join.\nBrief change log\n\nGet the RelOptSchema from the leaf RelNode which holds the non-null RelOptSchema\n\nVerifying this change\n\nAdd a plan test that left input is a filter query\nAdd a IT case that left input is a temporal join\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-01-03T16:18:09Z", "url": "https://github.com/apache/flink/pull/10763", "merged": true, "mergeCommit": {"oid": "1121949bd6018d5c44238dc5550364285751faf9"}, "closed": true, "closedAt": "2020-01-07T05:43:58Z", "author": {"login": "wuchong"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2wwR4gH2gAyMzU5MDQyMzQyOjk5YTBmNzQ0NTNkZGVlZGIzMmEzMmI5MmRhYTE5YjIyNDM2MjFlN2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb3sHqCgFqTMzODYzOTIyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "99a0f74453ddeedb32a32b92daa19b2243621e7f", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/99a0f74453ddeedb32a32b92daa19b2243621e7f", "committedDate": "2020-01-03T16:15:01Z", "message": "[FLINK-14200][table-planner] Fix NPE for Temporal Table Function Join when left side is a query instead of a source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19e2bf9244667af4490f1463bdf48ba40d02e5ed", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/19e2bf9244667af4490f1463bdf48ba40d02e5ed", "committedDate": "2020-01-03T16:15:11Z", "message": "[FLINK-14200][table-planner-blink] Fix NPE for Temporal Table Function Join when left side is a query instead of a source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da8137a5c135ee86f12bd4cbd33f6aea77c06a14", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/da8137a5c135ee86f12bd4cbd33f6aea77c06a14", "committedDate": "2020-01-04T02:59:04Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "committedDate": "2020-01-04T14:58:05Z", "message": "fix  test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NTIzNDQy", "url": "https://github.com/apache/flink/pull/10763#pullrequestreview-338523442", "createdAt": "2020-01-06T08:47:00Z", "commit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwODo0NzowMFrOFaYGuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwOTozMDoyNFrOFaY8cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwMjIzNQ==", "bodyText": "nit: this comment is a bit misleading don't you think? It depends on the subsequent query what will be the view used for.\nAnyway it does not provide any extra info therefore personally I'm always against adding redundant comments as they easily go out of sync.", "url": "https://github.com/apache/flink/pull/10763#discussion_r363202235", "createdAt": "2020-01-06T08:47:00Z", "author": {"login": "dawidwys"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -73,6 +73,21 @@ class TemporalJoinTest extends TableTestBase {\n     util.verifyPlan(sqlQuery)\n   }\n \n+  @Test\n+  def testJoinOnQueryLeft(): Unit = {\n+    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n+    // register a query as left side", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwOTY1MQ==", "bodyText": "How about fixing the generic type of TimestampExtractor instead?\n      .fromCollection(ordersData)\n      .assignTimestampsAndWatermarks(new TimestampExtractor[(Long, String, String, Timestamp)]())\n\n\nclass TimestampExtractor[T <: Product]\n  extends BoundedOutOfOrdernessTimestampExtractor[T]", "url": "https://github.com/apache/flink/pull/10763#discussion_r363209651", "createdAt": "2020-01-06T09:12:13Z", "author": {"login": "dawidwys"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price\n+        |FROM\n+        |  Orders AS o,\n+        |  LATERAL TABLE (Rates(o.rowtime)) AS r,\n+        |  LATERAL TABLE (Prices(o.rowtime)) AS p\n+        |WHERE r.currency = o.currency AND p.productId = o.productId\n+        |\"\"\".stripMargin\n+\n+    val ordersData = new mutable.MutableList[(Long, String, String, Timestamp)]\n+    ordersData.+=((2L, \"A1\", \"Euro\", new Timestamp(2L)))\n+    ordersData.+=((1L, \"A2\", \"US Dollar\", new Timestamp(3L)))\n+    ordersData.+=((50L, \"A4\", \"Yen\", new Timestamp(4L)))\n+    ordersData.+=((3L, \"A2\", \"Euro\", new Timestamp(5L)))\n+\n+    val ratesHistoryData = new mutable.MutableList[(String, Long, Timestamp)]\n+    ratesHistoryData.+=((\"US Dollar\", 102L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 114L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Yen\", 1L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 116L, new Timestamp(5L)))\n+    ratesHistoryData.+=((\"Euro\", 119L, new Timestamp(7L)))\n+\n+    val pricesHistoryData = new mutable.MutableList[(String, Double, Timestamp)]\n+    pricesHistoryData.+=((\"A2\", 10.2D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.4D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A4\", 1D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.6D, new Timestamp(5L)))\n+    pricesHistoryData.+=((\"A1\", 11.9D, new Timestamp(7L)))\n+\n+    val orders = env\n+      .fromCollection(ordersData)\n+      .asInstanceOf[DataStream[Product]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIxNDkyOA==", "bodyText": "If we are using a real world example, could we make it more useful?\nHow about:\nOrders\n  |- orderId: String\n  |- productId: String\n  |- amount: Long\n  |- timestamp: Timestamp\n\nRates\n  |- currency: String\n  |- rate: Double\n  |- timestamp: Timestamp\n\nPrices\n  |- productId: String\n  |- currency: String\n  |- price: Double\n  |- timestamp: Timestamp\n\nQuery:\nSELECT\n  o.orderId,\n  (o.amount * p.price * r.rate) as total_price\nFROM\n  Orders AS o,\n  LATERAL TABLE (Rates(o.rowtime)) AS r,\n  LATERAL TABLE (Prices(o.rowtime)) AS p\nWHERE\n  o.productId = p.productId AND \n  r.currency = p.currency", "url": "https://github.com/apache/flink/pull/10763#discussion_r363214928", "createdAt": "2020-01-06T09:27:25Z", "author": {"login": "dawidwys"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIxNTk4NQ==", "bodyText": "add a default branch:\ncase _ => throw new IllegalArgumentException(\"Expected the last element in a tuple to be of a Timestamp type.\")\n\nThis will make it easier to use this extractor in future tests.", "url": "https://github.com/apache/flink/pull/10763#discussion_r363215985", "createdAt": "2020-01-06T09:30:24Z", "author": {"login": "dawidwys"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price\n+        |FROM\n+        |  Orders AS o,\n+        |  LATERAL TABLE (Rates(o.rowtime)) AS r,\n+        |  LATERAL TABLE (Prices(o.rowtime)) AS p\n+        |WHERE r.currency = o.currency AND p.productId = o.productId\n+        |\"\"\".stripMargin\n+\n+    val ordersData = new mutable.MutableList[(Long, String, String, Timestamp)]\n+    ordersData.+=((2L, \"A1\", \"Euro\", new Timestamp(2L)))\n+    ordersData.+=((1L, \"A2\", \"US Dollar\", new Timestamp(3L)))\n+    ordersData.+=((50L, \"A4\", \"Yen\", new Timestamp(4L)))\n+    ordersData.+=((3L, \"A2\", \"Euro\", new Timestamp(5L)))\n+\n+    val ratesHistoryData = new mutable.MutableList[(String, Long, Timestamp)]\n+    ratesHistoryData.+=((\"US Dollar\", 102L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 114L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Yen\", 1L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 116L, new Timestamp(5L)))\n+    ratesHistoryData.+=((\"Euro\", 119L, new Timestamp(7L)))\n+\n+    val pricesHistoryData = new mutable.MutableList[(String, Double, Timestamp)]\n+    pricesHistoryData.+=((\"A2\", 10.2D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.4D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A4\", 1D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.6D, new Timestamp(5L)))\n+    pricesHistoryData.+=((\"A1\", 11.9D, new Timestamp(7L)))\n+\n+    val orders = env\n+      .fromCollection(ordersData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'amount, 'productId, 'currency, 'rowtime.rowtime)\n+    val ratesHistory = env\n+      .fromCollection(ratesHistoryData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'currency, 'rate, 'rowtime.rowtime)\n+    val pricesHistory = env\n+      .fromCollection(pricesHistoryData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'productId, 'price, 'rowtime.rowtime)\n+\n+    tEnv.createTemporaryView(\"Orders\", orders)\n+    tEnv.createTemporaryView(\"RatesHistory\", ratesHistory)\n+    tEnv.registerFunction(\n+      \"Rates\",\n+      ratesHistory.createTemporalTableFunction(\"rowtime\", \"currency\"))\n+    tEnv.registerFunction(\n+      \"Prices\",\n+      pricesHistory.createTemporalTableFunction(\"rowtime\", \"productId\"))\n+\n+    tEnv.createTemporaryView(\"TemporalJoinResult\", tEnv.sqlQuery(sqlQuery))\n+\n+    // Scan from registered table to test for interplay between\n+    // LogicalCorrelateToTemporalTableJoinRule and TableScanRule\n+    val result = tEnv.from(\"TemporalJoinResult\").toAppendStream[Row]\n+    val sink = new TestingAppendSink\n+    result.addSink(sink)\n+    env.execute()\n+\n+    val expected = List(\"1,102,10.2\", \"3,116,10.2\", \"2,114,11.4\", \"50,1,1.0\")\n+    assertEquals(expected.sorted, sink.getAppendResults.sorted)\n+  }\n }\n \n-class TimestampExtractor[T1, T2]\n-  extends BoundedOutOfOrdernessTimestampExtractor[(T1, T2, Timestamp)](Time.seconds(10))  {\n-  override def extractTimestamp(element: (T1, T2, Timestamp)): Long = {\n-    element._3.getTime\n+class TimestampExtractor\n+  extends BoundedOutOfOrdernessTimestampExtractor[Product](Time.seconds(10))  {\n+  override def extractTimestamp(element: Product): Long = element match {\n+    case (_, _, ts: Timestamp) => ts.getTime\n+    case (_, _, _, ts: Timestamp) => ts.getTime", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f65244f166d33141c1d722a8244e4de4e4c9f1c", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/6f65244f166d33141c1d722a8244e4de4e4c9f1c", "committedDate": "2020-01-06T10:34:31Z", "message": "address comments (blink planner)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4311bd9a01f16b10d03ce1744c7baebd3c2872e4", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/4311bd9a01f16b10d03ce1744c7baebd3c2872e4", "committedDate": "2020-01-06T10:34:43Z", "message": "address comments (old planner)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NjM5MjI3", "url": "https://github.com/apache/flink/pull/10763#pullrequestreview-338639227", "createdAt": "2020-01-06T13:24:57Z", "commit": {"oid": "4311bd9a01f16b10d03ce1744c7baebd3c2872e4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4925, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}