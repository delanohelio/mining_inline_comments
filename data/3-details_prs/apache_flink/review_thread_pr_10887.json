{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTY0OTM1", "number": 10887, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODoxNzoyOVrODZlvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODoxNzoyOVrODZlvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTU5MjY5OnYy", "diffSide": "RIGHT", "path": "flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODoxNzoyOVrOFgD8Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzowMzoxN1rOFgbTRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MzM0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\texecutionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(10, Duration.ofSeconds(10).toMillis()));\n          \n          \n            \n            \t\texecutionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(100, Duration.ofMillis(100).toMillis()));", "url": "https://github.com/apache/flink/pull/10887#discussion_r369163346", "createdAt": "2020-01-21T18:17:29Z", "author": {"login": "tillrohrmann"}, "path": "flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java", "diffHunk": "@@ -141,13 +144,23 @@ private DispatcherGateway getNextLeadingDispatcherGateway(TestingMiniCluster min\n \t\treturn miniCluster.getDispatcherGatewayFuture().get();\n \t}\n \n-\tprivate JobGraph createJobGraph(int parallelism) {\n+\tprivate JobGraph createJobGraph(int parallelism) throws IOException {\n \t\tBlockingOperator.isBlocking = true;\n \t\tfinal JobVertex vertex = new JobVertex(\"blocking operator\");\n \t\tvertex.setParallelism(parallelism);\n \t\tvertex.setInvokableClass(BlockingOperator.class);\n \n-\t\treturn new JobGraph(\"Blocking test job\", vertex);\n+\t\tJobGraph jobGraph = new JobGraph(\"Blocking test job\", vertex);\n+\n+\t\t// explicitly allow restarts; this is necessary since the shutdown may result in the job failing and hence being\n+\t\t// removed from ZooKeeper. What happens to running jobs if the Dispatcher shuts down in an orderly fashion\n+\t\t// is undefined behavior. By allowing restarts we prevent the job from reaching a globally terminal state,\n+\t\t// causing it to be recovered by the next Dispatcher.\n+\t\tExecutionConfig executionConfig = new ExecutionConfig();\n+\t\texecutionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(10, Duration.ofSeconds(10).toMillis()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f91b3855bca5e7e2d2d9abf196cca861e122312"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3MTQ1Mg==", "bodyText": "My idea here was to not have the job actually restart since it shouldn't be relevant to the test whether the job is running/restarting (just that it's not failed), and these state transitions add additional noise to the logs.", "url": "https://github.com/apache/flink/pull/10887#discussion_r369171452", "createdAt": "2020-01-21T18:33:29Z", "author": {"login": "zentol"}, "path": "flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java", "diffHunk": "@@ -141,13 +144,23 @@ private DispatcherGateway getNextLeadingDispatcherGateway(TestingMiniCluster min\n \t\treturn miniCluster.getDispatcherGatewayFuture().get();\n \t}\n \n-\tprivate JobGraph createJobGraph(int parallelism) {\n+\tprivate JobGraph createJobGraph(int parallelism) throws IOException {\n \t\tBlockingOperator.isBlocking = true;\n \t\tfinal JobVertex vertex = new JobVertex(\"blocking operator\");\n \t\tvertex.setParallelism(parallelism);\n \t\tvertex.setInvokableClass(BlockingOperator.class);\n \n-\t\treturn new JobGraph(\"Blocking test job\", vertex);\n+\t\tJobGraph jobGraph = new JobGraph(\"Blocking test job\", vertex);\n+\n+\t\t// explicitly allow restarts; this is necessary since the shutdown may result in the job failing and hence being\n+\t\t// removed from ZooKeeper. What happens to running jobs if the Dispatcher shuts down in an orderly fashion\n+\t\t// is undefined behavior. By allowing restarts we prevent the job from reaching a globally terminal state,\n+\t\t// causing it to be recovered by the next Dispatcher.\n+\t\tExecutionConfig executionConfig = new ExecutionConfig();\n+\t\texecutionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(10, Duration.ofSeconds(10).toMillis()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MzM0Ng=="}, "originalCommit": {"oid": "7f91b3855bca5e7e2d2d9abf196cca861e122312"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NjA1NQ==", "bodyText": "Good point. Then ignore my comment.", "url": "https://github.com/apache/flink/pull/10887#discussion_r369546055", "createdAt": "2020-01-22T13:03:17Z", "author": {"login": "tillrohrmann"}, "path": "flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java", "diffHunk": "@@ -141,13 +144,23 @@ private DispatcherGateway getNextLeadingDispatcherGateway(TestingMiniCluster min\n \t\treturn miniCluster.getDispatcherGatewayFuture().get();\n \t}\n \n-\tprivate JobGraph createJobGraph(int parallelism) {\n+\tprivate JobGraph createJobGraph(int parallelism) throws IOException {\n \t\tBlockingOperator.isBlocking = true;\n \t\tfinal JobVertex vertex = new JobVertex(\"blocking operator\");\n \t\tvertex.setParallelism(parallelism);\n \t\tvertex.setInvokableClass(BlockingOperator.class);\n \n-\t\treturn new JobGraph(\"Blocking test job\", vertex);\n+\t\tJobGraph jobGraph = new JobGraph(\"Blocking test job\", vertex);\n+\n+\t\t// explicitly allow restarts; this is necessary since the shutdown may result in the job failing and hence being\n+\t\t// removed from ZooKeeper. What happens to running jobs if the Dispatcher shuts down in an orderly fashion\n+\t\t// is undefined behavior. By allowing restarts we prevent the job from reaching a globally terminal state,\n+\t\t// causing it to be recovered by the next Dispatcher.\n+\t\tExecutionConfig executionConfig = new ExecutionConfig();\n+\t\texecutionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(10, Duration.ofSeconds(10).toMillis()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MzM0Ng=="}, "originalCommit": {"oid": "7f91b3855bca5e7e2d2d9abf196cca861e122312"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1237, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}