{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMTU2NTY0", "number": 14057, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMTo0Njo1NFrOFDb4jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTo0MTozNVrOFGQggg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTQ2ODkzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMTo0Njo1NFrOIDFT3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMTo0Njo1NFrOIDFT3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwMzY0NQ==", "bodyText": "optional nit: I would prefer to static import checkState for shorter code (we are using it frequently enough, that I think Preconditions.checkState is too verbose).", "url": "https://github.com/apache/flink/pull/14057#discussion_r540103645", "createdAt": "2020-12-10T11:46:54Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "diffHunk": "@@ -23,6 +23,7 @@\n import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.CheckpointableInput;\n+import org.apache.flink.util.Preconditions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e08db569433493d0dc192ce5a1bed064d464f6a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTUzMjEzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjowMTo1MlrOIDF37g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjowMTo1MlrOIDF37g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExMjg3OA==", "bodyText": "Commit message is a bit misleading/out dated (pendingBarrier -> lastSeenBarrier). (also in a some of the following commits)", "url": "https://github.com/apache/flink/pull/14057#discussion_r540112878", "createdAt": "2020-12-10T12:01:52Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java", "diffHunk": "@@ -88,16 +88,16 @@ protected void maybePersist(Buffer buffer) {\n \t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3bb1e044f3716d12abb0241589364889766fe82"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTU2MjgyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjowOTozMlrOIDGJzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDo1MDo0MFrOIGfZvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzQ1NA==", "bodyText": "Can you add a unit test that would show/explain the problem?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540117454", "createdAt": "2020-12-10T12:09:32Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -229,11 +229,8 @@ public void run() {\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n-\t\tif (buffer.getDataType().hasPriority()) {\n-\t\t\tchannelStatePersister.checkForBarrier(buffer);\n-\t\t} else {\n-\t\t\tchannelStatePersister.maybePersist(buffer);\n-\t\t}\n+\t\tchannelStatePersister.checkForBarrier(buffer);\n+\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3bb1e044f3716d12abb0241589364889766fe82"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3Njg2Mw==", "bodyText": "I've added LocalInputChannelTest.testNoDataPersistedAfterReceivingAlignedBarrier.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543676863", "createdAt": "2020-12-15T20:50:40Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -229,11 +229,8 @@ public void run() {\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n-\t\tif (buffer.getDataType().hasPriority()) {\n-\t\t\tchannelStatePersister.checkForBarrier(buffer);\n-\t\t} else {\n-\t\t\tchannelStatePersister.maybePersist(buffer);\n-\t\t}\n+\t\tchannelStatePersister.checkForBarrier(buffer);\n+\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzQ1NA=="}, "originalCommit": {"oid": "c3bb1e044f3716d12abb0241589364889766fe82"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTYwMDc3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoxODozM1rOIDGfTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDo1Mzo0M1rOIGfgow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyMjk1Nw==", "bodyText": "ditto about a unit test? (What is the scenario that is working differently and how is it is supposed to be working)", "url": "https://github.com/apache/flink/pull/14057#discussion_r540122957", "createdAt": "2020-12-10T12:18:33Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,17 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister.checkForBarrier(sequenceBuffer.buffer).ifPresent(id -> {\n+\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3bb1e044f3716d12abb0241589364889766fe82"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODYyNw==", "bodyText": "I didn't add a unit test as after the other fixes in master (#14052) this change is not strictly necessary\n(though I think it's still less error-prone to not update SQN unnecessarily).", "url": "https://github.com/apache/flink/pull/14057#discussion_r543678627", "createdAt": "2020-12-15T20:53:43Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,17 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister.checkForBarrier(sequenceBuffer.buffer).ifPresent(id -> {\n+\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyMjk1Nw=="}, "originalCommit": {"oid": "c3bb1e044f3716d12abb0241589364889766fe82"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTYxMzAzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoyMToyMFrOIDGmXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDo0Nzo0NFrOIGfTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNDc2NA==", "bodyText": "ditto unit test", "url": "https://github.com/apache/flink/pull/14057#discussion_r540124764", "createdAt": "2020-12-10T12:21:20Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "diffHunk": "@@ -120,6 +122,12 @@ public void obsoleteBarrierReceived(\n \t\tresumeConsumption(channelInfo);\n \t}\n \n+\tprotected void resetPendingCheckpoint(long cancelledId) {\n+\t\tfor (final CheckpointableInput input : inputs) {\n+\t\t\tinput.checkpointStopped(cancelledId);\n+\t\t}\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f066cdb9d50b0be0967d458581a855781b4e43ee"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NTE1Mw==", "bodyText": "I've added AlternatingControllerTest.testChannelResetOnNewBarrier.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543675153", "createdAt": "2020-12-15T20:47:44Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "diffHunk": "@@ -120,6 +122,12 @@ public void obsoleteBarrierReceived(\n \t\tresumeConsumption(channelInfo);\n \t}\n \n+\tprotected void resetPendingCheckpoint(long cancelledId) {\n+\t\tfor (final CheckpointableInput input : inputs) {\n+\t\t\tinput.checkpointStopped(cancelledId);\n+\t\t}\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNDc2NA=="}, "originalCommit": {"oid": "f066cdb9d50b0be0967d458581a855781b4e43ee"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjQzOTg0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToxMzo1M1rOIDOMWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo1MjowNFrOIGHG7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng==", "bodyText": "I'm not entirely convinced if this a better approach.\nFor me, using global checkpoint time (in other words recently added checkpoinStartDelay metric) seemed easier to understand for the user. If aligned checkpoint barrier is taking too much time to reach given tasks - we are timeouting it to unaligned checkpoint that overtakes in-flight data. This seemed easier to comprehend and easier to explain  compared to time outing alignment on some subtask?\nSecondly your proposed change will not work with single input tasks without active timeouts?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540249176", "createdAt": "2020-12-10T15:13:53Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -193,6 +202,11 @@ private CheckpointBarrierBehaviourController chooseController(CheckpointBarrier\n \n \tprivate boolean canTimeout(CheckpointBarrier barrier) {\n \t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() < (System.currentTimeMillis() - barrier.getTimestamp());\n+\t\t\tbarrier.getId() <= lastSeenBarrier &&\n+\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n+\t}\n+\n+\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n+\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "781e25d56e06bcf4668470a393c1caeb35944e33"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzODIzMg==", "bodyText": "easier to understand\n\nI agree that it might be true for some users, but not for all. During the previous discussion, and also the one before, the consensus was that it's not easier to understand. However, we can discuss it again.\n(also there are some more technical advantages of \"local\" timeouts)\n\nSecondly your proposed change will not work with single input tasks without active timeouts?\n\nWhy, could you explain?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540438232", "createdAt": "2020-12-10T19:28:21Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -193,6 +202,11 @@ private CheckpointBarrierBehaviourController chooseController(CheckpointBarrier\n \n \tprivate boolean canTimeout(CheckpointBarrier barrier) {\n \t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() < (System.currentTimeMillis() - barrier.getTimestamp());\n+\t\t\tbarrier.getId() <= lastSeenBarrier &&\n+\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n+\t}\n+\n+\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n+\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}, "originalCommit": {"oid": "781e25d56e06bcf4668470a393c1caeb35944e33"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NDIwOQ==", "bodyText": "Why, could you explain?\n\nOn a second thought, maybe it will partially, but not fully as well.  guess we still have the code, that we can timeout to UC on the last processed barrier? So in case of single channel:\n\nannouncement is processed (first announcement will never timeout in this version) it won't timeout\nbarrier will be processed, and only it can timeout\n\nSo a timeout on the first network exchange will work worse. That's a bit problematic, especially for simple jobs, with for example just a single exchange. Previous version would cut the checkpointing time by half, this version will do worse than that, in a way that's hard to quantify for me.\nThere is some extreme corner case when imagine there is a heavy back pressure, but all CB are processed at the same time. That means announcements in this version wouldn't cause timeout (it would in my older proposal), and this version will need to wait for some CB to be processed (which can take long time).\nActive timeout would alleviate this problem though.", "url": "https://github.com/apache/flink/pull/14057#discussion_r540854209", "createdAt": "2020-12-11T10:41:41Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -193,6 +202,11 @@ private CheckpointBarrierBehaviourController chooseController(CheckpointBarrier\n \n \tprivate boolean canTimeout(CheckpointBarrier barrier) {\n \t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() < (System.currentTimeMillis() - barrier.getTimestamp());\n+\t\t\tbarrier.getId() <= lastSeenBarrier &&\n+\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n+\t}\n+\n+\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n+\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}, "originalCommit": {"oid": "781e25d56e06bcf4668470a393c1caeb35944e33"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3ODgzMQ==", "bodyText": "With a single input, this is not an alignment issue but a (related) back-pressure issue. And I think this is the right way to solve it:\n\nActive timeout would alleviate this problem though.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543278831", "createdAt": "2020-12-15T11:52:04Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -193,6 +202,11 @@ private CheckpointBarrierBehaviourController chooseController(CheckpointBarrier\n \n \tprivate boolean canTimeout(CheckpointBarrier barrier) {\n \t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() < (System.currentTimeMillis() - barrier.getTimestamp());\n+\t\t\tbarrier.getId() <= lastSeenBarrier &&\n+\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n+\t}\n+\n+\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n+\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}, "originalCommit": {"oid": "781e25d56e06bcf4668470a393c1caeb35944e33"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjQ1MDg0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToxNTo1NlrOIDOS9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTo0ODowNlrOIHL_yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ==", "bodyText": "?\nWhy is it not enough to do this in preProcessFirstBarrierOrAnnouncement?\n(as in other places: a unit test would be helpful)", "url": "https://github.com/apache/flink/pull/14057#discussion_r540250869", "createdAt": "2020-12-10T15:15:56Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyODg3NQ==", "bodyText": "Consider a checkpoint with two barriers from two channels: UC and AC:\n\nProcess AC announcement. Set SingleCheckpointBarrierHandler.currentCheckpointId. Don't timeout.\nProcess UC barrier (no announcements). Because currentCheckpointId was set checkSubsumedCheckpoint does nothing, i.e. preProcessFirstBarrierOrAnnouncement not called and controller so activeController == AC\nFurther process (UC) barrier - now AC controller is processing UC barrier\n\n\n(as in other places: a unit test would be helpful)\n\nI agree, will add it.", "url": "https://github.com/apache/flink/pull/14057#discussion_r540428875", "createdAt": "2020-12-10T19:13:39Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODYxOQ==", "bodyText": "But doesn't it mean we should support time outing on every UC barrier? And it looks like we are doing that:\n\t@Override\n\tpublic Optional<CheckpointBarrier> barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == alignedController) {\n\t\t\tbarrier = barrier.asUnaligned();\n\t\t\tswitchToUnaligned(channelInfo, barrier);\n\t\t\tactiveController.barrierReceived(channelInfo, barrier);\n\t\t\treturn Optional.of(barrier);\n\t\t}", "url": "https://github.com/apache/flink/pull/14057#discussion_r540858619", "createdAt": "2020-12-11T10:49:08Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI4MDAwNA==", "bodyText": "But there is a preProcessFirstBarrier before the switch in barrierReceived.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543280004", "createdAt": "2020-12-15T11:54:00Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NTg1MQ==", "bodyText": "I've added AlternatingControllerTest.testSwitchToUnalignedByUpstream.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543675851", "createdAt": "2020-12-15T20:48:53Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwNzQ5OA==", "bodyText": "I still don't get this fix.\n\nBut there is a preProcessFirstBarrier before the switch in barrierReceived.\n\nYes, but my intention was that in that case, preProcessFirstBarrier would be called on the AlignedController. Next on the first barrier, we would switch to unaligned controller, which is doing this:\n\t\t// alignedController might has already processed some barriers, so \"migrate\"/forward those calls to unalignedController.\n\t\tunalignedController.preProcessFirstBarrier(channelInfo, barrier);\n\t\tfor (InputChannelInfo blockedChannel : blockedChannels) {\n\t\t\tunalignedController.barrierReceived(blockedChannel, barrier);\n\t\t}\n\nso preProcessFirstBarrier would be eventually called on the unaligned controller.", "url": "https://github.com/apache/flink/pull/14057#discussion_r544407498", "createdAt": "2020-12-16T15:48:06Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, "originalCommit": {"oid": "8317386822507ae18c796b34c886aca0e1c8b351"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjQ3OTIyOnYy", "diffSide": "LEFT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyMToxNVrOIDOkLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo1OToxM1rOIGHXdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA==", "bodyText": "Why have you removed this code? What was the problem?\nWas it subsumed by switchToUnaligned  call happening in the last barrierReceived call?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540255278", "createdAt": "2020-12-10T15:21:15Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -146,28 +146,7 @@ private void switchToUnaligned(\n \n \t@Override\n \tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28800009950ce82faf214cfd2540d92d858089d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDQ3NQ==", "bodyText": "Yes, with switchToUnaligned in barrierReceived it seems unnecessary.\nWith this code, UnalignedCheckpointITCase fails: some tests on checkState (line 164 above), some hanging up.\nBesides, why timeout alignment if it's the last barrier? This essentially means that alignment is done.", "url": "https://github.com/apache/flink/pull/14057#discussion_r540444475", "createdAt": "2020-12-10T19:38:21Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -146,28 +146,7 @@ private void switchToUnaligned(\n \n \t@Override\n \tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}, "originalCommit": {"oid": "a28800009950ce82faf214cfd2540d92d858089d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTc0Mg==", "bodyText": "Besides, why timeout alignment if it's the last barrier? This essentially means that alignment is done.\n\nThe alignment is done, but that's just input. As we do not have code to timeout outputs, it's better to timeout to UC even if the alignment was completed (although too late). Think especially about a case with just a single input channel.", "url": "https://github.com/apache/flink/pull/14057#discussion_r540859742", "createdAt": "2020-12-11T10:51:00Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -146,28 +146,7 @@ private void switchToUnaligned(\n \n \t@Override\n \tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}, "originalCommit": {"oid": "a28800009950ce82faf214cfd2540d92d858089d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI4MzA2MQ==", "bodyText": "Isn't it enough to just convert the barrier upon triggering checkpoint in subtask?\nThis is what I've done in [FLINK-19681][checkpointing] Use converted barrier after disabling alignment. It is needed anyways for correct handling in SubtaskCheckpointCoordinatorImpl.", "url": "https://github.com/apache/flink/pull/14057#discussion_r543283061", "createdAt": "2020-12-15T11:59:13Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -146,28 +146,7 @@ private void switchToUnaligned(\n \n \t@Override\n \tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}, "originalCommit": {"oid": "a28800009950ce82faf214cfd2540d92d858089d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjQ5NjEyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyNDoxN1rOIDOuLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo0MTo0NVrOIDaPdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NzgzOQ==", "bodyText": "part of a previous fixup?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540257839", "createdAt": "2020-12-10T15:24:17Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "diffHunk": "@@ -119,6 +119,6 @@ public boolean isCheckpoint() {\n \t}\n \n \tpublic CheckpointBarrier asUnaligned() {\n-\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().asTimedOut());\n+\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().toUnaligned());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d17f1c3fdc7bdf4632f58d7d52150f45f5cb11cd"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NjU4Mw==", "bodyText": "No, I think it belongs to the right commit. With CheckpointOptions hotfix/refactoring, this method converts it to unaligned, which can't be timed out.", "url": "https://github.com/apache/flink/pull/14057#discussion_r540446583", "createdAt": "2020-12-10T19:41:45Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "diffHunk": "@@ -119,6 +119,6 @@ public boolean isCheckpoint() {\n \t}\n \n \tpublic CheckpointBarrier asUnaligned() {\n-\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().asTimedOut());\n+\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().toUnaligned());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NzgzOQ=="}, "originalCommit": {"oid": "d17f1c3fdc7bdf4632f58d7d52150f45f5cb11cd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjUyNjk5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyOTo0NlrOIDPAmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDo0OTo0N1rOIGfX1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MjU1NA==", "bodyText": "nit: I don't understand this comment, can you rephrase/elaborate a bit?", "url": "https://github.com/apache/flink/pull/14057#discussion_r540262554", "createdAt": "2020-12-10T15:29:46Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -569,14 +569,23 @@ public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n \t\t\t\t\"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n \t\t\t\ttoPrioritize,\n \t\t\t\tnumPriorityElementsBeforeRemoval);\n+\t\t\t// set the priority flag (checked on poll)\n+\t\t\t// don't convert the barrier itself (barrier controller might not have been switched yet)\n+\t\t\tAbstractEvent e = EventSerializer.fromBuffer(toPrioritize.buffer, this.getClass().getClassLoader());\n+\t\t\ttoPrioritize.buffer.setReaderIndex(0);\n+\t\t\ttoPrioritize = new SequenceBuffer(EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n \t\t\tfirstPriorityEvent = addPriorityBuffer(toPrioritize); \t// note that only position of the element is changed\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// converting the event itself would require switching the controller sooner\n \t\t}\n \t\tif (firstPriorityEvent) {\n-\t\t\tnotifyPriorityEvent(sequenceNumber);\n+\t\t\tnotifyPriorityEventForce(); // use force here because the barrier SQN might be seen by gate during the announcement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64f5b48580f748cc15bc7ee65db45dd937b4821a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NjM3NQ==", "bodyText": "Rephrased as:\n// forcibly notify about the priority event\n// instead of passing barrier SQN to be checked\n// because this SQN might have be seen by the input gate during the announcement", "url": "https://github.com/apache/flink/pull/14057#discussion_r543676375", "createdAt": "2020-12-15T20:49:47Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -569,14 +569,23 @@ public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n \t\t\t\t\"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n \t\t\t\ttoPrioritize,\n \t\t\t\tnumPriorityElementsBeforeRemoval);\n+\t\t\t// set the priority flag (checked on poll)\n+\t\t\t// don't convert the barrier itself (barrier controller might not have been switched yet)\n+\t\t\tAbstractEvent e = EventSerializer.fromBuffer(toPrioritize.buffer, this.getClass().getClassLoader());\n+\t\t\ttoPrioritize.buffer.setReaderIndex(0);\n+\t\t\ttoPrioritize = new SequenceBuffer(EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n \t\t\tfirstPriorityEvent = addPriorityBuffer(toPrioritize); \t// note that only position of the element is changed\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// converting the event itself would require switching the controller sooner\n \t\t}\n \t\tif (firstPriorityEvent) {\n-\t\t\tnotifyPriorityEvent(sequenceNumber);\n+\t\t\tnotifyPriorityEventForce(); // use force here because the barrier SQN might be seen by gate during the announcement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MjU1NA=="}, "originalCommit": {"oid": "64f5b48580f748cc15bc7ee65db45dd937b4821a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMDg5ODE2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNToxMTozM1rOIHKJGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyNDozMlrOIHn7ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM3NzExNA==", "bodyText": "And what about test coverage for  those changes?\nSide question, shouldn't those two fixes be separate commits?", "url": "https://github.com/apache/flink/pull/14057#discussion_r544377114", "createdAt": "2020-12-16T15:11:33Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,20 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister\n+\t\t\t\t\t.checkForBarrier(sequenceBuffer.buffer)\n+\t\t\t\t\t.filter(id -> id > lastBarrierId)\n+\t\t\t\t\t.ifPresent(id -> {\n+\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc2357282481837865c7c16a8d46e08a35a0b50"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTEyNQ==", "bodyText": "Side question, shouldn't those two fixes be separate commits?\n\nThey were in the beginning, but it seemed to me just way too many commits :) So I tried to group some related changes. I can extract it if you prefer.\n\nAnd what about test coverage for those changes?\n\nAs noted above\n\nI didn't add a unit test as after the other fixes in master (#14052) this change is not strictly necessary\n(though I think it's still less error-prone to not update SQN unnecessarily).", "url": "https://github.com/apache/flink/pull/14057#discussion_r544865125", "createdAt": "2020-12-17T07:24:32Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,20 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister\n+\t\t\t\t\t.checkForBarrier(sequenceBuffer.buffer)\n+\t\t\t\t\t.filter(id -> id > lastBarrierId)\n+\t\t\t\t\t.ifPresent(id -> {\n+\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM3NzExNA=="}, "originalCommit": {"oid": "1bc2357282481837865c7c16a8d46e08a35a0b50"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTAyMTg3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTozNDoyMVrOIHLSTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzozMDo1NlrOIHoGxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NTg1NA==", "bodyText": "Otherwise, channels may capture in-flight buffers from an older checkpoint\n\nIs this test actually checking for that? I do not see any buffer that would belong to an older checkpoint?\n(I think I still do not understand this fix)", "url": "https://github.com/apache/flink/pull/14057#discussion_r544395854", "createdAt": "2020-12-16T15:34:21Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -68,6 +68,22 @@\n  */\n public class AlternatingControllerTest {\n \n+\t/**\n+\t * Upon subsuming (or canceling) a checkpoint, channels should be notified regardless of whether UC controller is\n+\t * currently being used or not. Otherwise, channels may capture in-flight buffers from an older checkpoint.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "007d12dad11d4b24f24bebf6388f273a54b7c1f4"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2ODAzOQ==", "bodyText": "Sorry, my bad, I didn't update the comment after updating the test.\nIt checks whether the buffer (on the other channel) was captured or not. I'll update the comment.", "url": "https://github.com/apache/flink/pull/14057#discussion_r544868039", "createdAt": "2020-12-17T07:30:56Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -68,6 +68,22 @@\n  */\n public class AlternatingControllerTest {\n \n+\t/**\n+\t * Upon subsuming (or canceling) a checkpoint, channels should be notified regardless of whether UC controller is\n+\t * currently being used or not. Otherwise, channels may capture in-flight buffers from an older checkpoint.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NTg1NA=="}, "originalCommit": {"oid": "007d12dad11d4b24f24bebf6388f273a54b7c1f4"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTA1OTM4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTo0MTowMVrOIHLoJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTo0MTowMVrOIHLoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTQ0NA==", "bodyText": "* If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n\t * then it should be processed by the UC controller.\n\n->\n\t * If a checkpoint announcement was processed from one channel and then UC-barrier arrives \n\t * on another channel, this UC barrier should be processed by the UC controller.\n\n?", "url": "https://github.com/apache/flink/pull/14057#discussion_r544401444", "createdAt": "2020-12-16T15:41:01Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -84,6 +84,24 @@ public void testChannelResetOnNewBarrier() throws Exception {\n \t\tassertFalse(stateWriter.getAddedInput().isEmpty());\n \t}\n \n+\t/**\n+\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n+\t * then it should be processed by the UC controller.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf08a45c31dacf497440b2cc889ccb7bef95cce"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTA2MjQyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTo0MTozNVrOIHLp-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzo0NzozMVrOIHon6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTkxNQ==", "bodyText": "Aren't we missing some assertion?", "url": "https://github.com/apache/flink/pull/14057#discussion_r544401915", "createdAt": "2020-12-16T15:41:35Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -84,6 +84,24 @@ public void testChannelResetOnNewBarrier() throws Exception {\n \t\tassertFalse(stateWriter.getAddedInput().isEmpty());\n \t}\n \n+\t/**\n+\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n+\t * then it should be processed by the UC controller.\n+\t */\n+\t@Test\n+\tpublic void testSwitchToUnalignedByUpstream() throws Exception {\n+\t\tSingleInputGate inputGate = new SingleInputGateBuilder().setNumberOfChannels(2).build();\n+\t\tinputGate.setInputChannels(new TestInputChannel(inputGate, 0), new TestInputChannel(inputGate, 1));\n+\t\tValidatingCheckpointHandler target = new ValidatingCheckpointHandler();\n+\t\tSingleCheckpointBarrierHandler barrierHandler = barrierHandler(inputGate, target);\n+\t\tCheckpointedInputGate gate = buildGate(target, 2);\n+\n+\t\tCheckpointBarrier aligned = new CheckpointBarrier(1, System.currentTimeMillis(), alignedWithTimeout(getDefault(), Integer.MAX_VALUE));\n+\n+\t\tsend(toBuffer(new EventAnnouncement(aligned, 0), true), 0, gate); // process announcement but not the barrier\n+\t\tsend(toBuffer(aligned.asUnaligned(), true), 1, gate); // pretend it came from upstream before the first (AC) barrier was picked up\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf08a45c31dacf497440b2cc889ccb7bef95cce"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NjUyMg==", "bodyText": "The expectation is that it just won't fail (without the fix, it will).", "url": "https://github.com/apache/flink/pull/14057#discussion_r544876522", "createdAt": "2020-12-17T07:47:31Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -84,6 +84,24 @@ public void testChannelResetOnNewBarrier() throws Exception {\n \t\tassertFalse(stateWriter.getAddedInput().isEmpty());\n \t}\n \n+\t/**\n+\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n+\t * then it should be processed by the UC controller.\n+\t */\n+\t@Test\n+\tpublic void testSwitchToUnalignedByUpstream() throws Exception {\n+\t\tSingleInputGate inputGate = new SingleInputGateBuilder().setNumberOfChannels(2).build();\n+\t\tinputGate.setInputChannels(new TestInputChannel(inputGate, 0), new TestInputChannel(inputGate, 1));\n+\t\tValidatingCheckpointHandler target = new ValidatingCheckpointHandler();\n+\t\tSingleCheckpointBarrierHandler barrierHandler = barrierHandler(inputGate, target);\n+\t\tCheckpointedInputGate gate = buildGate(target, 2);\n+\n+\t\tCheckpointBarrier aligned = new CheckpointBarrier(1, System.currentTimeMillis(), alignedWithTimeout(getDefault(), Integer.MAX_VALUE));\n+\n+\t\tsend(toBuffer(new EventAnnouncement(aligned, 0), true), 0, gate); // process announcement but not the barrier\n+\t\tsend(toBuffer(aligned.asUnaligned(), true), 1, gate); // pretend it came from upstream before the first (AC) barrier was picked up\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTkxNQ=="}, "originalCommit": {"oid": "8bf08a45c31dacf497440b2cc889ccb7bef95cce"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4787, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}