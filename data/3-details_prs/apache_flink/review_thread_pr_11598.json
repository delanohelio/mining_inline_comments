{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2ODg5NjY2", "number": 11598, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNDoxMDoyNlrODtydgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMzoxMDoyNlrODvYVzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzM5MjY2OnYy", "diffSide": "RIGHT", "path": "flink-python/pyflink/table/tests/test_pandas_udf.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNDoxMDoyNlrOF_apbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNDoxMDoyNlrOF_apbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0MTE5Nw==", "bodyText": "Test nested array?", "url": "https://github.com/apache/flink/pull/11598#discussion_r402041197", "createdAt": "2020-04-02T04:10:26Z", "author": {"login": "hequn8128"}, "path": "flink-python/pyflink/table/tests/test_pandas_udf.py", "diffHunk": "@@ -207,20 +213,38 @@ def timestamp_func(timestamp_param):\n             udf(timestamp_func, [DataTypes.TIMESTAMP(3)], DataTypes.TIMESTAMP(3),\n                 udf_type=\"pandas\"))\n \n+        self.t_env.register_function(\n+            \"array_str_func\",\n+            udf(array_func, [DataTypes.ARRAY(DataTypes.STRING())],\n+                DataTypes.ARRAY(DataTypes.STRING()), udf_type=\"pandas\"))\n+\n+        self.t_env.register_function(\n+            \"array_timestamp_func\",\n+            udf(array_func, [DataTypes.ARRAY(DataTypes.TIMESTAMP(3))],\n+                DataTypes.ARRAY(DataTypes.TIMESTAMP(3)), udf_type=\"pandas\"))\n+\n+        self.t_env.register_function(\n+            \"array_int_func\",\n+            udf(array_func, [DataTypes.ARRAY(DataTypes.INT())],\n+                DataTypes.ARRAY(DataTypes.INT()), udf_type=\"pandas\"))\n+\n         table_sink = source_sink_utils.TestAppendSink(\n-            ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p'],\n+            ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n+             'r', 's'],\n             [DataTypes.TINYINT(), DataTypes.SMALLINT(), DataTypes.INT(), DataTypes.BIGINT(),\n              DataTypes.BOOLEAN(), DataTypes.BOOLEAN(), DataTypes.FLOAT(), DataTypes.DOUBLE(),\n              DataTypes.STRING(), DataTypes.STRING(), DataTypes.BYTES(), DataTypes.DECIMAL(38, 18),\n-             DataTypes.DECIMAL(38, 18), DataTypes.DATE(), DataTypes.TIME(), DataTypes.TIMESTAMP(3)])\n+             DataTypes.DECIMAL(38, 18), DataTypes.DATE(), DataTypes.TIME(), DataTypes.TIMESTAMP(3),\n+             DataTypes.ARRAY(DataTypes.STRING()), DataTypes.ARRAY(DataTypes.TIMESTAMP(3)),\n+             DataTypes.ARRAY(DataTypes.INT())])\n         self.t_env.register_table_sink(\"Results\", table_sink)\n \n         t = self.t_env.from_elements(\n             [(1, 32767, -2147483648, 1, True, False, 1.0, 1.0, 'hello', '\u4e2d\u6587',\n               bytearray(b'flink'), decimal.Decimal('1000000000000000000.05'),\n               decimal.Decimal('1000000000000000000.05999999999999999899999999999'),\n               datetime.date(2014, 9, 13), datetime.time(hour=1, minute=0, second=1),\n-              timestamp_value)],\n+              timestamp_value, ['hello', '\u4e2d\u6587', None], [timestamp_value], [1, 2])],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81b0e98dc23cf9370cdfdd20b39dd8cfdab3f84"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzQxNTAwOnYy", "diffSide": "RIGHT", "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/writers/BaseRowIntWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNDoyNjoyMFrOF_a2SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNjowMzo1MFrOF_cZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0NDQ4OA==", "bodyText": "If we going to support generic type that extends TypeGetterSetters, the class name BaseRowIntWriter may not be appropriate now. It may not be a BaseRow but can also be a BaseArray.\nSame for other BaseRowXXXWriter classes.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402044488", "createdAt": "2020-04-02T04:26:20Z", "author": {"login": "hequn8128"}, "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/writers/BaseRowIntWriter.java", "diffHunk": "@@ -19,22 +19,22 @@\n package org.apache.flink.table.runtime.arrow.writers;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.table.dataformat.BaseRow;\n+import org.apache.flink.table.dataformat.TypeGetterSetters;\n \n import org.apache.arrow.vector.IntVector;\n \n /**\n  * {@link ArrowFieldWriter} for Int.\n  */\n @Internal\n-public final class BaseRowIntWriter extends ArrowFieldWriter<BaseRow> {\n+public final class BaseRowIntWriter<T extends TypeGetterSetters> extends ArrowFieldWriter<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81b0e98dc23cf9370cdfdd20b39dd8cfdab3f84"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA2OTg3Nw==", "bodyText": "Make sense to me. Have renamed the original IntWriter to RowIntWriter and BaseRowIntWriter to IntWriter. Also updated the other classes.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402069877", "createdAt": "2020-04-02T06:03:50Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/writers/BaseRowIntWriter.java", "diffHunk": "@@ -19,22 +19,22 @@\n package org.apache.flink.table.runtime.arrow.writers;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.table.dataformat.BaseRow;\n+import org.apache.flink.table.dataformat.TypeGetterSetters;\n \n import org.apache.arrow.vector.IntVector;\n \n /**\n  * {@link ArrowFieldWriter} for Int.\n  */\n @Internal\n-public final class BaseRowIntWriter extends ArrowFieldWriter<BaseRow> {\n+public final class BaseRowIntWriter<T extends TypeGetterSetters> extends ArrowFieldWriter<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0NDQ4OA=="}, "originalCommit": {"oid": "d81b0e98dc23cf9370cdfdd20b39dd8cfdab3f84"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzc1NjY1OnYy", "diffSide": "RIGHT", "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/ArrowUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzowODoxMlrOF_d9Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0NDoxMVrOF_hLsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NTQxNQ==", "bodyText": "The return type now may not be a BaseRow. Maybe also add a test in BaseRowArrowReaderWriterTest to cover this case\uff1f", "url": "https://github.com/apache/flink/pull/11598#discussion_r402095415", "createdAt": "2020-04-02T07:08:12Z", "author": {"login": "hequn8128"}, "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/ArrowUtils.java", "diffHunk": "@@ -223,39 +239,43 @@ private static Field toArrowField(RowType.RowField rowField) {\n \n \tprivate static ArrowFieldWriter<BaseRow> createBaseRowArrowFieldWriter(FieldVector vector, LogicalType fieldType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18822435d028d86859d2b2becbb4e63ae2843f1c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0ODI3Mw==", "bodyText": "Good catch! Updated the result type. However, have not added a new test as this is already covered in the BaseRowArrowReaderWriterTest.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402148273", "createdAt": "2020-04-02T08:44:11Z", "author": {"login": "dianfu"}, "path": "flink-python/src/main/java/org/apache/flink/table/runtime/arrow/ArrowUtils.java", "diffHunk": "@@ -223,39 +239,43 @@ private static Field toArrowField(RowType.RowField rowField) {\n \n \tprivate static ArrowFieldWriter<BaseRow> createBaseRowArrowFieldWriter(FieldVector vector, LogicalType fieldType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NTQxNQ=="}, "originalCommit": {"oid": "18822435d028d86859d2b2becbb4e63ae2843f1c"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzg1MDUwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozNTozNlrOGAFqpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozNTozNlrOGAFqpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NjAyMg==", "bodyText": "Can we move this method to serializer or somewhere?\nSo we don't need this elementType field.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402746022", "createdAt": "2020-04-03T05:35:36Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;\n+\t}\n+\n+\t@Override\n+\tpublic int numElements() {\n+\t\treturn length;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isNullAt(int pos) {\n+\t\treturn data.isNullAt(offset + pos);\n+\t}\n+\n+\t@Override\n+\tpublic void setNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean getBoolean(int ordinal) {\n+\t\treturn ((BooleanColumnVector) data).getBoolean(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic byte getByte(int ordinal) {\n+\t\treturn ((ByteColumnVector) data).getByte(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic short getShort(int ordinal) {\n+\t\treturn ((ShortColumnVector) data).getShort(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic int getInt(int ordinal) {\n+\t\treturn ((IntColumnVector) data).getInt(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic long getLong(int ordinal) {\n+\t\treturn ((LongColumnVector) data).getLong(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic float getFloat(int ordinal) {\n+\t\treturn ((FloatColumnVector) data).getFloat(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic double getDouble(int ordinal) {\n+\t\treturn ((DoubleColumnVector) data).getDouble(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BinaryString getString(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\treturn BinaryString.fromBytes(byteArray.data, byteArray.offset, byteArray.len);\n+\t}\n+\n+\t@Override\n+\tpublic Decimal getDecimal(int ordinal, int precision, int scale) {\n+\t\treturn ((DecimalColumnVector) data).getDecimal(offset + ordinal, precision, scale);\n+\t}\n+\n+\t@Override\n+\tpublic SqlTimestamp getTimestamp(int ordinal, int precision) {\n+\t\treturn ((TimestampColumnVector) data).getTimestamp(offset + ordinal, precision);\n+\t}\n+\n+\t@Override\n+\tpublic <T> BinaryGeneric<T> getGeneric(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"GenericType is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getBinary(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\tif (byteArray.len == byteArray.data.length) {\n+\t\t\treturn byteArray.data;\n+\t\t} else {\n+\t\t\tbyte[] ret = new byte[byteArray.len];\n+\t\t\tSystem.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic BaseArray getArray(int ordinal) {\n+\t\treturn ((ArrayColumnVector) data).getArray(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BaseMap getMap(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"Map is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic BaseRow getRow(int ordinal, int numFields) {\n+\t\tthrow new UnsupportedOperationException(\"Row is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic void setBoolean(int ordinal, boolean value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setByte(int ordinal, byte value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setShort(int ordinal, short value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setInt(int ordinal, int value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setLong(int ordinal, long value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setFloat(int ordinal, float value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setDouble(int ordinal, double value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setDecimal(int i, Decimal value, int precision) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setTimestamp(int ordinal, SqlTimestamp value, int precision) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNotNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullLong(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullInt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullBoolean(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullByte(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullShort(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullFloat(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullDouble(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean[] toBooleanArray() {\n+\t\tboolean[] res = new boolean[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getBoolean(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic byte[] toByteArray() {\n+\t\tbyte[] res = new byte[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getByte(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic short[] toShortArray() {\n+\t\tshort[] res = new short[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getShort(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic int[] toIntArray() {\n+\t\tint[] res = new int[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getInt(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic long[] toLongArray() {\n+\t\tlong[] res = new long[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getLong(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic float[] toFloatArray() {\n+\t\tfloat[] res = new float[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getFloat(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic double[] toDoubleArray() {\n+\t\tdouble[] res = new double[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getDouble(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\tpublic BaseArray copy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzg1MTYzOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozNjozMFrOGAFrVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNjozODoxOVrOGAG1bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NjE5OA==", "bodyText": "These annoyed \"set\" will be removed after FLIP-95.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402746198", "createdAt": "2020-04-03T05:36:30Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;\n+\t}\n+\n+\t@Override\n+\tpublic int numElements() {\n+\t\treturn length;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isNullAt(int pos) {\n+\t\treturn data.isNullAt(offset + pos);\n+\t}\n+\n+\t@Override\n+\tpublic void setNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean getBoolean(int ordinal) {\n+\t\treturn ((BooleanColumnVector) data).getBoolean(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic byte getByte(int ordinal) {\n+\t\treturn ((ByteColumnVector) data).getByte(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic short getShort(int ordinal) {\n+\t\treturn ((ShortColumnVector) data).getShort(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic int getInt(int ordinal) {\n+\t\treturn ((IntColumnVector) data).getInt(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic long getLong(int ordinal) {\n+\t\treturn ((LongColumnVector) data).getLong(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic float getFloat(int ordinal) {\n+\t\treturn ((FloatColumnVector) data).getFloat(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic double getDouble(int ordinal) {\n+\t\treturn ((DoubleColumnVector) data).getDouble(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BinaryString getString(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\treturn BinaryString.fromBytes(byteArray.data, byteArray.offset, byteArray.len);\n+\t}\n+\n+\t@Override\n+\tpublic Decimal getDecimal(int ordinal, int precision, int scale) {\n+\t\treturn ((DecimalColumnVector) data).getDecimal(offset + ordinal, precision, scale);\n+\t}\n+\n+\t@Override\n+\tpublic SqlTimestamp getTimestamp(int ordinal, int precision) {\n+\t\treturn ((TimestampColumnVector) data).getTimestamp(offset + ordinal, precision);\n+\t}\n+\n+\t@Override\n+\tpublic <T> BinaryGeneric<T> getGeneric(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"GenericType is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getBinary(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\tif (byteArray.len == byteArray.data.length) {\n+\t\t\treturn byteArray.data;\n+\t\t} else {\n+\t\t\tbyte[] ret = new byte[byteArray.len];\n+\t\t\tSystem.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic BaseArray getArray(int ordinal) {\n+\t\treturn ((ArrayColumnVector) data).getArray(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BaseMap getMap(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"Map is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic BaseRow getRow(int ordinal, int numFields) {\n+\t\tthrow new UnsupportedOperationException(\"Row is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic void setBoolean(int ordinal, boolean value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NTE2Nw==", "bodyText": "Thanks for letting me know. As this is still needed for now and so just keep it in this PR and we can remove it during FLIP-95.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402765167", "createdAt": "2020-04-03T06:38:19Z", "author": {"login": "dianfu"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;\n+\t}\n+\n+\t@Override\n+\tpublic int numElements() {\n+\t\treturn length;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isNullAt(int pos) {\n+\t\treturn data.isNullAt(offset + pos);\n+\t}\n+\n+\t@Override\n+\tpublic void setNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean getBoolean(int ordinal) {\n+\t\treturn ((BooleanColumnVector) data).getBoolean(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic byte getByte(int ordinal) {\n+\t\treturn ((ByteColumnVector) data).getByte(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic short getShort(int ordinal) {\n+\t\treturn ((ShortColumnVector) data).getShort(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic int getInt(int ordinal) {\n+\t\treturn ((IntColumnVector) data).getInt(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic long getLong(int ordinal) {\n+\t\treturn ((LongColumnVector) data).getLong(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic float getFloat(int ordinal) {\n+\t\treturn ((FloatColumnVector) data).getFloat(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic double getDouble(int ordinal) {\n+\t\treturn ((DoubleColumnVector) data).getDouble(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BinaryString getString(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\treturn BinaryString.fromBytes(byteArray.data, byteArray.offset, byteArray.len);\n+\t}\n+\n+\t@Override\n+\tpublic Decimal getDecimal(int ordinal, int precision, int scale) {\n+\t\treturn ((DecimalColumnVector) data).getDecimal(offset + ordinal, precision, scale);\n+\t}\n+\n+\t@Override\n+\tpublic SqlTimestamp getTimestamp(int ordinal, int precision) {\n+\t\treturn ((TimestampColumnVector) data).getTimestamp(offset + ordinal, precision);\n+\t}\n+\n+\t@Override\n+\tpublic <T> BinaryGeneric<T> getGeneric(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"GenericType is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getBinary(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\tif (byteArray.len == byteArray.data.length) {\n+\t\t\treturn byteArray.data;\n+\t\t} else {\n+\t\t\tbyte[] ret = new byte[byteArray.len];\n+\t\t\tSystem.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic BaseArray getArray(int ordinal) {\n+\t\treturn ((ArrayColumnVector) data).getArray(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BaseMap getMap(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"Map is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic BaseRow getRow(int ordinal, int numFields) {\n+\t\tthrow new UnsupportedOperationException(\"Row is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic void setBoolean(int ordinal, boolean value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NjE5OA=="}, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzg1NTg3OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozODo1M1rOGAFt6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozODo1M1rOGAFt6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Njg1Ng==", "bodyText": "Can we use Arrays.copyOfRange?", "url": "https://github.com/apache/flink/pull/11598#discussion_r402746856", "createdAt": "2020-04-03T05:38:53Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;\n+\t}\n+\n+\t@Override\n+\tpublic int numElements() {\n+\t\treturn length;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isNullAt(int pos) {\n+\t\treturn data.isNullAt(offset + pos);\n+\t}\n+\n+\t@Override\n+\tpublic void setNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean getBoolean(int ordinal) {\n+\t\treturn ((BooleanColumnVector) data).getBoolean(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic byte getByte(int ordinal) {\n+\t\treturn ((ByteColumnVector) data).getByte(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic short getShort(int ordinal) {\n+\t\treturn ((ShortColumnVector) data).getShort(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic int getInt(int ordinal) {\n+\t\treturn ((IntColumnVector) data).getInt(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic long getLong(int ordinal) {\n+\t\treturn ((LongColumnVector) data).getLong(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic float getFloat(int ordinal) {\n+\t\treturn ((FloatColumnVector) data).getFloat(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic double getDouble(int ordinal) {\n+\t\treturn ((DoubleColumnVector) data).getDouble(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BinaryString getString(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\treturn BinaryString.fromBytes(byteArray.data, byteArray.offset, byteArray.len);\n+\t}\n+\n+\t@Override\n+\tpublic Decimal getDecimal(int ordinal, int precision, int scale) {\n+\t\treturn ((DecimalColumnVector) data).getDecimal(offset + ordinal, precision, scale);\n+\t}\n+\n+\t@Override\n+\tpublic SqlTimestamp getTimestamp(int ordinal, int precision) {\n+\t\treturn ((TimestampColumnVector) data).getTimestamp(offset + ordinal, precision);\n+\t}\n+\n+\t@Override\n+\tpublic <T> BinaryGeneric<T> getGeneric(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"GenericType is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getBinary(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\tif (byteArray.len == byteArray.data.length) {\n+\t\t\treturn byteArray.data;\n+\t\t} else {\n+\t\t\tbyte[] ret = new byte[byteArray.len];\n+\t\t\tSystem.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzg1Njg1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozOToyOFrOGAFukA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNTozOToyOFrOGAFukA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NzAyNA==", "bodyText": "length -> numElements?", "url": "https://github.com/apache/flink/pull/11598#discussion_r402747024", "createdAt": "2020-04-03T05:39:28Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzk0NTkyOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNjoyMzozNFrOGAGh4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNjoyMzozNFrOGAGh4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2MDE2MA==", "bodyText": "I can not get this. What we want is copy instead of conversion between external and internal.", "url": "https://github.com/apache/flink/pull/11598#discussion_r402760160", "createdAt": "2020-04-03T06:23:34Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/ColumnarArray.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.dataformat;\n+\n+import org.apache.flink.table.dataformat.vector.ArrayColumnVector;\n+import org.apache.flink.table.dataformat.vector.BooleanColumnVector;\n+import org.apache.flink.table.dataformat.vector.ByteColumnVector;\n+import org.apache.flink.table.dataformat.vector.BytesColumnVector;\n+import org.apache.flink.table.dataformat.vector.ColumnVector;\n+import org.apache.flink.table.dataformat.vector.DecimalColumnVector;\n+import org.apache.flink.table.dataformat.vector.DoubleColumnVector;\n+import org.apache.flink.table.dataformat.vector.FloatColumnVector;\n+import org.apache.flink.table.dataformat.vector.IntColumnVector;\n+import org.apache.flink.table.dataformat.vector.LongColumnVector;\n+import org.apache.flink.table.dataformat.vector.ShortColumnVector;\n+import org.apache.flink.table.dataformat.vector.TimestampColumnVector;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.DateType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.FloatType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.SmallIntType;\n+import org.apache.flink.table.types.logical.TimeType;\n+import org.apache.flink.table.types.logical.TinyIntType;\n+\n+/**\n+ * Columnar array to support access to vector column data.\n+ */\n+public final class ColumnarArray implements BaseArray {\n+\n+\tprivate final DataType elementType;\n+\tprivate final ColumnVector data;\n+\tprivate final int offset;\n+\tprivate final int length;\n+\n+\tpublic ColumnarArray(DataType elementType, ColumnVector data, int offset, int length) {\n+\t\tthis.elementType = elementType;\n+\t\tthis.data = data;\n+\t\tthis.offset = offset;\n+\t\tthis.length = length;\n+\t}\n+\n+\t@Override\n+\tpublic int numElements() {\n+\t\treturn length;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isNullAt(int pos) {\n+\t\treturn data.isNullAt(offset + pos);\n+\t}\n+\n+\t@Override\n+\tpublic void setNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean getBoolean(int ordinal) {\n+\t\treturn ((BooleanColumnVector) data).getBoolean(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic byte getByte(int ordinal) {\n+\t\treturn ((ByteColumnVector) data).getByte(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic short getShort(int ordinal) {\n+\t\treturn ((ShortColumnVector) data).getShort(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic int getInt(int ordinal) {\n+\t\treturn ((IntColumnVector) data).getInt(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic long getLong(int ordinal) {\n+\t\treturn ((LongColumnVector) data).getLong(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic float getFloat(int ordinal) {\n+\t\treturn ((FloatColumnVector) data).getFloat(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic double getDouble(int ordinal) {\n+\t\treturn ((DoubleColumnVector) data).getDouble(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BinaryString getString(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\treturn BinaryString.fromBytes(byteArray.data, byteArray.offset, byteArray.len);\n+\t}\n+\n+\t@Override\n+\tpublic Decimal getDecimal(int ordinal, int precision, int scale) {\n+\t\treturn ((DecimalColumnVector) data).getDecimal(offset + ordinal, precision, scale);\n+\t}\n+\n+\t@Override\n+\tpublic SqlTimestamp getTimestamp(int ordinal, int precision) {\n+\t\treturn ((TimestampColumnVector) data).getTimestamp(offset + ordinal, precision);\n+\t}\n+\n+\t@Override\n+\tpublic <T> BinaryGeneric<T> getGeneric(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"GenericType is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic byte[] getBinary(int ordinal) {\n+\t\tBytesColumnVector.Bytes byteArray = getByteArray(ordinal);\n+\t\tif (byteArray.len == byteArray.data.length) {\n+\t\t\treturn byteArray.data;\n+\t\t} else {\n+\t\t\tbyte[] ret = new byte[byteArray.len];\n+\t\t\tSystem.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic BaseArray getArray(int ordinal) {\n+\t\treturn ((ArrayColumnVector) data).getArray(offset + ordinal);\n+\t}\n+\n+\t@Override\n+\tpublic BaseMap getMap(int ordinal) {\n+\t\tthrow new UnsupportedOperationException(\"Map is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic BaseRow getRow(int ordinal, int numFields) {\n+\t\tthrow new UnsupportedOperationException(\"Row is not supported.\");\n+\t}\n+\n+\t@Override\n+\tpublic void setBoolean(int ordinal, boolean value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setByte(int ordinal, byte value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setShort(int ordinal, short value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setInt(int ordinal, int value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setLong(int ordinal, long value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setFloat(int ordinal, float value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setDouble(int ordinal, double value) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setDecimal(int i, Decimal value, int precision) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setTimestamp(int ordinal, SqlTimestamp value, int precision) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNotNullAt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullLong(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullInt(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullBoolean(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullByte(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullShort(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullFloat(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic void setNullDouble(int pos) {\n+\t\tthrow new UnsupportedOperationException(\"Not support the operation!\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean[] toBooleanArray() {\n+\t\tboolean[] res = new boolean[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getBoolean(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic byte[] toByteArray() {\n+\t\tbyte[] res = new byte[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getByte(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic short[] toShortArray() {\n+\t\tshort[] res = new short[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getShort(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic int[] toIntArray() {\n+\t\tint[] res = new int[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getInt(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic long[] toLongArray() {\n+\t\tlong[] res = new long[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getLong(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic float[] toFloatArray() {\n+\t\tfloat[] res = new float[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getFloat(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t@Override\n+\tpublic double[] toDoubleArray() {\n+\t\tdouble[] res = new double[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tres[i] = getDouble(i);\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\tpublic BaseArray copy() {\n+\t\tLogicalType elementLogicalType = elementType.getLogicalType();\n+\t\tif (elementLogicalType instanceof BooleanType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toBooleanArray());\n+\t\t} else if (elementLogicalType instanceof TinyIntType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toByteArray());\n+\t\t} else if (elementLogicalType instanceof SmallIntType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toShortArray());\n+\t\t} else if (elementLogicalType instanceof IntType || elementLogicalType instanceof DateType || elementLogicalType instanceof TimeType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toIntArray());\n+\t\t} else if (elementLogicalType instanceof BigIntType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toLongArray());\n+\t\t} else if (elementLogicalType instanceof FloatType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toFloatArray());\n+\t\t} else if (elementLogicalType instanceof DoubleType) {\n+\t\t\treturn BinaryArray.fromPrimitiveArray(toDoubleArray());\n+\t\t} else {\n+\t\t\tDataFormatConverters.ObjectArrayConverter converter = new DataFormatConverters.ObjectArrayConverter(elementType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6849f6c616060c7ecb85f65a9a915b6b3182710d"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDA4NDYxOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/typeutils/BaseArraySerializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMzoxMDoyNlrOGBxVLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNDowNzozOFrOGByIRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwOTk5OA==", "bodyText": "We can invoke toPrimitiveArray only then nullable is false?", "url": "https://github.com/apache/flink/pull/11598#discussion_r404509998", "createdAt": "2020-04-07T03:10:26Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/typeutils/BaseArraySerializer.java", "diffHunk": "@@ -134,6 +139,48 @@ private GenericArray copyGenericArray(GenericArray array) {\n \t\treturn new GenericArray(arr, array.numElements(), array.isPrimitiveArray());\n \t}\n \n+\tprivate GenericArray copyColumnarArray(ColumnarArray from) {\n+\t\tObject arr;\n+\t\tboolean isPrimitiveArray = true;\n+\t\tswitch (eleType.getTypeRoot()) {\n+\t\t\tcase BOOLEAN:\n+\t\t\t\tarr = from.toBooleanArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74dc1907b38d2336682cc4e5833a78e436871714"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMzA3Nw==", "bodyText": "Good catch. We should check the nullable. Updated the PR.", "url": "https://github.com/apache/flink/pull/11598#discussion_r404523077", "createdAt": "2020-04-07T04:07:38Z", "author": {"login": "dianfu"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/typeutils/BaseArraySerializer.java", "diffHunk": "@@ -134,6 +139,48 @@ private GenericArray copyGenericArray(GenericArray array) {\n \t\treturn new GenericArray(arr, array.numElements(), array.isPrimitiveArray());\n \t}\n \n+\tprivate GenericArray copyColumnarArray(ColumnarArray from) {\n+\t\tObject arr;\n+\t\tboolean isPrimitiveArray = true;\n+\t\tswitch (eleType.getTypeRoot()) {\n+\t\t\tcase BOOLEAN:\n+\t\t\t\tarr = from.toBooleanArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwOTk5OA=="}, "originalCommit": {"oid": "74dc1907b38d2336682cc4e5833a78e436871714"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 603, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}