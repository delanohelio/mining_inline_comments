{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxODI0MDQx", "number": 13466, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzo1MzoyOFrOEnWR2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxNjo1OVrOEnYEvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Njk0OTM2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzo1MzoyOFrOHX47BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOTozNDowMFrOHX8VaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMTkwOA==", "bodyText": "Why do we need this override?", "url": "https://github.com/apache/flink/pull/13466#discussion_r494811908", "createdAt": "2020-09-25T07:53:28Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -726,15 +803,188 @@ public void processElement(StreamRecord<T> element) throws Exception {\n \t * Factory for {@link MapToStringMultipleInputOperator}.\n \t */\n \tprotected static class MapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\tprivate final int numberOfInputs;\n+\n+\t\tpublic MapToStringMultipleInputOperatorFactory(int numberOfInputs) {\n+\t\t\tthis.numberOfInputs = numberOfInputs;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n-\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters);\n+\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters, numberOfInputs);\n \t\t}\n \n \t\t@Override\n \t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n \t\t\treturn MapToStringMultipleInputOperator.class;\n \t\t}\n \t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness() throws Exception {\n+\t\treturn buildTestHarness(false);\n+\t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness(boolean unaligned) throws Exception {\n+\t\treturn new StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n+\t\t\t.modifyStreamConfig(config -> config.setUnalignedCheckpointsEnabled(unaligned))\n+\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.addSourceInput(\n+\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\tnew MockSource(Boundedness.BOUNDED, 1),\n+\t\t\t\t\tWatermarkStrategy.noWatermarks()))\n+\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n+\t\t\t.build();\n+\t}\n+\n+\tstatic void addSourceRecords(\n+\t\t\tStreamTaskMailboxTestHarness<String> testHarness,\n+\t\t\tint sourceId,\n+\t\t\tint... records) throws Exception {\n+\t\tOperatorID sourceOperatorID = getSourceOperatorID(testHarness, sourceId);\n+\n+\t\t// Prepare the source split and assign it to the source reader.\n+\t\tMockSourceSplit split = new MockSourceSplit(0, 0, records.length);\n+\t\tfor (int record : records) {\n+\t\t\tsplit.addRecord(record);\n+\t\t}\n+\n+\t\t// Assign the split to the source reader.\n+\t\tAddSplitEvent<MockSourceSplit> addSplitEvent =\n+\t\t\tnew AddSplitEvent<>(Collections.singletonList(split), new MockSourceSplitSerializer());\n+\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tsourceOperatorID,\n+\t\t\tnew SerializedValue<>(addSplitEvent));\n+\t}\n+\n+\tprivate static OperatorID getSourceOperatorID(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) {\n+\t\tStreamConfig.InputConfig[] inputs = testHarness.getStreamTask().getConfiguration().getInputs(testHarness.getClass().getClassLoader());\n+\t\tStreamConfig.SourceInputConfig input = (StreamConfig.SourceInputConfig) inputs[sourceId];\n+\t\treturn testHarness.getStreamTask().operatorChain.getSourceTaskInput(input).getOperatorID();\n+\t}\n+\n+\tprivate void finishAddingRecords(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) throws Exception {\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tgetSourceOperatorID(testHarness, sourceId),\n+\t\t\tnew SerializedValue<>(new SourceEventWrapper(new MockNoMoreSplitsEvent())));\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperator\n+\t\t\textends MapToStringMultipleInputOperator implements BoundedMultiInput {\n+\t\tpublic static final String OPEN = \"MultipleInputOperator#open\";\n+\t\tpublic static final String CLOSE = \"MultipleInputOperator#close\";\n+\t\tpublic static final String END_INPUT = \"MultipleInputOperator#endInput\";\n+\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\tpublic LifeCycleTrackingMapToStringMultipleInputOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\tsuper(parameters, 3);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(OPEN);\n+\t\t\tsuper.open();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(CLOSE);\n+\t\t\tsuper.close();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void endInput(int inputId) {\n+\t\t\tLIFE_CYCLE_EVENTS.add(END_INPUT);\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\t@Override\n+\t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\treturn (T) new LifeCycleTrackingMapToStringMultipleInputOperator(parameters);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n+\t\t\treturn LifeCycleTrackingMapToStringMultipleInputOperator.class;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSource extends MockSource {\n+\t\tpublic LifeCycleTrackingMockSource(Boundedness boundedness, int numSplits) {\n+\t\t\tsuper(boundedness, numSplits);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SourceReader<Integer, MockSourceSplit> createReader(SourceReaderContext readerContext) {\n+\t\t\tLifeCycleTrackingMockSourceReader sourceReader = new LifeCycleTrackingMockSourceReader();\n+\t\t\tcreatedReaders.add(sourceReader);\n+\t\t\treturn sourceReader;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSourceReader extends MockSourceReader {\n+\t\tpublic static final String START = \"SourceReader#start\";\n+\t\tpublic static final String CLOSE = \"SourceReader#close\";\n+\n+\t\t@Override\n+\t\tpublic void start() {\n+\t\t\tLIFE_CYCLE_EVENTS.add(START);\n+\t\t\tsuper.start();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic InputStatus pollNext(ReaderOutput<Integer> sourceOutput) throws Exception {\n+\t\t\treturn super.pollNext(sourceOutput);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb8f6bd3f92b03760701f3208190ee3330867f7"}, "originalPosition": 814}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg2NzgxNg==", "bodyText": "Probably some left over of a previous version. Removed.", "url": "https://github.com/apache/flink/pull/13466#discussion_r494867816", "createdAt": "2020-09-25T09:34:00Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -726,15 +803,188 @@ public void processElement(StreamRecord<T> element) throws Exception {\n \t * Factory for {@link MapToStringMultipleInputOperator}.\n \t */\n \tprotected static class MapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\tprivate final int numberOfInputs;\n+\n+\t\tpublic MapToStringMultipleInputOperatorFactory(int numberOfInputs) {\n+\t\t\tthis.numberOfInputs = numberOfInputs;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n-\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters);\n+\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters, numberOfInputs);\n \t\t}\n \n \t\t@Override\n \t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n \t\t\treturn MapToStringMultipleInputOperator.class;\n \t\t}\n \t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness() throws Exception {\n+\t\treturn buildTestHarness(false);\n+\t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness(boolean unaligned) throws Exception {\n+\t\treturn new StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n+\t\t\t.modifyStreamConfig(config -> config.setUnalignedCheckpointsEnabled(unaligned))\n+\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.addSourceInput(\n+\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\tnew MockSource(Boundedness.BOUNDED, 1),\n+\t\t\t\t\tWatermarkStrategy.noWatermarks()))\n+\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n+\t\t\t.build();\n+\t}\n+\n+\tstatic void addSourceRecords(\n+\t\t\tStreamTaskMailboxTestHarness<String> testHarness,\n+\t\t\tint sourceId,\n+\t\t\tint... records) throws Exception {\n+\t\tOperatorID sourceOperatorID = getSourceOperatorID(testHarness, sourceId);\n+\n+\t\t// Prepare the source split and assign it to the source reader.\n+\t\tMockSourceSplit split = new MockSourceSplit(0, 0, records.length);\n+\t\tfor (int record : records) {\n+\t\t\tsplit.addRecord(record);\n+\t\t}\n+\n+\t\t// Assign the split to the source reader.\n+\t\tAddSplitEvent<MockSourceSplit> addSplitEvent =\n+\t\t\tnew AddSplitEvent<>(Collections.singletonList(split), new MockSourceSplitSerializer());\n+\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tsourceOperatorID,\n+\t\t\tnew SerializedValue<>(addSplitEvent));\n+\t}\n+\n+\tprivate static OperatorID getSourceOperatorID(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) {\n+\t\tStreamConfig.InputConfig[] inputs = testHarness.getStreamTask().getConfiguration().getInputs(testHarness.getClass().getClassLoader());\n+\t\tStreamConfig.SourceInputConfig input = (StreamConfig.SourceInputConfig) inputs[sourceId];\n+\t\treturn testHarness.getStreamTask().operatorChain.getSourceTaskInput(input).getOperatorID();\n+\t}\n+\n+\tprivate void finishAddingRecords(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) throws Exception {\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tgetSourceOperatorID(testHarness, sourceId),\n+\t\t\tnew SerializedValue<>(new SourceEventWrapper(new MockNoMoreSplitsEvent())));\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperator\n+\t\t\textends MapToStringMultipleInputOperator implements BoundedMultiInput {\n+\t\tpublic static final String OPEN = \"MultipleInputOperator#open\";\n+\t\tpublic static final String CLOSE = \"MultipleInputOperator#close\";\n+\t\tpublic static final String END_INPUT = \"MultipleInputOperator#endInput\";\n+\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\tpublic LifeCycleTrackingMapToStringMultipleInputOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\tsuper(parameters, 3);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(OPEN);\n+\t\t\tsuper.open();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(CLOSE);\n+\t\t\tsuper.close();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void endInput(int inputId) {\n+\t\t\tLIFE_CYCLE_EVENTS.add(END_INPUT);\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\t@Override\n+\t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\treturn (T) new LifeCycleTrackingMapToStringMultipleInputOperator(parameters);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n+\t\t\treturn LifeCycleTrackingMapToStringMultipleInputOperator.class;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSource extends MockSource {\n+\t\tpublic LifeCycleTrackingMockSource(Boundedness boundedness, int numSplits) {\n+\t\t\tsuper(boundedness, numSplits);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SourceReader<Integer, MockSourceSplit> createReader(SourceReaderContext readerContext) {\n+\t\t\tLifeCycleTrackingMockSourceReader sourceReader = new LifeCycleTrackingMockSourceReader();\n+\t\t\tcreatedReaders.add(sourceReader);\n+\t\t\treturn sourceReader;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSourceReader extends MockSourceReader {\n+\t\tpublic static final String START = \"SourceReader#start\";\n+\t\tpublic static final String CLOSE = \"SourceReader#close\";\n+\n+\t\t@Override\n+\t\tpublic void start() {\n+\t\t\tLIFE_CYCLE_EVENTS.add(START);\n+\t\t\tsuper.start();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic InputStatus pollNext(ReaderOutput<Integer> sourceOutput) throws Exception {\n+\t\t\treturn super.pollNext(sourceOutput);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMTkwOA=="}, "originalCommit": {"oid": "7eb8f6bd3f92b03760701f3208190ee3330867f7"}, "originalPosition": 814}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Njk3NTAzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODowMDo0N1rOHX5K-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODowMDo0N1rOHX5K-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxNTk5Mw==", "bodyText": "Can you elaborate on this change in the commit message please?\n[FLINK-18907][task] Fix numRecordsIn metric with chained sources", "url": "https://github.com/apache/flink/pull/13466#discussion_r494815993", "createdAt": "2020-09-25T08:00:47Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -68,7 +69,9 @@\n \t */\n \tprivate final StreamStatus[] streamStatuses;\n \n-\tprivate final Counter numRecordsIn;\n+\tprivate final Counter networkRecordsIn = new SimpleCounter();\n+\n+\tprivate final Counter mainOperatorRecordsIn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb8f6bd3f92b03760701f3208190ee3330867f7"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzEwMDc5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODozNzoxMFrOHX6YIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODozNzoxMFrOHX6YIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgzNTc0NQ==", "bodyText": "The method is ~70 LOC now with 7 assertions and a bit generic name testWatermark.\nI think it can be shortened if we extract method for the sequence: processElement, expectedOutput.add, assert output equals.", "url": "https://github.com/apache/flink/pull/13466#discussion_r494835745", "createdAt": "2020-09-25T08:37:10Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -417,20 +451,22 @@ public void testWatermark() throws Exception {\n \n \t\t\t// advance watermark from one of the inputs, now we should get a new one since the\n \t\t\t// minimum increases\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 1);\n \t\t\texpectedOutput.add(new Watermark(initialTime + 3));\n \t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n \n-\t\t\t// advance the other two inputs, now we should get a new one since the\n-\t\t\t// minimum increases again\n+\t\t\t// advance the other inputs, now we should get a new one since the minimum increases again\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 1);\n+\n+\t\t\taddSourceRecords(testHarness, 1, initialTime + 4);\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"\" + (initialTime + 4), TimestampAssigner.NO_TIMESTAMP));\n+\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 0);\n \t\t\texpectedOutput.add(new Watermark(initialTime + 4));\n \t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n \n \t\t\tList<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput());\n-\t\t\tassertEquals(2, resultElements.size());\n+\t\t\tassertEquals(5, resultElements.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 365}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzEzMzQ1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo0NjoyMFrOHX6sBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo0NjoyMFrOHX6sBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MDgzOA==", "bodyText": "How about inlining this constructor (and maybe commenting at call site) to make it clear when (and why) there is no inputWatermarkGauge.", "url": "https://github.com/apache/flink/pull/13466#discussion_r494840838", "createdAt": "2020-09-25T08:46:20Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java", "diffHunk": "@@ -63,13 +66,22 @@ public void init() {\n \tpublic static class AsyncDataOutputToOutput<T> extends AbstractDataOutput<T> {\n \n \t\tprivate final Output<StreamRecord<T>> output;\n+\t\t@Nullable private final WatermarkGauge inputWatermarkGauge;\n \n \t\tpublic AsyncDataOutputToOutput(\n \t\t\t\tOutput<StreamRecord<T>> output,\n \t\t\t\tStreamStatusMaintainer streamStatusMaintainer) {\n+\t\t\tthis(output, streamStatusMaintainer, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzE1OTk4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo1MzoxMVrOHX68Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMTowMTowM1rOHX_B4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NDk2Ng==", "bodyText": "Extract method in test harness? (or use existing processWhileAvailable?)", "url": "https://github.com/apache/flink/pull/13466#discussion_r494844966", "createdAt": "2020-09-25T08:53:11Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -443,38 +479,66 @@ public void testWatermark() throws Exception {\n \tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n \t\t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n \t\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO, 2)\n-\t\t\t\t\t.addInput(BasicTypeInfo.INT_TYPE_INFO, 2)\n+\t\t\t\t\t.addSourceInput(\n+\t\t\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\t\t\tnew MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2, true, true),\n+\t\t\t\t\t\t\tWatermarkStrategy.forGenerator(ctx -> new RecordToWatermarkGenerator())))\n \t\t\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, 2)\n \t\t\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n \t\t\t\t\t.build()) {\n \t\t\tArrayDeque<Object> expectedOutput = new ArrayDeque<>();\n \n-\t\t\tlong initialTime = 0L;\n+\t\t\tint initialTime = 0;\n \n \t\t\t// test whether idle input channels are acknowledged correctly when forwarding watermarks\n \t\t\ttestHarness.processElement(StreamStatus.IDLE, 0, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 0);\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 0, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 1, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 2, 1); // this watermark should be advanced first\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 1); // once this is acknowledged,\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 1, 1); // this watermark should be advanced first\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 0); // once this is acknowledged,\n \n-\t\t\texpectedOutput.add(new Watermark(initialTime + 5));\n \t\t\t// We don't expect to see Watermark(6) here because the idle status of one\n \t\t\t// input doesn't propagate to the other input. That is, if input 1 is at WM 6 and input\n \t\t\t// two was at WM 5 before going to IDLE then the output watermark will not jump to WM 6.\n+\n+\t\t\t// OPS, there is a known bug: https://issues.apache.org/jira/browse/FLINK-18934\n+\t\t\t// that prevents this check from succeeding (AbstractStreamOperator and AbstractStreamOperatorV2\n+\t\t\t// are ignoring StreamStatus), so those checks needs to be commented out ...\n+\n+\t\t\t//expectedOutput.add(new Watermark(initialTime + 5));\n+\t\t\t//assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// and in as a temporary replacement we need this code block:\n+\t\t\t{\n+\t\t\t\t// we wake up the source and emit watermark\n+\t\t\t\taddSourceRecords(testHarness, 1, initialTime + 5);\n+\t\t\t\twhile (testHarness.processSingleStep()) {\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkxMTk3MA==", "bodyText": "Ok, I went a step further and I have dropped the old processIfAvailable and processWhileAvailable and replaced them with processSingleStep. Previously I was afraid that some tests might be relaying on the previous behaviour, but apparently that's not the case:\nceb02da", "url": "https://github.com/apache/flink/pull/13466#discussion_r494911970", "createdAt": "2020-09-25T11:01:03Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -443,38 +479,66 @@ public void testWatermark() throws Exception {\n \tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n \t\t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n \t\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO, 2)\n-\t\t\t\t\t.addInput(BasicTypeInfo.INT_TYPE_INFO, 2)\n+\t\t\t\t\t.addSourceInput(\n+\t\t\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\t\t\tnew MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2, true, true),\n+\t\t\t\t\t\t\tWatermarkStrategy.forGenerator(ctx -> new RecordToWatermarkGenerator())))\n \t\t\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, 2)\n \t\t\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n \t\t\t\t\t.build()) {\n \t\t\tArrayDeque<Object> expectedOutput = new ArrayDeque<>();\n \n-\t\t\tlong initialTime = 0L;\n+\t\t\tint initialTime = 0;\n \n \t\t\t// test whether idle input channels are acknowledged correctly when forwarding watermarks\n \t\t\ttestHarness.processElement(StreamStatus.IDLE, 0, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 0);\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 0, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 1, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 2, 1); // this watermark should be advanced first\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 1); // once this is acknowledged,\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 1, 1); // this watermark should be advanced first\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 0); // once this is acknowledged,\n \n-\t\t\texpectedOutput.add(new Watermark(initialTime + 5));\n \t\t\t// We don't expect to see Watermark(6) here because the idle status of one\n \t\t\t// input doesn't propagate to the other input. That is, if input 1 is at WM 6 and input\n \t\t\t// two was at WM 5 before going to IDLE then the output watermark will not jump to WM 6.\n+\n+\t\t\t// OPS, there is a known bug: https://issues.apache.org/jira/browse/FLINK-18934\n+\t\t\t// that prevents this check from succeeding (AbstractStreamOperator and AbstractStreamOperatorV2\n+\t\t\t// are ignoring StreamStatus), so those checks needs to be commented out ...\n+\n+\t\t\t//expectedOutput.add(new Watermark(initialTime + 5));\n+\t\t\t//assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// and in as a temporary replacement we need this code block:\n+\t\t\t{\n+\t\t\t\t// we wake up the source and emit watermark\n+\t\t\t\taddSourceRecords(testHarness, 1, initialTime + 5);\n+\t\t\t\twhile (testHarness.processSingleStep()) {\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NDk2Ng=="}, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 416}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzE3MzIyOnYy", "diffSide": "RIGHT", "path": "flink-core/src/test/java/org/apache/flink/api/connector/source/mocks/MockSourceReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo1Njo0MlrOHX7EQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo1Njo0MlrOHX7EQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NzA0MQ==", "bodyText": "nit: flatten nested else { if {} } to else if {}?", "url": "https://github.com/apache/flink/pull/13466#discussion_r494847041", "createdAt": "2020-09-25T08:56:42Z", "author": {"login": "rkhachatryan"}, "path": "flink-core/src/test/java/org/apache/flink/api/connector/source/mocks/MockSourceReader.java", "diffHunk": "@@ -68,7 +78,16 @@ public InputStatus pollNext(ReaderOutput<Integer> sourceOutput) throws Exception\n \t\t\treturn InputStatus.MORE_AVAILABLE;\n \t\t} else {\n \t\t\t// In case no split has available record, return depending on whether all the splits has finished.\n-\t\t\treturn finished ? InputStatus.END_OF_INPUT : InputStatus.NOTHING_AVAILABLE;\n+\t\t\tif (finished) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NzI0MzUwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxNjo1OVrOHX7vnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxNjo1OVrOHX7vnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODE0Mw==", "bodyText": "Can you add a comment explaining this line?", "url": "https://github.com/apache/flink/pull/13466#discussion_r494858143", "createdAt": "2020-09-25T09:16:59Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -210,45 +233,63 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testOperatorMetricReuse() throws Exception {\n+\tpublic void testMetrics() throws Exception {\n+\n+\t\tHashMap<String, OperatorMetricGroup> operatorMetrics = new HashMap<>();\n \n \t\tTaskMetricGroup taskMetricGroup = new UnregisteredMetricGroups.UnregisteredTaskMetricGroup() {\n \t\t\t@Override\n \t\t\tpublic OperatorMetricGroup getOrAddOperator(OperatorID operatorID, String name) {\n-\t\t\t\treturn new OperatorMetricGroup(NoOpMetricRegistry.INSTANCE, this, operatorID, name);\n+\t\t\t\tOperatorMetricGroup operatorMetricGroup = new OperatorMetricGroup(NoOpMetricRegistry.INSTANCE, this, operatorID, name);\n+\t\t\t\toperatorMetrics.put(name, operatorMetricGroup);\n+\t\t\t\treturn operatorMetricGroup;\n \t\t\t}\n \t\t};\n \n+\t\tString mainOperatorName = \"MainOperator\";\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n \t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n \t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t.addSourceInput(\n+\t\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\t\tnew LifeCycleTrackingMockSource(Boundedness.BOUNDED, 1),\n+\t\t\t\t\t\tWatermarkStrategy.noWatermarks()))\n \t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n-\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n-\t\t\t\t.setupOperatorChain(new DuplicatingOperatorFactory())\n+\t\t\t\t.setupOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n+\t\t\t\t.name(mainOperatorName)\n+\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.finish()\n \t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n \t\t\t\t.build()) {\n+\n+\t\t\tassertTrue(operatorMetrics.containsKey(mainOperatorName));\n+\t\t\tOperatorMetricGroup mainOperatorMetrics = operatorMetrics.get(mainOperatorName);\n \t\t\tCounter numRecordsInCounter = taskMetricGroup.getIOMetricGroup().getNumRecordsInCounter();\n \t\t\tCounter numRecordsOutCounter = taskMetricGroup.getIOMetricGroup().getNumRecordsOutCounter();\n \n \t\t\tint numRecords1 = 5;\n \t\t\tint numRecords2 = 3;\n \t\t\tint numRecords3 = 2;\n+\t\t\t// add source splits before processing any elements, so the MockSourceReader does not end prematurely\n+\t\t\tfor (int x = 0; x < numRecords2; x++) {\n+\t\t\t\taddSourceRecords(testHarness, 1, 42);\n+\t\t\t}\n \t\t\tfor (int x = 0; x < numRecords1; x++) {\n \t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 0, 0);\n \t\t\t}\n-\t\t\tfor (int x = 0; x < numRecords2; x++) {\n-\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 1, 0);\n-\t\t\t}\n \t\t\tfor (int x = 0; x < numRecords3; x++) {\n-\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 2, 0);\n+\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 1, 0);\n \t\t\t}\n \n-\t\t\tint totalRecords = numRecords1 + numRecords2 + numRecords3;\n-\t\t\tassertEquals(totalRecords, numRecordsInCounter.getCount());\n-\t\t\tassertEquals((totalRecords) * 2 * 2 * 2, numRecordsOutCounter.getCount());\n+\t\t\tint networkRecordsIn = numRecords1 + numRecords3;\n+\t\t\tint mainOpeartorRecordsIn = networkRecordsIn + numRecords2;\n+\t\t\tint totalRecordsOut = (networkRecordsIn + numRecords2) * 2 * 2 * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3728ea45538546b24d96081697a108eccab13cd"}, "originalPosition": 192}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 355, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}