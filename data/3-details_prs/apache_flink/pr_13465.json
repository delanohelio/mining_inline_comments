{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxODE0MTA1", "number": 13465, "title": "[FLINK-18906][task] Support checkpointing with multiple input operator chained with sources", "bodyText": "This PR depends on #13228 and large bunch of commits is coming from there. Please ignore them in this PR.\nThis PR adds support for checkpointing with multiple input operator chained with sources. It's doing it via hooking in StreamTaskSourceInput to CheckpointBarrierHandlers. Please check individual commits for the changelog.\nVerifying this change\nThis change is covered by the existing tests and is also adding MultipleInputStreamTaskChainedSourcesCheckpointingTest to cover for the new features (checkpointing with chained sources).\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-09-23T14:15:18Z", "url": "https://github.com/apache/flink/pull/13465", "merged": true, "mergeCommit": {"oid": "f547f4c05e21d227cb45db10dab0d86b2a1b8a80"}, "closed": true, "closedAt": "2020-09-25T08:25:15Z", "author": {"login": "pnowojski"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLtbg7gBqjM3OTg0MTE3MzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMPhBJABqjM4MDYxNTU5OTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69696d3185a14cb896ab6e6432c9bc48fa1d54a4", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/69696d3185a14cb896ab6e6432c9bc48fa1d54a4", "committedDate": "2020-09-23T13:25:34Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "committedDate": "2020-09-23T14:21:58Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "committedDate": "2020-09-23T14:21:58Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ac0d032298233f33ea335341728c254a11db51b3", "committedDate": "2020-09-24T07:27:37Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Mzk4NzEx", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-495398711", "createdAt": "2020-09-24T09:45:24Z", "commit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTo0NToyNFrOHXScWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMTo0NjowN1rOHXWlcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MTQ2Nw==", "bodyText": "I think less if nesting would be more readabile:\nif (first == AVAILABLE && second == AVAILABLE) return AVAILABLE;\nelse if (first == AVAILABLE) return second;\nelse if (second == AVAILABLE) return first;\nelse return allOf(first, second);", "url": "https://github.com/apache/flink/pull/13465#discussion_r494181467", "createdAt": "2020-09-24T09:45:24Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java", "diffHunk": "@@ -66,6 +66,32 @@ default boolean isApproximatelyAvailable() {\n \t\treturn getAvailableFuture() == AVAILABLE;\n \t}\n \n+\tstatic CompletableFuture<?> and(CompletableFuture<?> first, CompletableFuture<?> second) {\n+\t\tif (first == AVAILABLE) {\n+\t\t\tif (second == AVAILABLE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4OTQ5NA==", "bodyText": "Why not just return false here?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494189494", "createdAt": "2020-09-24T09:58:35Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -249,25 +259,34 @@ private void sendControlMail(RunnableWithException mail, String descriptionForma\n \t}\n \n \t/**\n-\t * This helper method handles all special actions from the mailbox. It returns true if the mailbox loop should\n-\t * continue running, false if it should stop. In the current design, this method also evaluates all control flag\n-\t * changes. This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n+\t * This helper method handles all special actions from the mailbox.\n+\t * In the current design, this method also evaluates all control flag changes.\n+\t * This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n \t * that all flag changes must make sure that the mailbox signals mailbox#hasMail.\n+\t *\n+\t * @return true if a mail has been processed.\n \t */\n-\tprivate boolean processMail(TaskMailbox mailbox) throws Exception {\n-\n+\tprivate boolean processMail(TaskMailbox mailbox, boolean singleStep) throws Exception {\n+\t\tboolean processed = false;\n \t\t// Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only\n \t\t// acquired after this point.\n \t\tif (!mailbox.createBatch()) {\n \t\t\t// We can also directly return true because all changes to #isMailboxLoopRunning must be connected to\n \t\t\t// mailbox.hasMail() == true.\n-\t\t\treturn true;\n+\t\t\treturn processed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MDUwMg==", "bodyText": "Why not just return true here?\nAnd then after the loop if singleStep == true we can also return false.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494190502", "createdAt": "2020-09-24T10:00:13Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -249,25 +259,34 @@ private void sendControlMail(RunnableWithException mail, String descriptionForma\n \t}\n \n \t/**\n-\t * This helper method handles all special actions from the mailbox. It returns true if the mailbox loop should\n-\t * continue running, false if it should stop. In the current design, this method also evaluates all control flag\n-\t * changes. This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n+\t * This helper method handles all special actions from the mailbox.\n+\t * In the current design, this method also evaluates all control flag changes.\n+\t * This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n \t * that all flag changes must make sure that the mailbox signals mailbox#hasMail.\n+\t *\n+\t * @return true if a mail has been processed.\n \t */\n-\tprivate boolean processMail(TaskMailbox mailbox) throws Exception {\n-\n+\tprivate boolean processMail(TaskMailbox mailbox, boolean singleStep) throws Exception {\n+\t\tboolean processed = false;\n \t\t// Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only\n \t\t// acquired after this point.\n \t\tif (!mailbox.createBatch()) {\n \t\t\t// We can also directly return true because all changes to #isMailboxLoopRunning must be connected to\n \t\t\t// mailbox.hasMail() == true.\n-\t\t\treturn true;\n+\t\t\treturn processed;\n \t\t}\n \n \t\t// Take mails in a non-blockingly and execute them.\n \t\tOptional<Mail> maybeMail;\n \t\twhile (isMailboxLoopRunning() && (maybeMail = mailbox.tryTakeFromBatch()).isPresent()) {\n \t\t\tmaybeMail.get().run();\n+\t\t\tprocessed = true;\n+\t\t\tif (singleStep) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MjIwNQ==", "bodyText": "This is a change in the production code, so I think it's better to not mark it as [test] in commit message (even though the motivation is to fix tests).", "url": "https://github.com/apache/flink/pull/13465#discussion_r494192205", "createdAt": "2020-09-24T10:03:02Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -178,17 +178,27 @@ public void runMailboxLoop() throws Exception {\n \n \t\tfinal MailboxController defaultActionContext = new MailboxController(this);\n \n-\t\twhile (runMailboxStep(localMailbox, defaultActionContext)) {\n+\t\twhile (isMailboxLoopRunning()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw==", "bodyText": "How about using vararg parameter and replacing here with just Arrays.asList(inputGates)?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494202103", "createdAt": "2020-09-24T10:20:12Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -56,12 +59,13 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\ttaskIOMetricGroup,\n \t\t\ttaskName,\n \t\t\tmailboxExecutor,\n-\t\t\tArrays.asList(inputGates));\n+\t\t\tnew List[]{ Arrays.asList(inputGates) },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzM0Mg==", "bodyText": "nit: this comment doesn't say much to me", "url": "https://github.com/apache/flink/pull/13465#discussion_r494207342", "createdAt": "2020-09-24T10:29:30Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java", "diffHunk": "@@ -34,30 +40,75 @@\n  * unavailable or finished.\n  */\n @Internal\n-public final class StreamTaskSourceInput<T> implements StreamTaskInput<T> {\n+public final class StreamTaskSourceInput<T> implements StreamTaskInput<T>, BlockableInput {\n \n \tprivate final SourceOperator<T, ?> operator;\n+\tprivate final int inputGateIndex;\n+\tprivate final AvailabilityHelper isBlockedAvailability = new AvailabilityHelper();\n+\tprivate final List<InputChannelInfo> inputChannelInfos;\n \n-\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator) {\n+\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator, int inputGateIndex) {\n \t\tthis.operator = checkNotNull(operator);\n+\t\tthis.inputGateIndex = inputGateIndex;\n+\t\tinputChannelInfos = Collections.singletonList(new InputChannelInfo(inputGateIndex, 0));\n+\t\tisBlockedAvailability.resetAvailable();\n \t}\n \n \t@Override\n \tpublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n+\t\tif (!isBlockedAvailability.isApproximatelyAvailable()) {\n+\t\t\t// Safe guard", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzU1OA==", "bodyText": "nit: this is a bit difficult to read (maybe just invert the condition?)", "url": "https://github.com/apache/flink/pull/13465#discussion_r494207558", "createdAt": "2020-09-24T10:29:52Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java", "diffHunk": "@@ -34,30 +40,75 @@\n  * unavailable or finished.\n  */\n @Internal\n-public final class StreamTaskSourceInput<T> implements StreamTaskInput<T> {\n+public final class StreamTaskSourceInput<T> implements StreamTaskInput<T>, BlockableInput {\n \n \tprivate final SourceOperator<T, ?> operator;\n+\tprivate final int inputGateIndex;\n+\tprivate final AvailabilityHelper isBlockedAvailability = new AvailabilityHelper();\n+\tprivate final List<InputChannelInfo> inputChannelInfos;\n \n-\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator) {\n+\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator, int inputGateIndex) {\n \t\tthis.operator = checkNotNull(operator);\n+\t\tthis.inputGateIndex = inputGateIndex;\n+\t\tinputChannelInfos = Collections.singletonList(new InputChannelInfo(inputGateIndex, 0));\n+\t\tisBlockedAvailability.resetAvailable();\n \t}\n \n \t@Override\n \tpublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n+\t\tif (!isBlockedAvailability.isApproximatelyAvailable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxODkwNA==", "bodyText": "Shouldn't we also update super.latestAsyncCheckpointStartDelayNanos?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494218904", "createdAt": "2020-09-24T10:51:38Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIyNjcwMA==", "bodyText": "I'm concerned about the cleanup of this map.\nFrom the code, I see it's assumed at least one triggerOnBarrier or abortOnBarrier after triggerAsync, right?\nBut can abort come after triggerAsync?\nShould we state these ordering assumptions?\nOr maybe we can just remove the map? I see the future result is only used by SourceStreamTask which is irrelevant here.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494226700", "createdAt": "2020-09-24T11:06:46Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -18,32 +18,48 @@\n package org.apache.flink.streaming.runtime.tasks;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;\n import org.apache.flink.runtime.metrics.MetricNames;\n import org.apache.flink.streaming.api.graph.StreamConfig;\n import org.apache.flink.streaming.api.graph.StreamConfig.InputConfig;\n import org.apache.flink.streaming.api.graph.StreamEdge;\n import org.apache.flink.streaming.api.operators.InputSelectable;\n import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.runtime.io.CheckpointBarrierHandler;\n import org.apache.flink.streaming.runtime.io.CheckpointedInputGate;\n import org.apache.flink.streaming.runtime.io.InputProcessorUtil;\n import org.apache.flink.streaming.runtime.io.MultipleInputSelectionHandler;\n import org.apache.flink.streaming.runtime.io.StreamMultipleInputProcessor;\n+import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;\n import org.apache.flink.streaming.runtime.metrics.MinWatermarkGauge;\n import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n \n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n-\n-import static org.apache.flink.util.Preconditions.checkState;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n \n /**\n  * A {@link StreamTask} for executing a {@link MultipleInputStreamOperator} and supporting\n  * the {@link MultipleInputStreamOperator} to select input for reading.\n  */\n @Internal\n public class MultipleInputStreamTask<OUT> extends StreamTask<OUT, MultipleInputStreamOperator<OUT>> {\n+\tprivate final HashMap<Long, CompletableFuture<Boolean>> pendingCheckpointCompletedFutures = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzNTUxNQ==", "bodyText": "Shouldn't we differentiate for which sourceInput current barrier is (and call processBarrier only for it)?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494235515", "createdAt": "2020-09-24T11:23:36Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tpendingCheckpointCompletedFutures.put(metadata.getCheckpointId(), resultFuture);\n+\t\t\t\t\ttriggerSourcesCheckpoint(new CheckpointBarrier(metadata.getCheckpointId(), metadata.getTimestamp(), options));\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t// Report the failure both via the Future result but also to the mailbox\n+\t\t\t\t\tpendingCheckpointCompletedFutures.remove(metadata.getCheckpointId());\n+\t\t\t\t\tresultFuture.completeExceptionally(ex);\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\t\"checkpoint %s with %s\",\n+\t\t\tmetadata,\n+\t\t\toptions);\n+\t\treturn resultFuture;\n+\t}\n+\n+\tprivate void triggerSourcesCheckpoint(CheckpointBarrier checkpointBarrier) throws IOException {\n+\t\tfor (StreamTaskSourceInput<?> sourceInput : operatorChain.getSourceTaskInputs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0OTMyOA==", "bodyText": "Why do we block source inputs when we receive a barrier from a non-source input?\n(maybe a comment is missing here or for StreamTaskSourceInput.checkpointStarted)", "url": "https://github.com/apache/flink/pull/13465#discussion_r494249328", "createdAt": "2020-09-24T11:46:07Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -101,10 +101,8 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \t\t\tallBarriersReceivedFuture = new CompletableFuture<>();\n \t\t\tcheckpointCoordinator.initCheckpoint(barrierId, barrier.getCheckpointOptions());\n \n-\t\t\tfor (final InputGate gate : inputGates) {\n-\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n-\t\t\t\t\tgate.getChannel(index).checkpointStarted(barrier);\n-\t\t\t\t}\n+\t\t\tfor (final BlockableInput input : inputs) {\n+\t\t\t\tinput.checkpointStarted(barrier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NTE3Mjcy", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-495517272", "createdAt": "2020-09-24T12:29:44Z", "commit": {"oid": "d6e9d67aa16b9153bb3be59a7ed9212c0ef4fc35"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjoyOTo0NFrOHXYHCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo0MTo1MVrOHXYvyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3NDMxNA==", "bodyText": "Good question. I've added a larger explanation why in StreamTaskSourceInput#checkpointStarted", "url": "https://github.com/apache/flink/pull/13465#discussion_r494274314", "createdAt": "2020-09-24T12:29:44Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -101,10 +101,8 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \t\t\tallBarriersReceivedFuture = new CompletableFuture<>();\n \t\t\tcheckpointCoordinator.initCheckpoint(barrierId, barrier.getCheckpointOptions());\n \n-\t\t\tfor (final InputGate gate : inputGates) {\n-\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n-\t\t\t\t\tgate.getChannel(index).checkpointStarted(barrier);\n-\t\t\t\t}\n+\t\t\tfor (final BlockableInput input : inputs) {\n+\t\t\t\tinput.checkpointStarted(barrier);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0OTMyOA=="}, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3NTYzMQ==", "bodyText": "? It used to be like that, but now we are submitting two different lists, so having a vararg for just one of them would be a bit inconsistent.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494275631", "createdAt": "2020-09-24T12:31:48Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -56,12 +59,13 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\ttaskIOMetricGroup,\n \t\t\ttaskName,\n \t\t\tmailboxExecutor,\n-\t\t\tArrays.asList(inputGates));\n+\t\t\tnew List[]{ Arrays.asList(inputGates) },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw=="}, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3OTkzOQ==", "bodyText": "expanded", "url": "https://github.com/apache/flink/pull/13465#discussion_r494279939", "createdAt": "2020-09-24T12:35:18Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java", "diffHunk": "@@ -34,30 +40,75 @@\n  * unavailable or finished.\n  */\n @Internal\n-public final class StreamTaskSourceInput<T> implements StreamTaskInput<T> {\n+public final class StreamTaskSourceInput<T> implements StreamTaskInput<T>, BlockableInput {\n \n \tprivate final SourceOperator<T, ?> operator;\n+\tprivate final int inputGateIndex;\n+\tprivate final AvailabilityHelper isBlockedAvailability = new AvailabilityHelper();\n+\tprivate final List<InputChannelInfo> inputChannelInfos;\n \n-\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator) {\n+\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator, int inputGateIndex) {\n \t\tthis.operator = checkNotNull(operator);\n+\t\tthis.inputGateIndex = inputGateIndex;\n+\t\tinputChannelInfos = Collections.singletonList(new InputChannelInfo(inputGateIndex, 0));\n+\t\tisBlockedAvailability.resetAvailable();\n \t}\n \n \t@Override\n \tpublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n+\t\tif (!isBlockedAvailability.isApproximatelyAvailable()) {\n+\t\t\t// Safe guard", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzM0Mg=="}, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4MjUxOA==", "bodyText": "No. This field is used only in the SourceStreamTask. MetricNames#CHECKPOINT_START_DELAY_TIME metric is defined in two ways:\n\nin SourceStreamTask via latestAsyncCheckpointStartDelayNanos\neverywhere else via CheckpointBarrierHandler#getCheckpointStartDelayNanos\n\nMultipleInputStreamTask is using the second way.\nI've added a comment about that.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494282518", "createdAt": "2020-09-24T12:38:09Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxODkwNA=="}, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NDc0NQ==", "bodyText": "There is no need to do that. Please check the updated java doc in StreamTaskSourceInput#checkpointStarted.\nRuntime has a flexibility to checkpoint the sources at any point of time, as long as it is in sync with network inputs.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494284745", "createdAt": "2020-09-24T12:41:51Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tpendingCheckpointCompletedFutures.put(metadata.getCheckpointId(), resultFuture);\n+\t\t\t\t\ttriggerSourcesCheckpoint(new CheckpointBarrier(metadata.getCheckpointId(), metadata.getTimestamp(), options));\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t// Report the failure both via the Future result but also to the mailbox\n+\t\t\t\t\tpendingCheckpointCompletedFutures.remove(metadata.getCheckpointId());\n+\t\t\t\t\tresultFuture.completeExceptionally(ex);\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\t\"checkpoint %s with %s\",\n+\t\t\tmetadata,\n+\t\t\toptions);\n+\t\treturn resultFuture;\n+\t}\n+\n+\tprivate void triggerSourcesCheckpoint(CheckpointBarrier checkpointBarrier) throws IOException {\n+\t\tfor (StreamTaskSourceInput<?> sourceInput : operatorChain.getSourceTaskInputs()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzNTUxNQ=="}, "originalCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3"}, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac0d032298233f33ea335341728c254a11db51b3", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ac0d032298233f33ea335341728c254a11db51b3", "committedDate": "2020-09-24T07:27:37Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "3bd46778d0a609df1923acee5a0647ed61e14c69", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/3bd46778d0a609df1923acee5a0647ed61e14c69", "committedDate": "2020-09-24T12:42:29Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3bd46778d0a609df1923acee5a0647ed61e14c69", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/3bd46778d0a609df1923acee5a0647ed61e14c69", "committedDate": "2020-09-24T12:42:29Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "committedDate": "2020-09-24T14:21:44Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjM0Nzky", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-495634792", "createdAt": "2020-09-24T14:29:20Z", "commit": {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDoyOToyMVrOHXduaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDozNjoxNFrOHXeDcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2NjMxNQ==", "bodyText": "Can this be private?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494366315", "createdAt": "2020-09-24T14:29:21Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -18,32 +18,51 @@\n package org.apache.flink.streaming.runtime.tasks;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;\n import org.apache.flink.runtime.metrics.MetricNames;\n import org.apache.flink.streaming.api.graph.StreamConfig;\n import org.apache.flink.streaming.api.graph.StreamConfig.InputConfig;\n import org.apache.flink.streaming.api.graph.StreamEdge;\n import org.apache.flink.streaming.api.operators.InputSelectable;\n import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.runtime.io.CheckpointBarrierHandler;\n import org.apache.flink.streaming.runtime.io.CheckpointedInputGate;\n import org.apache.flink.streaming.runtime.io.InputProcessorUtil;\n import org.apache.flink.streaming.runtime.io.MultipleInputSelectionHandler;\n import org.apache.flink.streaming.runtime.io.StreamMultipleInputProcessor;\n+import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;\n import org.apache.flink.streaming.runtime.metrics.MinWatermarkGauge;\n import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n \n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n-\n-import static org.apache.flink.util.Preconditions.checkState;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n \n /**\n  * A {@link StreamTask} for executing a {@link MultipleInputStreamOperator} and supporting\n  * the {@link MultipleInputStreamOperator} to select input for reading.\n  */\n @Internal\n public class MultipleInputStreamTask<OUT> extends StreamTask<OUT, MultipleInputStreamOperator<OUT>> {\n+\tpublic static final int MAX_TRACKED_CHECKPOINTS = 100_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3MTY5OA==", "bodyText": "I think we can end up with O(MAX_TRACKED_CHECKPOINTS ^ 2) here, right?\nEven though it shouldn't happen normally (if map is cleared by triggerOnBarrier/abort), I think it's better to cap it by either using LinkedHashMap, TreeMap, or just reducing\nMAX_TRACKED_CHECKPOINTS to something very small.", "url": "https://github.com/apache/flink/pull/13465#discussion_r494371698", "createdAt": "2020-09-24T14:36:14Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +137,81 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\t/**\n+\t\t\t\t\t * Contrary to {@link SourceStreamTask}, we are not using here\n+\t\t\t\t\t * {@link StreamTask#latestAsyncCheckpointStartDelayNanos} to measure the start delay\n+\t\t\t\t\t * metric, but we will be using {@link CheckpointBarrierHandler#getCheckpointStartDelayNanos()}\n+\t\t\t\t\t * instead.\n+\t\t\t\t\t */\n+\t\t\t\t\tpendingCheckpointCompletedFutures.put(metadata.getCheckpointId(), resultFuture);\n+\t\t\t\t\tcheckPendingCheckpointCompletedFuturesSize();\n+\t\t\t\t\ttriggerSourcesCheckpoint(new CheckpointBarrier(metadata.getCheckpointId(), metadata.getTimestamp(), options));\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t// Report the failure both via the Future result but also to the mailbox\n+\t\t\t\t\tpendingCheckpointCompletedFutures.remove(metadata.getCheckpointId());\n+\t\t\t\t\tresultFuture.completeExceptionally(ex);\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\t\"checkpoint %s with %s\",\n+\t\t\tmetadata,\n+\t\t\toptions);\n+\t\treturn resultFuture;\n+\t}\n+\n+\tprivate void checkPendingCheckpointCompletedFuturesSize() {\n+\t\twhile (pendingCheckpointCompletedFutures.size() > MAX_TRACKED_CHECKPOINTS) {\n+\t\t\tLong minCheckpointID = Collections.min(pendingCheckpointCompletedFutures.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1"}, "originalPosition": 118}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "committedDate": "2020-09-24T14:21:44Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "ef4d75dea974295ad688c5866dbde706cffe579c", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ef4d75dea974295ad688c5866dbde706cffe579c", "committedDate": "2020-09-24T14:47:17Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjU5NTk3", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-495659597", "createdAt": "2020-09-24T14:53:26Z", "commit": {"oid": "57fd9e04e148e73743f469bb53be84ef523fb8f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo1MzoyNlrOHXe4Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo1MzoyNlrOHXe4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4NTIwMw==", "bodyText": "It's odd to see BlockableInput without any explicit block function. Maybe it's more about CheckpointableInput?", "url": "https://github.com/apache/flink/pull/13465#discussion_r494385203", "createdAt": "2020-09-24T14:53:26Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BlockableInput.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Input, with just basic methods for blocking and resuming consumption. It can be for example an {@link InputGate}\n+ */\n+@Internal\n+public interface BlockableInput {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57fd9e04e148e73743f469bb53be84ef523fb8f4"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc1MDky", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-495675092", "createdAt": "2020-09-24T15:08:27Z", "commit": {"oid": "ef4d75dea974295ad688c5866dbde706cffe579c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTowODoyN1rOHXfkuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTowODoyN1rOHXfkuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NjYwMw==", "bodyText": "resumeConsumption could be implicitly triggered by checkpointStopped.\nThen, the last unfitting method is blockConsumption, which could be modeled as void barrierReceived(int channelIndex, CheckpointBarrier barrier); (and it wouldn't be odd that it's ignored by InputGate).", "url": "https://github.com/apache/flink/pull/13465#discussion_r494396603", "createdAt": "2020-09-24T15:08:27Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BlockableInput.java", "diffHunk": "@@ -26,9 +26,12 @@\n \n /**\n  * Input, with just basic methods for blocking and resuming consumption. It can be for example an {@link InputGate}\n+ * or a chained source.\n  */\n @Internal\n public interface BlockableInput {\n+\tvoid blockConsumption(int inputChannelIdx);\n+\n \tvoid resumeConsumption(int channelIndex) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef4d75dea974295ad688c5866dbde706cffe579c"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d11ce95c29fc032e38c57228fb07e85106a6931e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/d11ce95c29fc032e38c57228fb07e85106a6931e", "committedDate": "2020-09-24T16:22:46Z", "message": "[FLINK-18906][hotfix] Fix JavaDoc for in InputProcessorUtil"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96537b7ee5f691eebf2376ae93398eba1415c713", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/96537b7ee5f691eebf2376ae93398eba1415c713", "committedDate": "2020-09-24T16:22:46Z", "message": "[FLINK-18906][hotfix] Move isFinished checkState inside InputGate#resumeConsumption\n\nThis will minimize the visible interface of an Input as used by CheckpointBarrierHandlers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8d28ce802579551dc21d2d5c0fd8c6c67a9beef", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/b8d28ce802579551dc21d2d5c0fd8c6c67a9beef", "committedDate": "2020-09-24T16:22:47Z", "message": "[FLINK-18906][hotfix] Fix method names in CheckpointBarrierAlignerTestBase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c86aaf89cd1282e90610b82d717e624eb3819e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/21c86aaf89cd1282e90610b82d717e624eb3819e", "committedDate": "2020-09-24T16:22:47Z", "message": "[FLINK-18906][task] Construct StreamTaskSourceInput earlier in the OperatorChain\n\ninstead of in StreamMultipleInputProcessor. This will allow CheckpointBarrierHandlers to\nuse and reference StreamTaskSourceInput instances."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67dd035175275021c1470c0349cbd52e99682554", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/67dd035175275021c1470c0349cbd52e99682554", "committedDate": "2020-09-24T16:22:47Z", "message": "[FLINK-18906][task] Decouple CheckpointBarrierHandlers from InputGates\n\nThis is still only a refactor. It extracts an interface from the IndexedInputGate\nto be used by CheckpointBarierHandlers."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59bd0e18fb1d3d74e6b84e1501c1175e8baed76a", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/59bd0e18fb1d3d74e6b84e1501c1175e8baed76a", "committedDate": "2020-09-24T16:22:47Z", "message": "[FLINK-18906][hotfix] Provide helper and/or functions on availability futures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68d7dd1c9f46d2f1c2351af923d725d2646132c1", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/68d7dd1c9f46d2f1c2351af923d725d2646132c1", "committedDate": "2020-09-24T16:22:48Z", "message": "[FLINK-18906][task] Fix processSingleStep semantic\n\nPreviously processSingleStep call could be ignored, and wouldn't process mail actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b6162725a47e5f7e994077f8ac00b2dc758f3c7", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/4b6162725a47e5f7e994077f8ac00b2dc758f3c7", "committedDate": "2020-09-24T16:22:48Z", "message": "[FLINK-18906][test] Generalise testing code for MultipleInputStreamTask\n\nThis will allow to re-use it for checkpointing tests with chained sources"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc93dcd36ffa5fb0449fcfa51a8bce3bc2aee27e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/fc93dcd36ffa5fb0449fcfa51a8bce3bc2aee27e", "committedDate": "2020-09-24T16:22:48Z", "message": "[FLINK-18906][task] Expose InputProcessorUtil#createCheckpointBarrierHandler\n\nThis will be useful in a next commit, where MultipleInputStreamTask will need\nto have an access to the CheckpointBarrierHandler"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef4d75dea974295ad688c5866dbde706cffe579c", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ef4d75dea974295ad688c5866dbde706cffe579c", "committedDate": "2020-09-24T14:47:17Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "5799b14d314e5b58b2c46a56c3a6ca8132660303", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/5799b14d314e5b58b2c46a56c3a6ca8132660303", "committedDate": "2020-09-24T16:22:48Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTA3MDI4", "url": "https://github.com/apache/flink/pull/13465#pullrequestreview-496107028", "createdAt": "2020-09-25T04:45:14Z", "commit": {"oid": "5799b14d314e5b58b2c46a56c3a6ca8132660303"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3276e0e9b8c435529255acc155a3c3236418330", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/c3276e0e9b8c435529255acc155a3c3236418330", "committedDate": "2020-09-25T06:08:39Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5799b14d314e5b58b2c46a56c3a6ca8132660303", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/5799b14d314e5b58b2c46a56c3a6ca8132660303", "committedDate": "2020-09-24T16:22:48Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}, "afterCommit": {"oid": "c3276e0e9b8c435529255acc155a3c3236418330", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/c3276e0e9b8c435529255acc155a3c3236418330", "committedDate": "2020-09-25T06:08:39Z", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4224, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}