{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4ODA2MjQ0", "number": 12186, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNDozNjoyNFrOD9D7Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwODo0OTozOVrOD9Jhhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU0MDUxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNDozNjoyNFrOGWYJqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNzo0MTowN1rOGWY3Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzU0NQ==", "bodyText": "I wonder if we shouldn't throw some exception?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426117545", "createdAt": "2020-05-16T04:36:24Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -174,7 +174,9 @@ public void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> oper\n \t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n \n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointComplete(checkpointId);\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyNzI4Ng==", "bodyText": "It depends on what we are trying to achieve. Assume that we have a chain source -> map -> sink and source and map have been closed already. Wouldn't it be nice to still commit stuff in sink?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426127286", "createdAt": "2020-05-16T07:09:47Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -174,7 +174,9 @@ public void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> oper\n \t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n \n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointComplete(checkpointId);\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzU0NQ=="}, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyNzU2OA==", "bodyText": "If one operator is closed in the chain, doesn't it mean all of them are closed?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426127568", "createdAt": "2020-05-16T07:14:07Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -174,7 +174,9 @@ public void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> oper\n \t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n \n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointComplete(checkpointId);\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzU0NQ=="}, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyOTE5NA==", "bodyText": "Not with the wrapper. It closes them one after another from head to tail with mails. That's why the notify can sneak in in the first place.\nOnly when one operator is closed completed, the next operator in line is closed.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426129194", "createdAt": "2020-05-16T07:41:07Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -174,7 +174,9 @@ public void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> oper\n \t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n \n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointComplete(checkpointId);\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzU0NQ=="}, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzU0MTMzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNDozODowN1rOGWYKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwNzoyNDoxMlrOGWYy5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzY1OA==", "bodyText": "ditto about exception or letting checkpoint coordinator know, that this checkpoint was declined. Otherwise, aren't we risking a situation where this checkpoint will complete, despite this operator not participating in it?\nAlso it might be better to move this if check much higher, somewhere to the top of checkpointState method?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426117658", "createdAt": "2020-05-16T04:38:07Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -279,16 +281,18 @@ private void takeSnapshotSync(\n \n \t\ttry {\n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorSnapshotsInProgress.put(\n-\t\t\t\t\toperatorWrapper.getStreamOperator().getOperatorID(),\n-\t\t\t\t\tbuildOperatorSnapshotFutures(\n-\t\t\t\t\t\tcheckpointMetaData,\n-\t\t\t\t\t\tcheckpointOptions,\n-\t\t\t\t\t\toperatorChain,\n-\t\t\t\t\t\toperatorWrapper.getStreamOperator(),\n-\t\t\t\t\t\tisCanceled,\n-\t\t\t\t\t\tchannelStateWriteResult,\n-\t\t\t\t\t\tstorage));\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyNzM0Ng==", "bodyText": "Here I guess you are right, inconsistent checkpoint does not make any sense.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426127346", "createdAt": "2020-05-16T07:10:31Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -279,16 +281,18 @@ private void takeSnapshotSync(\n \n \t\ttry {\n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorSnapshotsInProgress.put(\n-\t\t\t\t\toperatorWrapper.getStreamOperator().getOperatorID(),\n-\t\t\t\t\tbuildOperatorSnapshotFutures(\n-\t\t\t\t\t\tcheckpointMetaData,\n-\t\t\t\t\t\tcheckpointOptions,\n-\t\t\t\t\t\toperatorChain,\n-\t\t\t\t\t\toperatorWrapper.getStreamOperator(),\n-\t\t\t\t\t\tisCanceled,\n-\t\t\t\t\t\tchannelStateWriteResult,\n-\t\t\t\t\t\tstorage));\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzY1OA=="}, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyODEwMQ==", "bodyText": "But we have to be careful with the implementation here. I think we can not simply throw an exception, as after fixing https://issues.apache.org/jira/browse/FLINK-17350 (my PR pending review), exceptions thrown from here would fail the task immediately.\nOn the other hand, letting this task continue running (even if it's closing?), we could repeat some mistakes from FLINK-17350.\nBut as there was no exception in any of the operators, I think it might be fine to just cancel this checkpoint, clean it up and decline it (inform CheckpointCoordinator that it has failed).\nAnother complication might be, how is this suppose to work with stop with savepoint? I hope isClosed() couldn't happen in that scenario, since failures while stopping with savepoint might be irrecoverable.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426128101", "createdAt": "2020-05-16T07:24:12Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -279,16 +281,18 @@ private void takeSnapshotSync(\n \n \t\ttry {\n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorSnapshotsInProgress.put(\n-\t\t\t\t\toperatorWrapper.getStreamOperator().getOperatorID(),\n-\t\t\t\t\tbuildOperatorSnapshotFutures(\n-\t\t\t\t\t\tcheckpointMetaData,\n-\t\t\t\t\t\tcheckpointOptions,\n-\t\t\t\t\t\toperatorChain,\n-\t\t\t\t\t\toperatorWrapper.getStreamOperator(),\n-\t\t\t\t\t\tisCanceled,\n-\t\t\t\t\t\tchannelStateWriteResult,\n-\t\t\t\t\t\tstorage));\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzY1OA=="}, "originalCommit": {"oid": "a3129c8853f1b9af6ceb3a1f8749a70a7dc2f9f2"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzY1ODk1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozMDo0OFrOGWZFBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNDoxNDoxN1rOGWakVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjc0MQ==", "bodyText": "Maybe it would be better push the isClosed() checks into the wrapper class? And instead of:\nif (!operatorWrapper.isClosed()) {\n\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n}\n\nhave here (and in other places):\noperatorWrapper.prepareSnapshotPreBarrier(checkpointId);\n\n?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426132741", "createdAt": "2020-05-16T08:30:48Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -262,7 +262,9 @@ public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {\n \t\t// go forward through the operator chain and tell each operator\n \t\t// to prepare the checkpoint\n \t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : getAllOperators()) {\n-\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\tif (!operatorWrapper.isClosed()) {\n+\t\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0NDM3MQ==", "bodyText": "I was also think about that. The question is should we then replace it for all StreamOperatorWrapper.getOperator  calls eventually?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426144371", "createdAt": "2020-05-16T11:14:39Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -262,7 +262,9 @@ public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {\n \t\t// go forward through the operator chain and tell each operator\n \t\t// to prepare the checkpoint\n \t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : getAllOperators()) {\n-\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\tif (!operatorWrapper.isClosed()) {\n+\t\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjc0MQ=="}, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NzE0Mw==", "bodyText": "Maybe in the future?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426157143", "createdAt": "2020-05-16T14:14:17Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java", "diffHunk": "@@ -262,7 +262,9 @@ public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {\n \t\t// go forward through the operator chain and tell each operator\n \t\t// to prepare the checkpoint\n \t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : getAllOperators()) {\n-\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\tif (!operatorWrapper.isClosed()) {\n+\t\t\t\toperatorWrapper.getStreamOperator().prepareSnapshotPreBarrier(checkpointId);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjc0MQ=="}, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzY2MzAyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozOToxNFrOGWZHIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxMToxNDo1NFrOGWZylQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzI4MA==", "bodyText": "isn't this a duplicated call, now with the same check above?", "url": "https://github.com/apache/flink/pull/12186#discussion_r426133280", "createdAt": "2020-05-16T08:39:14Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -269,16 +284,18 @@ private void takeSnapshotSync(\n \n \t\ttry {\n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorSnapshotsInProgress.put(\n-\t\t\t\t\toperatorWrapper.getStreamOperator().getOperatorID(),\n-\t\t\t\t\tbuildOperatorSnapshotFutures(\n-\t\t\t\t\t\tcheckpointMetaData,\n-\t\t\t\t\t\tcheckpointOptions,\n-\t\t\t\t\t\toperatorChain,\n-\t\t\t\t\t\toperatorWrapper.getStreamOperator(),\n-\t\t\t\t\t\tisCanceled,\n-\t\t\t\t\t\tchannelStateWriteResult,\n-\t\t\t\t\t\tstorage));\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0NDQwNQ==", "bodyText": "yep sorry that's a left over from the previous version.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426144405", "createdAt": "2020-05-16T11:14:54Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -269,16 +284,18 @@ private void takeSnapshotSync(\n \n \t\ttry {\n \t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n-\t\t\t\toperatorSnapshotsInProgress.put(\n-\t\t\t\t\toperatorWrapper.getStreamOperator().getOperatorID(),\n-\t\t\t\t\tbuildOperatorSnapshotFutures(\n-\t\t\t\t\t\tcheckpointMetaData,\n-\t\t\t\t\t\tcheckpointOptions,\n-\t\t\t\t\t\toperatorChain,\n-\t\t\t\t\t\toperatorWrapper.getStreamOperator(),\n-\t\t\t\t\t\tisCanceled,\n-\t\t\t\t\t\tchannelStateWriteResult,\n-\t\t\t\t\t\tstorage));\n+\t\t\t\tif (!operatorWrapper.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzI4MA=="}, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzY2NDc5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODo0MTowN1rOGWZH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODo0MTowN1rOGWZH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzQ4Nw==", "bodyText": "oO I haven't tested it with OneInputStreamTask::new :) Good to know that it's working.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426133487", "createdAt": "2020-05-16T08:41:07Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java", "diffHunk": "@@ -934,6 +936,62 @@ public void testOperatorClosingBeforeStopRunning() throws Throwable {\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests that {@link StreamTask#notifyCheckpointCompleteAsync(long)} is not relayed to closed operators.\n+\t *\n+\t * <p>See FLINK-16383.\n+\t */\n+\t@Test\n+\tpublic void testNotifyCheckpointOnClosedOperator() throws Throwable {\n+\t\tClosingOperator operator = new ClosingOperator();\n+\t\tMultipleInputStreamTaskTestHarnessBuilder<Integer> builder =\n+\t\t\tnew MultipleInputStreamTaskTestHarnessBuilder<>(OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)\n+\t\t\t\t.addInput(BasicTypeInfo.INT_TYPE_INFO);\n+\t\tStreamTaskMailboxTestHarness<Integer> harness = builder\n+\t\t\t.setupOutputForSingletonOperatorChain(operator)\n+\t\t\t.build();\n+\t\t// keeps the mailbox from suspending\n+\t\tharness.setAutoProcess(false);\n+\t\tharness.processElement(new StreamRecord<>(1));\n+\n+\t\tharness.streamTask.notifyCheckpointCompleteAsync(1);\n+\t\tharness.streamTask.runMailboxStep();\n+\t\tassertEquals(1, operator.notified.get());\n+\t\tassertEquals(false, operator.closed.get());\n+\n+\t\t// close operators directly, so that task is still fully running\n+\t\tharness.streamTask.operatorChain.closeOperators(harness.streamTask.getActionExecutor());\n+\t\tharness.streamTask.notifyCheckpointCompleteAsync(2);\n+\t\tharness.streamTask.runMailboxStep();\n+\t\tassertEquals(1, operator.notified.get());\n+\t\tassertEquals(true, operator.closed.get());\n+\t}\n+\n+\t/**\n+\t * Tests that checkpoints are declined if operators are (partially) closed.\n+\t *\n+\t * <p>See FLINK-16383.\n+\t */\n+\t@Test\n+\tpublic void testCheckpointDeclinedOnClosedOperator() throws Throwable {\n+\t\tClosingOperator operator = new ClosingOperator();\n+\t\tMultipleInputStreamTaskTestHarnessBuilder<Integer> builder =\n+\t\t\tnew MultipleInputStreamTaskTestHarnessBuilder<>(OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25f5493bb635b3876ef629cdfb87b3d7a6aa8fff"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDQ1NzY3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureReason.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwODo0OTozOVrOGWfVBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNTo0MzoxMlrOGWhxpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNTE0Mg==", "bodyText": "I think this is missing a relevant entry in CheckpointFailureManager switch/case", "url": "https://github.com/apache/flink/pull/12186#discussion_r426235142", "createdAt": "2020-05-17T08:49:39Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureReason.java", "diffHunk": "@@ -44,6 +44,8 @@\n \n \tCHECKPOINT_DECLINED_TASK_NOT_READY(false, \"Checkpoint was declined (tasks not ready)\"),\n \n+\tCHECKPOINT_DECLINED_TASK_CLOSING(false, \"Checkpoint was declined (task's operators partially closed)\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17deb1ace51d274715027adbeb607feb3958347a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTIzNw==", "bodyText": "Ah jesus, wtf is this monstrosity. But fixed.", "url": "https://github.com/apache/flink/pull/12186#discussion_r426275237", "createdAt": "2020-05-17T15:43:12Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureReason.java", "diffHunk": "@@ -44,6 +44,8 @@\n \n \tCHECKPOINT_DECLINED_TASK_NOT_READY(false, \"Checkpoint was declined (tasks not ready)\"),\n \n+\tCHECKPOINT_DECLINED_TASK_CLOSING(false, \"Checkpoint was declined (task's operators partially closed)\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNTE0Mg=="}, "originalCommit": {"oid": "17deb1ace51d274715027adbeb607feb3958347a"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1340, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}