{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNjg5MDU2", "number": 10832, "title": "[FLINK-14163][runtime]Enforce synchronous registration of Execution#producedPartitions", "bodyText": "What is the purpose of the change\nExecution#producedPartitions are registered through an asynchronous interface ShuffleMaster#registerPartitionWithProducer to ShuffleMaster, however they are not always accessed through callbacks. So, it is possible that Execution#producedPartitions have not been available yet when accessed (in Execution#deploy for example). Since the only implementation of ShuffleMaster is NettyShuffleMaster, which indeed registers producedPartition in a synchronous way, this pull request enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.\nBrief change log\n\nMake sure the future of registration is done immediately after registration.\nThrows IllegalStateException otherwise.\n\nVerifying this change\nunit test:\nExecutionTest#testSynchronousRegisterProducedPartitions\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): no\nThe public API, i.e., is any changed class annotated with @Public(Evolving): no\nThe serializers: no\nThe runtime per-record code paths (performance sensitive): no\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: no\nThe S3 file system connector: no\n\nDocumentation\n\nDoes this pull request introduce a new feature? no\nIf yes, how is the feature documented? JavaDocs", "createdAt": "2020-01-11T03:20:28Z", "url": "https://github.com/apache/flink/pull/10832", "merged": true, "mergeCommit": {"oid": "6fa1ea1caa0de4892e5942f760305422859585da"}, "closed": true, "closedAt": "2020-01-17T14:34:53Z", "author": {"login": "curcur"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb5KkOlABqjI5NDAzNjE5NTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7PtbBgBqjI5NTgzNTQ3ODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f327a0f2cf227e32c6c46fd0a698117d972a35eb", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/f327a0f2cf227e32c6c46fd0a698117d972a35eb", "committedDate": "2020-01-11T03:01:00Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of Execution#producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, hence this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "5eb1599945f1bee35c342f762cc25684013d2d83", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/5eb1599945f1bee35c342f762cc25684013d2d83", "committedDate": "2020-01-11T03:26:36Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, hence this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5eb1599945f1bee35c342f762cc25684013d2d83", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/5eb1599945f1bee35c342f762cc25684013d2d83", "committedDate": "2020-01-11T03:26:36Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, hence this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/73579bbc6b556fe42e55e21581c5994f84480843", "committedDate": "2020-01-12T01:51:34Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzM0MzQ5", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-341734349", "createdAt": "2020-01-13T10:02:22Z", "commit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDowMjoyMlrOFcxzHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDoyODo1NlrOFcygtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDM1MA==", "bodyText": "We are trying to get rid of Mockito in flink tests.\nIf we are touching this part, I'd prefer to introduce a mock ExecutionEdge class for this purpose.", "url": "https://github.com/apache/flink/pull/10832#discussion_r365720350", "createdAt": "2020-01-13T10:02:22Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -431,6 +433,18 @@ public static ExecutionJobVertex getExecutionVertex(JobVertexID id) throws Excep\n \t\treturn getExecutionVertex(id, new DirectScheduledExecutorService());\n \t}\n \n+\tpublic static ExecutionEdge createMockExecutionEdge(int maxParallelism) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMTE4NQ==", "bodyText": "I'd prefer to state that \"one must return a completed future at the moment\". It is clear enough so the user do need to refer to NettyShuffleMaster for the implementation.", "url": "https://github.com/apache/flink/pull/10832#discussion_r365721185", "createdAt": "2020-01-13T10:04:18Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.\n+\t * The default scheduler only supports synchronous registration for now.\n+\t * Please refer to {@link NettyShuffleMaster#registerPartitionWithProducer} for example.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMzYxMA==", "bodyText": "This is a temporary fix. So we'd better have a TODO here as a reminder for follow up fixes.", "url": "https://github.com/apache/flink/pull/10832#discussion_r365723610", "createdAt": "2020-01-13T10:09:49Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n+\t * synchronous registration under an asynchronous interface for now.\n+\t *\n+\t * <p>If asynchronous registration is needed in the future, use callbacks to access {@link Execution#producedPartitions}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTUzNw==", "bodyText": "Could we extend ExecutionGraphTestUtils#getExecutionVertex(...) to customize shuffleMaster and reuse it?", "url": "https://github.com/apache/flink/pull/10832#discussion_r365729537", "createdAt": "2020-01-13T10:23:10Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +557,65 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tExecutionJobVertex jobVertex = getExecutionVertex(\n+\t\t\t\tnew JobVertexID(),\n+\t\t\t\tnew DirectScheduledExecutorService(),\n+\t\t\t\tEAGER);\n+\t\tIntermediateResult result =\n+\t\t\t\tnew IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED);\n+\t\tExecutionVertex vertex =\n+\t\t\t\tnew ExecutionVertex(jobVertex, 0, new IntermediateResult[]{result}, Time.minutes(1));\n+\t\tExecutionEdge edge = createMockExecutionEdge(1);\n+\t\tresult.getPartitions()[0].addConsumerGroup();\n+\t\tresult.getPartitions()[0].addConsumer(edge, 0);\n+\t\tTaskManagerLocation location =\n+\t\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);\n+\t\tExecutionAttemptID attemptID = new ExecutionAttemptID();\n+\t\tExecution.registerProducedPartitions(vertex, location, attemptID, EAGER.allowLazyDeployment());\n+\t}\n+\n+\t@Nonnull\n+\tprivate ExecutionJobVertex getExecutionVertex(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMjAyMA==", "bodyText": "Are these lines necessary?", "url": "https://github.com/apache/flink/pull/10832#discussion_r365732020", "createdAt": "2020-01-13T10:28:56Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +557,65 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tExecutionJobVertex jobVertex = getExecutionVertex(\n+\t\t\t\tnew JobVertexID(),\n+\t\t\t\tnew DirectScheduledExecutorService(),\n+\t\t\t\tEAGER);\n+\t\tIntermediateResult result =\n+\t\t\t\tnew IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED);\n+\t\tExecutionVertex vertex =\n+\t\t\t\tnew ExecutionVertex(jobVertex, 0, new IntermediateResult[]{result}, Time.minutes(1));\n+\t\tExecutionEdge edge = createMockExecutionEdge(1);\n+\t\tresult.getPartitions()[0].addConsumerGroup();\n+\t\tresult.getPartitions()[0].addConsumer(edge, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73579bbc6b556fe42e55e21581c5994f84480843", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/73579bbc6b556fe42e55e21581c5994f84480843", "committedDate": "2020-01-12T01:51:34Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "e303d84258f1e63edd45867f6c4e89e181307ee5", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/e303d84258f1e63edd45867f6c4e89e181307ee5", "committedDate": "2020-01-14T09:38:21Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e303d84258f1e63edd45867f6c4e89e181307ee5", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/e303d84258f1e63edd45867f6c4e89e181307ee5", "committedDate": "2020-01-14T09:38:21Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "426112c59a86ec127040178efda1085231f1988f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/426112c59a86ec127040178efda1085231f1988f", "committedDate": "2020-01-14T12:41:30Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTcxMjQx", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-342971241", "createdAt": "2020-01-15T03:26:52Z", "commit": {"oid": "426112c59a86ec127040178efda1085231f1988f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMzoyNjo1M1rOFdsdPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMzozMTowM1rOFdsf6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTQwNQ==", "bodyText": "I know that ExecutionGraphTestUtils did have several getExecutionVertex (...) methods to map JobVertexID to ExecutionJobVertex , but I think it's better we rename the old and newly added ones to getExecutionJobVertex (...). Because ExecutionVertex is a structure different from ExecutionJobVertex.", "url": "https://github.com/apache/flink/pull/10832#discussion_r366681405", "createdAt": "2020-01-15T03:26:53Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -398,6 +401,10 @@ public static JobVertex createJobVertex(String task1, int numTasks, Class<NoOpIn\n \t\treturn groupVertex;\n \t}\n \n+\tpublic static ExecutionJobVertex getExecutionVertex(JobVertexID id) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "426112c59a86ec127040178efda1085231f1988f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTU3MA==", "bodyText": "One indentation from the initial line is expected here.", "url": "https://github.com/apache/flink/pull/10832#discussion_r366681570", "createdAt": "2020-01-15T03:28:05Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -416,20 +431,17 @@ public static ExecutionJobVertex getExecutionVertex(\n \t\tjobGraph.setScheduleMode(scheduleMode);\n \n \t\tExecutionGraph graph = TestingExecutionGraphBuilder\n-\t\t\t.newBuilder()\n-\t\t\t.setJobGraph(jobGraph)\n-\t\t\t.setIoExecutor(executor)\n-\t\t\t.setFutureExecutor(executor)\n-\t\t\t.build();\n+\t\t\t\t.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "426112c59a86ec127040178efda1085231f1988f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MjA4OQ==", "bodyText": "This is not a must, but I'd still suggest to try to mark the variables final if possible, like we do in other parts in this test class.", "url": "https://github.com/apache/flink/pull/10832#discussion_r366682089", "createdAt": "2020-01-15T03:31:03Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +553,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tScheduledExecutorService executor = new DirectScheduledExecutorService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "426112c59a86ec127040178efda1085231f1988f"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "426112c59a86ec127040178efda1085231f1988f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/426112c59a86ec127040178efda1085231f1988f", "committedDate": "2020-01-14T12:41:30Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "fe731e4a039fba606be83a9535841c157a048d58", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/fe731e4a039fba606be83a9535841c157a048d58", "committedDate": "2020-01-15T05:52:20Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDM2OTYy", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-343036962", "createdAt": "2020-01-15T07:57:38Z", "commit": {"oid": "fe731e4a039fba606be83a9535841c157a048d58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzo1NzozOVrOFdvtXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzo1NzozOVrOFdvtXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczNDY4Nw==", "bodyText": "I think we should create an ExecutionGraph and get the vertices from it rather than using this getExecutionVertex(...) to create vertices. Otherwise these 2 vertices are actually from 2 different ExecutionGraphs.\nIn this way you do not need to create edges manually. You can leverage TestingExecutionGraphBuilder to build an ExecutionGraph and set the wanted shuffle master.", "url": "https://github.com/apache/flink/pull/10832#discussion_r366734687", "createdAt": "2020-01-15T07:57:39Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +553,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ScheduledExecutorService executor = new DirectScheduledExecutorService();\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\n+\t\tfinal ExecutionJobVertex sourceJobVertex = getExecutionVertex(new JobVertexID(), executor, EAGER, shuffleMaster);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe731e4a039fba606be83a9535841c157a048d58"}, "originalPosition": 63}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe731e4a039fba606be83a9535841c157a048d58", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/fe731e4a039fba606be83a9535841c157a048d58", "committedDate": "2020-01-15T05:52:20Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "1278b4488cb8bc05addaf359458ed4bae6c1967b", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/1278b4488cb8bc05addaf359458ed4bae6c1967b", "committedDate": "2020-01-16T04:13:02Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1278b4488cb8bc05addaf359458ed4bae6c1967b", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/1278b4488cb8bc05addaf359458ed4bae6c1967b", "committedDate": "2020-01-16T04:13:02Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "committedDate": "2020-01-16T05:22:14Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzA0MTU2", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-343704156", "createdAt": "2020-01-16T06:57:02Z", "commit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTc2Mzcy", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-343976372", "createdAt": "2020-01-16T15:00:55Z", "commit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNTowMDo1NVrOFecW_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNToxNzo1OVrOFec-0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2NjIzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n          \n          \n            \n            \t * Tests that we reject incompleted futures returned by {@link ShuffleMaster#registerPartitionWithProducer...}.", "url": "https://github.com/apache/flink/pull/10832#discussion_r367466238", "createdAt": "2020-01-16T15:00:55Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2NzU1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n          \n          \n            \n            \tpublic void testIncompletePartitionRegistrationFutureIsRejected() throws Exception {", "url": "https://github.com/apache/flink/pull/10832#discussion_r367467557", "createdAt": "2020-01-16T15:03:12Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2ODY5OQ==", "bodyText": "I prefer try/catch blocks since they guarantee the exception occurs where we want it to.", "url": "https://github.com/apache/flink/pull/10832#discussion_r367468699", "createdAt": "2020-01-16T15:05:08Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MTcyNg==", "bodyText": "use LocalTaskManagerLocation instead", "url": "https://github.com/apache/flink/pull/10832#discussion_r367471726", "createdAt": "2020-01-16T15:10:09Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\t\tfinal JobGraph jobGraph = new JobGraph(\"job graph\");\n+\t\tfinal JobVertex source = new JobVertex(\"source\");\n+\t\tfinal JobVertex target = new JobVertex(\"target\");\n+\n+\t\tsource.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.connectNewDataSetAsInput(source, POINTWISE, PIPELINED);\n+\t\tjobGraph.addVertex(source);\n+\t\tjobGraph.addVertex(target);\n+\t\tExecutionGraph executionGraph = TestingExecutionGraphBuilder\n+\t\t\t.newBuilder()\n+\t\t\t.setJobGraph(jobGraph)\n+\t\t\t.setShuffleMaster(shuffleMaster)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionVertex sourceVertex = executionGraph.getAllVertices().get(source.getID()).getTaskVertices()[0];\n+\t\tfinal TaskManagerLocation location =\n+\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3Mjg0Nw==", "bodyText": "Pretty roundabout way of defining the deployment mode; is it even relevant for this test?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tExecution.registerProducedPartitions(sourceVertex, location, attemptID, EAGER.allowLazyDeployment());\n          \n          \n            \n            \t\tExecution.registerProducedPartitions(sourceVertex, new LocalTaskManagerLocation(), new ExecutionAttemptID(), false);", "url": "https://github.com/apache/flink/pull/10832#discussion_r367472847", "createdAt": "2020-01-16T15:11:52Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\t\tfinal JobGraph jobGraph = new JobGraph(\"job graph\");\n+\t\tfinal JobVertex source = new JobVertex(\"source\");\n+\t\tfinal JobVertex target = new JobVertex(\"target\");\n+\n+\t\tsource.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.connectNewDataSetAsInput(source, POINTWISE, PIPELINED);\n+\t\tjobGraph.addVertex(source);\n+\t\tjobGraph.addVertex(target);\n+\t\tExecutionGraph executionGraph = TestingExecutionGraphBuilder\n+\t\t\t.newBuilder()\n+\t\t\t.setJobGraph(jobGraph)\n+\t\t\t.setShuffleMaster(shuffleMaster)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionVertex sourceVertex = executionGraph.getAllVertices().get(source.getID()).getTaskVertices()[0];\n+\t\tfinal TaskManagerLocation location =\n+\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);\n+\t\tfinal ExecutionAttemptID attemptID = new ExecutionAttemptID();\n+\t\tExecution.registerProducedPartitions(sourceVertex, location, attemptID, EAGER.allowLazyDeployment());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzE5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * is done immediately.\n          \n          \n            \n            \t * is completed immediately.", "url": "https://github.com/apache/flink/pull/10832#discussion_r367473190", "createdAt": "2020-01-16T15:12:23Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzQxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n          \n          \n            \n            \t * which indeed registers producedPartition in a synchronous way, this method enforces", "url": "https://github.com/apache/flink/pull/10832#discussion_r367473419", "createdAt": "2020-01-16T15:12:49Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NDMyMw==", "bodyText": "Replace block with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.\n          \n          \n            \n            \t * <p>IMPORTANT: The returned future must be completed due to limitations in the current scheduler.", "url": "https://github.com/apache/flink/pull/10832#discussion_r367474323", "createdAt": "2020-01-16T15:14:20Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NDc3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ProducedPartitions are expected to be registered and accessible\");\n          \n          \n            \n            \t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ShuffleDescriptor future was incomplete.\");", "url": "https://github.com/apache/flink/pull/10832#discussion_r367474772", "createdAt": "2020-01-16T15:15:04Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -626,6 +647,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t\t.getShuffleMaster()\n \t\t\t\t.registerPartitionWithProducer(partitionDescriptor, producerDescriptor);\n \n+\t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ProducedPartitions are expected to be registered and accessible\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return a CompletableFuture for registered producedPartitions. In the current version, the CompletableFuture has already completed.\n          \n          \n            \n            \t * @return a completed future of partition deployment descriptors", "url": "https://github.com/apache/flink/pull/10832#discussion_r367475499", "createdAt": "2020-01-16T15:16:22Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n+\t * synchronous registration under an asynchronous interface for now.\n+\t *\n+\t * <p>TODO: If asynchronous registration is needed in the future, use callbacks to access {@link Execution#producedPartitions}.\n+\t *\n+\t * @return a CompletableFuture for registered producedPartitions. In the current version, the CompletableFuture has already completed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NjQzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \t\t\t// temporary hack; the scheduler does not handle incomplete futures properly", "url": "https://github.com/apache/flink/pull/10832#discussion_r367476432", "createdAt": "2020-01-16T15:17:59Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -626,6 +647,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t\t.getShuffleMaster()\n \t\t\t\t.registerPartitionWithProducer(partitionDescriptor, producerDescriptor);\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "committedDate": "2020-01-16T05:22:14Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "66afb2a54d5da715b3d59bdf58a4de12af833c2f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/66afb2a54d5da715b3d59bdf58a4de12af833c2f", "committedDate": "2020-01-17T06:21:16Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66afb2a54d5da715b3d59bdf58a4de12af833c2f", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/66afb2a54d5da715b3d59bdf58a4de12af833c2f", "committedDate": "2020-01-17T06:21:16Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "f2d45fd25663092d9a11e0798900fb886ed46ba3", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/f2d45fd25663092d9a11e0798900fb886ed46ba3", "committedDate": "2020-01-17T06:31:37Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2d45fd25663092d9a11e0798900fb886ed46ba3", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/f2d45fd25663092d9a11e0798900fb886ed46ba3", "committedDate": "2020-01-17T06:31:37Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "committedDate": "2020-01-17T07:33:06Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTE5NTk1", "url": "https://github.com/apache/flink/pull/10832#pullrequestreview-344519595", "createdAt": "2020-01-17T11:29:03Z", "commit": {"oid": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyOTowM1rOFe2U8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyOTowM1rOFe2U8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTY5Nw==", "bodyText": "This line and the one below effectively do not provide any new information; I'd remove them.", "url": "https://github.com/apache/flink/pull/10832#discussion_r367891697", "createdAt": "2020-01-17T11:29:03Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: the returned future must be completed due to limitations in the default scheduler.\n+\t * The default scheduler only supports synchronous registration at the moment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "committedDate": "2020-01-17T14:32:27Z", "message": "[FLINK-14163][runtime] Enforce synchronous registration of produced partitions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "committedDate": "2020-01-17T07:33:06Z", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses."}, "afterCommit": {"oid": "ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "author": {"user": {"login": "curcur", "name": "Yuan Mei"}}, "url": "https://github.com/apache/flink/commit/ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "committedDate": "2020-01-17T14:32:27Z", "message": "[FLINK-14163][runtime] Enforce synchronous registration of produced partitions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4665, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}