{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MDgxMzg5", "number": 12722, "title": "[FLINK-18064][docs] Added unaligned checkpointing to docs.", "bodyText": "What is the purpose of the change\nAdds documentation about unaligned checkpoints.\nBrief change log\n\nAdded Python API to enable unaligned checkpoints.\n\nDoc is split into 3 parts to simulate the description of aligned checkpointing:\n\nIt's added on conceptual level in stateful-stream-processing.md with new/revised pics. It's written in a way that it could survive 1.12 without change.\nA small change to dev/stream/state/checkpointing.md to show how it is enabled programmatically in Java/Scala/Python. Might need to be extended for 1.12 when new options become available (depending whether they can be programmatically changed or not).\nA larger discussion in ops/state/checkpoints.md which includes the current limitations and a small glimpse into the next steps (will be in much more detail in blog post). This part needs to be largely rewritten for 1.12+ to reflect the new options.\n\nVerifying this change\nFor Python API, added case in test_check_point_config.py.\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-06-19T12:45:03Z", "url": "https://github.com/apache/flink/pull/12722", "merged": true, "mergeCommit": {"oid": "58c2047133d61073cb3e75fa092d102d3c7b4414"}, "closed": true, "closedAt": "2020-06-29T08:43:58Z", "author": {"login": "AHeise"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcs4LoIABqjM0NjM2NTI0ODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuev3dABqjM0Nzg4NzA5MDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d162c9220ef2f2d08cdc09ab10287cd9b56e1b67", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/d162c9220ef2f2d08cdc09ab10287cd9b56e1b67", "committedDate": "2020-06-19T12:42:52Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}, "afterCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/a1b55138a68d11ee5987199b1a4440429be0e9b0", "committedDate": "2020-06-19T19:25:53Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Njc1MDM3", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-434675037", "createdAt": "2020-06-22T07:42:32Z", "commit": {"oid": "d162c9220ef2f2d08cdc09ab10287cd9b56e1b67"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo0Mjo1NFrOGm1S3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzo1MjoxNlrOGm1lsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MjI1Mw==", "bodyText": "Hum, not sure I'd change this title, it might be more confusing than helpful. The sentence you have below is clarifying enough (\"Since Flink 1.11, checkpoints can be taken with or without alignment. In the\nfollowing, we describe aligned checkpoints first.\").", "url": "https://github.com/apache/flink/pull/12722#discussion_r443372253", "createdAt": "2020-06-22T07:42:54Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzE3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The figure depicts how an operator handle unaligned checkpoint barriers:\n          \n          \n            \n            The figure depicts how an operator handles unaligned checkpoint barriers:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373177", "createdAt": "2020-06-22T07:44:46Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzU3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            as possible. It's especially suited for application with at least one slow \n          \n          \n            \n            as possible. It's especially suited for applications with at least one slow", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373576", "createdAt": "2020-06-22T07:45:36Z", "author": {"login": "morsapaes"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            high due to back-pressure. Then, checkpointing time becomes mostly\n          \n          \n            \n            high due to backpressure. Then, checkpointing time becomes mostly", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375348", "createdAt": "2020-06-22T07:48:59Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTQ2OA==", "bodyText": "Just for the sake of coherence.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375468", "createdAt": "2020-06-22T07:49:12Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NjA0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons.\n          \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443376044", "createdAt": "2020-06-22T07:50:14Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NzA3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            checkpoints**, while window operators are safe to use. The work-around is to\n          \n          \n            \n            checkpoints**, while window operators are safe to use. The workaround is to", "url": "https://github.com/apache/flink/pull/12722#discussion_r443377072", "createdAt": "2020-06-22T07:52:16Z", "author": {"login": "morsapaes"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The work-around is to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NjkyODMx", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-434692831", "createdAt": "2020-06-22T08:07:51Z", "commit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODowNzo1MlrOGm2FTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODoyNzowNFrOGm2uPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA==", "bodyText": "To my understanding, there are were papers: one by Lamport and one by DataArtisans.\nOne of the differences is that the former proposed to persist channel state, while the latter proposed alignment (I might be wrong).\nSo it's probably better to move reference to the paper by Lamport to Unaligned section and mention \"Flink\" paper in this Aligned section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443385164", "createdAt": "2020-06-22T08:07:52Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing\n \n The central part of Flink's fault tolerance mechanism is drawing consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NzgzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator reacts on the first barrier that is stored in input buffers.\n          \n          \n            \n            - The operator reacts on the first barrier that is stored in its input buffers.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443387836", "createdAt": "2020-06-22T08:13:06Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5MDg4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator marks all overtaken buffers, which are asynchronously stored in\n          \n          \n            \n              the state backend together with the other operator state.\n          \n          \n            \n            - The operator marks all overtaken records to be stored asynchronously and creates a snapshot of its own state.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443390884", "createdAt": "2020-06-22T08:18:48Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA==", "bodyText": "It reads like a separate step (it's not, right?)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - It only briefly stops the processing of input to mark the buffers, forward \n          \n          \n            \n              the barrier and create the snapshot of the other state.\n          \n          \n            \n            Compared to aligned checkpoints, the operator doesn't need to suspend any of its inputs.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443392894", "createdAt": "2020-06-22T08:22:29Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mzg4NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/flink/pull/12722#discussion_r443393884", "createdAt": "2020-06-22T08:24:13Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O\n+to the state backends is the bottleneck. See the more in-depth discussion in \n+[ops]({% link ops/state/checkpoints.md %}#unaligned-checkpoints)\n+for other limitations.\n+\n+Note that savepoints will always be aligned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA==", "bodyText": "Should we mention that this is an experimental feature?\nI think it should be a separate statement in the end of the section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443395644", "createdAt": "2020-06-22T08:27:04Z", "author": {"login": "rkhachatryan"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NzI1MTUx", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-434725151", "createdAt": "2020-06-22T08:50:48Z", "commit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo1MDo0OVrOGm3juw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo1MTo1MVrOGm3mHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - You cannot rescale from unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment\n          \n          \n            \n            - You cannot rescale or change job graph with unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409339", "createdAt": "2020-06-22T08:50:49Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTk1MA==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following shortcomings:\n          \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following limitations:", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409950", "createdAt": "2020-06-22T08:51:51Z", "author": {"login": "rkhachatryan"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/a1b55138a68d11ee5987199b1a4440429be0e9b0", "committedDate": "2020-06-19T19:25:53Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}, "afterCommit": {"oid": "91dfe90937ec1c2680022a12a1c4984fd59e61cf", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/91dfe90937ec1c2680022a12a1c4984fd59e61cf", "committedDate": "2020-06-22T11:39:28Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91dfe90937ec1c2680022a12a1c4984fd59e61cf", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/91dfe90937ec1c2680022a12a1c4984fd59e61cf", "committedDate": "2020-06-22T11:39:28Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}, "afterCommit": {"oid": "e80e905a5d66919427300af45b088e33b01d46d2", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/e80e905a5d66919427300af45b088e33b01d46d2", "committedDate": "2020-06-22T11:53:53Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODQ0MjIw", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-434844220", "createdAt": "2020-06-22T11:43:57Z", "commit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo0Mzo1N1rOGm9FGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo1MzoyNVrOGm9Xdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5OTgwMA==", "bodyText": "Good question. I briefly looked at it and it seems as if you are right. I pinged @StephanEwen for clarification and he responded that it is indeed closer, but there are still some difference:\n\nFlink checkpoints start at sources, propagate through a DAG and persist in-flight as needed\nChandy-Lamport assumes no DAG, starts everywhere at the same time (think: RPC goes to every operators) and all operators log until they saw all markers.\n\nI'd probably leave the reference as is and add a clarifying line to unaligned section.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443499800", "createdAt": "2020-06-22T11:43:57Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing\n \n The central part of Flink's fault tolerance mechanism is drawing consistent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwMjQ3OQ==", "bodyText": "My understanding was that this document is rather an expanded glossary and talks about the concept and not the implementation. Thus, I'd leave the implementation state out of this place. The ops link will directly say that it's experimental in 1.11.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443502479", "createdAt": "2020-06-22T11:49:21Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDA2MA==", "bodyText": "Yes, I have removed the bullet and made it a summarizing sentence.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504060", "createdAt": "2020-06-22T11:52:34Z", "author": {"login": "AHeise"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDUwMg==", "bodyText": "Can you change the job graph with current checkpoints? I was always assuming that you need savepoints.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504502", "createdAt": "2020-06-22T11:53:25Z", "author": {"login": "AHeise"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, "originalCommit": {"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e80e905a5d66919427300af45b088e33b01d46d2", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/e80e905a5d66919427300af45b088e33b01d46d2", "committedDate": "2020-06-22T11:53:53Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}, "afterCommit": {"oid": "8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "committedDate": "2020-06-22T12:08:51Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDY4Nzc3", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-435068777", "createdAt": "2020-06-22T16:04:03Z", "commit": {"oid": "bfd067ea54c9c6662329cea2c8715a173961d9fb"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNDowM1rOGnHVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMjoxN1rOGnHpcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Nzc1MQ==", "bodyText": "As it's stable on our builds, maybe we could label it more production ready?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443667751", "createdAt": "2020-06-22T16:04:03Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/CheckpointConfig.java", "diffHunk": "@@ -382,7 +382,7 @@ public void setPreferCheckpointForRecovery(boolean preferCheckpointForRecovery)\n \t}\n \n \t/**\n-\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure.\n+\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure (experimental).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd067ea54c9c6662329cea2c8715a173961d9fb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2ODU1Mw==", "bodyText": "following section?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443668553", "createdAt": "2020-06-22T16:05:15Z", "author": {"login": "pnowojski"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -140,6 +140,8 @@ Keep in mind that everything to do with checkpointing can be done\n asynchronously. The checkpoint barriers don't travel in lock step and\n operations can asynchronously snapshot their state.\n \n+Since Flink 1.11, checkpoints can be taken with or without alignment. In the \n+following, we describe aligned checkpoints first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2OTczMA==", "bodyText": "I/O pressure to state backends ->  I/O pressure, as it's not using state backends per se.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443669730", "createdAt": "2020-06-22T16:07:06Z", "author": {"login": "pnowojski"}, "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,48 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+Note that this approach is actually closer to the [Chandy-Lamport algorithm\n+](http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf), but\n+Flink still inserts the barrier in the sources to avoid overloading the\n+checkpoint coordinator.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handles unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in its input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken records to be stored asynchronously and \n+  creates a snapshot of its own state.\n+ \n+Consequently, the operator only briefly stops the processing of input to mark\n+the buffers, forwards the barrier, and creates the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for applications with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MDk5MA==", "bodyText": "We should mention here that aligned savepoints also can not happen concurrently to unaligned checkpoint", "url": "https://github.com/apache/flink/pull/12722#discussion_r443670990", "createdAt": "2020-06-22T16:09:05Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MjEyOQ==", "bodyText": "I think this paragraph is a bit too strong. As far as I understand, it's not that the UC will produce incorrect result, just that some records during the reprocessing might not be accounted as late data, right?", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672129", "createdAt": "2020-06-22T16:10:55Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons:\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The workaround is to\n+store the watermark in the operator state. If rescaling may occur, watermarks\n+should be stored per key-group in a union-state. We mostly likely will\n+implement this approach as a general solution (didn't make it into Flink \n+1.11.0).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Mjk0NQ==", "bodyText": "I would also mention that flatMap operators can lead to unbounded spilled data.", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672945", "createdAt": "2020-06-22T16:12:17Z", "author": {"login": "pnowojski"}, "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3bb709aa5ba9e83d1729958bab256a60eb41da"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NDMyODE4", "url": "https://github.com/apache/flink/pull/12722#pullrequestreview-436432818", "createdAt": "2020-06-24T08:28:15Z", "commit": {"oid": "8718566c0b74fd6c3c6327980c1ee1d2abc8eda8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b9e224c9d8f40c3973974904a9ec477057761e9", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/1b9e224c9d8f40c3973974904a9ec477057761e9", "committedDate": "2020-06-24T18:49:16Z", "message": "[FLINK-18064][python] Adding unaligned checkpoint config options."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "351a5f9e8ef61ea3aead0a493256930e6cb0eea1", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/351a5f9e8ef61ea3aead0a493256930e6cb0eea1", "committedDate": "2020-06-24T18:50:24Z", "message": "[hotfix][conf] Fix javadoc of CheckpointConfig#isUnalignedCheckpointsEnabled."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0799d058a7ecc4ccead03029e0175336a4c928f", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/f0799d058a7ecc4ccead03029e0175336a4c928f", "committedDate": "2020-06-24T18:50:26Z", "message": "[hotfix][docs] Fix broken link in metrics.md."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d62757ad0b515c48c31cb1c4cde8878055b5ecfc", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/d62757ad0b515c48c31cb1c4cde8878055b5ecfc", "committedDate": "2020-06-24T18:50:26Z", "message": "[FLINK-18064][docs] Added unaligned checkpointing to docs.\n\nIt's split into 3 parts to simulate the description of aligned checkpointing:\n- It's added on conceptual level in stateful-stream-processing.md with new/revised pics. It's written in a way that it could survive 1.12 without change.\n- A small change to dev/stream/state/checkpointing.md to show how it is enabled programmatically in Java/Scala/Python. Might need to be extended for 1.12 when new options become available (depending whether they can be programmatically changed or not).\n- A larger discussion in ops/state/checkpoints.md which includes the current limitations and a small glimpse into the next steps (will be in much more detail in blog post). This part needs to be largely rewritten for 1.12+ to reflect the new options."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f818134b647f6e34bade6189640bd81575f0162c", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/f818134b647f6e34bade6189640bd81575f0162c", "committedDate": "2020-06-24T18:50:26Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "committedDate": "2020-06-22T12:08:51Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}, "afterCommit": {"oid": "f818134b647f6e34bade6189640bd81575f0162c", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/f818134b647f6e34bade6189640bd81575f0162c", "committedDate": "2020-06-24T18:50:26Z", "message": "[hotfix][docs] Replace/fix links in checkpointing documents."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3222, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}