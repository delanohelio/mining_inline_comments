{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MDE4MzM5", "number": 12670, "title": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit", "bodyText": "What is the purpose of the change\nDon't call System.exit on CheckpointCoordinator failure if it is shut down.\nbackport to 1.11: #12698\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): no\nThe public API, i.e., is any changed class annotated with @Public(Evolving): no\nThe serializers: no\nThe runtime per-record code paths (performance sensitive): no\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: no\nThe S3 file system connector: no\n\nDocumentation\n\nDoes this pull request introduce a new feature? no\nIf yes, how is the feature documented? not applicable", "createdAt": "2020-06-16T07:09:28Z", "url": "https://github.com/apache/flink/pull/12670", "merged": true, "mergeCommit": {"oid": "f85dfbb12dd7845a0e87a1aef23edefc20365058"}, "closed": true, "closedAt": "2020-06-17T17:33:17Z", "author": {"login": "rkhachatryan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrzyoMgFqTQzMTQxOTQzNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsIVrSAFqTQzMjMxNjUzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDE5NDM0", "url": "https://github.com/apache/flink/pull/12670#pullrequestreview-431419434", "createdAt": "2020-06-16T11:44:01Z", "commit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMTo0NDowMVrOGkXgDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMTo0NDowNlrOGkXgOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4Njk1Ng==", "bodyText": "It's a serious issue if it gets here. CheckpointCoordinator might be never recover even we fail the job. The state of isTrigger might not be reset, and it couldn't be reset forever. So we should reset the isTriggering to false first and then call the failureManager.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440786956", "createdAt": "2020-06-16T11:44:01Z", "author": {"login": "ifndef-SleePy"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4NzAwMw==", "bodyText": "Should we check the RejectedExecutionException here? It's kind of case by case. Do you think log.warn for every exception is better? In the future we could shut down timer and CheckpointCoordinator in a more elegant way to avoid this warning log.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440787003", "createdAt": "2020-06-16T11:44:06Z", "author": {"login": "ifndef-SleePy"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());\n+\t\t\t\t\t\t} else if (error instanceof RejectedExecutionException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMzM2NDE4", "url": "https://github.com/apache/flink/pull/12670#pullrequestreview-431336418", "createdAt": "2020-06-16T09:44:16Z", "commit": {"oid": "9e093628c7c2facb4913315997d0844a7a1b4e47"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwOTo0NDoxN1rOGkTpqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjoxNDowM1rOGkYdtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyMzg4MA==", "bodyText": "Maybe call it isCheckpointFailure as it seems that that we are ignoring a whole bunch of exception types.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440723880", "createdAt": "2020-06-16T09:44:17Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java", "diffHunk": "@@ -81,22 +78,24 @@ public void handleTaskLevelCheckpointException(\n \t\t\tCheckpointException exception,\n \t\t\tlong checkpointId,\n \t\t\tExecutionAttemptID executionAttemptID) {\n-\t\tcheckFailureCounter(exception, checkpointId);\n-\t\tif (continuousFailureCounter.get() > tolerableCpFailureNumber) {\n+\t\thandleException(exception, checkpointId, (failureCallback, e) -> failureCallback.failJobDueToTaskFailure(e, executionAttemptID));\n+\t}\n+\n+\tprivate void handleException(CheckpointException exception, long checkpointId, BiConsumer<FailJobCallback, Exception> onFailure) {\n+\t\tif (isFailure(exception) &&\n+\t\t\t\tcountedCheckpointIds.add(checkpointId) &&\n+\t\t\t\tcontinuousFailureCounter.incrementAndGet() > tolerableCpFailureNumber) {\n \t\t\tclearCount();\n-\t\t\tfailureCallback.failJobDueToTaskFailure(new FlinkRuntimeException(\"Exceeded checkpoint tolerable failure threshold.\"), executionAttemptID);\n+\t\t\tonFailure.accept(failureCallback, new FlinkRuntimeException(\"Exceeded checkpoint tolerable failure threshold.\"));\n \t\t}\n \t}\n \n-\tpublic void checkFailureCounter(\n-\t\t\tCheckpointException exception,\n-\t\t\tlong checkpointId) {\n+\tprivate boolean isFailure(CheckpointException exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e093628c7c2facb4913315997d0844a7a1b4e47"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4OTE1OA==", "bodyText": "This should not be necessary since we are clearing continuousFailureCounter in clearCount.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440789158", "createdAt": "2020-06-16T11:48:34Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java", "diffHunk": "@@ -84,7 +84,7 @@ public void handleTaskLevelCheckpointException(\n \tprivate void handleException(CheckpointException exception, long checkpointId, BiConsumer<FailJobCallback, Exception> onFailure) {\n \t\tif (isFailure(exception) &&\n \t\t\t\tcountedCheckpointIds.add(checkpointId) &&\n-\t\t\t\tcontinuousFailureCounter.incrementAndGet() > tolerableCpFailureNumber) {\n+\t\t\t\tcontinuousFailureCounter.incrementAndGet() == tolerableCpFailureNumber + 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce537ac0417ebb159a4589f028a024814e03d03f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4OTU4NQ==", "bodyText": "This test fails when running ce537ac0417ebb159a4589f028a024814e03d03f.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440789585", "createdAt": "2020-06-16T11:49:27Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManagerTest.java", "diffHunk": "@@ -76,7 +76,7 @@ public void testTotalCountValue() {\n \t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(reason), -1);\n \t\t}\n \n-\t\tassertEquals(2, callback.getInvokeCounter());\n+\t\tassertEquals(1, callback.getInvokeCounter());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce537ac0417ebb159a4589f028a024814e03d03f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MDEwNQ==", "bodyText": "Can we give this condition a bit more expressive name?", "url": "https://github.com/apache/flink/pull/12670#discussion_r440790105", "createdAt": "2020-06-16T11:50:27Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java", "diffHunk": "@@ -83,9 +83,10 @@ public void handleTaskLevelCheckpointException(\n \n \tprivate void handleException(CheckpointException exception, long checkpointId, BiConsumer<FailJobCallback, Exception> onFailure) {\n \t\tif (isFailure(exception) &&\n+\t\t\t\t!isAlreadyFailed() && // prevent unnecessary storing checkpointId\n \t\t\t\tcountedCheckpointIds.add(checkpointId) &&\n \t\t\t\tcontinuousFailureCounter.incrementAndGet() == tolerableCpFailureNumber + 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092e3c70f30ead3bcf3ba5142cc3e54bb954f124"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MjIzNg==", "bodyText": "I think we are changing an invariant of this class here. Before it seems that countedCheckpointIds.size() == continuousFailureCounter.get() which is now not longer true. I'm a bit sceptical that these changes can be justified to be put in a hotfix commit.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440792236", "createdAt": "2020-06-16T11:54:28Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java", "diffHunk": "@@ -83,9 +83,10 @@ public void handleTaskLevelCheckpointException(\n \n \tprivate void handleException(CheckpointException exception, long checkpointId, BiConsumer<FailJobCallback, Exception> onFailure) {\n \t\tif (isFailure(exception) &&\n+\t\t\t\t!isAlreadyFailed() && // prevent unnecessary storing checkpointId\n \t\t\t\tcountedCheckpointIds.add(checkpointId) &&\n \t\t\t\tcontinuousFailureCounter.incrementAndGet() == tolerableCpFailureNumber + 1) {\n-\t\t\tclearCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092e3c70f30ead3bcf3ba5142cc3e54bb954f124"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MzAyMQ==", "bodyText": "I would refrain from using static imports. The problem I see is that another person needs to know that this belongs to Optional when looking at this code.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440793021", "createdAt": "2020-06-16T11:55:50Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java", "diffHunk": "@@ -78,13 +74,13 @@ public void handleTaskLevelCheckpointException(\n \t\t\tCheckpointException exception,\n \t\t\tlong checkpointId,\n \t\t\tExecutionAttemptID executionAttemptID) {\n-\t\thandleException(exception, checkpointId, (failureCallback, e) -> failureCallback.failJobDueToTaskFailure(e, executionAttemptID));\n+\t\thandleException(exception, of(checkpointId), (failureCallback, e) -> failureCallback.failJobDueToTaskFailure(e, executionAttemptID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1e1ee97fef1de8a970521f5cd23399e61f8b33"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5NjUyNA==", "bodyText": "I think if a failure occurs here, then there must a programming error or it is an artifact of a non properly shut down task. In the first case, I think we should fail hard. In the latter case (e.g. if (isShutdown()) we should ignore the exception/log it on debug).", "url": "https://github.com/apache/flink/pull/12670#discussion_r440796524", "createdAt": "2020-06-16T12:02:21Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4Njk1Ng=="}, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5NzA0MQ==", "bodyText": "Consequently, I'm not convinced that we need to call the failureManager here.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440797041", "createdAt": "2020-06-16T12:03:27Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4Njk1Ng=="}, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5NzkyNA==", "bodyText": "I think we can say that we tolerate exception after the shut down because we have closed the timer and can no longer guarantee that things keep working.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440797924", "createdAt": "2020-06-16T12:05:06Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());\n+\t\t\t\t\t\t} else if (error instanceof RejectedExecutionException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4NzAwMw=="}, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5ODUwMw==", "bodyText": "I think we could add FutureUtils.assertNoException here again if we used handle or exceptionally instead of whenComplete for the final exception handler.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440798503", "createdAt": "2020-06-16T12:06:06Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -539,51 +541,62 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tCompletableFuture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bf8cc9dac706a48383be393551fdb25069be051"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgwMDc4OQ==", "bodyText": "A test is missing for the original problem.", "url": "https://github.com/apache/flink/pull/12670#discussion_r440800789", "createdAt": "2020-06-16T12:10:22Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -539,51 +541,62 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tCompletableFuture\n+\t\t\t\t.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());\n+\t\t\t\t\t\t} else if (error instanceof RejectedExecutionException) {\n+\t\t\t\t\t\t\tLOG.debug(\"Execution rejected during shutdown\");\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOG.warn(\"Error encountered during shutdown\", error);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bf8cc9dac706a48383be393551fdb25069be051"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgwMjc0MA==", "bodyText": "Which exceptions do you expect here to appear?", "url": "https://github.com/apache/flink/pull/12670#discussion_r440802740", "createdAt": "2020-06-16T12:14:03Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -538,51 +542,61 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n \t\t\t\t\t\t\ttimer);\n \n-\t\t\tFutureUtils.assertNoException(\n-\t\t\t\tCompletableFuture.allOf(masterStatesComplete, coordinatorCheckpointsComplete)\n-\t\t\t\t\t.handleAsync(\n-\t\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n-\t\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n-\n-\t\t\t\t\t\t\tPreconditions.checkState(\n-\t\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n-\t\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n-\n-\t\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\t\t// the initialization might not be finished yet\n-\t\t\t\t\t\t\t\tif (checkpoint == null) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n-\t\t\t\t\t\t\t\t}\n+\t\t\tFutureUtils.waitForAll(asList(masterStatesComplete, coordinatorCheckpointsComplete))\n+\t\t\t\t.handleAsync(\n+\t\t\t\t\t(ignored, throwable) -> {\n+\t\t\t\t\t\tfinal PendingCheckpoint checkpoint =\n+\t\t\t\t\t\t\tFutureUtils.getWithoutException(pendingCheckpointCompletableFuture);\n+\n+\t\t\t\t\t\tPreconditions.checkState(\n+\t\t\t\t\t\t\tcheckpoint != null || throwable != null,\n+\t\t\t\t\t\t\t\"Either the pending checkpoint needs to be created or an error must have been occurred.\");\n+\n+\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t// the initialization might not be finished yet\n+\t\t\t\t\t\t\tif (checkpoint == null) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(request, throwable);\n \t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n-\t\t\t\t\t\t\t\t\tonTriggerFailure(\n-\t\t\t\t\t\t\t\t\t\tcheckpoint,\n-\t\t\t\t\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n-\t\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n-\t\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n-\t\t\t\t\t\t\t\t\tsnapshotTaskState(\n-\t\t\t\t\t\t\t\t\t\ttimestamp,\n-\t\t\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n-\t\t\t\t\t\t\t\t\t\trequest.props,\n-\t\t\t\t\t\t\t\t\t\texecutions,\n-\t\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n-\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n-\n-\t\t\t\t\t\t\t\t\tonTriggerSuccess();\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tonTriggerFailure(checkpoint, throwable);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (checkpoint.isDiscarded()) {\n+\t\t\t\t\t\t\t\tonTriggerFailure(\n+\t\t\t\t\t\t\t\t\tcheckpoint,\n+\t\t\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\t\t\tCheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE,\n+\t\t\t\t\t\t\t\t\t\tcheckpoint.getFailureCause()));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// no exception, no discarding, everything is OK\n+\t\t\t\t\t\t\t\tfinal long checkpointId = checkpoint.getCheckpointId();\n+\t\t\t\t\t\t\t\tsnapshotTaskState(\n+\t\t\t\t\t\t\t\t\ttimestamp,\n+\t\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\t\tcheckpoint.getCheckpointStorageLocation(),\n+\t\t\t\t\t\t\t\t\trequest.props,\n+\t\t\t\t\t\t\t\t\texecutions,\n+\t\t\t\t\t\t\t\t\trequest.advanceToEndOfTime);\n+\n+\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint.forEach((ctx) -> ctx.afterSourceBarrierInjection(checkpointId));\n+\n+\t\t\t\t\t\t\t\tonTriggerSuccess();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t},\n+\t\t\t\t\ttimer)\n+\t\t\t\t.whenComplete((unused, error) -> {\n+\t\t\t\t\tif (error != null) {\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tfailureManager.handleJobLevelCheckpointException(new CheckpointException(EXCEPTION, error), Optional.empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4Njk1Ng=="}, "originalCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8"}, "originalPosition": 110}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b7a339a0755861a904a119770fc6a26edc59fd8", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/5b7a339a0755861a904a119770fc6a26edc59fd8", "committedDate": "2020-06-15T20:13:35Z", "message": "[hotfix][checkpointing] Fail checkpoint future ASAP"}, "afterCommit": {"oid": "edce7433fbf7d8f64feb9e0a5c541fb50ddb3cd0", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/edce7433fbf7d8f64feb9e0a5c541fb50ddb3cd0", "committedDate": "2020-06-16T15:20:06Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edce7433fbf7d8f64feb9e0a5c541fb50ddb3cd0", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/edce7433fbf7d8f64feb9e0a5c541fb50ddb3cd0", "committedDate": "2020-06-16T15:20:06Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}, "afterCommit": {"oid": "ad5d1ffa1d4a457d2f90f109b6eb9b87aa15c2b1", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/ad5d1ffa1d4a457d2f90f109b6eb9b87aa15c2b1", "committedDate": "2020-06-16T15:32:18Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad5d1ffa1d4a457d2f90f109b6eb9b87aa15c2b1", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/ad5d1ffa1d4a457d2f90f109b6eb9b87aa15c2b1", "committedDate": "2020-06-16T15:32:18Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}, "afterCommit": {"oid": "8c0119088686cbbe7253404ea13be77ef0b48716", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/8c0119088686cbbe7253404ea13be77ef0b48716", "committedDate": "2020-06-16T22:36:20Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c0119088686cbbe7253404ea13be77ef0b48716", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/8c0119088686cbbe7253404ea13be77ef0b48716", "committedDate": "2020-06-16T22:36:20Z", "message": "[FLINK-18290][checkpointing] Fail job on checkpoint future failure instead of System.exit"}, "afterCommit": {"oid": "a1d89c0bec4f034697dfd75cab099958995d4281", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/a1d89c0bec4f034697dfd75cab099958995d4281", "committedDate": "2020-06-17T10:32:12Z", "message": "[FLINK-18290][checkpointing] Don't System.exit on CheckpointCoordinator failure if it is shut down"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMzAwNzM0", "url": "https://github.com/apache/flink/pull/12670#pullrequestreview-432300734", "createdAt": "2020-06-17T11:17:35Z", "commit": {"oid": "a1d89c0bec4f034697dfd75cab099958995d4281"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMToxNzozNVrOGlBNTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMToyMDoxMFrOGlBR0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ3MDI4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t\tExceptionUtils.rethrow(error);\n          \n          \n            \n            \t\t\t\t\t\t\tthrow new CompletionException(error)\n          \n      \n    \n    \n  \n\nis better because it won't extend the stack trace with another exception.", "url": "https://github.com/apache/flink/pull/12670#discussion_r441470284", "createdAt": "2020-06-17T11:17:35Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -582,7 +583,18 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \n \t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\ttimer)\n+\t\t\t\t\t.exceptionally(error -> {\n+\t\t\t\t\t\tisTriggering = false;\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tExceptionUtils.rethrow(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d89c0bec4f034697dfd75cab099958995d4281"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ3MDU2NQ==", "bodyText": "I think we don't need to reset the internal state of CheckpointCoordinator here because it either is shut down or it will fail.", "url": "https://github.com/apache/flink/pull/12670#discussion_r441470565", "createdAt": "2020-06-17T11:18:11Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -582,7 +583,18 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \n \t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\ttimer)\n+\t\t\t\t\t.exceptionally(error -> {\n+\t\t\t\t\t\tisTriggering = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d89c0bec4f034697dfd75cab099958995d4281"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ3MTQ0Mw==", "bodyText": "Can't we collapse these two cases into logging error on debug if isShutdown() == true?", "url": "https://github.com/apache/flink/pull/12670#discussion_r441471443", "createdAt": "2020-06-17T11:20:10Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -582,7 +583,18 @@ private void startTriggeringCheckpoint(CheckpointTriggerRequest request) {\n \n \t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t},\n-\t\t\t\t\t\ttimer));\n+\t\t\t\t\t\ttimer)\n+\t\t\t\t\t.exceptionally(error -> {\n+\t\t\t\t\t\tisTriggering = false;\n+\t\t\t\t\t\tif (!isShutdown()) {\n+\t\t\t\t\t\t\tExceptionUtils.rethrow(error);\n+\t\t\t\t\t\t} else if (error instanceof RejectedExecutionException) {\n+\t\t\t\t\t\t\tLOG.debug(\"Execution rejected during shutdown\");\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOG.warn(\"Error encountered during shutdown\", error);\n+\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d89c0bec4f034697dfd75cab099958995d4281"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37ada58c9248a7c2c659450dad9e793d20c34d98", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/37ada58c9248a7c2c659450dad9e793d20c34d98", "committedDate": "2020-06-17T11:34:05Z", "message": "[FLINK-18290][checkpointing] Don't System.exit on CheckpointCoordinator failure if it is shut down"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f83bb30e9f79e7bdecb665c3363e169651fed175", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/f83bb30e9f79e7bdecb665c3363e169651fed175", "committedDate": "2020-06-17T11:30:28Z", "message": "Accept suggested change to use CompletionException instead of rethrow\n\nCo-authored-by: Till Rohrmann <till.rohrmann@gmail.com>"}, "afterCommit": {"oid": "37ada58c9248a7c2c659450dad9e793d20c34d98", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/37ada58c9248a7c2c659450dad9e793d20c34d98", "committedDate": "2020-06-17T11:34:05Z", "message": "[FLINK-18290][checkpointing] Don't System.exit on CheckpointCoordinator failure if it is shut down"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMzE2NTM5", "url": "https://github.com/apache/flink/pull/12670#pullrequestreview-432316539", "createdAt": "2020-06-17T11:41:40Z", "commit": {"oid": "37ada58c9248a7c2c659450dad9e793d20c34d98"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3560, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}