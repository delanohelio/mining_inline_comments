{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NDEwNjUy", "number": 11098, "title": "[FLINK-16060][task] Implement working StreamMultipleInputProcessor", "bodyText": "This PR adds a basic support for multiple input operators and relevant interfaces.\nThis doesn't fully support input selection, watermarks, latency markers and keyed context yet.\nVerifying this change\nThis change adds couple of new test classes, most importantly MultipleInputStreamTaskTest\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-02-14T14:18:03Z", "url": "https://github.com/apache/flink/pull/11098", "merged": true, "mergeCommit": {"oid": "8becccb8dc4d00eb2c5f2e13827ad02c93331343"}, "closed": true, "closedAt": "2020-02-28T08:29:29Z", "author": {"login": "pnowojski"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEeM8QABqjMwNDA3MDY2NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIc0gRABqjMwNzgyMjMxNDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df7f0151d94bc7705c87baf855ae3d8d57f7e463", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/df7f0151d94bc7705c87baf855ae3d8d57f7e463", "committedDate": "2020-02-14T14:14:27Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "311d3e9843bd601a8de8bee78c2ecd34222d19d6", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/311d3e9843bd601a8de8bee78c2ecd34222d19d6", "committedDate": "2020-02-15T06:32:34Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "311d3e9843bd601a8de8bee78c2ecd34222d19d6", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/311d3e9843bd601a8de8bee78c2ecd34222d19d6", "committedDate": "2020-02-15T06:32:34Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "8355093ce1ed0dab9985d9f522f3bcd97c66d016", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8355093ce1ed0dab9985d9f522f3bcd97c66d016", "committedDate": "2020-02-15T06:36:13Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8355093ce1ed0dab9985d9f522f3bcd97c66d016", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8355093ce1ed0dab9985d9f522f3bcd97c66d016", "committedDate": "2020-02-15T06:36:13Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "committedDate": "2020-02-15T06:44:29Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "committedDate": "2020-02-15T06:44:29Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "committedDate": "2020-02-16T09:13:30Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "committedDate": "2020-02-16T09:13:30Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "e9472785fa25680b297986397e3c732875d4ccff", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e9472785fa25680b297986397e3c732875d4ccff", "committedDate": "2020-02-16T10:56:15Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e9472785fa25680b297986397e3c732875d4ccff", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e9472785fa25680b297986397e3c732875d4ccff", "committedDate": "2020-02-16T10:56:15Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "committedDate": "2020-02-17T11:59:11Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTgxNTE5", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-360181519", "createdAt": "2020-02-18T09:26:35Z", "commit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToyNjozNVrOFq64yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjozMzoyN1rOFrJkTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTMyMQ==", "bodyText": "If I understood correctly, there are two use-cases: with stateKeySelectors and without.\nI think it's better to have separate classes for these, or at least document these cases and invariants (on class or field level).", "url": "https://github.com/apache/flink/pull/11098#discussion_r380549321", "createdAt": "2020-02-18T09:26:35Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Mzg4MA==", "bodyText": "Could you please explain the purpose of this method?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380553880", "createdAt": "2020-02-18T09:34:15Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -581,6 +611,13 @@ public void setTwoInputStateKey(Integer vertexID, KeySelector<?, ?> keySelector1\n \t\tnode.setStateKeySerializer(keySerializer);\n \t}\n \n+\tpublic void setMultipleInputStateKey(\n+\t\t\tint id,\n+\t\t\tList<KeySelector<?, ?>> stateKeySelectors,\n+\t\t\tTypeSerializer<?> keySerializer) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA==", "bodyText": "With this signature, it's possible to call without any arguments.\nIf it's not a legal state then it makes sense to check arguments (or better ensure at compile time).\nAlso in other classes, e.g. MinWatermarkGauge.", "url": "https://github.com/apache/flink/pull/11098#discussion_r380557788", "createdAt": "2020-02-18T09:41:11Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamNode.java", "diffHunk": "@@ -235,20 +234,16 @@ public void addOutputSelector(OutputSelector<?> outputSelector) {\n \t\tthis.outputSelectors.add(outputSelector);\n \t}\n \n-\tpublic TypeSerializer<?> getTypeSerializerIn1() {\n-\t\treturn typeSerializerIn1;\n+\tpublic void setSerializersIn(TypeSerializer<?> ...typeSerializersIn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1NDMyMQ==", "bodyText": "nit: extract method (repeated 4 times)?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380654321", "createdAt": "2020-02-18T12:56:59Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -330,6 +332,34 @@ public boolean isIterative() {\n \t\t}\n \t}\n \n+\tpublic <OUT> void addMultipleInputOperator(\n+\t\t\tInteger vertexID,\n+\t\t\tString slotSharingGroup,\n+\t\t\t@Nullable String coLocationGroup,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tList<TypeInformation<?>> inTypeInfos,\n+\t\t\tTypeInformation<OUT> outTypeInfo,\n+\t\t\tString operatorName) {\n+\n+\t\tClass<? extends AbstractInvokable> vertexClass = MultipleInputStreamTask.class;\n+\n+\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, vertexClass, operatorFactory, operatorName);\n+\n+\t\tTypeSerializer<OUT> outSerializer = (outTypeInfo != null) && !(outTypeInfo instanceof MissingTypeInfo) ?\n+\t\t\toutTypeInfo.createSerializer(executionConfig) : null;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ==", "bodyText": "Could you please explain:\n\nwhy do we need this check here? there is already one in transform()?\nwhy the check doesn't precede transform() of inputs?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380658811", "createdAt": "2020-02-18T13:06:19Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java", "diffHunk": "@@ -735,6 +739,56 @@ public StreamGraph generate() {\n \t\treturn Collections.singleton(transform.getId());\n \t}\n \n+\tprivate <OUT> Collection<Integer> transformMultipleInputTransform(MultipleInputTransformation<OUT> transform) {\n+\t\tList<Collection<Integer>> allInputIds = new ArrayList<>();\n+\n+\t\tfor (Transformation<?> input : transform.getInputs()) {\n+\t\t\tallInputIds.add(transform(input));\n+\t\t}\n+\n+\t\t// the recursive call might have already transformed this\n+\t\tif (alreadyTransformed.containsKey(transform)) {\n+\t\t\treturn alreadyTransformed.get(transform);\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY3ODEwNQ==", "bodyText": "Why can't we use Transformation#getId here? E.g.\nassertEquals(1, streamGraph.getStreamEdges(transform.getId(), source1.getId()).size());", "url": "https://github.com/apache/flink/pull/11098#discussion_r380678105", "createdAt": "2020-02-18T13:42:53Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -312,6 +316,40 @@ public void testOutputTypeConfigurationWithTwoInputTransformation() throws Excep\n \t\tassertEquals(BasicTypeInfo.INT_TYPE_INFO, outputTypeConfigurableOperation.getTypeInformation());\n \t}\n \n+\t@Test\n+\tpublic void testMultipleInputTransformation() throws Exception {\n+\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n+\t\t//TODO: referring to getNewNodeId() is hacky, but I'm not sure if there is a better idea?\n+\t\tint startingNewNodeId = Transformation.getNewNodeId();\n+\n+\t\tDataStream<Integer> source1 = env.fromElements(1, 10);\n+\t\tDataStream<Long> source2 = env.fromElements(2L, 11L);\n+\t\tDataStream<String> source3 = env.fromElements(\"42\", \"44\");\n+\n+\t\tMultipleInputTransformation<String> transform = new MultipleInputTransformation<String>(\n+\t\t\t\"My Operator\",\n+\t\t\tnew MultipleInputOperatorFactory(),\n+\t\t\tBasicTypeInfo.STRING_TYPE_INFO,\n+\t\t\t3);\n+\n+\t\ttransform.addInput(source1.getTransformation());\n+\t\ttransform.addInput(source2.getTransformation());\n+\t\ttransform.addInput(source3.getTransformation());\n+\n+\t\tenv.addOperator(transform);\n+\t\tStreamGraph streamGraph = env.getStreamGraph();\n+\t\tassertEquals(4, streamGraph.getStreamNodes().size());\n+\n+\t\tint id = startingNewNodeId;\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3).size());\n+\t\tassertEquals(0, streamGraph.getStreamEdges(id + 4).size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5MTIyMA==", "bodyText": "Can we improve it with two arrayCopy calls:\nSystem.arraycopy(bufferStorages, 0, copy, 0, skipStorage);\nSystem.arraycopy(bufferStorages, skipStorage + 1, copy, skipStorage, bufferStorages.length - skipStorage - 1);\n\n?\nAlso, variable names don't say much to me (just src, dst and i would be better).", "url": "https://github.com/apache/flink/pull/11098#discussion_r380691220", "createdAt": "2020-02-18T14:05:43Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -63,40 +63,57 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \tpublic static CheckpointedInputGate[] createCheckpointedInputGatePair(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tCheckpointingMode checkpointMode,\n-\t\t\tInputGate inputGate1,\n-\t\t\tInputGate inputGate2,\n \t\t\tConfiguration taskManagerConfig,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n-\t\t\tString taskName) {\n+\t\t\tString taskName,\n+\t\t\tInputGate ...inputGates) {\n \n \t\tint pageSize = ConfigurationParserUtils.getPageSize(taskManagerConfig);\n \n-\t\tBufferStorage mainBufferStorage1 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tBufferStorage mainBufferStorage2 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tcheckState(mainBufferStorage1.getMaxBufferedBytes() == mainBufferStorage2.getMaxBufferedBytes());\n+\t\tBufferStorage[] mainBufferStorages = new BufferStorage[inputGates.length];\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tmainBufferStorages[i] = createBufferStorage(\n+\t\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n+\t\t}\n+\n+\t\tBufferStorage[] linkedBufferStorages = new BufferStorage[inputGates.length];\n \n-\t\tBufferStorage linkedBufferStorage1 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n-\t\tBufferStorage linkedBufferStorage2 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tlinkedBufferStorages[i] = new LinkedBufferStorage(\n+\t\t\t\tmainBufferStorages[i],\n+\t\t\t\tmainBufferStorages[i].getMaxBufferedBytes(),\n+\t\t\t\tcopyBufferStoragesExceptOf(i, mainBufferStorages));\n+\t\t}\n \n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tcheckpointMode,\n-\t\t\tinputGate1.getNumberOfInputChannels() + inputGate2.getNumberOfInputChannels(),\n+\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum(),\n \t\t\ttaskName,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n-\t\treturn new CheckpointedInputGate[] {\n-\t\t\tnew CheckpointedInputGate(inputGate1, linkedBufferStorage1, barrierHandler),\n-\t\t\tnew CheckpointedInputGate(inputGate2, linkedBufferStorage2, barrierHandler, inputGate1.getNumberOfInputChannels())\n-\t\t};\n+\t\tCheckpointedInputGate[] checkpointedInputGates = new CheckpointedInputGate[inputGates.length];\n+\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tcheckpointedInputGates[i] = new CheckpointedInputGate(inputGates[i], linkedBufferStorages[i], barrierHandler, channelIndexOffset);\n+\t\t\tchannelIndexOffset += inputGates[i].getNumberOfInputChannels();\n+\t\t}\n+\n+\t\treturn checkpointedInputGates;\n+\t}\n+\n+\tprivate static BufferStorage[] copyBufferStoragesExceptOf(\n+\t\t\tint skipStorage,\n+\t\t\tBufferStorage[] bufferStorages) {\n+\t\tBufferStorage[] copy = new BufferStorage[bufferStorages.length - 1];\n+\t\tint copyTo = 0;\n+\t\tfor (int copyFrom = 0; copyFrom < bufferStorages.length; copyFrom++) {\n+\t\t\tif (copyFrom != skipStorage) {\n+\t\t\t\tcopy[copyTo++] = bufferStorages[copyFrom];\n+\t\t\t}\n+\t\t}\n+\t\treturn copy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5OTcwOQ==", "bodyText": "nit: mark the class with @NotThreadSafe?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380699709", "createdAt": "2020-02-18T14:19:37Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/LinkedBufferStorage.java", "diffHunk": "@@ -56,17 +57,27 @@ public boolean isFull() {\n \t@Override\n \tpublic void rollOver() {\n \t\tmainStorage.rollOver();\n-\t\tlinkedStorage.rollOver();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tlinked.rollOver();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic long getPendingBytes() {\n-\t\treturn mainStorage.getPendingBytes() + linkedStorage.getPendingBytes();\n+\t\tlong pendingBytes = mainStorage.getPendingBytes();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tpendingBytes += linked.getPendingBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyODM3MQ==", "bodyText": "I think the whole function can be simplified as:\nprivate int fairSelectFromRightBits(int bits, int next) {\n    for (bits >>= next; bits > 0 && bits % 2 != 1; bits >>= 1, next++) {\n    }\n    return bits > 0 ? next : -1;\n}\n\nRemoving if makes loop more predictable (I understand it's a critical code path, right?)", "url": "https://github.com/apache/flink/pull/11098#discussion_r380728371", "createdAt": "2020-02-18T15:03:39Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyOTk3MQ==", "bodyText": "Here, we check if the rightmost bit is set, right?\nIn that case, masking would be faster and more readable:\nrightBits & 1 == 1", "url": "https://github.com/apache/flink/pull/11098#discussion_r380729971", "createdAt": "2020-02-18T15:06:00Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMDQ1MQ==", "bodyText": "Should we use >>> instead of >>? (unlikely we hit this situation... but IPv4... :) )\n(same in other places where we shift)", "url": "https://github.com/apache/flink/pull/11098#discussion_r380730451", "createdAt": "2020-02-18T15:06:48Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {\n+\t\t\t\treturn nextReadInputIndex;\n+\t\t\t}\n+\t\t\tnextReadInputIndex++;\n+\t\t\trightBits >>= 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc0MTA1NQ==", "bodyText": "Do we need special mask for the case when all inputs are selected (-1L)?\nOr how is this case handled?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380741055", "createdAt": "2020-02-18T15:22:33Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw==", "bodyText": "If this method is only for tests, should we place it into TestStreamTask which extends StreamTask?\nIf not:\n\nshould we re-use it in runMailboxLoop below?\nmake it package-private?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380755077", "createdAt": "2020-02-18T15:42:43Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -484,11 +485,15 @@ public final void invoke() throws Exception {\n \t\t}\n \t}\n \n+\tprotected boolean runMailboxStep() throws Exception {\n+\t\treturn mailboxProcessor.runMailboxStep();\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2MTA2Nw==", "bodyText": "Can we instead of null add something like\npublic interface InputSelectable {\n    InputSelectable ALL = () -> InputSelection.ALL;\n\nand then use it in this class?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380761067", "createdAt": "2020-02-18T15:50:59Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {\n+\t\tswitch (inputStatus) {\n+\t\t\tcase MORE_AVAILABLE:\n+\t\t\t\tcheckState(checkBitMask(availableInputsMask, inputIndex));\n+\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t\tcase NOTHING_AVAILABLE:\n+\t\t\t\tavailableInputsMask = unsetBitMask(availableInputsMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tcase END_OF_INPUT:\n+\t\t\t\tendOfInputMask = setBitMask(endOfInputMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported inputStatus = \" + inputStatus);\n+\t\t}\n+\n+\t\treturn calculateInputStatus();\n+\t}\n+\n+\tpublic InputStatus calculateInputStatus() throws IOException {\n+\t\tif (endOfInputMask == allSelectedMask) {\n+\t\t\treturn InputStatus.END_OF_INPUT;\n+\t\t}\n+\n+\t\tif (isAnyInputAvailable()) {\n+\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t}\n+\t\telse {\n+\t\t\tlong selectedNotFinishedInputMask = inputSelection.getInputMask() & ~(endOfInputMask);\n+\t\t\tif (selectedNotFinishedInputMask == 0) {\n+\t\t\t\tthrow new IOException(\"Can not make a progress: all selected inputs are already finished\");\n+\t\t\t}\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\t}\n+\n+\tvoid nextSelection() {\n+\t\tif (inputSelector == null) {\n+\t\t\tinputSelection = InputSelection.ALL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2NjI4NA==", "bodyText": "Looks like endOfInputMask is always negated.\nShould we reverse the logic then?\nI.e., have nonEndedInputs set to all ones initially, and zeroed on END_OF_INPUT?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380766284", "createdAt": "2020-02-18T15:58:21Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ==", "bodyText": "I think this method shouldn't mix these responsibilities:\n\nupdate state for the given input\ncalculate the aggregate status\n\n(reportInputStatus could be void and client could additinally call calculateInputStatus )", "url": "https://github.com/apache/flink/pull/11098#discussion_r380770621", "createdAt": "2020-02-18T16:04:48Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw==", "bodyText": "Do we start effectively with 2?\nThere is lastReadInputIndex + 1 in InputSelection", "url": "https://github.com/apache/flink/pull/11098#discussion_r380772843", "createdAt": "2020-02-18T16:08:01Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NjA4Mg==", "bodyText": "Should it be i instead of 0?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380776082", "createdAt": "2020-02-18T16:12:49Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NzYxNw==", "bodyText": "Could you please explain why is it not supported?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380787617", "createdAt": "2020-02-18T16:30:04Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg==", "bodyText": "The future will never complete if all inputs are finished, won't it?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380789462", "createdAt": "2020-02-18T16:32:48Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\t// to avoid starvation, if the input selection is ALL and availableInputsMask is not ALL,\n+\t\t// always try to check and set the availability of another input\n+\t\tif (inputSelectionHandler.shouldSetAvailableForAnotherInput()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\treturn readingInputIndex;\n+\t}\n+\n+\tprivate void fullCheckAndSetAvailable() {\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tInputProcessor<?> inputProcessor = inputProcessors[i];\n+\t\t\t// TODO: isAvailable() can be a costly operation (checking volatile). If one of\n+\t\t\t// the input is constantly available and another is not, we will be checking this volatile\n+\t\t\t// once per every record. This might be optimized to only check once per processed NetworkBuffer\n+\t\t\tif (inputProcessor.networkInput.isApproximatelyAvailable() || inputProcessor.networkInput.isAvailable()) {\n+\t\t\t\tinputSelectionHandler.setAvailableInput(i);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate CompletableFuture<?> isAnyInputAvailable() {\n+\t\tif (inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\treturn AVAILABLE;\n+\t\t}\n+\t\tfinal CompletableFuture<?> anyInputAvailable = new CompletableFuture<>();\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tif (!inputSelectionHandler.isInputFinished(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTgzNg==", "bodyText": "nit: extract constant?", "url": "https://github.com/apache/flink/pull/11098#discussion_r380789836", "createdAt": "2020-02-18T16:33:27Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzIxNjky", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-362721692", "createdAt": "2020-02-21T15:44:01Z", "commit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNTo0NDowMlrOFs7T4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzowNDozNlrOFs-EMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MzQwOA==", "bodyText": "I think it might be a good idea to provide both MultipleInputTransformation and MultipleInputKeyedTransformation (I was duplicating pre-existing pattern), with some common base class. Maybe for this PR, I would just provide non keyed version, and in the later one, where I'm planning to add actual support for key selectors and multiple input, I would try to add separate class for handling key selectors.\nThis way, if there will come up any reason why having a single class is actually a better idea, we won't have to revert the changes.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382653408", "createdAt": "2020-02-21T15:44:02Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTMyMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1Nzg1Ng==", "bodyText": "what is repeated 4 times? I see that addMultipleInputOperator  duplicates (once) addCoOperator, but where are other two duplications?\nnever mind, found it.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382657856", "createdAt": "2020-02-21T15:51:45Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -330,6 +332,34 @@ public boolean isIterative() {\n \t\t}\n \t}\n \n+\tpublic <OUT> void addMultipleInputOperator(\n+\t\t\tInteger vertexID,\n+\t\t\tString slotSharingGroup,\n+\t\t\t@Nullable String coLocationGroup,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tList<TypeInformation<?>> inTypeInfos,\n+\t\t\tTypeInformation<OUT> outTypeInfo,\n+\t\t\tString operatorName) {\n+\n+\t\tClass<? extends AbstractInvokable> vertexClass = MultipleInputStreamTask.class;\n+\n+\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, vertexClass, operatorFactory, operatorName);\n+\n+\t\tTypeSerializer<OUT> outSerializer = (outTypeInfo != null) && !(outTypeInfo instanceof MissingTypeInfo) ?\n+\t\t\toutTypeInfo.createSerializer(executionConfig) : null;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1NDMyMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODMyNQ==", "bodyText": "I dropped the method as a result of a previous comment", "url": "https://github.com/apache/flink/pull/11098#discussion_r382658325", "createdAt": "2020-02-21T15:52:32Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -581,6 +611,13 @@ public void setTwoInputStateKey(Integer vertexID, KeySelector<?, ?> keySelector1\n \t\tnode.setStateKeySerializer(keySerializer);\n \t}\n \n+\tpublic void setMultipleInputStateKey(\n+\t\t\tint id,\n+\t\t\tList<KeySelector<?, ?>> stateKeySelectors,\n+\t\t\tTypeSerializer<?> keySerializer) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Mzg4MA=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NzI2NQ==", "bodyText": "Usually we treat most of the classes @NotThreadSafe by default and all/almost all of the classes in this package are not thread safe.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382667265", "createdAt": "2020-02-21T16:07:36Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/LinkedBufferStorage.java", "diffHunk": "@@ -56,17 +57,27 @@ public boolean isFull() {\n \t@Override\n \tpublic void rollOver() {\n \t\tmainStorage.rollOver();\n-\t\tlinkedStorage.rollOver();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tlinked.rollOver();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic long getPendingBytes() {\n-\t\treturn mainStorage.getPendingBytes() + linkedStorage.getPendingBytes();\n+\t\tlong pendingBytes = mainStorage.getPendingBytes();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tpendingBytes += linked.getPendingBytes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5OTcwOQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDY2Mg==", "bodyText": "Good question, I had to double check that. availableInputsMask could only be set to -1 to indicate all 32 inputs are available. I will document that. MultipleInputSelectionHandler is adhering to this contract.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382674662", "createdAt": "2020-02-21T16:21:07Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc0MTA1NQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MDU4OQ==", "bodyText": "I'm not sure if this alternative is more readable and I don't think it will be faster (compiler should be able to optimise it anyway AND branch prediction wouldn't work for one or two iterations anyway), but ok.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382680589", "createdAt": "2020-02-21T16:31:24Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyODM3MQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTQwOA==", "bodyText": "For me % 2 is easier to understand, as % operator is used much more frequently compared to &. And there is zero performance difference between those two (both will be optimised to the same machine code)\nscratch that, & 1 behaves somehow better for negative inputs.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382681408", "createdAt": "2020-02-21T16:32:55Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyOTk3MQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5Njc0NA==", "bodyText": "Yes. There was also another bug  in this method. If nextReadInputIndex was larger or equal to 32, method would enter endless loop, as bitshifts have undefined behaviour for shifting more than number of bits.", "url": "https://github.com/apache/flink/pull/11098#discussion_r382696744", "createdAt": "2020-02-21T17:00:57Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {\n+\t\t\t\treturn nextReadInputIndex;\n+\t\t\t}\n+\t\t\tnextReadInputIndex++;\n+\t\t\trightBits >>= 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMDQ1MQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5ODU0NA==", "bodyText": "I don't see an easy way how to do it, as we would have to provide multiple different test classes (one per each production StreamTask subclass?).", "url": "https://github.com/apache/flink/pull/11098#discussion_r382698544", "createdAt": "2020-02-21T17:04:36Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -484,11 +485,15 @@ public final void invoke() throws Exception {\n \t\t}\n \t}\n \n+\tprotected boolean runMailboxStep() throws Exception {\n+\t\treturn mailboxProcessor.runMailboxStep();\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjcyMDA0", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-363272004", "createdAt": "2020-02-24T10:00:27Z", "commit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMDowMDoyN1rOFta1ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToxNDoxMVrOFtdGKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2OTk4Nw==", "bodyText": "n-input?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383169987", "createdAt": "2020-02-24T10:00:27Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+\n+/**\n+ * {@link Input} interface used in {@link MultipleInputStreamOperator}.\n+ */\n+public interface Input<IN> {\n+\t/**\n+\t * Processes one element that arrived on the first input of this two-input operator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MjE0MQ==", "bodyText": "List<Transformation<?>> inputs", "url": "https://github.com/apache/flink/pull/11098#discussion_r383172141", "createdAt": "2020-02-24T10:04:44Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MjE5Mg==", "bodyText": "List<KeySelector<?, ?>> stateKeySelectors", "url": "https://github.com/apache/flink/pull/11098#discussion_r383172192", "createdAt": "2020-02-24T10:04:51Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MzYwOQ==", "bodyText": "Any reason to not use streams here?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383173609", "createdAt": "2020-02-24T10:07:42Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");\n+\t\tinputs.add(input);\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input, KeySelector<?, ?> keySelector) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.size() == inputs.size(),\n+\t\t\t\"Trying to add keyed input to non-keyed transformation\");\n+\t\tinputs.add(input);\n+\t\tstateKeySelectors.add(keySelector);\n+\t}\n+\n+\tpublic List<KeySelector<?, ?>> getStateKeySelectors() {\n+\t\treturn stateKeySelectors;\n+\t}\n+\n+\tpublic void setStateKeyType(TypeInformation<?> stateKeyType) {\n+\t\tthis.stateKeyType = stateKeyType;\n+\t}\n+\n+\tpublic TypeInformation<?> getStateKeyType() {\n+\t\treturn stateKeyType;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<Transformation<?>> getTransitivePredecessors() {\n+\t\tList<Transformation<?>> result = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3Mzc5NQ==", "bodyText": "Random change?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383173795", "createdAt": "2020-02-24T10:08:06Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/SingleOutputStreamOperator.java", "diffHunk": "@@ -59,7 +59,7 @@\n \n \tprivate boolean wasSplitApplied = false;\n \n-\tprotected SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {\n+\tpublic SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg==", "bodyText": "Not sure what this whole change is about. Better commit message? Why is the new method deprecated already?\nUsually when I read orThrow I except some customizable error; see Optional#orElseThrow(Supplier<X> exceptionSupplier).\nI'd probably just add this methods to the test as\npublic static List<StreamEdge> getNonEmptyStreamEdges(Environment env, int sourceId, int targetId) { ... }\n\nIt just adds convenience for writing test.  @VisibleForTesting should be about giving access to something that is inaccessible.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383177132", "createdAt": "2020-02-24T10:14:21Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -637,19 +638,24 @@ public StreamNode getStreamNode(Integer vertexID) {\n \t\treturn streamNodes.keySet();\n \t}\n \n+\t@VisibleForTesting\n \tpublic List<StreamEdge> getStreamEdges(int sourceId, int targetId) {\n-\n \t\tList<StreamEdge> result = new ArrayList<>();\n \t\tfor (StreamEdge edge : getStreamNode(sourceId).getOutEdges()) {\n \t\t\tif (edge.getTargetId() == targetId) {\n \t\t\t\tresult.add(edge);\n \t\t\t}\n \t\t}\n+\t\treturn result;\n+\t}\n \n+\t@VisibleForTesting\n+\t@Deprecated\n+\tpublic List<StreamEdge> getStreamEdgesOrThrow(int sourceId, int targetId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c07ff8c333074b60425360c101ffd1de8e58c5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODQ2MQ==", "bodyText": "Start at 1 for backwards compatibility?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383178461", "createdAt": "2020-02-24T10:16:52Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -158,12 +158,11 @@ public TimeCharacteristic getTimeCharacteristic() {\n \t\t}\n \t}\n \n-\tpublic void setTypeSerializerIn1(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_1, serializer);\n-\t}\n-\n-\tpublic void setTypeSerializerIn2(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_2, serializer);\n+\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n+\t\tconfig.setInteger(TYPE_SERIALIZERS_IN_COUNT, serializers.length);\n+\t\tfor (int i = 0; i < serializers.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODgzNQ==", "bodyText": "PREFIX would be good enough, see TYPE_SERIALIZER_SIDEOUT_PREFIX.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383178835", "createdAt": "2020-02-24T10:17:37Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -73,8 +73,8 @@\n \tprivate static final String ITERATION_ID = \"iterationId\";\n \tprivate static final String OUTPUT_SELECTOR_WRAPPER = \"outputSelectorWrapper\";\n \tprivate static final String BUFFER_TIMEOUT = \"bufferTimeout\";\n-\tprivate static final String TYPE_SERIALIZER_IN_1 = \"typeSerializer_in_1\";\n-\tprivate static final String TYPE_SERIALIZER_IN_2 = \"typeSerializer_in_2\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_COUNT = \"typeSerializer_in_count\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_PATTERN = \"typeSerializer_in_%d\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3OTM3Mw==", "bodyText": "handle -1? Would give a weird exception.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383179373", "createdAt": "2020-02-24T10:18:36Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -174,19 +173,35 @@ public void setTypeSerializerSideOut(OutputTag<?> outputTag, TypeSerializer<?> s\n \t\tsetTypeSerializer(TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), serializer);\n \t}\n \n+\t@Deprecated\n \tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n-\t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_IN_1, cl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n-\t\t}\n+\t\treturn getTypeSerializerIn(0, cl);\n \t}\n \n+\t@Deprecated\n \tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(1, cl);\n+\t}\n+\n+\tpublic TypeSerializer<?>[] getTypeSerializersIn(ClassLoader cl) {\n+\t\tint typeSerializersCount = config.getInteger(TYPE_SERIALIZERS_IN_COUNT, -1);\n+\t\tTypeSerializer<?>[] typeSerializers = new TypeSerializer<?>[typeSerializersCount];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MDgyOA==", "bodyText": "TypeSerializer[]::new not working?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383180828", "createdAt": "2020-02-24T10:21:23Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -590,17 +626,30 @@ public void setBufferTimeout(Integer vertexID, long bufferTimeout) {\n \n \tpublic void setSerializers(Integer vertexID, TypeSerializer<?> in1, TypeSerializer<?> in2, TypeSerializer<?> out) {\n \t\tStreamNode vertex = getStreamNode(vertexID);\n-\t\tvertex.setSerializerIn1(in1);\n-\t\tvertex.setSerializerIn2(in2);\n+\t\tvertex.setSerializersIn(in1, in2);\n+\t\tvertex.setSerializerOut(out);\n+\t}\n+\n+\tprivate <OUT> void setSerializers(\n+\t\t\tInteger vertexID,\n+\t\t\tList<TypeInformation<?>> inTypeInfos,\n+\t\t\tTypeSerializer<OUT> out) {\n+\n+\t\tStreamNode vertex = getStreamNode(vertexID);\n+\n+\t\tvertex.setSerializersIn(\n+\t\t\tinTypeInfos.stream()\n+\t\t\t\t.map(typeInfo -> typeInfo.createSerializer(executionConfig))\n+\t\t\t\t.toArray(size -> new TypeSerializer<?>[size]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MTk0MQ==", "bodyText": "Should be before transform() of inputs.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383181941", "createdAt": "2020-02-24T10:23:32Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java", "diffHunk": "@@ -735,6 +739,56 @@ public StreamGraph generate() {\n \t\treturn Collections.singleton(transform.getId());\n \t}\n \n+\tprivate <OUT> Collection<Integer> transformMultipleInputTransform(MultipleInputTransformation<OUT> transform) {\n+\t\tList<Collection<Integer>> allInputIds = new ArrayList<>();\n+\n+\t\tfor (Transformation<?> input : transform.getInputs()) {\n+\t\t\tallInputIds.add(transform(input));\n+\t\t}\n+\n+\t\t// the recursive call might have already transformed this\n+\t\tif (alreadyTransformed.containsKey(transform)) {\n+\t\t\treturn alreadyTransformed.get(transform);\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NDE1NQ==", "bodyText": "Empty needed for sources, I guess.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383184155", "createdAt": "2020-02-24T10:27:41Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamNode.java", "diffHunk": "@@ -235,20 +234,16 @@ public void addOutputSelector(OutputSelector<?> outputSelector) {\n \t\tthis.outputSelectors.add(outputSelector);\n \t}\n \n-\tpublic TypeSerializer<?> getTypeSerializerIn1() {\n-\t\treturn typeSerializerIn1;\n+\tpublic void setSerializersIn(TypeSerializer<?> ...typeSerializersIn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTcyOQ==", "bodyText": "Weird that we need that here... the real factories are still SimpleX? Or can we not add a real factory.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383185729", "createdAt": "2020-02-24T10:30:41Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -633,4 +671,29 @@ protected boolean matchesSafely(ResourceSpec item) {\n \t\t\treturn resources.lessThanOrEqual(item) && item.lessThanOrEqual(resources);\n \t\t}\n \t}\n+\n+\tprivate static class MultipleInputOperatorFactory implements StreamOperatorFactory<String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NjIxNA==", "bodyText": "Imho not a hotfix.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383186214", "createdAt": "2020-02-24T10:31:37Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -28,7 +28,7 @@\n import org.apache.flink.runtime.util.ConfigurationParserUtils;\n import org.apache.flink.streaming.api.CheckpointingMode;\n \n-import static org.apache.flink.util.Preconditions.checkState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ed31dfcf341a632addaf43b3db2a171508aec3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NzQ1NQ==", "bodyText": "nit declare in loop.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383187455", "createdAt": "2020-02-24T10:34:01Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -63,40 +63,57 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \tpublic static CheckpointedInputGate[] createCheckpointedInputGatePair(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tCheckpointingMode checkpointMode,\n-\t\t\tInputGate inputGate1,\n-\t\t\tInputGate inputGate2,\n \t\t\tConfiguration taskManagerConfig,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n-\t\t\tString taskName) {\n+\t\t\tString taskName,\n+\t\t\tInputGate ...inputGates) {\n \n \t\tint pageSize = ConfigurationParserUtils.getPageSize(taskManagerConfig);\n \n-\t\tBufferStorage mainBufferStorage1 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tBufferStorage mainBufferStorage2 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tcheckState(mainBufferStorage1.getMaxBufferedBytes() == mainBufferStorage2.getMaxBufferedBytes());\n+\t\tBufferStorage[] mainBufferStorages = new BufferStorage[inputGates.length];\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tmainBufferStorages[i] = createBufferStorage(\n+\t\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n+\t\t}\n+\n+\t\tBufferStorage[] linkedBufferStorages = new BufferStorage[inputGates.length];\n \n-\t\tBufferStorage linkedBufferStorage1 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n-\t\tBufferStorage linkedBufferStorage2 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tlinkedBufferStorages[i] = new LinkedBufferStorage(\n+\t\t\t\tmainBufferStorages[i],\n+\t\t\t\tmainBufferStorages[i].getMaxBufferedBytes(),\n+\t\t\t\tcopyBufferStoragesExceptOf(i, mainBufferStorages));\n+\t\t}\n \n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tcheckpointMode,\n-\t\t\tinputGate1.getNumberOfInputChannels() + inputGate2.getNumberOfInputChannels(),\n+\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum(),\n \t\t\ttaskName,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n-\t\treturn new CheckpointedInputGate[] {\n-\t\t\tnew CheckpointedInputGate(inputGate1, linkedBufferStorage1, barrierHandler),\n-\t\t\tnew CheckpointedInputGate(inputGate2, linkedBufferStorage2, barrierHandler, inputGate1.getNumberOfInputChannels())\n-\t\t};\n+\t\tCheckpointedInputGate[] checkpointedInputGates = new CheckpointedInputGate[inputGates.length];\n+\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tcheckpointedInputGates[i] = new CheckpointedInputGate(inputGates[i], linkedBufferStorages[i], barrierHandler, channelIndexOffset);\n+\t\t\tchannelIndexOffset += inputGates[i].getNumberOfInputChannels();\n+\t\t}\n+\n+\t\treturn checkpointedInputGates;\n+\t}\n+\n+\tprivate static BufferStorage[] copyBufferStoragesExceptOf(\n+\t\t\tint skipStorage,\n+\t\t\tBufferStorage[] bufferStorages) {\n+\t\tBufferStorage[] copy = new BufferStorage[bufferStorages.length - 1];\n+\t\tint copyTo = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ed31dfcf341a632addaf43b3db2a171508aec3"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4OTAwOQ==", "bodyText": "Again not a hotfix imho.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383189009", "createdAt": "2020-02-24T10:37:02Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/metrics/MinWatermarkGauge.java", "diffHunk": "@@ -20,21 +20,23 @@\n \n import org.apache.flink.metrics.Gauge;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d0c2c8fc103a2268a3b064913d6b3a4e76cfd7"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5MTcyNw==", "bodyText": "any reason why inputMask is long but availableInputsMask is not?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383191727", "createdAt": "2020-02-24T10:42:26Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,6 +110,41 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ac483978e13949e15a03ebd7523ee3610661da"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5NDM3OA==", "bodyText": "Since this is very performance critical, we might need to check if we can use the ideas behind Integer#numberOfTrailingZeros to speed things up.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383194378", "createdAt": "2020-02-24T10:47:42Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,6 +110,41 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ac483978e13949e15a03ebd7523ee3610661da"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5NTAwOA==", "bodyText": "This looks like two test cases to me.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383195008", "createdAt": "2020-02-24T10:48:45Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/InputSelectionTest.java", "diffHunk": "@@ -75,6 +75,28 @@ public void testFairSelectNextIndexOutOf2() {\n \t\tassertEquals(-1, InputSelection.SECOND.fairSelectNextIndexOutOf2(0, 1));\n \t}\n \n+\t@Test\n+\tpublic void testFairSelectNextIndex() {\n+\t\tassertEquals(1, InputSelection.ALL.fairSelectNextIndex(7, 0));\n+\t\tassertEquals(2, InputSelection.ALL.fairSelectNextIndex(7, 1));\n+\t\tassertEquals(0, InputSelection.ALL.fairSelectNextIndex(7, 2));\n+\t\tassertEquals(1, InputSelection.ALL.fairSelectNextIndex(7, 0));\n+\n+\t\t// combination of selection and availability is supposed to be 3, 5, 8:\n+\t\tInputSelection selection = new Builder().select(2).select(3).select(4).select(5).select(8).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ac483978e13949e15a03ebd7523ee3610661da"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5Njc0Mw==", "bodyText": "We could just expose mailboxProcessor to tests and delegate to MailboxProcessor#runMailboxStep in harness.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383196743", "createdAt": "2020-02-24T10:52:03Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -484,11 +485,15 @@ public final void invoke() throws Exception {\n \t\t}\n \t}\n \n+\tprotected boolean runMailboxStep() throws Exception {\n+\t\treturn mailboxProcessor.runMailboxStep();\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5ODUzMQ==", "bodyText": "Visible for testing.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383198531", "createdAt": "2020-02-24T10:55:43Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -183,9 +183,20 @@ public void runMailboxLoop() throws Exception {\n \n \t\tfinal MailboxController defaultActionContext = new MailboxController(this);\n \n-\t\twhile (processMail(localMailbox)) {\n+\t\twhile (runMailboxStep(localMailbox, defaultActionContext)) {\n+\t\t}\n+\t}\n+\n+\tpublic boolean runMailboxStep() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b562ca278304274d87807b319e64c6b57d65d7d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA==", "bodyText": "I didn't get why we'd need the owner in this commit.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383201040", "createdAt": "2020-02-24T11:00:46Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamConfigChainer.java", "diffHunk": "@@ -42,15 +42,17 @@\n /**\n  * Helper class to build StreamConfig for chain of operators.\n  */\n-public class StreamConfigChainer {\n+public class StreamConfigChainer<OWNER> {\n+\tprivate final OWNER owner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b562ca278304274d87807b319e64c6b57d65d7d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTM4OA==", "bodyText": "Could also be done with prefix.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383201388", "createdAt": "2020-02-24T11:01:26Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java", "diffHunk": "@@ -42,8 +42,11 @@ private MetricNames() {\n \tpublic static final String IO_NUM_BUFFERS_OUT_RATE = IO_NUM_BUFFERS_OUT + SUFFIX_RATE;\n \n \tpublic static final String IO_CURRENT_INPUT_WATERMARK = \"currentInputWatermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_1_WATERMARK = \"currentInput1Watermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_2_WATERMARK = \"currentInput2Watermark\";\n+\tpublic static final String IO_CURRENT_INPUT_WATERMARK_PATERN = \"currentInput%dWatermark\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMzIwNQ==", "bodyText": "I don't see an issue with that. For me this is the transition function of an finite automate.\nnit: reportInputStatus -> updateInputStatus", "url": "https://github.com/apache/flink/pull/11098#discussion_r383203205", "createdAt": "2020-02-24T11:05:33Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMzkxNQ==", "bodyText": "Should probably be -1 if we start at 0 as always.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383203915", "createdAt": "2020-02-24T11:07:06Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNDg5MQ==", "bodyText": "Couldn't we introduce some open/init for this case?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383204891", "createdAt": "2020-02-24T11:09:29Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNjk1NA==", "bodyText": "Would probably be better to use CompletableFuture#any in any case.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383206954", "createdAt": "2020-02-24T11:14:11Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\t// to avoid starvation, if the input selection is ALL and availableInputsMask is not ALL,\n+\t\t// always try to check and set the availability of another input\n+\t\tif (inputSelectionHandler.shouldSetAvailableForAnotherInput()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\treturn readingInputIndex;\n+\t}\n+\n+\tprivate void fullCheckAndSetAvailable() {\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tInputProcessor<?> inputProcessor = inputProcessors[i];\n+\t\t\t// TODO: isAvailable() can be a costly operation (checking volatile). If one of\n+\t\t\t// the input is constantly available and another is not, we will be checking this volatile\n+\t\t\t// once per every record. This might be optimized to only check once per processed NetworkBuffer\n+\t\t\tif (inputProcessor.networkInput.isApproximatelyAvailable() || inputProcessor.networkInput.isAvailable()) {\n+\t\t\t\tinputSelectionHandler.setAvailableInput(i);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate CompletableFuture<?> isAnyInputAvailable() {\n+\t\tif (inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\treturn AVAILABLE;\n+\t\t}\n+\t\tfinal CompletableFuture<?> anyInputAvailable = new CompletableFuture<>();\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tif (!inputSelectionHandler.isInputFinished(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjg1Mzg4", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-363285388", "createdAt": "2020-02-24T10:22:23Z", "commit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMDoyMjoyM1rOFtbiDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNzo1MTozM1rOFtqASg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MTMyNw==", "bodyText": "I'm not sure. Also as it is now, the hot looping path\n\t\t\tcase MORE_AVAILABLE:\n\t\t\t\tcheckState(checkBitMask(availableInputsMask, inputIndex));\n\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n\nis a bit shorter, this probably doesn't matter much, but I'm not sure in the first place if it makes sense to push the responsibility on a caller, to always call two methods (especially since they are logically inseparable), .", "url": "https://github.com/apache/flink/pull/11098#discussion_r383181327", "createdAt": "2020-02-24T10:22:23Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTI4MA==", "bodyText": "It would be indeed nicer. However this brings extra overhead of virtualisation, and might mess up with the optimiser for the common path (no  InputSelector), preventing inlining etc. I'm not sure how much does it matter in here though.\nHowever if we wanted to do it, it should also be changed in the two input processor as well, and would require more cautious regression benchmarks. So I would suggest to do it independently.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383185280", "createdAt": "2020-02-24T10:29:52Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {\n+\t\tswitch (inputStatus) {\n+\t\t\tcase MORE_AVAILABLE:\n+\t\t\t\tcheckState(checkBitMask(availableInputsMask, inputIndex));\n+\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t\tcase NOTHING_AVAILABLE:\n+\t\t\t\tavailableInputsMask = unsetBitMask(availableInputsMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tcase END_OF_INPUT:\n+\t\t\t\tendOfInputMask = setBitMask(endOfInputMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported inputStatus = \" + inputStatus);\n+\t\t}\n+\n+\t\treturn calculateInputStatus();\n+\t}\n+\n+\tpublic InputStatus calculateInputStatus() throws IOException {\n+\t\tif (endOfInputMask == allSelectedMask) {\n+\t\t\treturn InputStatus.END_OF_INPUT;\n+\t\t}\n+\n+\t\tif (isAnyInputAvailable()) {\n+\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t}\n+\t\telse {\n+\t\t\tlong selectedNotFinishedInputMask = inputSelection.getInputMask() & ~(endOfInputMask);\n+\t\t\tif (selectedNotFinishedInputMask == 0) {\n+\t\t\t\tthrow new IOException(\"Can not make a progress: all selected inputs are already finished\");\n+\t\t\t}\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\t}\n+\n+\tvoid nextSelection() {\n+\t\tif (inputSelector == null) {\n+\t\t\tinputSelection = InputSelection.ALL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2MTA2Nw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NjIxNg==", "bodyText": "Hmmm, indeed we do. I've noticed this behaviour when writing a unit test and was wondering where does it come from, but in the end, it made me realise that neither the production code nor the tests should relay on such behaviour, so I think this is just fine.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383186216", "createdAt": "2020-02-24T10:31:37Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NzcyMQ==", "bodyText": "I haven't yet tested it with the input selection and I'm not sure if the isAnyInputAvailable properly supports inputs selection.\nHmm.. it looks like it might be just missing a single if check, but I'm not sure.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383187721", "createdAt": "2020-02-24T10:34:31Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NzYxNw=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIzMTIxNQ==", "bodyText": "Good catch, there should be one more check +/-:\nif (inputSelectionHandler.isAnyInputAvailable() || inputSelectionHandler.areAllInputsFinished()) {\n\treturn AVAILABLE;\n}", "url": "https://github.com/apache/flink/pull/11098#discussion_r383231215", "createdAt": "2020-02-24T12:14:18Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\t// to avoid starvation, if the input selection is ALL and availableInputsMask is not ALL,\n+\t\t// always try to check and set the availability of another input\n+\t\tif (inputSelectionHandler.shouldSetAvailableForAnotherInput()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\treturn readingInputIndex;\n+\t}\n+\n+\tprivate void fullCheckAndSetAvailable() {\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tInputProcessor<?> inputProcessor = inputProcessors[i];\n+\t\t\t// TODO: isAvailable() can be a costly operation (checking volatile). If one of\n+\t\t\t// the input is constantly available and another is not, we will be checking this volatile\n+\t\t\t// once per every record. This might be optimized to only check once per processed NetworkBuffer\n+\t\t\tif (inputProcessor.networkInput.isApproximatelyAvailable() || inputProcessor.networkInput.isAvailable()) {\n+\t\t\t\tinputSelectionHandler.setAvailableInput(i);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate CompletableFuture<?> isAnyInputAvailable() {\n+\t\tif (inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\treturn AVAILABLE;\n+\t\t}\n+\t\tfinal CompletableFuture<?> anyInputAvailable = new CompletableFuture<>();\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tif (!inputSelectionHandler.isInputFinished(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM1MDU5OQ==", "bodyText": "Good catch. Currently this is a dead code (watermarks not yet supported). I think this has a dedicated test in TwoInputStreamTask version, which I wanted to port with a follow up PR adding support for watermarks.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383350599", "createdAt": "2020-02-24T15:56:00Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NjA4Mg=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM3NzgyNw==", "bodyText": "actually not :) This constructor is the only way to actually use the MutlipleInputTransformation. But as this is a @Public class, good that you are rising this issue.\n@aljoscha you might want to voice your opinion about this and the first commit of this PR in general.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383377827", "createdAt": "2020-02-24T16:38:33Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/SingleOutputStreamOperator.java", "diffHunk": "@@ -59,7 +59,7 @@\n \n \tprivate boolean wasSplitApplied = false;\n \n-\tprotected SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {\n+\tpublic SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3Mzc5NQ=="}, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4MTA1NQ==", "bodyText": "Bah, I don't like going back and forth between collections and streams. Especially in flatMap. But ok ;)", "url": "https://github.com/apache/flink/pull/11098#discussion_r383381055", "createdAt": "2020-02-24T16:43:52Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");\n+\t\tinputs.add(input);\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input, KeySelector<?, ?> keySelector) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.size() == inputs.size(),\n+\t\t\t\"Trying to add keyed input to non-keyed transformation\");\n+\t\tinputs.add(input);\n+\t\tstateKeySelectors.add(keySelector);\n+\t}\n+\n+\tpublic List<KeySelector<?, ?>> getStateKeySelectors() {\n+\t\treturn stateKeySelectors;\n+\t}\n+\n+\tpublic void setStateKeyType(TypeInformation<?> stateKeyType) {\n+\t\tthis.stateKeyType = stateKeyType;\n+\t}\n+\n+\tpublic TypeInformation<?> getStateKeyType() {\n+\t\treturn stateKeyType;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<Transformation<?>> getTransitivePredecessors() {\n+\t\tList<Transformation<?>> result = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MzYwOQ=="}, "originalCommit": {"oid": "cc14a078882901405f9531d06eb83bdd45a528fb"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTUwNw==", "bodyText": "Keep in mind that this method is only used in the tests, to make some assertions.\nGenerally speaking this old getStreamEdges() with throwing an exception was a bad & confusing design. It should never be like that. If it wasn't supposed to be empty, test should just assert manually content of the actual list, instead of relaying on this method throwing an exception. I tried to use it to actually make an assertion that the list is empty and it exploded in my face with some RuntimeException...\nIf not for the fact that this method is used a lot in the tests and annoyingly, couple percent of those tests are actually relaying on the fact that this method throws, I would just drop it and use getStreamEdges() everywhere properly , but there were too many usages and I gave up...", "url": "https://github.com/apache/flink/pull/11098#discussion_r383385507", "createdAt": "2020-02-24T16:51:02Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -637,19 +638,24 @@ public StreamNode getStreamNode(Integer vertexID) {\n \t\treturn streamNodes.keySet();\n \t}\n \n+\t@VisibleForTesting\n \tpublic List<StreamEdge> getStreamEdges(int sourceId, int targetId) {\n-\n \t\tList<StreamEdge> result = new ArrayList<>();\n \t\tfor (StreamEdge edge : getStreamNode(sourceId).getOutEdges()) {\n \t\t\tif (edge.getTargetId() == targetId) {\n \t\t\t\tresult.add(edge);\n \t\t\t}\n \t\t}\n+\t\treturn result;\n+\t}\n \n+\t@VisibleForTesting\n+\t@Deprecated\n+\tpublic List<StreamEdge> getStreamEdgesOrThrow(int sourceId, int targetId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg=="}, "originalCommit": {"oid": "33c07ff8c333074b60425360c101ffd1de8e58c5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NzY2Mw==", "bodyText": "but with %d it's a pattern now, not a prefix, so the name fits. Or do you mean to change it to prefix (by dropping the %d part?)? If the latter, I think pattern > prefix.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383387663", "createdAt": "2020-02-24T16:54:36Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -73,8 +73,8 @@\n \tprivate static final String ITERATION_ID = \"iterationId\";\n \tprivate static final String OUTPUT_SELECTOR_WRAPPER = \"outputSelectorWrapper\";\n \tprivate static final String BUFFER_TIMEOUT = \"bufferTimeout\";\n-\tprivate static final String TYPE_SERIALIZER_IN_1 = \"typeSerializer_in_1\";\n-\tprivate static final String TYPE_SERIALIZER_IN_2 = \"typeSerializer_in_2\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_COUNT = \"typeSerializer_in_count\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_PATTERN = \"typeSerializer_in_%d\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODgzNQ=="}, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4ODAzNw==", "bodyText": "no need for the backwards compatibility - I've double checked that with SDK team.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383388037", "createdAt": "2020-02-24T16:55:14Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -158,12 +158,11 @@ public TimeCharacteristic getTimeCharacteristic() {\n \t\t}\n \t}\n \n-\tpublic void setTypeSerializerIn1(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_1, serializer);\n-\t}\n-\n-\tpublic void setTypeSerializerIn2(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_2, serializer);\n+\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n+\t\tconfig.setInteger(TYPE_SERIALIZERS_IN_COUNT, serializers.length);\n+\t\tfor (int i = 0; i < serializers.length; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODQ2MQ=="}, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5MjE1NA==", "bodyText": "I'm not sure. I was mostly copying the logic from transformTwoInputTransform (and also the same pattern is in transformOneInputTransform as well).\nHowever it looks like this might be because of cyclic dependencies.\nDo you think this is a bug in all of those places?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383392154", "createdAt": "2020-02-24T17:02:16Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java", "diffHunk": "@@ -735,6 +739,56 @@ public StreamGraph generate() {\n \t\treturn Collections.singleton(transform.getId());\n \t}\n \n+\tprivate <OUT> Collection<Integer> transformMultipleInputTransform(MultipleInputTransformation<OUT> transform) {\n+\t\tList<Collection<Integer>> allInputIds = new ArrayList<>();\n+\n+\t\tfor (Transformation<?> input : transform.getInputs()) {\n+\t\t\tallInputIds.add(transform(input));\n+\t\t}\n+\n+\t\t// the recursive call might have already transformed this\n+\t\tif (alreadyTransformed.containsKey(transform)) {\n+\t\t\treturn alreadyTransformed.get(transform);\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5NjA0OQ==", "bodyText": "It's not used in the sources. I think indeed the job graph generator could crash if this is empty. Also currently that could happen only with incorrectly constructed/implemented MultipleInputOperator, so I think it's a good idea to just disallow it.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383396049", "createdAt": "2020-02-24T17:09:20Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamNode.java", "diffHunk": "@@ -235,20 +234,16 @@ public void addOutputSelector(OutputSelector<?> outputSelector) {\n \t\tthis.outputSelectors.add(outputSelector);\n \t}\n \n-\tpublic TypeSerializer<?> getTypeSerializerIn1() {\n-\t\treturn typeSerializerIn1;\n+\tpublic void setSerializersIn(TypeSerializer<?> ...typeSerializersIn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwMjA0OQ==", "bodyText": "I don't know why I haven't figured this out \ud83d\ude13", "url": "https://github.com/apache/flink/pull/11098#discussion_r383402049", "createdAt": "2020-02-24T17:20:11Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -312,6 +316,40 @@ public void testOutputTypeConfigurationWithTwoInputTransformation() throws Excep\n \t\tassertEquals(BasicTypeInfo.INT_TYPE_INFO, outputTypeConfigurableOperation.getTypeInformation());\n \t}\n \n+\t@Test\n+\tpublic void testMultipleInputTransformation() throws Exception {\n+\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n+\t\t//TODO: referring to getNewNodeId() is hacky, but I'm not sure if there is a better idea?\n+\t\tint startingNewNodeId = Transformation.getNewNodeId();\n+\n+\t\tDataStream<Integer> source1 = env.fromElements(1, 10);\n+\t\tDataStream<Long> source2 = env.fromElements(2L, 11L);\n+\t\tDataStream<String> source3 = env.fromElements(\"42\", \"44\");\n+\n+\t\tMultipleInputTransformation<String> transform = new MultipleInputTransformation<String>(\n+\t\t\t\"My Operator\",\n+\t\t\tnew MultipleInputOperatorFactory(),\n+\t\t\tBasicTypeInfo.STRING_TYPE_INFO,\n+\t\t\t3);\n+\n+\t\ttransform.addInput(source1.getTransformation());\n+\t\ttransform.addInput(source2.getTransformation());\n+\t\ttransform.addInput(source3.getTransformation());\n+\n+\t\tenv.addOperator(transform);\n+\t\tStreamGraph streamGraph = env.getStreamGraph();\n+\t\tassertEquals(4, streamGraph.getStreamNodes().size());\n+\n+\t\tint id = startingNewNodeId;\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3).size());\n+\t\tassertEquals(0, streamGraph.getStreamEdges(id + 4).size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY3ODEwNQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwMjkwNg==", "bodyText": "This is not using SimpleOperatorFactory, isn't it?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383402906", "createdAt": "2020-02-24T17:21:43Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -633,4 +671,29 @@ protected boolean matchesSafely(ResourceSpec item) {\n \t\t\treturn resources.lessThanOrEqual(item) && item.lessThanOrEqual(resources);\n \t\t}\n \t}\n+\n+\tprivate static class MultipleInputOperatorFactory implements StreamOperatorFactory<String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTcyOQ=="}, "originalCommit": {"oid": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwOTM0Mg==", "bodyText": "I've forgotten about a TODO in the code to investigate it. I think we should be fine by supporting longs. Previously for two input case it was int, as  it was max 2.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383409342", "createdAt": "2020-02-24T17:33:26Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,6 +110,41 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5MTcyNw=="}, "originalCommit": {"oid": "34ac483978e13949e15a03ebd7523ee3610661da"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNDY2Ng==", "bodyText": "I think this could be part of the public api for this class.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383414666", "createdAt": "2020-02-24T17:44:01Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -183,9 +183,20 @@ public void runMailboxLoop() throws Exception {\n \n \t\tfinal MailboxController defaultActionContext = new MailboxController(this);\n \n-\t\twhile (processMail(localMailbox)) {\n+\t\twhile (runMailboxStep(localMailbox, defaultActionContext)) {\n+\t\t}\n+\t}\n+\n+\tpublic boolean runMailboxStep() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5ODUzMQ=="}, "originalCommit": {"oid": "5b562ca278304274d87807b319e64c6b57d65d7d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNTkwNw==", "bodyText": "It's in order to provide a nice builder like API, for nested builder. That after finish() call on setting up the chaining, we  can continue configuring or build the test harness:\n\t\t\tnew MultipleInputStreamTaskTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.setupOperatorChain(new DuplicatingOperator())\n\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t.finish()\n\t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n\t\t\t\t.build()\n\nAnd OWNER is template, so that finish() and hence build() would return correct specific type of the test harness (MultipleInput)", "url": "https://github.com/apache/flink/pull/11098#discussion_r383415907", "createdAt": "2020-02-24T17:46:30Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamConfigChainer.java", "diffHunk": "@@ -42,15 +42,17 @@\n /**\n  * Helper class to build StreamConfig for chain of operators.\n  */\n-public class StreamConfigChainer {\n+public class StreamConfigChainer<OWNER> {\n+\tprivate final OWNER owner;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA=="}, "originalCommit": {"oid": "5b562ca278304274d87807b319e64c6b57d65d7d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNzMyMg==", "bodyText": "As previously, even if we re ordered it as prefix, patterns carry more information and are more concrete/well defined. For example, if you have prefix, does it mean that there is no suffix or other infix? Pattern mitigates this ambiguity.", "url": "https://github.com/apache/flink/pull/11098#discussion_r383417322", "createdAt": "2020-02-24T17:49:21Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java", "diffHunk": "@@ -42,8 +42,11 @@ private MetricNames() {\n \tpublic static final String IO_NUM_BUFFERS_OUT_RATE = IO_NUM_BUFFERS_OUT + SUFFIX_RATE;\n \n \tpublic static final String IO_CURRENT_INPUT_WATERMARK = \"currentInputWatermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_1_WATERMARK = \"currentInput1Watermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_2_WATERMARK = \"currentInput2Watermark\";\n+\tpublic static final String IO_CURRENT_INPUT_WATERMARK_PATERN = \"currentInput%dWatermark\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTM4OA=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxODQ0Mg==", "bodyText": "+/- 0 from my side. Complicating the interface of the class vs a tinny implementation hiccup ?", "url": "https://github.com/apache/flink/pull/11098#discussion_r383418442", "createdAt": "2020-02-24T17:51:33Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNDg5MQ=="}, "originalCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f"}, "originalPosition": 126}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "committedDate": "2020-02-17T11:59:11Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "ac7b323867f647d50b170c23df6c6052b2c08d61", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ac7b323867f647d50b170c23df6c6052b2c08d61", "committedDate": "2020-02-24T17:52:59Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac7b323867f647d50b170c23df6c6052b2c08d61", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ac7b323867f647d50b170c23df6c6052b2c08d61", "committedDate": "2020-02-24T17:52:59Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "68393ef701e7b462638a26e89df167fa4a36ec14", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/68393ef701e7b462638a26e89df167fa4a36ec14", "committedDate": "2020-02-25T08:29:10Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68393ef701e7b462638a26e89df167fa4a36ec14", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/68393ef701e7b462638a26e89df167fa4a36ec14", "committedDate": "2020-02-25T08:29:10Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "352eaf94ac42b2428e2f2f90081e7a023136d9fd", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/352eaf94ac42b2428e2f2f90081e7a023136d9fd", "committedDate": "2020-02-26T08:43:50Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NzI0MjEz", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-364724213", "createdAt": "2020-02-26T09:05:53Z", "commit": {"oid": "68393ef701e7b462638a26e89df167fa4a36ec14"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NzU3ODIw", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-364757820", "createdAt": "2020-02-26T09:52:17Z", "commit": {"oid": "352eaf94ac42b2428e2f2f90081e7a023136d9fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "352eaf94ac42b2428e2f2f90081e7a023136d9fd", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/352eaf94ac42b2428e2f2f90081e7a023136d9fd", "committedDate": "2020-02-26T08:43:50Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "8e56fa6affa8e58ed6ad9233345c7c5b697de4ea", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8e56fa6affa8e58ed6ad9233345c7c5b697de4ea", "committedDate": "2020-02-26T14:53:34Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTY1NzU3", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-364965757", "createdAt": "2020-02-26T14:55:29Z", "commit": {"oid": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1NToyOVrOFuuuZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1NToyOVrOFuuuZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDM1OQ==", "bodyText": "@AHeise could you take a look at the first commit once more time? I've reverted the @Public api change.", "url": "https://github.com/apache/flink/pull/11098#discussion_r384544359", "createdAt": "2020-02-26T14:55:29Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/MultipleConnectedStreams.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.datastream;\n+\n+import org.apache.flink.annotation.Experimental;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.transformations.MultipleInputTransformation;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This is a very basic and rough stub for a class connecting multiple input {@link DataStream}s\n+ * into one, using {@link MultipleInputStreamOperator}.\n+ */\n+@Experimental\n+public class MultipleConnectedStreams {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NjYyOTQ0", "url": "https://github.com/apache/flink/pull/11098#pullrequestreview-365662944", "createdAt": "2020-02-27T13:05:35Z", "commit": {"oid": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzowNTozNlrOFvRbVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzowNTozNlrOFvRbVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMjkxOA==", "bodyText": "Should be transform. doTransform would be the private implementation.", "url": "https://github.com/apache/flink/pull/11098#discussion_r385112918", "createdAt": "2020-02-27T13:05:36Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/MultipleConnectedStreams.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.datastream;\n+\n+import org.apache.flink.annotation.Experimental;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.transformations.MultipleInputTransformation;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This is a very basic and rough stub for a class connecting multiple input {@link DataStream}s\n+ * into one, using {@link MultipleInputStreamOperator}.\n+ */\n+@Experimental\n+public class MultipleConnectedStreams {\n+\n+\tprotected final StreamExecutionEnvironment environment;\n+\n+\tpublic MultipleConnectedStreams(StreamExecutionEnvironment env) {\n+\t\tthis.environment = requireNonNull(env);\n+\t}\n+\n+\tpublic StreamExecutionEnvironment getExecutionEnvironment() {\n+\t\treturn environment;\n+\t}\n+\n+\tpublic <OUT> SingleOutputStreamOperator<OUT> doTransform(MultipleInputTransformation<OUT> transform) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "445bb2c0d1e78d34129e36b1372de9a900aef7d1", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/445bb2c0d1e78d34129e36b1372de9a900aef7d1", "committedDate": "2020-02-27T15:07:02Z", "message": "[FLINK-15688][streaming] Define DataStream API for MultipleInputStreamOperator\n\nThis interface is still not complete - it's missing for example watermark and\nlatency markers support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a74317be52485be3ec6b07ab6c648cbf27cc762e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/a74317be52485be3ec6b07ab6c648cbf27cc762e", "committedDate": "2020-02-27T15:07:02Z", "message": "[hotfix][test] Rename getStreamEdges to getStreamEdgesOrThrow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e84b830ceb9ff05b07c955f63145157f5711bb4c", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/e84b830ceb9ff05b07c955f63145157f5711bb4c", "committedDate": "2020-02-27T15:07:02Z", "message": "[hotfix][streaming] Deduplicate code in StreamGraph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0585cb5c374c2db5bddf3d54546fcba594c418d3", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/0585cb5c374c2db5bddf3d54546fcba594c418d3", "committedDate": "2020-02-27T15:07:02Z", "message": "[FLINK-15688][streaming] Add support for MultipleInputStreamOperator in the StreamGraphGenerator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df071c1e7d71fca6b26a36026c39d4c21361dc63", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/df071c1e7d71fca6b26a36026c39d4c21361dc63", "committedDate": "2020-02-27T15:07:02Z", "message": "[hotfix][test] Deduplicate code in LinkedBufferStorageTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf72510a524f4f5506ccb70d69e0ce9e08502241", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/bf72510a524f4f5506ccb70d69e0ce9e08502241", "committedDate": "2020-02-27T15:07:03Z", "message": "[FLINK-16060][checkpointing] Generalize LinkedBufferStorage to support arbitrary number of linked buffer storages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c477b07a4c393b2a6555b4d60776ffa93aa50f83", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/c477b07a4c393b2a6555b4d60776ffa93aa50f83", "committedDate": "2020-02-27T15:07:03Z", "message": "[FLINK-16060][metrics] Generalize MinWatermarkGauge to accept an aribtrary number of input gauges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f82f13a03c276d59b4f6dca4ee8692d6cb5bc5e", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/6f82f13a03c276d59b4f6dca4ee8692d6cb5bc5e", "committedDate": "2020-02-27T15:07:03Z", "message": "[hotfix][task] Extract InputSelection.NONE_AVAILABLE constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2462b4ef88b2633222ad4ae6ee12c09d5f7725f8", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/2462b4ef88b2633222ad4ae6ee12c09d5f7725f8", "committedDate": "2020-02-27T15:07:03Z", "message": "[FLINK-16060][task] Implement InputSelection#fairSelectNextIndex\n\nThis is going to be used for runtime support of MultipleInputStreamOperator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed5c836b342a54914f77ea922328a7f17318e3dc", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/ed5c836b342a54914f77ea922328a7f17318e3dc", "committedDate": "2020-02-27T15:07:04Z", "message": "[FLINK-16060][task] Generalize InputSelection#isAllMaskOf2 to multiple inputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dac2a72a8184939f537c52962555971b7ff3097", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8dac2a72a8184939f537c52962555971b7ff3097", "committedDate": "2020-02-27T15:07:04Z", "message": "[hotfix][tests] Clean up exception lists of StreamTestSingleInputGate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a3c8c731bf1b7b42cefc827dc87473f02b65069", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/1a3c8c731bf1b7b42cefc827dc87473f02b65069", "committedDate": "2020-02-27T15:07:04Z", "message": "[FLINK-16060][test] Provide a test harness for MultipleInputStreamTask\n\nThis creates new hierarchy of task harnesses that could be used for other tasks as well."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b85332b20e2765101e28eca8ac45584ab57c77a0", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/b85332b20e2765101e28eca8ac45584ab57c77a0", "committedDate": "2020-02-27T15:07:04Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eddb9c592940b4c05578dd31e446b7c4ad6f14de", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/eddb9c592940b4c05578dd31e446b7c4ad6f14de", "committedDate": "2020-02-27T14:47:20Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet."}, "afterCommit": {"oid": "8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "committedDate": "2020-02-27T15:04:35Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "committedDate": "2020-02-27T15:04:35Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet"}, "afterCommit": {"oid": "b85332b20e2765101e28eca8ac45584ab57c77a0", "author": {"user": {"login": "pnowojski", "name": "Piotr Nowojski"}}, "url": "https://github.com/apache/flink/commit/b85332b20e2765101e28eca8ac45584ab57c77a0", "committedDate": "2020-02-27T15:07:04Z", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4379, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}