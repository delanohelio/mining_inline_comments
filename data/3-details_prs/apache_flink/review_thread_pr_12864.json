{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MjQ0MDUw", "number": 12864, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzo0ODoxOVrOEQc8Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjoyMDozMVrOEQetIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Njg2Nzk1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzo0ODoxOVrOG0nD0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzo0ODoxOVrOG0nD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxOTA4OA==", "bodyText": "make the default value a static member?", "url": "https://github.com/apache/flink/pull/12864#discussion_r457819088", "createdAt": "2020-07-21T03:48:19Z", "author": {"login": "lirui-apache"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);\n+\n+\t\tSet<String> consumedOptionKeys = new HashSet<>();\n+\t\tconsumedOptionKeys.add(CONNECTOR.key());\n+\t\tconsumedOptionKeys.add(ROWS_PER_SECOND.key());\n+\t\toptionalOptions.stream().map(ConfigOption::key).forEach(consumedOptionKeys::add);\n+\t\tFactoryUtil.validateUnconsumedKeys(factoryIdentifier(), options.keySet(), consumedOptionKeys);\n+\n+\t\treturn new DataGenTableSource(fieldGenerators, schema, options.get(ROWS_PER_SECOND));\n \t}\n \n-\tprivate DataGenerator createDataGenerator(String name, DataType type, ReadableConfig options) {\n-\t\tString genType = options.get(\n-\t\t\t\tkey(FIELDS + \".\" + name + \".\" + KIND).stringType().defaultValue(RANDOM));\n-\t\tswitch (genType) {\n+\tprivate DataGeneratorContainer createContainer(\n+\t\t\tString name, DataType type, String kind, ReadableConfig options) {\n+\t\tswitch (kind) {\n \t\t\tcase RANDOM:\n-\t\t\t\treturn createRandomGenerator(name, type, options);\n+\t\t\t\treturn createRandomContainer(name, type, options);\n \t\t\tcase SEQUENCE:\n-\t\t\t\treturn createSequenceGenerator(name, type, options);\n+\t\t\t\treturn createSequenceContainer(name, type, options);\n \t\t\tdefault:\n-\t\t\t\tthrow new ValidationException(\"Unsupported generator type: \" + genType);\n+\t\t\t\tthrow new ValidationException(\"Unsupported generator kind: \" + kind);\n \t\t}\n \t}\n \n-\tprivate DataGenerator createRandomGenerator(String name, DataType type, ReadableConfig options) {\n-\t\tConfigOption<Integer> lenKey = key(FIELDS + \".\" + name + \".\" + LENGTH)\n-\t\t\t\t.intType().defaultValue(100);\n+\tprivate DataGeneratorContainer createRandomContainer(String name, DataType type, ReadableConfig config) {\n \t\tOptionBuilder minKey = key(FIELDS + \".\" + name + \".\" + MIN);\n \t\tOptionBuilder maxKey = key(FIELDS + \".\" + name + \".\" + MAX);\n \t\tswitch (type.getLogicalType().getTypeRoot()) {\n-\t\t\tcase BOOLEAN:\n-\t\t\t\treturn RandomGenerator.booleanGenerator();\n+\t\t\tcase BOOLEAN: {\n+\t\t\t\treturn DataGeneratorContainer.of(RandomGenerator.booleanGenerator());\n+\t\t\t}\n \t\t\tcase CHAR:\n-\t\t\tcase VARCHAR:\n-\t\t\t\tint length = options.get(lenKey);\n-\t\t\t\treturn getRandomStringGenerator(length);\n-\t\t\tcase TINYINT:\n-\t\t\t\treturn RandomGenerator.byteGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue((int) Byte.MIN_VALUE)).byteValue(),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue((int) Byte.MAX_VALUE)).byteValue());\n-\t\t\tcase SMALLINT:\n-\t\t\t\treturn RandomGenerator.shortGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue((int) Short.MIN_VALUE)).shortValue(),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue((int) Short.MAX_VALUE)).shortValue());\n-\t\t\tcase INTEGER:\n-\t\t\t\treturn RandomGenerator.intGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue(Integer.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue(Integer.MAX_VALUE)));\n-\t\t\tcase BIGINT:\n-\t\t\t\treturn RandomGenerator.longGenerator(\n-\t\t\t\t\t\toptions.get(minKey.longType().defaultValue(Long.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.longType().defaultValue(Long.MAX_VALUE)));\n-\t\t\tcase FLOAT:\n-\t\t\t\treturn RandomGenerator.floatGenerator(\n-\t\t\t\t\t\toptions.get(minKey.floatType().defaultValue(Float.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.floatType().defaultValue(Float.MAX_VALUE)));\n-\t\t\tcase DOUBLE:\n-\t\t\t\treturn RandomGenerator.doubleGenerator(\n-\t\t\t\t\t\toptions.get(minKey.doubleType().defaultValue(Double.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.doubleType().defaultValue(Double.MAX_VALUE)));\n+\t\t\tcase VARCHAR: {\n+\t\t\t\tConfigOption<Integer> lenOption = key(FIELDS + \".\" + name + \".\" + LENGTH)\n+\t\t\t\t\t\t.intType()\n+\t\t\t\t\t\t.defaultValue(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzExOTY4OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjowNDoxOFrOG0pWsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjowNDoxOFrOG0pWsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NjY5MA==", "bodyText": "Call requiredOptions() instead of new HashSet<>()?", "url": "https://github.com/apache/flink/pull/12864#discussion_r457856690", "createdAt": "2020-07-21T06:04:18Z", "author": {"login": "lirui-apache"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzE1MjYwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjoxODozOVrOG0pqCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTozMzoyOFrOG2DEXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTY0Mg==", "bodyText": "Is this necessary, given that we'll call FactoryUtil.validateFactoryOptions and FactoryUtil.validateUnconsumedKeys later on?", "url": "https://github.com/apache/flink/pull/12864#discussion_r457861642", "createdAt": "2020-07-21T06:18:39Z", "author": {"login": "lirui-apache"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNjU1Ng==", "bodyText": "Yes, No necessary.", "url": "https://github.com/apache/flink/pull/12864#discussion_r459326556", "createdAt": "2020-07-23T09:33:28Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTY0Mg=="}, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzE1NzQ1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjoyMDozMVrOG0ps3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTozMzoxNFrOG2DD2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MjM2Nw==", "bodyText": "Do we also need to add PROPERTY_VERSION to consumedOptionKeys?", "url": "https://github.com/apache/flink/pull/12864#discussion_r457862367", "createdAt": "2020-07-21T06:20:31Z", "author": {"login": "lirui-apache"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);\n+\n+\t\tSet<String> consumedOptionKeys = new HashSet<>();\n+\t\tconsumedOptionKeys.add(CONNECTOR.key());\n+\t\tconsumedOptionKeys.add(ROWS_PER_SECOND.key());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNjQyNQ==", "bodyText": "No need. We don't have another version.", "url": "https://github.com/apache/flink/pull/12864#discussion_r459326425", "createdAt": "2020-07-23T09:33:14Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);\n+\n+\t\tSet<String> consumedOptionKeys = new HashSet<>();\n+\t\tconsumedOptionKeys.add(CONNECTOR.key());\n+\t\tconsumedOptionKeys.add(ROWS_PER_SECOND.key());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MjM2Nw=="}, "originalCommit": {"oid": "dc885404cf1343b8316b8574208a2ed9f862673e"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4182, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}