{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMDA2MDg2", "number": 12243, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNToxMTozMVrOD92CLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODoyNFrOD93Uzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTc1MDIwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNToxMTozMVrOGXlRFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozNTo0N1rOGYO8yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MTAxMw==", "bodyText": "Yes... It took me a while to understand their usage. Why don't we make them consistent by easily sorting the inputGates before doing anything here (there's no risk if I understand correctly), so that it won't bother us in the future.", "url": "https://github.com/apache/flink/pull/12243#discussion_r427381013", "createdAt": "2020-05-19T15:11:31Z", "author": {"login": "Jiayi-Liao"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -79,11 +80,26 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tunionedInputGates[i] = InputGateUtil.createInputGate(inputGates[i].toArray(new IndexedInputGate[0]));\n \t\t}\n \n+\t\tIntStream numberOfInputChannelsPerGate =\n+\t\t\tArrays\n+\t\t\t\t.stream(inputGates)\n+\t\t\t\t.flatMap(collection -> collection.stream())\n+\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n+\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n+\n \t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n+\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNjgwNg==", "bodyText": "Hmmm, I'm not sure, as what if left input has input gates with indexes 0 and 3, while the right input has indexes 1, 2 and 4? (I'm not sure if that's a valid scenario in the JobGraphGenerator) Left input would have a one instance of UnionInputGate over gates 0 and 3, while right input would have another instance with gates 1, 2 and 4. However we sort them, it would be somehow inconsistent?", "url": "https://github.com/apache/flink/pull/12243#discussion_r428016806", "createdAt": "2020-05-20T13:37:31Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -79,11 +80,26 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tunionedInputGates[i] = InputGateUtil.createInputGate(inputGates[i].toArray(new IndexedInputGate[0]));\n \t\t}\n \n+\t\tIntStream numberOfInputChannelsPerGate =\n+\t\t\tArrays\n+\t\t\t\t.stream(inputGates)\n+\t\t\t\t.flatMap(collection -> collection.stream())\n+\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n+\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n+\n \t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n+\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MTAxMw=="}, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2Mzk0NQ==", "bodyText": "You're right. I didn't notice that inputGateToChannelIndexOffset's key is an unioned InputGate. Thanks for pointing this out.", "url": "https://github.com/apache/flink/pull/12243#discussion_r428063945", "createdAt": "2020-05-20T14:35:47Z", "author": {"login": "Jiayi-Liao"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -79,11 +80,26 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tunionedInputGates[i] = InputGateUtil.createInputGate(inputGates[i].toArray(new IndexedInputGate[0]));\n \t\t}\n \n+\t\tIntStream numberOfInputChannelsPerGate =\n+\t\t\tArrays\n+\t\t\t\t.stream(inputGates)\n+\t\t\t\t.flatMap(collection -> collection.stream())\n+\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n+\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n+\n \t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n+\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MTAxMw=="}, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTk0ODgyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1NTozMVrOGXnPtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzozODo0OVrOGYMIwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMzQzMQ==", "bodyText": "seems redundant codes new MockChannelStateWriter()", "url": "https://github.com/apache/flink/pull/12243#discussion_r427413431", "createdAt": "2020-05-19T15:55:31Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "diffHunk": "@@ -58,4 +79,57 @@ public void testGenerateInputGateToChannelIndexOffsetMap() {\n \t\tassertEquals(0, inputGateToChannelIndexOffsetMap.get(ig1).intValue());\n \t\tassertEquals(3, inputGateToChannelIndexOffsetMap.get(ig2).intValue());\n \t}\n+\n+\t@Test\n+\tpublic void testCreateCheckpointedMultipleInputGate() throws Exception {\n+\t\ttry (CloseableRegistry registry = new CloseableRegistry()) {\n+\t\t\tMockEnvironment environment = new MockEnvironmentBuilder().build();\n+\t\t\tMockStreamTask streamTask = new MockStreamTaskBuilder(environment).build();\n+\t\t\tStreamConfig streamConfig = new StreamConfig(environment.getJobConfiguration());\n+\t\t\tstreamConfig.setCheckpointMode(CheckpointingMode.EXACTLY_ONCE);\n+\t\t\tstreamConfig.setUnalignedCheckpointsEnabled(true);\n+\n+\t\t\t// First input gate has index larger than the second\n+\t\t\tCollection<IndexedInputGate>[] inputGates = new Collection[] {\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(1, 4)),\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(0, 2)),\n+\t\t\t};\n+\n+\t\t\tnew MockChannelStateWriter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAxNzg1Ng==", "bodyText": "ops, that's a left over of some previous version.", "url": "https://github.com/apache/flink/pull/12243#discussion_r428017856", "createdAt": "2020-05-20T13:38:49Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "diffHunk": "@@ -58,4 +79,57 @@ public void testGenerateInputGateToChannelIndexOffsetMap() {\n \t\tassertEquals(0, inputGateToChannelIndexOffsetMap.get(ig1).intValue());\n \t\tassertEquals(3, inputGateToChannelIndexOffsetMap.get(ig2).intValue());\n \t}\n+\n+\t@Test\n+\tpublic void testCreateCheckpointedMultipleInputGate() throws Exception {\n+\t\ttry (CloseableRegistry registry = new CloseableRegistry()) {\n+\t\t\tMockEnvironment environment = new MockEnvironmentBuilder().build();\n+\t\t\tMockStreamTask streamTask = new MockStreamTaskBuilder(environment).build();\n+\t\t\tStreamConfig streamConfig = new StreamConfig(environment.getJobConfiguration());\n+\t\t\tstreamConfig.setCheckpointMode(CheckpointingMode.EXACTLY_ONCE);\n+\t\t\tstreamConfig.setUnalignedCheckpointsEnabled(true);\n+\n+\t\t\t// First input gate has index larger than the second\n+\t\t\tCollection<IndexedInputGate>[] inputGates = new Collection[] {\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(1, 4)),\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(0, 2)),\n+\t\t\t};\n+\n+\t\t\tnew MockChannelStateWriter() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMzQzMQ=="}, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTk1NjQwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1NzoxM1rOGXnUig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1NzoxM1rOGXnUig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNDY2Ng==", "bodyText": "nit: might be better to place these two lines out of loop to together with barrierHandler\nCheckpointBarrierHandler barrierHandler = checkpointedMultipleInputGate[0].getCheckpointBarrierHandler();\nassertTrue(barrierHandler.getBufferReceivedListener().isPresent());\nBufferReceivedListener bufferReceivedListener = barrierHandler.getBufferReceivedListener().get();", "url": "https://github.com/apache/flink/pull/12243#discussion_r427414666", "createdAt": "2020-05-19T15:57:13Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "diffHunk": "@@ -58,4 +79,57 @@ public void testGenerateInputGateToChannelIndexOffsetMap() {\n \t\tassertEquals(0, inputGateToChannelIndexOffsetMap.get(ig1).intValue());\n \t\tassertEquals(3, inputGateToChannelIndexOffsetMap.get(ig2).intValue());\n \t}\n+\n+\t@Test\n+\tpublic void testCreateCheckpointedMultipleInputGate() throws Exception {\n+\t\ttry (CloseableRegistry registry = new CloseableRegistry()) {\n+\t\t\tMockEnvironment environment = new MockEnvironmentBuilder().build();\n+\t\t\tMockStreamTask streamTask = new MockStreamTaskBuilder(environment).build();\n+\t\t\tStreamConfig streamConfig = new StreamConfig(environment.getJobConfiguration());\n+\t\t\tstreamConfig.setCheckpointMode(CheckpointingMode.EXACTLY_ONCE);\n+\t\t\tstreamConfig.setUnalignedCheckpointsEnabled(true);\n+\n+\t\t\t// First input gate has index larger than the second\n+\t\t\tCollection<IndexedInputGate>[] inputGates = new Collection[] {\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(1, 4)),\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(0, 2)),\n+\t\t\t};\n+\n+\t\t\tnew MockChannelStateWriter() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void addInputData(\n+\t\t\t\t\tlong checkpointId,\n+\t\t\t\t\tInputChannelInfo info,\n+\t\t\t\t\tint startSeqNum,\n+\t\t\t\t\tBuffer... data) {\n+\t\t\t\t\tsuper.addInputData(checkpointId, info, startSeqNum, data);\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tCheckpointedInputGate[] checkpointedMultipleInputGate = InputProcessorUtil.createCheckpointedMultipleInputGate(\n+\t\t\t\tstreamTask,\n+\t\t\t\tstreamConfig,\n+\t\t\t\tnew MockChannelStateWriter(),\n+\t\t\t\tenvironment.getMetricGroup().getIOMetricGroup(),\n+\t\t\t\tstreamTask.getName(),\n+\t\t\t\tinputGates);\n+\t\t\tfor (CheckpointedInputGate checkpointedInputGate : checkpointedMultipleInputGate) {\n+\t\t\t\tregistry.registerCloseable(checkpointedInputGate);\n+\t\t\t}\n+\n+\t\t\tCheckpointBarrierHandler barrierHandler = checkpointedMultipleInputGate[0].getCheckpointBarrierHandler();\n+\n+\t\t\tList<IndexedInputGate> allInputGates = Arrays.stream(inputGates).flatMap(gates -> gates.stream()).collect(Collectors.toList());\n+\t\t\tfor (IndexedInputGate inputGate : allInputGates) {\n+\t\t\t\tfor (int channelId = 0; channelId < inputGate.getNumberOfInputChannels(); channelId++) {\n+\t\t\t\t\tassertTrue(barrierHandler.getBufferReceivedListener().isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTk2MTc1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODoyNFrOGXnXvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODoyNFrOGXnXvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTQ4NQ==", "bodyText": "I am not sure why we need to verify this because it never process the barrier in this test. Maybe verify assertTrue(barrierHandler.getAllBarriersReceivedFuture(1).isDone()) instead?", "url": "https://github.com/apache/flink/pull/12243#discussion_r427415485", "createdAt": "2020-05-19T15:58:24Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/InputProcessorUtilTest.java", "diffHunk": "@@ -58,4 +79,57 @@ public void testGenerateInputGateToChannelIndexOffsetMap() {\n \t\tassertEquals(0, inputGateToChannelIndexOffsetMap.get(ig1).intValue());\n \t\tassertEquals(3, inputGateToChannelIndexOffsetMap.get(ig2).intValue());\n \t}\n+\n+\t@Test\n+\tpublic void testCreateCheckpointedMultipleInputGate() throws Exception {\n+\t\ttry (CloseableRegistry registry = new CloseableRegistry()) {\n+\t\t\tMockEnvironment environment = new MockEnvironmentBuilder().build();\n+\t\t\tMockStreamTask streamTask = new MockStreamTaskBuilder(environment).build();\n+\t\t\tStreamConfig streamConfig = new StreamConfig(environment.getJobConfiguration());\n+\t\t\tstreamConfig.setCheckpointMode(CheckpointingMode.EXACTLY_ONCE);\n+\t\t\tstreamConfig.setUnalignedCheckpointsEnabled(true);\n+\n+\t\t\t// First input gate has index larger than the second\n+\t\t\tCollection<IndexedInputGate>[] inputGates = new Collection[] {\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(1, 4)),\n+\t\t\t\tCollections.singletonList(new MockIndexedInputGate(0, 2)),\n+\t\t\t};\n+\n+\t\t\tnew MockChannelStateWriter() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void addInputData(\n+\t\t\t\t\tlong checkpointId,\n+\t\t\t\t\tInputChannelInfo info,\n+\t\t\t\t\tint startSeqNum,\n+\t\t\t\t\tBuffer... data) {\n+\t\t\t\t\tsuper.addInputData(checkpointId, info, startSeqNum, data);\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tCheckpointedInputGate[] checkpointedMultipleInputGate = InputProcessorUtil.createCheckpointedMultipleInputGate(\n+\t\t\t\tstreamTask,\n+\t\t\t\tstreamConfig,\n+\t\t\t\tnew MockChannelStateWriter(),\n+\t\t\t\tenvironment.getMetricGroup().getIOMetricGroup(),\n+\t\t\t\tstreamTask.getName(),\n+\t\t\t\tinputGates);\n+\t\t\tfor (CheckpointedInputGate checkpointedInputGate : checkpointedMultipleInputGate) {\n+\t\t\t\tregistry.registerCloseable(checkpointedInputGate);\n+\t\t\t}\n+\n+\t\t\tCheckpointBarrierHandler barrierHandler = checkpointedMultipleInputGate[0].getCheckpointBarrierHandler();\n+\n+\t\t\tList<IndexedInputGate> allInputGates = Arrays.stream(inputGates).flatMap(gates -> gates.stream()).collect(Collectors.toList());\n+\t\t\tfor (IndexedInputGate inputGate : allInputGates) {\n+\t\t\t\tfor (int channelId = 0; channelId < inputGate.getNumberOfInputChannels(); channelId++) {\n+\t\t\t\t\tassertTrue(barrierHandler.getBufferReceivedListener().isPresent());\n+\t\t\t\t\tBufferReceivedListener bufferReceivedListener = barrierHandler.getBufferReceivedListener().get();\n+\t\t\t\t\tbufferReceivedListener.notifyBarrierReceived(\n+\t\t\t\t\t\tnew CheckpointBarrier(1, 42, CheckpointOptions.forCheckpointWithDefaultLocation(true, true)),\n+\t\t\t\t\t\tnew InputChannelInfo(inputGate.getGateIndex(), channelId));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tassertFalse(barrierHandler.isCheckpointPending());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b956522108b0344ff004e859c0bc399dc8c38348"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4515, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}