{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMjk5ODMz", "number": 12256, "title": "[FLINK-17018][runtime] Allocates slots in bulks for pipelined region scheduling", "bodyText": "What is the purpose of the change\nBulk slot allocation is needed to check whether a bulk of slot requests can be fulfilled at the same time. See FLIP-119|Bulk Slot Allocation.\nThe dynamic slot sharing makes it hard to implement bulk slot allocation.\nSo we will ignore slot sharing in the first version. Co-location constraints are not supported as a result.\nIntra-bulk input location preferences will also be ignored, otherwise a bulk allocation can be blocked on waiting for producers in the same bulk to be assigned slots first.\nBrief change log\n\nEnables SlotPoolImpl to check whether a bulk of slot requests is fulfillable\nEnables SchedulerImpl for bulk slot allocation\nEnables SlotProviderStrategy for bulk slot allocation\nChange DefaultExecutionSlotAllocator to use bulk slot allocation when it is pipelined region scheduling\n\nVerifying this change\nThis change added tests and can be verified as follows:\n\nAdded tests in SlotPoolImplTest\nAdded SlotOccupationTest\nAdded BulkSlotAllocationTest\n[WIP] Added DefaultExecutionSlotAllocatorBulkSlotAllocationTest\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-05-19T18:47:43Z", "url": "https://github.com/apache/flink/pull/12256", "merged": true, "mergeCommit": {"oid": "0aea300ccf23780221bd9d628511b698a0aa519b"}, "closed": true, "closedAt": "2020-06-16T09:13:42Z", "author": {"login": "zhuzhurk"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjDRJ2gBqjMzNTQ5MzUyMzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrtL0oABqjM0NDcxMDk3OTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "265fa7767926382824b2894b2662d3a93a76b176", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/265fa7767926382824b2894b2662d3a93a76b176", "committedDate": "2020-05-19T18:35:14Z", "message": "DefaultExecutionSlotAllocator uses bulk slot allocation for pipelined region scheduling"}, "afterCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/edab8aef00bcac9a530501fa64165f344d7c74e7", "committedDate": "2020-05-20T06:41:29Z", "message": "[FLINK-17018][runtime] DefaultExecutionSlotAllocator supports bulk slot allocation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2ODI0NTA5", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-416824509", "createdAt": "2020-05-22T10:57:58Z", "commit": {"oid": "1ccc37fca05d5a3d616af8c6eee21b741e6759f1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDo1Nzo1OFrOGZTHjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMzoyMDoxNVrOGZWzlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4MDgxNA==", "bodyText": "Method name doesn't match the field name willOccupySlotIndefinitely vs willBeOccupiedIndefinitely. Is it intentional?", "url": "https://github.com/apache/flink/pull/12256#discussion_r429180814", "createdAt": "2020-05-22T10:57:58Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java", "diffHunk": "@@ -168,6 +185,11 @@ public void release(Throwable cause) {\n \t\treleaseFuture.complete(null);\n \t}\n \n+\t@Override\n+\tpublic boolean willOccupySlotIndefinitely() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccc37fca05d5a3d616af8c6eee21b741e6759f1"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODM3OQ==", "bodyText": "I would prefer this method (allocateSlotsFor()) to be the first in the class.", "url": "https://github.com/apache/flink/pull/12256#discussion_r429208379", "createdAt": "2020-05-22T12:07:28Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -67,23 +76,211 @@\n \n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n+\tprivate final SlotOwner slotOwner;\n+\n \tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n \n+\t// temporary hack. can be removed along with the individual slot allocation code path\n+\t// once bulk slot allocation is fully functional\n+\tprivate final boolean enableBulkSlotAllocation;\n+\n \tpublic DefaultExecutionSlotAllocator(\n \t\t\tSlotProviderStrategy slotProviderStrategy,\n-\t\t\tInputsLocationsRetriever inputsLocationsRetriever) {\n+\t\t\tInputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tboolean enableBulkSlotAllocation) {\n \t\tthis.slotProviderStrategy = checkNotNull(slotProviderStrategy);\n \t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t\tthis.enableBulkSlotAllocation = enableBulkSlotAllocation;\n+\n+\t\tthis.slotOwner = new DefaultExecutionSlotAllocatorSlotOwner();\n \n \t\tpendingSlotAssignments = new HashMap<>();\n \t}\n \n+\t/**\n+\t * Allocate slots in bulks. It has some limitations at the moment and is for pipelined region scheduling only.\n+\t * Slot sharing will be ignored.\n+\t * Co-location constraints are not allowed as a result.\n+\t * Intra-bulk input location preferences will be ignored.\n+\t */\n+\tprivate List<SlotExecutionVertexAssignment> allocateSlotsInBulks(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU1Nw==", "bodyText": "Should be final.", "url": "https://github.com/apache/flink/pull/12256#discussion_r429217557", "createdAt": "2020-05-22T12:29:48Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+/**\n+ * Represents a request for a physical slot.\n+ */\n+public class PhysicalSlotRequest {\n+\n+\tprivate SlotRequestId slotRequestId;\n+\n+\tprivate SlotProfile slotProfile;\n+\n+\tprivate boolean slotWillBeOccupiedIndefinitely;\n+\n+\tpublic PhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely) {\n+\n+\t\tthis.slotRequestId = slotRequestId;\n+\t\tthis.slotProfile = slotProfile;\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t}\n+\n+\tpublic SlotRequestId getSlotRequestId() {\n+\t\treturn slotRequestId;\n+\t}\n+\n+\tpublic SlotProfile getSlotProfile() {\n+\t\treturn slotProfile;\n+\t}\n+\n+\tboolean willSlotBeOccupiedIndefinitely() {\n+\t\treturn slotWillBeOccupiedIndefinitely;\n+\t}\n+\n+\t/**\n+\t * Result of a {@link PhysicalSlotRequest}.\n+\t */\n+\tpublic static class Result {\n+\n+\t\tprivate SlotRequestId slotRequestId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU4Nw==", "bodyText": "Should be final.", "url": "https://github.com/apache/flink/pull/12256#discussion_r429217587", "createdAt": "2020-05-22T12:29:53Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+/**\n+ * Represents a request for a physical slot.\n+ */\n+public class PhysicalSlotRequest {\n+\n+\tprivate SlotRequestId slotRequestId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzg4Nw==", "bodyText": "Would it be possible to move the new logic to a new class (e.g., OneSlotPerExecutionSlotAllocator) that subclasses from DefaultExecutionSlotAllocator?", "url": "https://github.com/apache/flink/pull/12256#discussion_r429223887", "createdAt": "2020-05-22T12:44:03Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -67,23 +76,211 @@\n \n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n+\tprivate final SlotOwner slotOwner;\n+\n \tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n \n+\t// temporary hack. can be removed along with the individual slot allocation code path\n+\t// once bulk slot allocation is fully functional\n+\tprivate final boolean enableBulkSlotAllocation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MTIzNg==", "bodyText": "What is the benefit of passing an external timestamp instead of calling clock.relativeTimeMillis() inside this method?", "url": "https://github.com/apache/flink/pull/12256#discussion_r429241236", "createdAt": "2020-05-22T13:20:15Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Clock clock;\n+\n+\t/** Timestamps indicate when bulks become unfulfillable. */\n+\tprivate final Map<PhysicalSlotRequestBulk, Long> bulkUnfulfillableTimestamps;\n+\n+\tPhysicalSlotRequestBulkTracker(final Clock clock) {\n+\t\tthis.clock = clock;\n+\t\tthis.bulkUnfulfillableTimestamps = new IdentityHashMap<>();\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\t// a bulk is initially unfulfillable\n+\t\tbulkUnfulfillableTimestamps.put(bulk, clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tbulkUnfulfillableTimestamps.remove(bulk);\n+\t}\n+\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn bulkUnfulfillableTimestamps.containsKey(bulk);\n+\t}\n+\n+\tvoid markBulkFulfillable(final PhysicalSlotRequestBulk bulk) {\n+\t\tcheckState(isTracked(bulk));\n+\n+\t\tbulkUnfulfillableTimestamps.put(bulk, Long.MAX_VALUE);\n+\t}\n+\n+\tvoid markBulkUnfulfillable(final PhysicalSlotRequestBulk bulk, final long currentTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTk0MDYz", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-416994063", "createdAt": "2020-05-22T15:20:35Z", "commit": {"oid": "a2fa66e19cbba4726a27da817fdfbabd1d054cf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToyMDozNVrOGZa_jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToyMDozNVrOGZa_jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwOTgzNw==", "bodyText": "private", "url": "https://github.com/apache/flink/pull/12256#discussion_r429309837", "createdAt": "2020-05-22T15:20:35Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {\n+\n+\tfinal Map<SlotRequestId, PhysicalSlotRequest> pendingRequests;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2fa66e19cbba4726a27da817fdfbabd1d054cf1"}, "originalPosition": 36}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/edab8aef00bcac9a530501fa64165f344d7c74e7", "committedDate": "2020-05-20T06:41:29Z", "message": "[FLINK-17018][runtime] DefaultExecutionSlotAllocator supports bulk slot allocation"}, "afterCommit": {"oid": "cce8477d3eae8bad8b4109fa1f85e810220b6d39", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/cce8477d3eae8bad8b4109fa1f85e810220b6d39", "committedDate": "2020-05-25T06:47:50Z", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cce8477d3eae8bad8b4109fa1f85e810220b6d39", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/cce8477d3eae8bad8b4109fa1f85e810220b6d39", "committedDate": "2020-05-25T06:47:50Z", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable"}, "afterCommit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/7f16b12b9c89b723a6c201da252d65e259a53c84", "committedDate": "2020-05-25T07:32:33Z", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NTQ0MDM1", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-417544035", "createdAt": "2020-05-25T08:24:35Z", "commit": {"oid": "5682f58a0f2dc3b7a460f123eb1c29cac216c415"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNDozNVrOGZ5ATA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1ODoyMFrOGaI1YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTU0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n          \n          \n            \n            \t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, false);\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertFalse(physicalSlot.willBeOccupiedIndefinitely());", "url": "https://github.com/apache/flink/pull/12256#discussion_r429801548", "createdAt": "2020-05-25T08:24:35Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation works correctly.\n+ */\n+public class SlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\t@Test\n+\tpublic void testSingleTaskNotOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5682f58a0f2dc3b7a460f123eb1c29cac216c415"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTk0Mw==", "bodyText": "Do we need to keep PhysicalSlotRequests in PhysicalSlotRequestBulk?\nIt seems we use only ids and ResourceProfile of PhysicalSlotRequest.SlotProfile.\nWould it be enough for now to keep only ResourceProfiles in PhysicalSlotRequestBulk.pendingRequests?", "url": "https://github.com/apache/flink/pull/12256#discussion_r429821943", "createdAt": "2020-05-25T09:05:12Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -469,6 +469,47 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic boolean isSlotRequestBulkFulfillable(final PhysicalSlotRequestBulk slotRequestBulk) {\n+\t\tfinal Set<AllocationID> assignedSlots = new HashSet<>(slotRequestBulk.getFulfilledRequests().values());\n+\t\tfinal Set<SlotInfo> reusableSlots = getReusableSlots(assignedSlots);\n+\t\treturn areRequestsFulfillableWithSlots(slotRequestBulk.getPendingRequests().values(), reusableSlots);\n+\t}\n+\n+\tprivate Set<SlotInfo> getReusableSlots(final Set<AllocationID> slotsToExclude) {\n+\t\treturn Stream\n+\t\t\t.concat(\n+\t\t\t\tgetAvailableSlotsInformation().stream(),\n+\t\t\t\tgetAllocatedSlotsInformation().stream())\n+\t\t\t.filter(slotInfo -> !slotInfo.willBeOccupiedIndefinitely())\n+\t\t\t.filter(slotInfo -> !slotsToExclude.contains(slotInfo.getAllocationId()))\n+\t\t\t.collect(Collectors.toSet());\n+\t}\n+\n+\tprivate static boolean areRequestsFulfillableWithSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> requests,\n+\t\t\tfinal Set<SlotInfo> slots) {\n+\n+\t\tfinal Set<SlotInfo> remainingSlots = new HashSet<>(slots);\n+\t\tfor (PhysicalSlotRequest request : requests) {\n+\t\t\tfinal Optional<SlotInfo> matchedSlot = findMatchingSlotForRequest(request, remainingSlots);\n+\t\t\tif (matchedSlot.isPresent()) {\n+\t\t\t\tremainingSlots.remove(matchedSlot.get());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static Optional<SlotInfo> findMatchingSlotForRequest(\n+\t\t\tfinal PhysicalSlotRequest request,\n+\t\t\tfinal Collection<SlotInfo> slots) {\n+\n+\t\tfinal ResourceProfile requiredResource = request.getSlotProfile().getPhysicalSlotResourceProfile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90581a62267f9ce4129ed37497e92e41a4cc4840"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzODYzMg==", "bodyText": "Do we need to mix this concern of bulk allocation to SlotPool?\nCould we keep the SlotPool as only single physical slot allocator?\nWould it not be more natural to expose SlotPool#getAllocatedSlotsInformation and move the bulk logic to its tracker?", "url": "https://github.com/apache/flink/pull/12256#discussion_r429838632", "createdAt": "2020-05-25T09:38:29Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -469,6 +469,47 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic boolean isSlotRequestBulkFulfillable(final PhysicalSlotRequestBulk slotRequestBulk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90581a62267f9ce4129ed37497e92e41a4cc4840"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw==", "bodyText": "It looks like componentMainThreadExecutor/tryAllocateFromAvailable/cancelSlotRequest are the only things, we reuse in SchedulerImpl.\nNot sure whether it makes sense to extend this class which has not been designed for bulk slot allocation.\nDo you think we can reuse SchedulerImpl in future?\nCould we just introduce another component for the change in this commit (basically bulk timeout), e.g. BulkSlotProvider.allocatePhysicalSlots/cancelSlotRequest interface or so?\nWould just duplicating tryAllocateFromAvailable/cancelSlotRequest in BulkSlotProviderImpl bring less confusion in future?\nWill we need single slot provider eventually for pipeline region scheduling at all?\nLater we could see how to introduce slot sharing and co-location concerns, maybe as other components on top.", "url": "https://github.com/apache/flink/pull/12256#discussion_r430051357", "createdAt": "2020-05-25T19:12:42Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulerImpl.java", "diffHunk": "@@ -562,4 +575,110 @@ private void releaseSharedSlot(\n \tpublic boolean requiresPreviousExecutionGraphAllocations() {\n \t\treturn slotSelectionStrategy instanceof PreviousAllocationSlotSelectionStrategy;\n \t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\n+\t\tfinal Optional<SlotAndLocality> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4408dbdd70acda6cce06ae6974515c694115d6db"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MjUxMg==", "bodyText": "These requests to SlotPoolImpl will also schedule per-slot timeout in streaming and additional fullfilability check for batch slot in SlotPoolImpl. Do we want to keep this complication, especially in future? Bulk timeout seems to be enough and basically addresses the same.\nWould it be easier to add e.g. SlotPoolImpl#requestNewAllocatedSlotWithoutTimeout? requestNewAllocatedSlotWithoutTimeout could be similar to requestNewAllocatedSlot for streaming but w/o any per-slot timeout tracking in SlotPoolImpl.", "url": "https://github.com/apache/flink/pull/12256#discussion_r430052512", "createdAt": "2020-05-25T19:18:31Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulerImpl.java", "diffHunk": "@@ -562,4 +575,110 @@ private void releaseSharedSlot(\n \tpublic boolean requiresPreviousExecutionGraphAllocations() {\n \t\treturn slotSelectionStrategy instanceof PreviousAllocationSlotSelectionStrategy;\n \t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\n+\t\tfinal Optional<SlotAndLocality> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get().getSlot());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(slotRequestId, slotProfile.getPhysicalSlotResourceProfile(), timeout);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(slotRequestId, slotProfile.getPhysicalSlotResourceProfile());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4408dbdd70acda6cce06ae6974515c694115d6db"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NDI2Mw==", "bodyText": "Do we need SlotProviderStrategy in OneSlotPerExecutionSlotAllocator at all?\nCould we use directly new BulkSlotProvider.allocatePhysicalSlots/cancelSlotRequest and create OneSlotPerExecutionSlotAllocator with willSlotBeOccupiedIndefinitely flag based on ScheduleMode?", "url": "https://github.com/apache/flink/pull/12256#discussion_r430054263", "createdAt": "2020-05-25T19:26:43Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/SlotProviderStrategy.java", "diffHunk": "@@ -56,6 +62,24 @@\n \t\tScheduledUnit scheduledUnit,\n \t\tSlotProfile slotProfile);\n \n+\t/**\n+\t * Allocates a bulk of physical slots.\n+\t *\n+\t * @param physicalSlotRequests requests for physical slots\n+\t * @return future of the allocation which will be completed normally only when all the requests are fulfilled\n+\t */\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "201574e26e493e30b3ab868df25ff4b3b1ece05e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA==", "bodyText": "Could we introduce new SlotProfileRetriever(inputsLocationsRetriever, ignoreInternalProducers, useTaskProfile).createSlotProfileFutures(Collection<ExecutionVertexSchedulingRequirements>)?\nThis would deduplicate a lot of code in OneSlotPerExecutionSlotAllocator/DefaultExecutionSlotAllocator.", "url": "https://github.com/apache/flink/pull/12256#discussion_r430057814", "createdAt": "2020-05-25T19:44:16Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -96,52 +97,88 @@ public DefaultExecutionSlotAllocator(\n \n \t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n \n-\t\t\tCompletableFuture<LogicalSlot> slotFuture = calculatePreferredLocations(\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tCollections.emptySet(),\n+\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n+\t\t\t\tallPreviousAllocationIds);\n+\n+\t\t\tfinal CompletableFuture<LogicalSlot> slotFuture = slotProfileFuture.thenCompose(\n+\t\t\t\tslotProfile ->\n+\t\t\t\t\tslotProviderStrategy.allocateSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tnew ScheduledUnit(\n+\t\t\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\t\t\tslotSharingGroupId,\n+\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n+\t\t\t\t\t\tslotProfile));\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n \t\t\t\t\texecutionVertexId,\n-\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n-\t\t\t\t\tinputsLocationsRetriever,\n-\t\t\t\t\tCollections.emptySet()).thenCompose(\n-\t\t\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n-\t\t\t\t\t\t\t\tslotProviderStrategy.allocateSlot(\n-\t\t\t\t\t\t\t\t\tslotRequestId,\n-\t\t\t\t\t\t\t\t\tnew ScheduledUnit(\n-\t\t\t\t\t\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\t\t\t\t\t\tslotSharingGroupId,\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n-\t\t\t\t\t\t\t\t\tSlotProfile.priorAllocation(\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tpreferredLocations,\n-\t\t\t\t\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n-\t\t\t\t\t\t\t\t\t\tallPreviousAllocationIds)));\n-\n-\t\t\tSlotExecutionVertexAssignment slotExecutionVertexAssignment =\n-\t\t\t\t\tnew SlotExecutionVertexAssignment(executionVertexId, slotFuture);\n-\t\t\t// add to map first to avoid the future completed before added.\n-\t\t\tpendingSlotAssignments.put(executionVertexId, slotExecutionVertexAssignment);\n-\n-\t\t\tslotFuture.whenComplete(\n-\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\tpendingSlotAssignments.remove(executionVertexId);\n-\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\tslotProviderStrategy.cancelSlotRequest(slotRequestId, slotSharingGroupId, throwable);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\t\t\t\tslotFuture,\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tslotSharingGroupId);\n \n \t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n \t\t}\n \n \t\treturn slotExecutionVertexAssignments;\n \t}\n \n-\tprivate void validateSchedulingRequirements(Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\tprotected void validateSchedulingRequirements(Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n \t\tschedulingRequirements.stream()\n \t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n \t\t\t.forEach(id -> checkState(\n \t\t\t\t!pendingSlotAssignments.containsKey(id),\n \t\t\t\t\"BUG: vertex %s tries to allocate a slot when its previous slot request is still pending\", id));\n \t}\n \n+\tprotected CompletableFuture<SlotProfile> createSlotProfile(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTM3MQ==", "bodyText": "Should we also release the slot from SlotPool?", "url": "https://github.com/apache/flink/pull/12256#discussion_r430059371", "createdAt": "2020-05-25T19:51:07Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\t\tsuper(slotProviderStrategy, inputsLocationsRetriever);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDg5Nw==", "bodyText": "OneSlotPerExecutionSlotAllocator and DefaultExecutionSlotAllocator implement different approaches.\nWould it make sense to introduce a base AbstractExecutionSlotAllocator and inherit it by both classes?\nThere will be not much in common, mostly some state management around pendingSlotAssignments, if we:\n\nintroduce a separate SlotProfileRetriever\nuse BulkSlotProvider and willSlotBeOccupiedIndefinitely flag in OneSlotPerExecutionSlotAllocator instead of slotProviderStrategy\nmaybe move static methods to utils if it make sense", "url": "https://github.com/apache/flink/pull/12256#discussion_r430060897", "createdAt": "2020-05-25T19:58:20Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MzcxNjIx", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-418371621", "createdAt": "2020-05-26T14:44:48Z", "commit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo0NDo0OFrOGahsYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo0NDo0OFrOGahsYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODE5NA==", "bodyText": "What is the subject under test here? I assume AllocatedSlot. It would be nice to rename this class AllocatedSlotOccupationTest so that Ctrl + Shift + T works in IDEA: https://www.jetbrains.com/help/idea/navigating-between-test-and-test-subject.html", "url": "https://github.com/apache/flink/pull/12256#discussion_r430468194", "createdAt": "2020-05-26T14:44:48Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation works correctly.\n+ */\n+public class SlotOccupationTest extends TestLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MzcyNjEy", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-418372612", "createdAt": "2020-05-26T14:45:48Z", "commit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo0NTo0OFrOGahvXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo0NTo0OFrOGahvXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODk1OQ==", "bodyText": "Under what circumstances can it happen that the physical slot is already assigned a payload?", "url": "https://github.com/apache/flink/pull/12256#discussion_r430468959", "createdAt": "2020-05-26T14:45:48Z", "author": {"login": "GJL"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\t\tsuper(slotProviderStrategy, inputsLocationsRetriever);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84"}, "originalPosition": 246}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/7f16b12b9c89b723a6c201da252d65e259a53c84", "committedDate": "2020-05-25T07:32:33Z", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable"}, "afterCommit": {"oid": "2aa39a469f86ceae75eafb75194f7c7f82e3a6cc", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/2aa39a469f86ceae75eafb75194f7c7f82e3a6cc", "committedDate": "2020-05-29T04:34:43Z", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ba2a2eb65072f71c66055c3f86549a061eb1514", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/8ba2a2eb65072f71c66055c3f86549a061eb1514", "committedDate": "2020-05-29T10:22:54Z", "message": "fixup! [FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator"}, "afterCommit": {"oid": "ca05fc241f6fd0550a39612b4ddef86b63a304a6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/ca05fc241f6fd0550a39612b4ddef86b63a304a6", "committedDate": "2020-06-03T08:56:03Z", "message": "fixup! [FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTkxMTI2", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-424191126", "createdAt": "2020-06-04T07:55:59Z", "commit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzo1NjowMFrOGe6GCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjozOTo1MVrOGfDx3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2MjI4Mg==", "bodyText": "Could we already make OneSlotPerExecutionSlotAllocator depending on BulkSlotProvider if SlotProvider interface extends BulkSlotProvider and we duplicate cancelSlotRequest in BulkSlotProvider interface? or make BulkSlotProvider extend SlotOwner later.\nIf cancelSlotRequest is basically only used to release slots, then maybe we could rename it later to releaseSlot in BulkSlotProvider.", "url": "https://github.com/apache/flink/pull/12256#discussion_r435062282", "createdAt": "2020-06-04T07:56:00Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjA0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds.values().stream()\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds.values()", "url": "https://github.com/apache/flink/pull/12256#discussion_r435082042", "createdAt": "2020-06-04T08:29:36Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjY2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic OneSlotPerExecutionSlotAllocator(\n          \n          \n            \n            \tOneSlotPerExecutionSlotAllocator(", "url": "https://github.com/apache/flink/pull/12256#discussion_r435082660", "createdAt": "2020-06-04T08:30:32Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA==", "bodyText": "private CompletableFuture<SlotProfile> getSlotProfileFuture(\n\t\t\tSet<ExecutionVertexID> allExecutionVertexIds,\n\t\t\tSet<AllocationID> allPreviousAllocationIds,\n\t\t\tExecutionVertexSchedulingRequirements schedulingRequirements) {\n\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n\t\t\tcalculatePreferredLocations(\n\t\t\t\tschedulingRequirements.getExecutionVertexId(),\n\t\t\t\tallExecutionVertexIds);\n\n\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n\t\treturn preferredLocationsFuture.thenApply(\n\t\t\tpreferredLocations ->\n\t\t\t\tSlotProfile.priorAllocation(\n\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n\t\t\t\t\tpreferredLocations,\n\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n\t\t\t\t\tallPreviousAllocationIds));\n\t}\n\nMaybe even deduplicate it with DefaultExecutionSlotAllocator by adding an additional ResourceProfile physicalSlotResourceProfile arg.", "url": "https://github.com/apache/flink/pull/12256#discussion_r435087400", "createdAt": "2020-06-04T08:38:09Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n          \n          \n            \n            \t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n          \n          \n            \n            \t\t\t.collect(Collectors.toSet());\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n          \n          \n            \n            \t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n          \n          \n            \n            \t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n          \n          \n            \n            \t\t\tcreatePhysicalSlotRequestFutures(\n          \n          \n            \n            \t\t\t\texecutionVertexSchedulingRequirements,\n          \n          \n            \n            \t\t\t\tallExecutionVertexIds,\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tallocateSlotsForAssignments(\n          \n          \n            \n            \t\t\tphysicalSlotRequestFutures,\n          \n          \n            \n            \t\t\tslotExecutionVertexAssignments,\n          \n          \n            \n            \t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\treturn slotExecutionVertexAssignments;\n          \n          \n            \n            \t\tfinal Map<SlotRequestId, SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n          \n          \n            \n            \t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n          \n          \n            \n            \t\t\t.entrySet()\n          \n          \n            \n            \t\t\t.stream()\n          \n          \n            \n            \t\t\t.collect(Collectors.toMap(e -> e.getValue().getExecutionVertexId(), Map.Entry::getKey));\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n          \n          \n            \n            \t\t\tcreatePhysicalSlotRequestFutures(\n          \n          \n            \n            \t\t\t\texecutionVertexSchedulingRequirements,\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tallocateSlotsForAssignments(\n          \n          \n            \n            \t\t\tphysicalSlotRequestFutures,\n          \n          \n            \n            \t\t\tslotExecutionVertexAssignments);\n          \n          \n            \n            \n          \n          \n            \n            \t\treturn new ArrayList<>(slotExecutionVertexAssignments.values());\n          \n      \n    \n    \n  \n\nThis seems to be a bit less indexing... It also implies some simplification of the called private methods.", "url": "https://github.com/apache/flink/pull/12256#discussion_r435095506", "createdAt": "2020-06-04T08:52:03Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjkxNg==", "bodyText": "Maybe, this could be SingleLogicalSlot#createAndAllocateFromPhysicalSlot.", "url": "https://github.com/apache/flink/pull/12256#discussion_r435096916", "createdAt": "2020-06-04T08:54:24Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODE2NA==", "bodyText": "If we would manage to make OneSlotPerExecutionSlotAllocator depending on BulkSlotProvider, this allocatePhysicalSlots could in a separate AllocationToggableBulkSlotProvider or so, as a separate commit if we do it.", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208164", "createdAt": "2020-06-04T12:17:38Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -216,13 +221,37 @@ private SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n \t\t\t\tTime timeout) {\n \n \t\t\tslotAllocationRequests.add(Tuple3.of(slotRequestId, task, slotProfile));\n-\t\t\tif (slotAllocationDisabled) {\n+\t\t\tif (forceFailingSlotAllocation) {\n+\t\t\t\treturn FutureUtils.completedExceptionally(new Exception(\"Forced failure\"));\n+\t\t\t} else if (slotAllocationDisabled) {\n \t\t\t\treturn new CompletableFuture<>();\n \t\t\t} else {\n \t\t\t\treturn CompletableFuture.completedFuture(new TestingLogicalSlotBuilder().createTestingLogicalSlot());\n \t\t\t}\n \t\t}\n \n+\t\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODQ3Ng==", "bodyText": "nit: would be nice to have a separate static util class for the shared static methods", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208476", "createdAt": "2020-06-04T12:18:13Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -189,7 +192,7 @@ private DefaultExecutionSlotAllocator createExecutionSlotAllocator(InputsLocatio\n \t\treturn schedulingRequirements;\n \t}\n \n-\tprivate SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n+\tstatic SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODczMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tprivate boolean forceFailingSlotAllocation = false;\n          \n          \n            \n            \t\tprivate boolean forceFailingSlotAllocation;", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208730", "createdAt": "2020-06-04T12:18:40Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -200,14 +203,16 @@ private SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n \t\t\t\t\t\texecutionVertexId)));\n \t}\n \n-\tprivate static class AllocationToggableSlotProvider implements SlotProvider {\n+\tstatic class AllocationToggableSlotProvider implements SlotProvider {\n \n \t\tprivate final List<Tuple3<SlotRequestId, ScheduledUnit, SlotProfile>> slotAllocationRequests = new ArrayList<>();\n \n \t\tprivate final List<SlotRequestId> cancelledSlotRequestIds = new ArrayList<>();\n \n \t\tprivate boolean slotAllocationDisabled;\n \n+\t\tprivate boolean forceFailingSlotAllocation = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxMDU2MQ==", "bodyText": "nit: it would be nice to introduce enum AllocationTypeEnum {ENABLED, DISABLED, FAILING}", "url": "https://github.com/apache/flink/pull/12256#discussion_r435210561", "createdAt": "2020-06-04T12:22:08Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -200,14 +203,16 @@ private SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n \t\t\t\t\t\texecutionVertexId)));\n \t}\n \n-\tprivate static class AllocationToggableSlotProvider implements SlotProvider {\n+\tstatic class AllocationToggableSlotProvider implements SlotProvider {\n \n \t\tprivate final List<Tuple3<SlotRequestId, ScheduledUnit, SlotProfile>> slotAllocationRequests = new ArrayList<>();\n \n \t\tprivate final List<SlotRequestId> cancelledSlotRequestIds = new ArrayList<>();\n \n \t\tprivate boolean slotAllocationDisabled;\n \n+\t\tprivate boolean forceFailingSlotAllocation = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODczMA=="}, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyMDk1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic OneSlotPerExecutionSlotAllocatorFactory(\n          \n          \n            \n            \tOneSlotPerExecutionSlotAllocatorFactory(", "url": "https://github.com/apache/flink/pull/12256#discussion_r435220956", "createdAt": "2020-06-04T12:39:51Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Factory for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorFactory implements ExecutionSlotAllocatorFactory {\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocatorFactory(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044add50e281be712b30e8628b52daaec89e7227"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ca05fc241f6fd0550a39612b4ddef86b63a304a6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/ca05fc241f6fd0550a39612b4ddef86b63a304a6", "committedDate": "2020-06-03T08:56:03Z", "message": "fixup! [FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator"}, "afterCommit": {"oid": "f181cf943442db6173eba4c817f40bbab49538da", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f181cf943442db6173eba4c817f40bbab49538da", "committedDate": "2020-06-06T05:05:37Z", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f181cf943442db6173eba4c817f40bbab49538da", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f181cf943442db6173eba4c817f40bbab49538da", "committedDate": "2020-06-06T05:05:37Z", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling"}, "afterCommit": {"oid": "eba9c31264c2a0fe9f5bf955ba21de081bd1aa25", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/eba9c31264c2a0fe9f5bf955ba21de081bd1aa25", "committedDate": "2020-06-06T05:26:28Z", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3ODYxNDEw", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-427861410", "createdAt": "2020-06-10T09:08:12Z", "commit": {"oid": "d754688951619f89701c5a49a915c611658a405b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwOTowODoxMlrOGhr9FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwOToyNDoyNlrOGhsiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NjM0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));\n          \n          \n            \n            \t\t\t\t\tslotProvider::cancelSlotRequest);", "url": "https://github.com/apache/flink/pull/12256#discussion_r437976340", "createdAt": "2020-06-10T09:08:12Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n+\t\t\t.stream()\n+\t\t\t.collect(\n+\t\t\t\tCollectors.toMap(\n+\t\t\t\t\tSlotExecutionVertexAssignment::getExecutionVertexId,\n+\t\t\t\t\tSlotExecutionVertexAssignment::getSlotRequestId));\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments);\n+\n+\t\treturn Collections.unmodifiableList(slotExecutionVertexAssignments);\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d754688951619f89701c5a49a915c611658a405b"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3OTExNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionSlotAllocatorTestUtils {\n          \n          \n            \n            class ExecutionSlotAllocatorTestUtils {", "url": "https://github.com/apache/flink/pull/12256#discussion_r437979115", "createdAt": "2020-06-10T09:13:11Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocatorTestUtils.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Test utils for {@link ExecutionSlotAllocator}.\n+ */\n+public class ExecutionSlotAllocatorTestUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277ee720dee5ab63dade29c7178d9e7af69a3f21"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTgwOQ==", "bodyText": "I meant at least to factor out getSlotProfileFuture into a separate private method inside OneSlotPerExecutionSlotAllocator and another one inside DefaultExecutionSlotAllocator . This would reduce the big method createPhysicalSlotRequestFutures.\nThe next idea was to deduplicate by adding what to use for physicalSlotResourceProfile in SlotProfile.priorAllocation:\nAbstractExecutionSlotAllocator#getSlotProfileFuture(..., ResourceProfile physicalSlotResourceProfile)\n\nThis might be too much.", "url": "https://github.com/apache/flink/pull/12256#discussion_r437985809", "createdAt": "2020-06-10T09:24:26Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA=="}, "originalCommit": {"oid": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583"}, "originalPosition": 197}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ae83a7f8381e681b2f378e5d8d0fd6d48b3e944", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/9ae83a7f8381e681b2f378e5d8d0fd6d48b3e944", "committedDate": "2020-06-10T12:26:48Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}, "afterCommit": {"oid": "f009698034f1c67e698a83e43bbb2bcc160f264d", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f009698034f1c67e698a83e43bbb2bcc160f264d", "committedDate": "2020-06-11T02:38:42Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f009698034f1c67e698a83e43bbb2bcc160f264d", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f009698034f1c67e698a83e43bbb2bcc160f264d", "committedDate": "2020-06-11T02:38:42Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}, "afterCommit": {"oid": "f5939316d96975bea8e877770acb52bc17683087", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f5939316d96975bea8e877770acb52bc17683087", "committedDate": "2020-06-11T03:19:45Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5939316d96975bea8e877770acb52bc17683087", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/f5939316d96975bea8e877770acb52bc17683087", "committedDate": "2020-06-11T03:19:45Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}, "afterCommit": {"oid": "7d4734369b4b87997cce4f593cfd706b78b212f6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/7d4734369b4b87997cce4f593cfd706b78b212f6", "committedDate": "2020-06-11T03:35:01Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NzQ0Mjc2", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-428744276", "createdAt": "2020-06-11T09:29:15Z", "commit": {"oid": "fc243db69366bfc95c96a272936ebe30cbd6b26a"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOToyOToxNVrOGiVpZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoyNjozOVrOGia3bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1OTQyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate class OneSlotPerExecutionSlotAllocatorSlotOwner implements SlotOwner {\n          \n          \n            \n            \n          \n          \n            \n            \t\t@Override\n          \n          \n            \n            \t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n          \n          \n            \n            \t\t\tslotProvider.cancelSlotRequest(\n          \n          \n            \n            \t\t\t\tlogicalSlot.getSlotRequestId(),\n          \n          \n            \n            \t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t}\n          \n          \n            \n            \t    @Override\n          \n          \n            \n            \t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n          \n          \n            \n            \t\t\tslotProvider.cancelSlotRequest(\n          \n          \n            \n            \t\t\t\tlogicalSlot.getSlotRequestId(),\n          \n          \n            \n            \t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\nMaybe it is just easier to implement SlotOwner in OneSlotPerExecutionSlotAllocator and pass this to SingleLogicalSlot.allocateFromPhysicalSlot?", "url": "https://github.com/apache/flink/pull/12256#discussion_r438659428", "createdAt": "2020-06-11T09:29:15Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n+\t\t\t.stream()\n+\t\t\t.collect(\n+\t\t\t\tCollectors.toMap(\n+\t\t\t\t\tSlotExecutionVertexAssignment::getExecutionVertexId,\n+\t\t\t\t\tSlotExecutionVertexAssignment::getSlotRequestId));\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments);\n+\n+\t\treturn Collections.unmodifiableList(slotExecutionVertexAssignments);\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(executionVertexId, allExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments) {\n+\n+\t\tfinal Map<SlotRequestId, SlotExecutionVertexAssignment> requestToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getSlotRequestId, Function.identity()));\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal SlotExecutionVertexAssignment assignment = requestToAssignmentMapping.get(slotRequestId);\n+\n+\t\t\t\t\tcheckState(assignment != null);\n+\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = SingleLogicalSlot.allocateFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot(),\n+\t\t\t\t\t\tLocality.UNKNOWN,\n+\t\t\t\t\t\tslotOwner,\n+\t\t\t\t\t\tslotWillBeOccupiedIndefinitely);\n+\t\t\t\t\tassignment.getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\tslotExecutionVertexAssignments.forEach(\n+\t\t\t\t\tassignment -> assignment.getLogicalSlotFuture().completeExceptionally(ex));\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate class OneSlotPerExecutionSlotAllocatorSlotOwner implements SlotOwner {\n+\n+\t\t@Override\n+\t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n+\t\t\tslotProvider.cancelSlotRequest(\n+\t\t\t\tlogicalSlot.getSlotRequestId(),\n+\t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc243db69366bfc95c96a272936ebe30cbd6b26a"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MDc5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprotected void validateSchedulingRequirements(\n          \n          \n            \n            \tvoid validateSchedulingRequirements(\n          \n      \n    \n    \n  \n\nnit: not sure, why we need protected for methods in AbstractExecutionSlotAllocator if it is used only within the package", "url": "https://github.com/apache/flink/pull/12256#discussion_r438660794", "createdAt": "2020-06-11T09:31:39Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\tprivate final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprivate final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tprotected AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\tprotected void validateSchedulingRequirements(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4866dbfb0920cc1a0cd7a9876810fa1fad4fc3c3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MzQzMg==", "bodyText": "If it is a private method now, I guess we do not need it?", "url": "https://github.com/apache/flink/pull/12256#discussion_r438663432", "createdAt": "2020-06-11T09:36:29Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -94,7 +96,26 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<SlotProfile> getSlotProfileFuture(\n+\t\t\tfinal ExecutionVertexSchedulingRequirements schedulingRequirements,\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal Set<AllocationID> allPreviousAllocationIds) {\n+\n+\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\tcalculatePreferredLocations(schedulingRequirements.getExecutionVertexId(), producersToIgnore);\n+\n+\t\treturn preferredLocationsFuture.thenApply(\n+\t\t\tpreferredLocations ->\n+\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\tallPreviousAllocationIds));\n+\t}\n+\n+\tprivate CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8234b6b1b11b6d08879fed60abdfbc948894c59d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NjUzMA==", "bodyText": "nit, it would be nice to have:\nprivate CompletableFuture<LogicalSlot> allocateSlot(\n\t\t\tSet<AllocationID> allPreviousAllocationIds,\n\t\t\tExecutionVertexSchedulingRequirements schedulingRequirements) {\n\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n\n\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n\n\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = getSlotProfileFuture(\n\t\t\tschedulingRequirements,\n\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n\t\t\tCollections.emptySet(),\n\t\t\tallPreviousAllocationIds);\n\n\t\treturn slotProfileFuture.thenCompose(\n\t\t\tslotProfile -> slotProviderStrategy.allocateSlot(\n\t\t\t\tslotRequestId,\n\t\t\t\tnew ScheduledUnit(\n\t\t\t\t\texecutionVertexId,\n\t\t\t\t\tschedulingRequirements.getSlotSharingGroupId(),\n\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n\t\t\t\tslotProfile));\n\t}", "url": "https://github.com/apache/flink/pull/12256#discussion_r438666530", "createdAt": "2020-06-11T09:42:14Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -77,22 +75,20 @@ public DefaultExecutionSlotAllocator(\n \n \t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n \n-\t\t\tCompletableFuture<LogicalSlot> slotFuture = calculatePreferredLocations(\n-\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\tCollections.emptySet()).thenCompose(\n-\t\t\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n-\t\t\t\t\t\t\t\tslotProviderStrategy.allocateSlot(\n-\t\t\t\t\t\t\t\t\tslotRequestId,\n-\t\t\t\t\t\t\t\t\tnew ScheduledUnit(\n-\t\t\t\t\t\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\t\t\t\t\t\tslotSharingGroupId,\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n-\t\t\t\t\t\t\t\t\tSlotProfile.priorAllocation(\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tpreferredLocations,\n-\t\t\t\t\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n-\t\t\t\t\t\t\t\t\t\tallPreviousAllocationIds)));\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = getSlotProfileFuture(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n+\t\t\t\tCollections.emptySet(),\n+\t\t\t\tallPreviousAllocationIds);\n+\n+\t\t\tfinal CompletableFuture<LogicalSlot> slotFuture = slotProfileFuture.thenCompose(\n+\t\t\t\tslotProfile -> slotProviderStrategy.allocateSlot(\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnew ScheduledUnit(\n+\t\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\t\tslotSharingGroupId,\n+\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n+\t\t\t\t\tslotProfile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8234b6b1b11b6d08879fed60abdfbc948894c59d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NzQyMQ==", "bodyText": "nit: constructor can be package-private", "url": "https://github.com/apache/flink/pull/12256#discussion_r438667421", "createdAt": "2020-06-11T09:43:55Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -36,41 +35,28 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.stream.Collectors;\n \n import static org.apache.flink.util.Preconditions.checkNotNull;\n-import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n  * Default {@link ExecutionSlotAllocator} which will use {@link SlotProvider} to allocate slots and\n  * keep the unfulfilled requests for further cancellation.\n  */\n-public class DefaultExecutionSlotAllocator implements ExecutionSlotAllocator {\n+public class DefaultExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultExecutionSlotAllocator.class);\n \n-\t/**\n-\t * Store the uncompleted slot assignments.\n-\t */\n-\tprivate final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n-\n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n-\tprivate final PreferredLocationsRetriever preferredLocationsRetriever;\n-\n \tpublic DefaultExecutionSlotAllocator(\n \t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n \t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever) {\n-\t\tthis.slotProviderStrategy = checkNotNull(slotProviderStrategy);\n-\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n \n-\t\tpendingSlotAssignments = new HashMap<>();\n+\t\tsuper(preferredLocationsRetriever);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4866dbfb0920cc1a0cd7a9876810fa1fad4fc3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDY2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n          \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Collections.singletonList(", "url": "https://github.com/apache/flink/pull/12256#discussion_r438744661", "createdAt": "2020-06-11T12:26:02Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotTestUtils.createPhysicalSlot;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.createSchedulingRequirements;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.findSlotAssignmentByExecutionVertexId;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorTest extends TestLogger {\n+\n+\tprivate TestingBulkSlotProvider slotProvider;\n+\n+\t@Before\n+\tpublic void setUp() throws Exception {\n+\t\tslotProvider = new TestingBulkSlotProvider();\n+\t}\n+\n+\t@Test\n+\tpublic void testSucceededSlotAllocation() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(1));\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getExecutionVertexId(), equalTo(executionVertexID));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedSlotAllocation() {\n+\t\tfinal OneSlotPerExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tslotProvider.forceFailingSlotAllocation();\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(true));\n+\t\tassertThat(executionSlotAllocator.getPendingSlotAssignments().keySet(), hasSize(0));\n+\t\tassertThat(slotProvider.getCancelledSlotRequestIds(), contains(slotAssignment.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testInterBulkInputLocationPreferencesAreRespected() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForProducer =\n+\t\t\tcreateSchedulingRequirements(producerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForProducer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForProducer);\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignmentsForProducer);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForConsumer =\n+\t\t\tcreateSchedulingRequirements(consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForConsumer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForConsumer);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignmentsForConsumer);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(false));\n+\n+\t\tinputsLocationsRetriever.assignTaskManagerLocation(producerId);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testIntraBulkInputLocationPreferencesDoNotBlockAllocation() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(producerId, consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(2));\n+\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignments);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreatedSlotRequests() {\n+\t\tfinal ExecutionVertexID executionVertexId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal SlotSharingGroupId sharingGroupId = new SlotSharingGroupId();\n+\t\tfinal ResourceProfile taskResourceProfile = ResourceProfile.fromResources(0.5, 250);\n+\t\tfinal ResourceProfile physicalSlotResourceProfile = ResourceProfile.fromResources(1.0, 300);\n+\t\tfinal TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingStateLocationRetriever stateLocationRetriever = new TestingStateLocationRetriever();\n+\t\tstateLocationRetriever.setStateLocation(executionVertexId, taskManagerLocation);\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tstateLocationRetriever,\n+\t\t\tnew TestingInputsLocationsRetriever.Builder().build());\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc243db69366bfc95c96a272936ebe30cbd6b26a"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDk0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n          \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Collections.singletonList(", "url": "https://github.com/apache/flink/pull/12256#discussion_r438744943", "createdAt": "2020-06-11T12:26:39Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotTestUtils.createPhysicalSlot;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.createSchedulingRequirements;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.findSlotAssignmentByExecutionVertexId;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorTest extends TestLogger {\n+\n+\tprivate TestingBulkSlotProvider slotProvider;\n+\n+\t@Before\n+\tpublic void setUp() throws Exception {\n+\t\tslotProvider = new TestingBulkSlotProvider();\n+\t}\n+\n+\t@Test\n+\tpublic void testSucceededSlotAllocation() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(1));\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getExecutionVertexId(), equalTo(executionVertexID));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedSlotAllocation() {\n+\t\tfinal OneSlotPerExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tslotProvider.forceFailingSlotAllocation();\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(true));\n+\t\tassertThat(executionSlotAllocator.getPendingSlotAssignments().keySet(), hasSize(0));\n+\t\tassertThat(slotProvider.getCancelledSlotRequestIds(), contains(slotAssignment.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testInterBulkInputLocationPreferencesAreRespected() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForProducer =\n+\t\t\tcreateSchedulingRequirements(producerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForProducer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForProducer);\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignmentsForProducer);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForConsumer =\n+\t\t\tcreateSchedulingRequirements(consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForConsumer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForConsumer);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignmentsForConsumer);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(false));\n+\n+\t\tinputsLocationsRetriever.assignTaskManagerLocation(producerId);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testIntraBulkInputLocationPreferencesDoNotBlockAllocation() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(producerId, consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(2));\n+\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignments);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreatedSlotRequests() {\n+\t\tfinal ExecutionVertexID executionVertexId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal SlotSharingGroupId sharingGroupId = new SlotSharingGroupId();\n+\t\tfinal ResourceProfile taskResourceProfile = ResourceProfile.fromResources(0.5, 250);\n+\t\tfinal ResourceProfile physicalSlotResourceProfile = ResourceProfile.fromResources(1.0, 300);\n+\t\tfinal TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingStateLocationRetriever stateLocationRetriever = new TestingStateLocationRetriever();\n+\t\tstateLocationRetriever.setStateLocation(executionVertexId, taskManagerLocation);\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tstateLocationRetriever,\n+\t\t\tnew TestingInputsLocationsRetriever.Builder().build());\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n+\t\t\tnew ExecutionVertexSchedulingRequirements.Builder()\n+\t\t\t\t.withExecutionVertexId(executionVertexId)\n+\t\t\t\t.withPreviousAllocationId(allocationId)\n+\t\t\t\t.withSlotSharingGroupId(sharingGroupId)\n+\t\t\t\t.withPhysicalSlotResourceProfile(physicalSlotResourceProfile)\n+\t\t\t\t.withTaskResourceProfile(taskResourceProfile)\n+\t\t\t\t.build()\n+\t\t);\n+\n+\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\t\tassertThat(slotProvider.getSlotRequests(), hasSize(1));\n+\n+\t\tfinal SlotProfile requestSlotProfile = slotProvider.getSlotRequests().iterator().next().getSlotProfile();\n+\n+\t\tassertThat(requestSlotProfile.getPreferredAllocations(), contains(allocationId));\n+\t\tassertThat(requestSlotProfile.getPreviousExecutionGraphAllocations(), contains(allocationId));\n+\t\tassertThat(requestSlotProfile.getTaskResourceProfile(), equalTo(taskResourceProfile));\n+\t\tassertThat(requestSlotProfile.getPreferredLocations(), contains(taskManagerLocation));\n+\t\t// task resource profile is used instead of slot sharing group resource profile since slot sharing is ignored\n+\t\tassertThat(requestSlotProfile.getPhysicalSlotResourceProfile(), equalTo(taskResourceProfile));\n+\t}\n+\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testCoLocationConstraintThrowsException() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal CoLocationConstraint coLocationConstraint = new CoLocationGroup().getLocationConstraint(0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc243db69366bfc95c96a272936ebe30cbd6b26a"}, "originalPosition": 225}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d4734369b4b87997cce4f593cfd706b78b212f6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/7d4734369b4b87997cce4f593cfd706b78b212f6", "committedDate": "2020-06-11T03:35:01Z", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex"}, "afterCommit": {"oid": "41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "committedDate": "2020-06-11T15:10:30Z", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "committedDate": "2020-06-11T15:10:30Z", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator"}, "afterCommit": {"oid": "a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "committedDate": "2020-06-12T10:38:57Z", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjc1NjQw", "url": "https://github.com/apache/flink/pull/12256#pullrequestreview-430675640", "createdAt": "2020-06-15T14:04:37Z", "commit": {"oid": "cdb2b1d720afc0866f6a1e95eb7c74022f135ada"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNDowNDozN1rOGjzqTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNDowNDozN1rOGjzqTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5OTc1Ng==", "bodyText": "Thanks for the fix @zhuzhurk\nI am wondering whether we need slotRequestId in SlotExecutionVertexAssignment.\nIf we make slotExecutionVertexAssignments LinkedHashMap<SlotRequestId, SlotExecutionVertexAssignment> and return new ArrayList<>(slotExecutionVertexAssignments.values()), we also do not need requestToAssignmentMapping in allocateSlotsForAssignments as it can be slotExecutionVertexAssignments.ketSet().\nIn tests, we could capture SlotRequestId from slotProvider.getSlotRequests/getSlotAllocationRequests.\nDoes it makes sense?", "url": "https://github.com/apache/flink/pull/12256#discussion_r440199756", "createdAt": "2020-06-15T14:04:37Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator implements SlotOwner {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb2b1d720afc0866f6a1e95eb7c74022f135ada"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "committedDate": "2020-06-12T10:38:57Z", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator"}, "afterCommit": {"oid": "1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "committedDate": "2020-06-15T16:03:55Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ceab54742dfb188455fc7592a8a4b026323a983", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/2ceab54742dfb188455fc7592a8a4b026323a983", "committedDate": "2020-06-16T02:55:43Z", "message": "[hotfix][runtime] Move shared static test methods of physical slot into PhysicalSlotTestUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "952b25c2f99830867e41a843a963f5582a593cb8", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/952b25c2f99830867e41a843a963f5582a593cb8", "committedDate": "2020-06-16T02:55:43Z", "message": "[hotfix][runtime] Move shared static test methods of slot allocator into ExecutionSlotAllocatorTestUtils"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "committedDate": "2020-06-15T16:03:55Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}, "afterCommit": {"oid": "a637f6415f4f46bc9cc576e0a170cab37266c17a", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a637f6415f4f46bc9cc576e0a170cab37266c17a", "committedDate": "2020-06-16T02:55:44Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd6650187ebbbd75dd84d6481a8a2161d7499490", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/fd6650187ebbbd75dd84d6481a8a2161d7499490", "committedDate": "2020-06-16T04:02:29Z", "message": "[FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df1096a06d6a1b7970a590207517d875d6b994f7", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/df1096a06d6a1b7970a590207517d875d6b994f7", "committedDate": "2020-06-16T04:02:31Z", "message": "[FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex\n\nOneSlotPerExecutionSlotAllocator allocates slots in bulks so that the SlotProvider can check whether this bulk of slot requests can be fulfilled at the same time.\nIt has several limitations:\n1. Slot sharing will be ignored.\n2. Co-location constraints are not allowed.\n3. Intra-bulk input location preferences will be ignored."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66694a74f8d8f8cb6379b98858b13ba3e16425fd", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/66694a74f8d8f8cb6379b98858b13ba3e16425fd", "committedDate": "2020-06-16T04:02:32Z", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "000efff83037daa2fc15fbc8768f9a6e0e407767", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/000efff83037daa2fc15fbc8768f9a6e0e407767", "committedDate": "2020-06-16T04:02:33Z", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "committedDate": "2020-06-16T04:02:34Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a637f6415f4f46bc9cc576e0a170cab37266c17a", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/a637f6415f4f46bc9cc576e0a170cab37266c17a", "committedDate": "2020-06-16T02:55:44Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}, "afterCommit": {"oid": "3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "committedDate": "2020-06-16T04:02:34Z", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4638, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}