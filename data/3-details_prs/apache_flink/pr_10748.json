{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NjYwNjg2", "number": 10748, "title": "[FLINK-15458][conf][docs] Add support for whitelisting ambiguous options ", "bodyText": "The ConfigOptionsDocsCompletenessITCase verifies that all existing and documented options are well-defined; as in that for any key there is exactly 1 default and description present, globally.\nThere is one use-case however where this check is too strict: reporters. These only work with key suffixes (like \"port\") and hence are failing this check. As a result we don't use the generator mechanism for reporters, which is unfortunate.\nThis PR introduces a whitelisting mechanism that allows us to define a set of keys for which this check is not performed.\nNote that the remaining checks of the test are still applied. (Is the option documented, does the documented option exist, do the defaults/description match).\nThe changes are mostly a refactoring of the test. Previously the test was checking whether an ambiguous key exists during the discovery of keys, which was now separated.\nThis implies that during discovery we no longer end up with a 1:1 mapping of key:option, but rather 1:N which is later checked.", "createdAt": "2020-01-02T13:35:12Z", "url": "https://github.com/apache/flink/pull/10748", "merged": true, "mergeCommit": {"oid": "eeee9b9a898cdb9ed2ed8882db6e54046bc34c39"}, "closed": true, "closedAt": "2020-01-18T16:06:30Z", "author": {"login": "zentol"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2Zvl7gH2gAyMzU4NjYwNjg2Ojc1MzFiOGUxYjJjODY4ZmQ1NzgxZGI0ZDQ1NzBkMjRkYjJiYTRjZjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7V7OAgBqjI5NTk1OTI0NzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7531b8e1b2c868fd5781db4d4570d24db2ba4cf6", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/7531b8e1b2c868fd5781db4d4570d24db2ba4cf6", "committedDate": "2020-01-02T13:26:27Z", "message": "[hotfix][conf][tests] Introduce factory method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NzgzMjM1", "url": "https://github.com/apache/flink/pull/10748#pullrequestreview-337783235", "createdAt": "2020-01-02T18:09:40Z", "commit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODowOTo0MFrOFZxl0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoxNzoxOVrOFZxvUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MTIxOA==", "bodyText": "I think we missed host and port here.", "url": "https://github.com/apache/flink/pull/10748#discussion_r362571218", "createdAt": "2020-01-02T18:09:40Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MzY1MA==", "bodyText": "I think we should better include containingClass to compare when calling ExistingOption#equals so that these two ExistingOptions are really identical.", "url": "https://github.com/apache/flink/pull/10748#discussion_r362573650", "createdAt": "2020-01-02T18:17:19Z", "author": {"login": "Myasuka"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,103 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38514c02c79ab0ddb7e80bb483b6034a40d4e199"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMjY0Nzgz", "url": "https://github.com/apache/flink/pull/10748#pullrequestreview-341264783", "createdAt": "2020-01-10T16:10:14Z", "commit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNjoxMDoxNFrOFcYwEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNjoxMDoxNFrOFcYwEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwOTk2OQ==", "bodyText": "I think we won't fail if we have a DocumentedOption which has no corresponding ExistingOption since we are only looking whether there is a DocumentedOption for every ExistingOption.", "url": "https://github.com/apache/flink/pull/10748#discussion_r365309969", "createdAt": "2020-01-10T16:10:14Z", "author": {"login": "tillrohrmann"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -61,50 +64,105 @@\n \n \tprivate static final Formatter htmlFormatter = new HtmlFormatter();\n \n+\t// options for which we allow distinct definitions\n+\t// this allows reporters to define their own options that are technically only key suffixes\n+\tprivate static final Set<String> WELL_DEFINED_WHITELIST = new HashSet<>(Arrays.asList(\n+\t\t\"host\",\n+\t\t\"port\"\n+\t));\n+\n \t@Test\n \tpublic void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedCommonOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(\n \t\t\toptionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null);\n \n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n+\n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n \t@Test\n \tpublic void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {\n-\t\tMap<String, DocumentedOption> documentedOptions = parseDocumentedOptions();\n-\t\tMap<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true);\n+\t\tMap<String, List<DocumentedOption>> documentedOptions = parseDocumentedOptions();\n+\t\tMap<String, List<ExistingOption>> existingOptions = findExistingOptions(ignored -> true);\n+\n+\t\tassertDocumentedOptionsAreWellDefined(documentedOptions);\n+\t\tassertExistingOptionsAreWellDefined(existingOptions);\n \n \t\tcompareDocumentedAndExistingOptions(documentedOptions, existingOptions);\n \t}\n \n-\tprivate static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {\n+\tprivate static void assertDocumentedOptionsAreWellDefined(Map<String, List<DocumentedOption>> documentedOptions) {\n+\t\tassertOptionsAreWellDefined(documentedOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct defaults for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Documentation contains distinct descriptions for \" +\n+\t\t\t\t\t\toption1.key + \" in \" + option1.containingFile + \" and \" + option2.containingFile + '.');\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static void assertExistingOptionsAreWellDefined(Map<String, List<ExistingOption>> existingOptions) {\n+\t\tassertOptionsAreWellDefined(existingOptions, (option1, option2) -> {\n+\t\t\t\t// found a ConfigOption pair with the same key that aren't equal\n+\t\t\t\t// we fail here outright as this is not a documentation-completeness problem\n+\t\t\t\tif (!option1.defaultValue.equals(option2.defaultValue)) {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct default values (\" + option1.defaultValue + \" vs \" + option2.defaultValue + \").\");\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new AssertionError(\"Ambiguous option \" + option1.key + \" due to distinct descriptions.\");\n+\t\t\t\t}\n+\t\t\t});\n+\t}\n+\n+\tprivate static <O> void assertOptionsAreWellDefined(Map<String, List<O>> allOptions, BiFunction<O, O, AssertionError> duplicateHandler) {\n+\t\tallOptions.entrySet().stream()\n+\t\t\t.filter(entry -> !WELL_DEFINED_WHITELIST.contains(entry.getKey()))\n+\t\t\t.map(Map.Entry::getValue)\n+\t\t\t.forEach(options -> options.stream().reduce((option1, option2) -> {\n+\t\t\t\tif (option1.equals(option2)) {\n+\t\t\t\t\t// we allow multiple instances of ConfigOptions with the same key if they are identical\n+\t\t\t\t\treturn option1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow duplicateHandler.apply(option1, option2);\n+\t\t\t\t}\n+\t\t\t}));\n+\t}\n+\n+\tprivate static void compareDocumentedAndExistingOptions(Map<String, List<DocumentedOption>> documentedOptions, Map<String, List<ExistingOption>> existingOptions) {\n \t\tfinal Collection<String> problems = new ArrayList<>(0);\n \n \t\t// first check that all existing options are properly documented\n-\t\texistingOptions.forEach((key, supposedState) -> {\n-\t\t\tDocumentedOption documentedState = documentedOptions.remove(key);\n-\n-\t\t\t// if nothing matches the docs for this option are up-to-date\n-\t\t\tif (documentedState == null) {\n-\t\t\t\t// option is not documented at all\n-\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t} else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {\n-\t\t\t\t// default is outdated\n-\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue + \" Actual: \" + documentedState.defaultValue);\n-\t\t\t} else if (!supposedState.description.equals(documentedState.description)) {\n-\t\t\t\t// description is outdated\n-\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\" is outdated.\");\n+\t\texistingOptions.forEach((key, supposedStates) -> {\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\n+\t\t\tfor (ExistingOption supposedState : supposedStates) {\n+\t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n+\t\t\t\t\t// option is not documented at all\n+\t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n+\t\t\t\t\t// default is outdated\n+\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n+\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n+\t\t\t\t\t// description is outdated\n+\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n+\t\t\t\t\t\t\" is outdated.\");\n+\t\t\t\t} else {\n+\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c2eb4fc84da2322124459c60c8263325cd8b6f1"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjYzMzc2", "url": "https://github.com/apache/flink/pull/10748#pullrequestreview-344663376", "createdAt": "2020-01-17T15:41:44Z", "commit": {"oid": "5506fe0e1f2a24a3c5c71eeaf33077b8f4571358"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo0MTo0NFrOFe88XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo0MTo0NFrOFe88XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDA5Mg==", "bodyText": "I'm not sure whether I completely understand this logic here. Can't it happen that we have two options where one fulfills the default value and the other fulfills the description? In this case we would remove the second option and not report any problems even though both of them should cause a problem.", "url": "https://github.com/apache/flink/pull/10748#discussion_r368000092", "createdAt": "2020-01-17T15:41:44Z", "author": {"login": "tillrohrmann"}, "path": "flink-docs/src/test/java/org/apache/flink/docs/configuration/ConfigOptionsDocsCompletenessITCase.java", "diffHunk": "@@ -139,22 +139,42 @@ private static void compareDocumentedAndExistingOptions(Map<String, List<Documen\n \n \t\t// first check that all existing options are properly documented\n \t\texistingOptions.forEach((key, supposedStates) -> {\n-\t\t\tList<DocumentedOption> documentedState = documentedOptions.remove(key);\n+\t\t\tList<DocumentedOption> documentedState = documentedOptions.get(key);\n \n \t\t\tfor (ExistingOption supposedState : supposedStates) {\n \t\t\t\tif (documentedState == null || documentedState.isEmpty()) {\n \t\t\t\t\t// option is not documented at all\n \t\t\t\t\tproblems.add(\"Option \" + supposedState.key + \" in \" + supposedState.containingClass + \" is not documented.\");\n-\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.defaultValue.equals(documentedOption.defaultValue))) {\n-\t\t\t\t\t// default is outdated\n-\t\t\t\t\tproblems.add(\"Documented default of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\t\" is outdated. Expected: \" + supposedState.defaultValue);\n-\t\t\t\t} else if (documentedState.stream().noneMatch(documentedOption -> supposedState.description.equals(documentedOption.description))) {\n-\t\t\t\t\t// description is outdated\n-\t\t\t\t\tproblems.add(\"Documented description of \" + supposedState.key + \" in \" + supposedState.containingClass +\n-\t\t\t\t\t\t\" is outdated.\");\n \t\t\t\t} else {\n-\t\t\t\t\t// the docs for this option are up-to-date\n+\t\t\t\t\tfinal Iterator<DocumentedOption> candidates = documentedState.iterator();\n+\n+\t\t\t\t\tboolean matchingDefaultFound = false;\n+\t\t\t\t\tboolean matchingDescriptionFound = false;\n+\t\t\t\t\twhile (candidates.hasNext()) {\n+\t\t\t\t\t\tDocumentedOption candidate = candidates.next();\n+\t\t\t\t\t\tif (supposedState.defaultValue.equals(candidate.defaultValue)) {\n+\t\t\t\t\t\t\tmatchingDefaultFound = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (supposedState.description.equals(candidate.description)) {\n+\t\t\t\t\t\t\tmatchingDescriptionFound = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (matchingDefaultFound && matchingDescriptionFound) {\n+\t\t\t\t\t\t\t// option is properly documented\n+\t\t\t\t\t\t\tcandidates.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5506fe0e1f2a24a3c5c71eeaf33077b8f4571358"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d17791c13a5d5efcd3e96a6b21adf6d69f6c923", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/1d17791c13a5d5efcd3e96a6b21adf6d69f6c923", "committedDate": "2020-01-17T21:37:34Z", "message": "[FLINK-15458][conf][tests] Separate options discovery and well-definedness check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d26c55a75aa0665df4d9e945eaf1e3da61f3b6fa", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/d26c55a75aa0665df4d9e945eaf1e3da61f3b6fa", "committedDate": "2020-01-17T21:46:33Z", "message": "[FLINK-15458][conf][docs] Introduce SuffixOption annotation\n\nThey key of a SuffixOption is only a suffix, with the prefix being determined at runtime.\nIn the case of reporters the prefix is \"metrics.reporter.\" with a user-provided infix.\n\nFor these options it doesn't make sense to check whether they are clashing with other options;\nin practive this is entirely dependent on the prefix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e0617bd355a1e8081ebb9ce615365cb8296dbf2", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/3e0617bd355a1e8081ebb9ce615365cb8296dbf2", "committedDate": "2020-01-17T21:48:57Z", "message": "[FLINK-14831][metrics][docs] Generate InfluxDB config docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6a0b8e7a74209ec6a22942a28c763207c27d503", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/f6a0b8e7a74209ec6a22942a28c763207c27d503", "committedDate": "2020-01-17T17:35:40Z", "message": "fix logic error"}, "afterCommit": {"oid": "3e0617bd355a1e8081ebb9ce615365cb8296dbf2", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/3e0617bd355a1e8081ebb9ce615365cb8296dbf2", "committedDate": "2020-01-17T21:48:57Z", "message": "[FLINK-14831][metrics][docs] Generate InfluxDB config docs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4903, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}