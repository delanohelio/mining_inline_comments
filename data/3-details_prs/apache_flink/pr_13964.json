{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NzA4MDY5", "number": 13964, "title": " [FLINK-19314][coordination] Add DeclarativeSlotPoolBridge ", "bodyText": "Based on #13722.\nThis PR adds the final bit declarative resource management: the DeclarativeSlotPoolBridge which acts as a glue between the declarative resource management and current SlotRequest-based scheduler.\nThe bridge essentially maps every incoming slot request, be it for a new or an existing slot, to a requirement increase, and every slot release/free to a requirement reduction.\nWhen allocating a new slot the bridge returns a slot future. Whenever a new slot is offered to the JobMaster the bridge tries to fulfill any non-completed slot futures with the new slots.", "createdAt": "2020-11-06T12:17:00Z", "url": "https://github.com/apache/flink/pull/13964", "merged": true, "mergeCommit": {"oid": "908d28145dc1a562ba918e348f05e651863a621f"}, "closed": true, "closedAt": "2020-12-17T21:59:05Z", "author": {"login": "zentol"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiV4kHgBqjQwNjQ1Njg0MTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnGoUWgBqjQxMjYxMjU5Mjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "002a26e22352ec2a5c79c3cde4ed4b749f87e7e1", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/002a26e22352ec2a5c79c3cde4ed4b749f87e7e1", "committedDate": "2020-11-06T12:10:23Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}, "afterCommit": {"oid": "b2fc4902b25f60f403bf5839ca717b465f09b67a", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/b2fc4902b25f60f403bf5839ca717b465f09b67a", "committedDate": "2020-12-02T21:59:57Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2fc4902b25f60f403bf5839ca717b465f09b67a", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/b2fc4902b25f60f403bf5839ca717b465f09b67a", "committedDate": "2020-12-02T21:59:57Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}, "afterCommit": {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/aa2a35104a430e3dada923f364ceff82d4fcc87d", "committedDate": "2020-12-03T09:44:43Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MDM3MTMx", "url": "https://github.com/apache/flink/pull/13964#pullrequestreview-548037131", "createdAt": "2020-12-09T10:23:01Z", "commit": {"oid": "8729bb29add5014ff34474fe14ab9a5c7d5717ca"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyMzowMlrOICNMvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNTozMDoyNVrOICapfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDMxNw==", "bodyText": "I think it returns Optional#empty if the given allocation id is not available.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184317", "createdAt": "2020-12-09T10:23:02Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8729bb29add5014ff34474fe14ab9a5c7d5717ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDU0NA==", "bodyText": "Returns Optional#empty instead of null.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184544", "createdAt": "2020-12-09T10:23:20Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.\n+\t *\n+\t * @param slotRequestId identifying the requested slot\n+\t * @param allocationID the allocation id of the requested available slot\n+\t * @param requiredSlotProfile requiredSlotProfile for which to allocate the slot\n+\t * @return the previously available slot with the given allocation id or {@code null} if no such slot existed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8729bb29add5014ff34474fe14ab9a5c7d5717ca"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDc0Ng==", "bodyText": "It would be good to state what it means if requiredSlotProfile is null. Also add for what this parameter is used.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184746", "createdAt": "2020-12-09T10:23:35Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.\n+\t *\n+\t * @param slotRequestId identifying the requested slot\n+\t * @param allocationID the allocation id of the requested available slot\n+\t * @param requiredSlotProfile requiredSlotProfile for which to allocate the slot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8729bb29add5014ff34474fe14ab9a5c7d5717ca"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MjQwMw==", "bodyText": "nit: I would change the order of the parameters. First saying which requests get cancelled and then with what.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539192403", "createdAt": "2020-12-09T10:34:28Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5NjA2NA==", "bodyText": "Just as a side note: I really would like to do FLINK-11719 at some point in time. This should allow us to get rid of this pattern here.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539196064", "createdAt": "2020-12-09T10:39:41Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg==", "bodyText": "I don't fully understand newSlotsSet. If this set is supposed to filter out repeated newSlotsAreAvailable calls, how is this possible if the only thing we are doing between adding a slot to newSlotsAreAvailable and removing it from there is to add the slot to matchingsToFulfill? Can it be that this is no longer possible because the completion of pending requests has been moved into a separate loop?", "url": "https://github.com/apache/flink/pull/13964#discussion_r539330192", "createdAt": "2020-12-09T14:01:54Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTU3Mw==", "bodyText": "I am wondering whether this logging statement shouldn't be part of the AllocatedSlotPool.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539331573", "createdAt": "2020-12-09T14:03:43Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODI4MQ==", "bodyText": "I'd suggest to use FlinkMatchers.containsCause", "url": "https://github.com/apache/flink/pull/13964#discussion_r539348281", "createdAt": "2020-12-09T14:24:40Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {\n+\n+\tprivate static final Time rpcTimeout = Time.seconds(20);\n+\tprivate static final JobID jobId = new JobID();\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\t@Test\n+\tpublic void testSlotOffer() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, null);\n+\n+\t\t\tdeclarativeSlotPoolBridge.newSlotsAreAvailable(Collections.singleton(allocatedSlot));\n+\n+\t\t\tslotAllocationFuture.join();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNotEnoughResourcesAvailableFailsPendingRequests() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = CompletableFuture\n+\t\t\t\t\t.supplyAsync(() -> declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, Time.minutes(5)), mainThreadExecutor)\n+\t\t\t\t\t.get();\n+\n+\t\t\tmainThreadExecutor.execute(() -> declarativeSlotPoolBridge.notifyNotEnoughResourcesAvailable(Collections.emptyList()));\n+\n+\t\t\ttry {\n+\t\t\t\tslotAllocationFuture.join();\n+\t\t\t\tAssert.fail();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tOptional<NoResourceAvailableException> expectedException = ExceptionUtils.findThrowable(e, NoResourceAvailableException.class);\n+\t\t\t\tassertThat(expectedException.isPresent(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODY4NQ==", "bodyText": "Or FlinkMatchers.futureWillCompleteExceptionally on slotAllocationFuture.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539348685", "createdAt": "2020-12-09T14:25:10Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {\n+\n+\tprivate static final Time rpcTimeout = Time.seconds(20);\n+\tprivate static final JobID jobId = new JobID();\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\t@Test\n+\tpublic void testSlotOffer() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, null);\n+\n+\t\t\tdeclarativeSlotPoolBridge.newSlotsAreAvailable(Collections.singleton(allocatedSlot));\n+\n+\t\t\tslotAllocationFuture.join();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNotEnoughResourcesAvailableFailsPendingRequests() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = CompletableFuture\n+\t\t\t\t\t.supplyAsync(() -> declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, Time.minutes(5)), mainThreadExecutor)\n+\t\t\t\t\t.get();\n+\n+\t\t\tmainThreadExecutor.execute(() -> declarativeSlotPoolBridge.notifyNotEnoughResourcesAvailable(Collections.emptyList()));\n+\n+\t\t\ttry {\n+\t\t\t\tslotAllocationFuture.join();\n+\t\t\t\tAssert.fail();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tOptional<NoResourceAvailableException> expectedException = ExceptionUtils.findThrowable(e, NoResourceAvailableException.class);\n+\t\t\t\tassertThat(expectedException.isPresent(), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODI4MQ=="}, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1MzAwOQ==", "bodyText": "I think FutureUtils.completeAll is what you want to use here.", "url": "https://github.com/apache/flink/pull/13964#discussion_r539353009", "createdAt": "2020-12-09T14:30:28Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {\n+\n+\tprivate static final Time rpcTimeout = Time.seconds(20);\n+\tprivate static final JobID jobId = new JobID();\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\t@Test\n+\tpublic void testSlotOffer() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, null);\n+\n+\t\t\tdeclarativeSlotPoolBridge.newSlotsAreAvailable(Collections.singleton(allocatedSlot));\n+\n+\t\t\tslotAllocationFuture.join();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNotEnoughResourcesAvailableFailsPendingRequests() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = CompletableFuture\n+\t\t\t\t\t.supplyAsync(() -> declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, Time.minutes(5)), mainThreadExecutor)\n+\t\t\t\t\t.get();\n+\n+\t\t\tmainThreadExecutor.execute(() -> declarativeSlotPoolBridge.notifyNotEnoughResourcesAvailable(Collections.emptyList()));\n+\n+\t\t\ttry {\n+\t\t\t\tslotAllocationFuture.join();\n+\t\t\t\tAssert.fail();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tOptional<NoResourceAvailableException> expectedException = ExceptionUtils.findThrowable(e, NoResourceAvailableException.class);\n+\t\t\t\tassertThat(expectedException.isPresent(), is(true));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasingAllocatedSlot() throws Exception {\n+\t\tfinal CompletableFuture<AllocationID> releaseSlotFuture = new CompletableFuture<>();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder builder = TestingDeclarativeSlotPool\n+\t\t\t\t.builder()\n+\t\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> {\n+\t\t\t\t\tassertThat(allocationId, is(expectedAllocationId));\n+\t\t\t\t\treturn allocatedSlot;\n+\t\t\t\t})\n+\t\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> {\n+\t\t\t\t\treleaseSlotFuture.complete(allocationID);\n+\t\t\t\t\treturn ResourceCounter.empty();\n+\t\t\t\t});\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(builder);\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\t\tdeclarativeSlotPoolBridge.allocateAvailableSlot(slotRequestId, expectedAllocationId, allocatedSlot.getResourceProfile());\n+\t\t\tdeclarativeSlotPoolBridge.releaseSlot(slotRequestId, null);\n+\n+\t\t\tassertThat(releaseSlotFuture.join(), is(expectedAllocationId));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNoConcurrentModificationWhenSuspendingAndReleasingSlot() throws Exception {\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(new DefaultDeclarativeSlotPoolFactory())) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tfinal List<SlotRequestId> slotRequestIds = Arrays.asList(new SlotRequestId(), new SlotRequestId());\n+\n+\t\t\tfinal List<CompletableFuture<PhysicalSlot>> slotFutures = slotRequestIds.stream()\n+\t\t\t\t\t.map(slotRequestId -> {\n+\t\t\t\t\t\tfinal CompletableFuture<PhysicalSlot> slotFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, rpcTimeout);\n+\t\t\t\t\t\tslotFuture.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t\tdeclarativeSlotPoolBridge.releaseSlot(slotRequestId, throwable);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\treturn slotFuture;\n+\t\t\t\t\t})\n+\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\tdeclarativeSlotPoolBridge.suspend();\n+\n+\t\t\ttry {\n+\t\t\t\tFutureUtils.waitForAll(slotFutures).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7f5dec4c973aa6592444b8e00738c8975a1aae"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDgwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n          \n          \n            \n            \t\t\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);", "url": "https://github.com/apache/flink/pull/13964#discussion_r539380807", "createdAt": "2020-12-09T15:02:59Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4OTQ1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest);\n          \n          \n            \n            \t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest());", "url": "https://github.com/apache/flink/pull/13964#discussion_r539389451", "createdAt": "2020-12-09T15:13:06Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);\n+\t\tdeclarativeSlotPool.reserveFreeSlot(allocationId, resourceProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\t}\n+\n+\tprivate Optional<PendingRequest> findMatchingPendingRequest(PhysicalSlot slot) {\n+\t\tfinal ResourceProfile resourceProfile = slot.getResourceProfile();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequests.values()) {\n+\t\t\tif (resourceProfile.isMatching(pendingRequest.getResourceProfile())) {\n+\t\t\t\tLOG.debug(\"Matched slot {} to pending request {}.\", slot, pendingRequest);\n+\t\t\t\treturn Optional.of(pendingRequest);\n+\t\t\t}\n+\t\t}\n+\t\tLOG.debug(\"Could not match slot {} to any pending request.\", slot);\n+\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {\n+\t\tthrow new UnsupportedOperationException(\"This method should not be used when using declarative resource management.\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID, @Nullable ResourceProfile requiredSlotProfile) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(requiredSlotProfile, \"The requiredSlotProfile must not be null.\");\n+\n+\t\tLOG.debug(\"Reserving free slot {} for slot request id {} and profile {}.\", allocationID, slotRequestId, requiredSlotProfile);\n+\n+\t\treturn Optional.of(reserveFreeSlotForResource(slotRequestId, allocationID, requiredSlotProfile));\n+\t}\n+\n+\tprivate PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(requiredSlotProfile, 1));\n+\t\tfinal PhysicalSlot physicalSlot = declarativeSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\n+\t\treturn physicalSlot;\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, @Nullable Time timeout) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createNormalRequest(slotRequestId, resourceProfile);\n+\n+\t\tif (timeout != null) {\n+\t\t\tFutureUtils\n+\t\t\t\t.orTimeout(\n+\t\t\t\t\tpendingRequest.getSlotFuture(),\n+\t\t\t\t\ttimeout.toMilliseconds(),\n+\t\t\t\t\tTimeUnit.MILLISECONDS,\n+\t\t\t\t\tcomponentMainThreadExecutor)\n+\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t}\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedBatchSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated batch slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\tprivate void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {\n+\t\treleaseSlot(slotRequestId, new TimeoutException(\"Pending slot request timed out in slot pool.\"));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlot> internalRequestNewAllocatedSlot(PendingRequest pendingRequest) {\n+\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);\n+\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\n+\t\treturn pendingRequest.getSlotFuture();\n+\t}\n+\n+\tprivate void declareResourceRequirements(Collection<ResourceRequirement> resourceRequirements) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Declare new resource requirements for job {}: {}.\", jobId, resourceRequirements);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.declareResourceRequirements(ResourceRequirements.create(jobId, jobManagerAddress, resourceRequirements));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(AllocationID allocationID, Exception cause) {\n+\t\tthrow new UnsupportedOperationException(\"Please call failAllocation(ResourceID, AllocationID, Exception)\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(@Nullable ResourceID resourceId, AllocationID allocationID, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tPreconditions.checkNotNull(allocationID);\n+\t\tPreconditions.checkNotNull(resourceId, \"This slot pool only supports failAllocation calls coming from the TaskExecutor.\");\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = declarativeSlotPool.releaseSlot(allocationID, cause);\n+\t\tif (!previouslyFulfilledRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirements);\n+\t\t}\n+\n+\t\tif (declarativeSlotPool.containsSlots(resourceId)) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn Optional.of(resourceId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {\n+\t\tLOG.debug(\"Release slot with slot request id {}\", slotRequestId);\n+\t\tassertRunningInMainThread();\n+\n+\t\tfinal PendingRequest pendingRequest = pendingRequests.remove(slotRequestId);\n+\n+\t\tif (pendingRequest != null) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\t\t\tpendingRequest.failRequest(new FlinkException(\n+\t\t\t\t\tString.format(\"Pending slot request with %s has been released.\", pendingRequest.getSlotRequestId()),\n+\t\t\t\t\tcause));\n+\t\t} else {\n+\t\t\tfinal AllocationID allocationId = fulfilledRequests.remove(slotRequestId);\n+\n+\t\t\tif (allocationId != null) {\n+\t\t\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.freeReservedSlot(allocationId, cause, clock.relativeTimeMillis());\n+\t\t\t\tif (!previouslyFulfilledRequirement.isEmpty()) {\n+\t\t\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tLOG.debug(\"Could not find slot which has fulfilled slot request {}. Ignoring the release operation.\", slotRequestId);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyNotEnoughResourcesAvailable(Collection<ResourceRequirement> acquiredResources) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tcomponentMainThreadExecutor.schedule(\n+\t\t\t\tfailPendingRequests(),\n+\t\t\t\tresourceAcquisitionTimeout.toMillis(),\n+\t\t\t\tTimeUnit.MILLISECONDS);\n+\t}\n+\n+\tprivate Runnable failPendingRequests() {\n+\t\treturn () -> {\n+\t\t\tif (!pendingRequests.isEmpty()) {\n+\t\t\t\tfinal NoResourceAvailableException cause = new NoResourceAvailableException(\"Could not acquire the minimum required resources.\");\n+\n+\t\t\t\tcancelPendingRequests(\n+\t\t\t\t\t\tcause,\n+\t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5OTcyMw==", "bodyText": "Why are we scheduling the failPendingRequests here and don't execute it immediately?", "url": "https://github.com/apache/flink/pull/13964#discussion_r539399723", "createdAt": "2020-12-09T15:24:58Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);\n+\t\tdeclarativeSlotPool.reserveFreeSlot(allocationId, resourceProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\t}\n+\n+\tprivate Optional<PendingRequest> findMatchingPendingRequest(PhysicalSlot slot) {\n+\t\tfinal ResourceProfile resourceProfile = slot.getResourceProfile();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequests.values()) {\n+\t\t\tif (resourceProfile.isMatching(pendingRequest.getResourceProfile())) {\n+\t\t\t\tLOG.debug(\"Matched slot {} to pending request {}.\", slot, pendingRequest);\n+\t\t\t\treturn Optional.of(pendingRequest);\n+\t\t\t}\n+\t\t}\n+\t\tLOG.debug(\"Could not match slot {} to any pending request.\", slot);\n+\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {\n+\t\tthrow new UnsupportedOperationException(\"This method should not be used when using declarative resource management.\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID, @Nullable ResourceProfile requiredSlotProfile) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(requiredSlotProfile, \"The requiredSlotProfile must not be null.\");\n+\n+\t\tLOG.debug(\"Reserving free slot {} for slot request id {} and profile {}.\", allocationID, slotRequestId, requiredSlotProfile);\n+\n+\t\treturn Optional.of(reserveFreeSlotForResource(slotRequestId, allocationID, requiredSlotProfile));\n+\t}\n+\n+\tprivate PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(requiredSlotProfile, 1));\n+\t\tfinal PhysicalSlot physicalSlot = declarativeSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\n+\t\treturn physicalSlot;\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, @Nullable Time timeout) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createNormalRequest(slotRequestId, resourceProfile);\n+\n+\t\tif (timeout != null) {\n+\t\t\tFutureUtils\n+\t\t\t\t.orTimeout(\n+\t\t\t\t\tpendingRequest.getSlotFuture(),\n+\t\t\t\t\ttimeout.toMilliseconds(),\n+\t\t\t\t\tTimeUnit.MILLISECONDS,\n+\t\t\t\t\tcomponentMainThreadExecutor)\n+\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t}\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedBatchSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated batch slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\tprivate void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {\n+\t\treleaseSlot(slotRequestId, new TimeoutException(\"Pending slot request timed out in slot pool.\"));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlot> internalRequestNewAllocatedSlot(PendingRequest pendingRequest) {\n+\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);\n+\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\n+\t\treturn pendingRequest.getSlotFuture();\n+\t}\n+\n+\tprivate void declareResourceRequirements(Collection<ResourceRequirement> resourceRequirements) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Declare new resource requirements for job {}: {}.\", jobId, resourceRequirements);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.declareResourceRequirements(ResourceRequirements.create(jobId, jobManagerAddress, resourceRequirements));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(AllocationID allocationID, Exception cause) {\n+\t\tthrow new UnsupportedOperationException(\"Please call failAllocation(ResourceID, AllocationID, Exception)\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(@Nullable ResourceID resourceId, AllocationID allocationID, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tPreconditions.checkNotNull(allocationID);\n+\t\tPreconditions.checkNotNull(resourceId, \"This slot pool only supports failAllocation calls coming from the TaskExecutor.\");\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = declarativeSlotPool.releaseSlot(allocationID, cause);\n+\t\tif (!previouslyFulfilledRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirements);\n+\t\t}\n+\n+\t\tif (declarativeSlotPool.containsSlots(resourceId)) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn Optional.of(resourceId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {\n+\t\tLOG.debug(\"Release slot with slot request id {}\", slotRequestId);\n+\t\tassertRunningInMainThread();\n+\n+\t\tfinal PendingRequest pendingRequest = pendingRequests.remove(slotRequestId);\n+\n+\t\tif (pendingRequest != null) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\t\t\tpendingRequest.failRequest(new FlinkException(\n+\t\t\t\t\tString.format(\"Pending slot request with %s has been released.\", pendingRequest.getSlotRequestId()),\n+\t\t\t\t\tcause));\n+\t\t} else {\n+\t\t\tfinal AllocationID allocationId = fulfilledRequests.remove(slotRequestId);\n+\n+\t\t\tif (allocationId != null) {\n+\t\t\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.freeReservedSlot(allocationId, cause, clock.relativeTimeMillis());\n+\t\t\t\tif (!previouslyFulfilledRequirement.isEmpty()) {\n+\t\t\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tLOG.debug(\"Could not find slot which has fulfilled slot request {}. Ignoring the release operation.\", slotRequestId);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyNotEnoughResourcesAvailable(Collection<ResourceRequirement> acquiredResources) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tcomponentMainThreadExecutor.schedule(\n+\t\t\t\tfailPendingRequests(),\n+\t\t\t\tresourceAcquisitionTimeout.toMillis(),\n+\t\t\t\tTimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNDY2OA==", "bodyText": "I think it would be great to add some tests which ensure that the set of declared resources is correct wrt to different actions on the SlotPool (e.g. failAllocation, releaseSlot, allocateAvailableSlot etc.)", "url": "https://github.com/apache/flink/pull/13964#discussion_r539404668", "createdAt": "2020-12-09T15:30:25Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MTc3ODY3", "url": "https://github.com/apache/flink/pull/13964#pullrequestreview-549177867", "createdAt": "2020-12-10T13:08:44Z", "commit": {"oid": "4a2a3fe7bf8c8b7f9579e2aebd100e4c58fefd6f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowODo0NFrOIDIbIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxNjoxOVrOIDIucw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NDY1Nw==", "bodyText": "What exception will be thrown?", "url": "https://github.com/apache/flink/pull/13964#discussion_r540154657", "createdAt": "2020-12-10T13:08:44Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -151,32 +151,18 @@ void start(\n \tCollection<SlotInfo> getAllocatedSlotsInformation();\n \n \t/**\n-\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n-\t * {@code null} if no slot with the given allocation id is available.\n+\t * Allocates the available slot with the given allocation id under the given request id for the given requirement profile.\n+\t * The slot must be able to fulfill the requirement profile, otherwise an exception will be thrown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a2a3fe7bf8c8b7f9579e2aebd100e4c58fefd6f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1OTYwMw==", "bodyText": "I think the fact that failing this future triggers the cleanup is an implementation detail which can change in the future. I would suggest to use a very small timeout so that the request fails fast.", "url": "https://github.com/apache/flink/pull/13964#discussion_r540159603", "createdAt": "2020-12-10T13:16:19Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeResourceDeclarationTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createAllocatedSlot;\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createDeclarativeSlotPoolBridge;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeResourceDeclarationTest extends TestLogger {\n+\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\tprivate RequirementListener requirementListener;\n+\tprivate DeclarativeSlotPoolBridge declarativeSlotPoolBridge;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\trequirementListener = new RequirementListener();\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder slotPoolBuilder = TestingDeclarativeSlotPool.builder()\n+\t\t\t.setIncreaseResourceRequirementsByConsumer(requirementListener::increaseRequirements)\n+\t\t\t.setDecreaseResourceRequirementsByConsumer(requirementListener::decreaseRequirements)\n+\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> createAllocatedSlot(allocationId))\n+\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1))\n+\t\t\t.setReleaseSlotFunction((allocationID, e) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1));\n+\n+\t\tfinal DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory(slotPoolBuilder);\n+\t\tdeclarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory);\n+\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\t}\n+\n+\t@After\n+\tpublic void teardown() throws Exception {\n+\t\tif (declarativeSlotPoolBridge != null) {\n+\t\t\tdeclarativeSlotPoolBridge.close();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsIncreasedOnNewAllocation() {\n+\t\t// requesting the allocation of a new slot should increase the requirements\n+\t\tdeclarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\tassertThat(requirementListener.getRequirements().getResourceCount(ResourceProfile.UNKNOWN), is(1));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsDecreasedOnAllocationTimeout() {\n+\t\t// requesting the allocation of a new slot increases the requirements\n+\t\tfinal CompletableFuture<PhysicalSlot> allocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\t// when the allocation fails the requirements should be reduced (it is the users responsibility to retry)\n+\t\tallocationFuture.completeExceptionally(new TimeoutException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a2a3fe7bf8c8b7f9579e2aebd100e4c58fefd6f"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDg0OTI4", "url": "https://github.com/apache/flink/pull/13964#pullrequestreview-549484928", "createdAt": "2020-12-10T18:27:11Z", "commit": {"oid": "93eba656d95d403a56f2f12dbf6ef4bf9642be94"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93eba656d95d403a56f2f12dbf6ef4bf9642be94", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/93eba656d95d403a56f2f12dbf6ef4bf9642be94", "committedDate": "2020-12-10T16:50:03Z", "message": "++"}, "afterCommit": {"oid": "38b20a3ba8f75871d2d12fe9c54f09372d72a995", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/38b20a3ba8f75871d2d12fe9c54f09372d72a995", "committedDate": "2020-12-13T23:40:47Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNjQ3NDcx", "url": "https://github.com/apache/flink/pull/13964#pullrequestreview-553647471", "createdAt": "2020-12-16T12:40:30Z", "commit": {"oid": "d4226484f9f498f8e4697a794027b1956bdb62c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjo0MDozMFrOIHDZOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjo0MDozMFrOIHDZOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI2NjU1NA==", "bodyText": "x", "url": "https://github.com/apache/flink/pull/13964#discussion_r544266554", "createdAt": "2020-12-16T12:40:30Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeResourceDeclarationTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.core.testutils.FlinkMatchers;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createAllocatedSlot;\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createDeclarativeSlotPoolBridge;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeResourceDeclarationTest extends TestLogger {\n+\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\tprivate RequirementListener requirementListener;\n+\tprivate DeclarativeSlotPoolBridge declarativeSlotPoolBridge;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\trequirementListener = new RequirementListener();\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder slotPoolBuilder = TestingDeclarativeSlotPool.builder()\n+\t\t\t.setIncreaseResourceRequirementsByConsumer(requirementListener::increaseRequirements)\n+\t\t\t.setDecreaseResourceRequirementsByConsumer(requirementListener::decreaseRequirements)\n+\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> createAllocatedSlot(allocationId))\n+\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1))\n+\t\t\t.setReleaseSlotFunction((allocationID, e) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1));\n+\n+\t\tfinal DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory(slotPoolBuilder);\n+\t\tdeclarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory);\n+\t}\n+\n+\t@After\n+\tpublic void teardown() throws Exception {\n+\t\tif (declarativeSlotPoolBridge != null) {\n+\t\t\tdeclarativeSlotPoolBridge.close();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsIncreasedOnNewAllocation() throws Exception {\n+\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t// requesting the allocation of a new slot should increase the requirements\n+\t\tdeclarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\tassertThat(requirementListener.getRequirements().getResourceCount(ResourceProfile.UNKNOWN), is(1));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsDecreasedOnAllocationTimeout() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4226484f9f498f8e4697a794027b1956bdb62c5"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzODA5MjA4", "url": "https://github.com/apache/flink/pull/13964#pullrequestreview-553809208", "createdAt": "2020-12-16T15:36:04Z", "commit": {"oid": "6f58354898bc5d4e76e1e99874e92db60ad09707"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTozNjowNFrOIHLYQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNTozNjowNFrOIHLYQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NzM3OA==", "bodyText": "After an offline discussion with Chesnay we concluded that this is not the fix for the problem. Instead we will try to not expose futures which have other dependents because this can lead to violating the main thread guarantee when waiting on this future outside of the main thread (get() will try to complete the future's dependents).", "url": "https://github.com/apache/flink/pull/13964#discussion_r544397378", "createdAt": "2020-12-16T15:36:04Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -317,11 +317,12 @@ private PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, All\n \t\t\t\t\ttimeout.toMilliseconds(),\n \t\t\t\t\tTimeUnit.MILLISECONDS,\n \t\t\t\t\tcomponentMainThreadExecutor)\n-\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n-\t\t\t\t\tif (throwable instanceof TimeoutException) {\n-\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n-\t\t\t\t\t}\n-\t\t\t\t});\n+\t\t\t\t.whenCompleteAsync((physicalSlot, throwable) -> {\n+\t\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t\tcomponentMainThreadExecutor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f58354898bc5d4e76e1e99874e92db60ad09707"}, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4122a02022d1bba12d99577c802e531d5fa609e", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/a4122a02022d1bba12d99577c802e531d5fa609e", "committedDate": "2020-12-16T22:50:30Z", "message": "Remove CancellationException block"}, "afterCommit": {"oid": "58bb428c34a3a544d622dafdbc455474e5d72592", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/58bb428c34a3a544d622dafdbc455474e5d72592", "committedDate": "2020-12-16T15:55:40Z", "message": "different approach for CompletableFuture issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35e50f75efaa798efea1ed3d139f7c021a9f00c1", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/35e50f75efaa798efea1ed3d139f7c021a9f00c1", "committedDate": "2020-12-17T14:27:36Z", "message": "[hotfix][coordination] Add ExcessResource#toString()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d686fcc297e7ba5ac9838a525a9e6ff3aba9faa4", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/d686fcc297e7ba5ac9838a525a9e6ff3aba9faa4", "committedDate": "2020-12-17T14:27:36Z", "message": "[hotfix][coordination][tests] Remove error message assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc0400f585e9502076269c190a6d0b06f108ae2c", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/cc0400f585e9502076269c190a6d0b06f108ae2c", "committedDate": "2020-12-17T14:27:36Z", "message": "[FLINK-19314][coordination][tests] Add TestingDeclarativeSlotPoolBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "049382bdaae5591daf56ae518d664df0e744e5b9", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/049382bdaae5591daf56ae518d664df0e744e5b9", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19314][coordination] Add DeclarativeSlotPoolFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed7bc13c0fe8696d68fbf2348b714115d521b42c", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/ed7bc13c0fe8696d68fbf2348b714115d521b42c", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19314][coordination] Extend SlotPool interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "633532e6ff6b74a0c90c1a8af98a627ada8ac88c", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/633532e6ff6b74a0c90c1a8af98a627ada8ac88c", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19314][coordination] Add DeclarativeSlotPoolBridge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "716aa2625b423f76c12b081ad6d3544cdc586f80", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/716aa2625b423f76c12b081ad6d3544cdc586f80", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19314][coordination] Wire notifications about resources not being available"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58bb428c34a3a544d622dafdbc455474e5d72592", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/58bb428c34a3a544d622dafdbc455474e5d72592", "committedDate": "2020-12-16T15:55:40Z", "message": "different approach for CompletableFuture issue"}, "afterCommit": {"oid": "1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "committedDate": "2020-12-17T17:03:32Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "committedDate": "2020-12-17T14:27:37Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}, "afterCommit": {"oid": "95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "committedDate": "2020-12-17T17:03:32Z", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4452, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}