{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NjUwOTI5", "number": 12478, "title": "[FLINK-17869][task][checkpointing] Fix race condition when calling ChannelStateWriter.abort", "bodyText": "What is the purpose of the change\nBefore FLINK-17218 there were two problems:\n\nExceeding ChannelStateWriterImpl.maxCheckpoints\nRace condition with out of order barriers (see be8fbcf of this PR)\n\nFLINK-17218 (24ff415) fixed the first one but introduced a new race condition when netty thread modifies a ChannelStateWriter map used by the task thread.\nThis PR reverts FLINK-17218 and addresses the issues above.\nBrief change log\n\nRevert 24ff415 \"[FLINK-17218][checkpointing] Ensuring that ChannelStateWriter aborts previous checkpoints before a new checkpoint\nAbort channel state write if checkpoint is subsumed - using future callback and task thread - fix race condition\nIncrease ChannelStateWriterImpl.DEFAULT_MAX_CHECKPOINTS - fix the original problem of FLINK-17218\nIgnore out of order checkpoints in SubtaskCheckpointCoordinator - fix a more subtle race condition\nUnignore UnalignedCheckpointITCase\n\nVerifying this change\nUnignore UnalignedCheckpointITCase.\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): no\nThe public API, i.e., is any changed class annotated with @Public(Evolving): no\nThe serializers: no\nThe runtime per-record code paths (performance sensitive): no\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: no\nThe S3 file system connector: no\n\nDocumentation\n\nDoes this pull request introduce a new feature? no\nIf yes, how is the feature documented? not applicable", "createdAt": "2020-06-04T07:44:42Z", "url": "https://github.com/apache/flink/pull/12478", "merged": true, "mergeCommit": {"oid": "b2d1c2d784741ae8d26382f4d64e0fca82ae5241"}, "closed": true, "closedAt": "2020-06-10T09:47:34Z", "author": {"login": "rkhachatryan"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcn-ThdAFqTQyNDQ2MzY3Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcp04TGAFqTQyNzc5OTA3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NDYzNjcz", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-424463673", "createdAt": "2020-06-04T13:44:33Z", "commit": {"oid": "be8fbcf506b8dd38e5425cf772a55f033f0962b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0NDozM1rOGfGj1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0NDozM1rOGfGj1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NjUxOQ==", "bodyText": "This is just an optimization.", "url": "https://github.com/apache/flink/pull/12478#discussion_r435266519", "createdAt": "2020-06-04T13:44:33Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -158,6 +159,16 @@ private ChannelStateWriter openChannelStateWriter() {\n \t@Override\n \tpublic void abortCheckpointOnBarrier(long checkpointId, Throwable cause, OperatorChain<?, ?> operatorChain) throws IOException {\n \t\tLOG.debug(\"Aborting checkpoint via cancel-barrier {} for task {}\", checkpointId, taskName);\n+\t\tlastCheckpointId = Math.max(lastCheckpointId, checkpointId);\n+\t\tIterator<Long> iterator = abortedCheckpointIds.iterator();\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tlong next = iterator.next();\n+\t\t\tif (next < lastCheckpointId) {\n+\t\t\t\titerator.remove();\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8fbcf506b8dd38e5425cf772a55f033f0962b0"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NDcwMDk4", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-424470098", "createdAt": "2020-06-04T13:51:08Z", "commit": {"oid": "420b7b3f645625b0b43f056440509cdd53bbd4ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo1MTowOFrOGfG-3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo1MTowOFrOGfG-3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MzQzOQ==", "bodyText": "This is just an optimization (possible now with abort and cleanup=false).", "url": "https://github.com/apache/flink/pull/12478#discussion_r435273439", "createdAt": "2020-06-04T13:51:08Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -281,6 +281,8 @@ public void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> opera\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tchannelStateWriter.abort(checkpointId, new CancellationException(\"checkpoint aborted via notification\"), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420b7b3f645625b0b43f056440509cdd53bbd4ef"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTcxMTQ4", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-425971148", "createdAt": "2020-06-08T07:24:00Z", "commit": {"oid": "72bfc6b84e33e5abcee8d078f6d4d00904f626f2"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzoyNDowMFrOGgR6_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTowMFrOGgSVgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwMTI0NQ==", "bodyText": "nit: usually we add task name to front, also it would be nice to use %d > %d for the comparison values.", "url": "https://github.com/apache/flink/pull/12478#discussion_r436501245", "createdAt": "2020-06-08T07:24:00Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateWriterImpl.java", "diffHunk": "@@ -102,11 +102,11 @@ public void start(long checkpointId, CheckpointOptions checkpointOptions) {\n \t\tLOG.debug(\"{} starting checkpoint {} ({})\", taskName, checkpointId, checkpointOptions);\n \t\tChannelStateWriteResult result = new ChannelStateWriteResult();\n \t\tChannelStateWriteResult put = results.computeIfAbsent(checkpointId, id -> {\n-\t\t\tPreconditions.checkState(results.size() < maxCheckpoints, \"results.size() > maxCheckpoints\", results.size(), maxCheckpoints);\n+\t\t\tPreconditions.checkState(results.size() < maxCheckpoints, String.format(\"can't start %d, results.size() > maxCheckpoints: %d, %d, %s\", checkpointId, results.size(), maxCheckpoints, taskName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72bfc6b84e33e5abcee8d078f6d4d00904f626f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwMjI2Mg==", "bodyText": "I also thought about that in FLINK-17218, but ultimately couldn't find a reason why any arbitrary large value offers an advantage over the current value. It makes the failing checkState more unlikely, but didn't eliminate it.\nI also thought about removing the checkState, but it helped me to find some issues previously.\nTL;DR I'm not convinced that this is a proper fix.", "url": "https://github.com/apache/flink/pull/12478#discussion_r436502262", "createdAt": "2020-06-08T07:26:13Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateWriterImpl.java", "diffHunk": "@@ -56,7 +56,7 @@\n public class ChannelStateWriterImpl implements ChannelStateWriter {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(ChannelStateWriterImpl.class);\n-\tprivate static final int DEFAULT_MAX_CHECKPOINTS = 5; // currently, only single in-flight checkpoint is supported\n+\tprivate static final int DEFAULT_MAX_CHECKPOINTS = 100; // includes max-concurrent-checkpoints + checkpoints to be aborted (scheduled via mailbox)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee338a57d401b7ae9c79d926f47637d4e6431e6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwNDI4NA==", "bodyText": "Should that be warning? I think on concept level yes.\nHowever, in reality, in current UC, this case happens probably quite frequently (barrier overtakes by cancellation marker doesn't). I wouldn't like seeing the log polluted with WARN.", "url": "https://github.com/apache/flink/pull/12478#discussion_r436504284", "createdAt": "2020-06-08T07:30:34Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -196,9 +207,14 @@ public void checkpointState(\n \t\t// We generally try to emit the checkpoint barrier as soon as possible to not affect downstream\n \t\t// checkpoint alignments\n \n+\t\tif (lastCheckpointId >= metadata.getCheckpointId()) {\n+\t\t\tLOG.warn(\"Out of order checkpoint barrier (aborted previously?): {} >= {}\", lastCheckpointId, metadata.getCheckpointId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be8fbcf506b8dd38e5425cf772a55f033f0962b0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwNTg0MA==", "bodyText": "Please rename getWriteResult. I think most developers would expect a getter to be idempotent.\nHow about removeWriteResult? That would be similar to how a Java map works. Or getAndRemoveWriteResult to be completely explicit.", "url": "https://github.com/apache/flink/pull/12478#discussion_r436505840", "createdAt": "2020-06-08T07:34:14Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateWriter.java", "diffHunk": "@@ -141,15 +141,10 @@ boolean isDone() {\n \tvoid abort(long checkpointId, Throwable cause);\n \n \t/**\n-\t * Must be called after {@link #start(long, CheckpointOptions)}.\n+\t * Must be called after {@link #start(long, CheckpointOptions)} once.\n \t */\n \tChannelStateWriteResult getWriteResult(long checkpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc0ec3ed824c9864430ed97bd681d510c8ee18e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwNzIwNQ==", "bodyText": "I guess the intend of cleanup is to avoid throwing an exception if getWriteResult(long) is called nonetheless, right?\nSo in which cases can that happen? Do we ensure cleanup in these cases (e.g., is abort then called twice?)?", "url": "https://github.com/apache/flink/pull/12478#discussion_r436507205", "createdAt": "2020-06-08T07:37:18Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateWriter.java", "diffHunk": "@@ -137,8 +137,9 @@ boolean isDone() {\n \n \t/**\n \t * Aborts the checkpoint and fails pending result for this checkpoint.\n+\t * @param cleanup true if {@link #getWriteResult(long)} is not supposed to be called afterwards.\n \t */\n-\tvoid abort(long checkpointId, Throwable cause);\n+\tvoid abort(long checkpointId, Throwable cause, boolean cleanup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad26a041df3442f65b6592bb10611828cf80d37"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwODAzMw==", "bodyText": "I like this optimization.\nWhat happens if some other thread still enqueues data to this checkpoint? Or the writes dismissed?", "url": "https://github.com/apache/flink/pull/12478#discussion_r436508033", "createdAt": "2020-06-08T07:39:00Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -281,6 +281,8 @@ public void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> opera\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tchannelStateWriter.abort(checkpointId, new CancellationException(\"checkpoint aborted via notification\"), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MzQzOQ=="}, "originalCommit": {"oid": "420b7b3f645625b0b43f056440509cdd53bbd4ef"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "420b7b3f645625b0b43f056440509cdd53bbd4ef", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/420b7b3f645625b0b43f056440509cdd53bbd4ef", "committedDate": "2020-06-04T08:06:15Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}, "afterCommit": {"oid": "29f103ced731a6939acb7d414e4545b07f13f370", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/29f103ced731a6939acb7d414e4545b07f13f370", "committedDate": "2020-06-08T09:53:31Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2OTEwMDMx", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-426910031", "createdAt": "2020-06-09T08:35:36Z", "commit": {"oid": "29f103ced731a6939acb7d414e4545b07f13f370"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "29f103ced731a6939acb7d414e4545b07f13f370", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/29f103ced731a6939acb7d414e4545b07f13f370", "committedDate": "2020-06-08T09:53:31Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}, "afterCommit": {"oid": "d587ae3d72bfca59ea734c668d43fcdeb72cff96", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/d587ae3d72bfca59ea734c668d43fcdeb72cff96", "committedDate": "2020-06-09T09:13:00Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf48798c9220b9c1d8d9ca5100688b45a292613", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/3cf48798c9220b9c1d8d9ca5100688b45a292613", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][hotfix] Add taskName to ChannelStateWriter log messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aafa060ee611f855654e8e9653bdf11ef54e8f84", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/aafa060ee611f855654e8e9653bdf11ef54e8f84", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][hotfix] Don't pass ChannelStateWrite Future to AsyncCheckpointRunnable\n\nOperatorSnapshotFinalizer already waits and holds this future.\nChannelStateWriter.getWriteResult() can then be non-idempotent.\nChannelStateWriter.stop() can then be removed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1582b47414a048efc0d9b634ffa57b020610a47f", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/1582b47414a048efc0d9b634ffa57b020610a47f", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Revert \"[FLINK-17218][checkpointing] Ensuring that ChannelStateWriter aborts previous checkpoints before a new checkpoint is started.\"\n\nThis reverts commit 24ff415f1b76392f75dea7c3538558d24fcb7058\nwhich introduced a race condition when task thread and netty\nthread compete for ChannelStateWriteResult.\n\nInstead, next commits fix it by:\n1. Map size validation error will be prevented simply by increasing the limit\n2. When a checkpoint is subsumed, it's write result will be removed from on future completion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eee77db29211ce1fc8c23d7f6e3df6af9fd12c6", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/6eee77db29211ce1fc8c23d7f6e3df6af9fd12c6", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Abort channel state write if checkpoint is subsumed\n\nMotivation: stop writing channel state ASAP if the checkpoint is subsumed\n\nChanges:\n1. complete CheckpointBarrierUnaligner.ThreadSafeUnaligner#allBarriersReceivedFuture\n2. abort channel state write on its erroneous completion\n3. add cleanup parameter to ChannelStateWriter.abort to use cleanup=false\nin the call above"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "884371e7dc8a604f5b55b8e39f27a1bffd002173", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/884371e7dc8a604f5b55b8e39f27a1bffd002173", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Increase ChannelStateWriterImpl.DEFAULT_MAX_CHECKPOINTS\n\nChannelStateWriter map is cleaned up by the task thread,\nso the check in netty thread should take possible delay\ninto account."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26343fa05d8e72cf21cea7246e332c7850e05db3", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/26343fa05d8e72cf21cea7246e332c7850e05db3", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Ignore out of order checkpoints in SubtaskCheckpointCoordinator\n\nCheck (by task thread) whether the current checkpoint was already aborted in the following scenario:\n1. on checkpoint barrier ThreadSafeUnaligner sends a mail to start checkpointing (netty thread)\n2. on cancellation marker CheckpointBarrierUnaligner aborts it (task thread)\n3. task thread processes a mail to start checkpointing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e92dd698cbc6786d5699e4f5aeab2f115587e5", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/a3e92dd698cbc6786d5699e4f5aeab2f115587e5", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][tests] Unignore UnalignedCheckpointITCase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22c99845ef4f863f1753d17b109fd2faecc8201e", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/22c99845ef4f863f1753d17b109fd2faecc8201e", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d587ae3d72bfca59ea734c668d43fcdeb72cff96", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/d587ae3d72bfca59ea734c668d43fcdeb72cff96", "committedDate": "2020-06-09T09:13:00Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}, "afterCommit": {"oid": "22c99845ef4f863f1753d17b109fd2faecc8201e", "author": {"user": {"login": "rkhachatryan", "name": "Roman"}}, "url": "https://github.com/apache/flink/commit/22c99845ef4f863f1753d17b109fd2faecc8201e", "committedDate": "2020-06-09T09:37:42Z", "message": "[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NzU2OTc2", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-427756976", "createdAt": "2020-06-10T06:52:19Z", "commit": {"oid": "6eee77db29211ce1fc8c23d7f6e3df6af9fd12c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo1MjoxOVrOGhnHZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo1MjoxOVrOGhnHZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5NzA2Mw==", "bodyText": "I am not quite sure whether we still have race condition here. abortCheckpointOnBarrier might be called from CheckpointBarrierUnaligner after triggering checkpoint into mailbox. After aborting, we did not remove the checkpoint action from mailbox, so the checkpoint might still happen afterwards. So how to guarantee that #getAndRemoveWriteResult would never be called after aborting?", "url": "https://github.com/apache/flink/pull/12478#discussion_r437897063", "createdAt": "2020-06-10T06:52:19Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -186,7 +186,7 @@ public void abortCheckpointOnBarrier(long checkpointId, Throwable cause, Operato\n \n \t\tcheckpointStorage.clearCacheFor(checkpointId);\n \n-\t\tchannelStateWriter.abort(checkpointId, cause);\n+\t\tchannelStateWriter.abort(checkpointId, cause, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eee77db29211ce1fc8c23d7f6e3df6af9fd12c6"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NzY4NzU4", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-427768758", "createdAt": "2020-06-10T07:12:40Z", "commit": {"oid": "884371e7dc8a604f5b55b8e39f27a1bffd002173"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoxMjo0MFrOGhnrFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoxMjo0MFrOGhnrFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkwNjE5Nw==", "bodyText": "I guess the current way seems a temporary work-around solution, not an elegant way. The initial purpose for introducing this threshold is for logic validating and avoiding invalid checkpoints retained in writer forever. But if we consider the abort delay into this threshold, it seems somehow lose the initial meaning for the guard, and we are really not sure what is the proper value for this threshold.\nThe proper way might resolve the potential race condition in essence, but it might pay more efforts not feasible ATM. So I think we might leave another debt here in future.", "url": "https://github.com/apache/flink/pull/12478#discussion_r437906197", "createdAt": "2020-06-10T07:12:40Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateWriterImpl.java", "diffHunk": "@@ -56,7 +56,7 @@\n public class ChannelStateWriterImpl implements ChannelStateWriter {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(ChannelStateWriterImpl.class);\n-\tprivate static final int DEFAULT_MAX_CHECKPOINTS = 5; // currently, only single in-flight checkpoint is supported\n+\tprivate static final int DEFAULT_MAX_CHECKPOINTS = 1000; // includes max-concurrent-checkpoints + checkpoints to be aborted (scheduled via mailbox)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884371e7dc8a604f5b55b8e39f27a1bffd002173"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Nzk5MDc4", "url": "https://github.com/apache/flink/pull/12478#pullrequestreview-427799078", "createdAt": "2020-06-10T07:53:32Z", "commit": {"oid": "26343fa05d8e72cf21cea7246e332c7850e05db3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzo1MzozMlrOGhpIzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzo1MzozMlrOGhpIzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMDE4OA==", "bodyText": "For the below logic for checking abort request from RPC:\nif (checkAndClearAbortedStatus(metadata.getCheckpointId())) {\n\t\t\tLOG.info(\"Checkpoint {} has been notified as aborted, would not trigger any checkpoint.\", metadata.getCheckpointId());\n\t\t\treturn;\n}\n\nDo we also need to call channelStateWriter.abort for RPC abort? If so, maybe we can integrate these two cases together for better handling the actions for aborting.", "url": "https://github.com/apache/flink/pull/12478#discussion_r437930188", "createdAt": "2020-06-10T07:53:32Z", "author": {"login": "zhijiangW"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java", "diffHunk": "@@ -221,9 +232,14 @@ public void checkpointState(\n \t\t// We generally try to emit the checkpoint barrier as soon as possible to not affect downstream\n \t\t// checkpoint alignments\n \n+\t\tif (lastCheckpointId >= metadata.getCheckpointId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26343fa05d8e72cf21cea7246e332c7850e05db3"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4292, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}