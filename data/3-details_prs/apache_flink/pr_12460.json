{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MDg0MTgw", "number": 12460, "title": " [FLINK-18063][checkpointing] Fix the race condition for aborting current checkpoint in CheckpointBarrierUnaligner", "bodyText": "What is the purpose of the change\nThere are three aborting scenarios which might encounter race condition:\n\nCheckpointBarrierUnaligner#processCancellationBarrier\nCheckpointBarrierUnaligner#processEndOfPartition\nAlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might also be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\nBrief change log\n\nFix the process of AlternatingCheckpointBarrierHandler#processBarrier\nFix the process of CheckpointBarrierUnaligner#processEndOfPartition to abort checkpoint properly\nFix the process of CheckpointBarrierUnaligner#processCancellationBarrier to abort checkpoint properly\n\nVerifying this change\n\nAdded new unit test CheckpointBarrierUnalignerTest#testProcessCancellationBarrierAfterNotifyBarrierReceived\nAdded new unit test CheckpointBarrierUnalignerTest#testProcessCancellationBarrierAfterProcessBarrier\nAdded new unit test CheckpointBarrierUnalignerTest#testProcessCancellationBarrierBeforeProcessAndReceiveBarrier\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-06-03T09:39:08Z", "url": "https://github.com/apache/flink/pull/12460", "merged": true, "mergeCommit": {"oid": "2fe888c9aff75a3ace18c30764b26cc9f53e2451"}, "closed": true, "closedAt": "2020-06-09T09:39:02Z", "author": {"login": "zhijiangW"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnpAJmAFqTQyMzQ4ODA0NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpgsYegFqTQyNjg4NjgyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDg4MDQ0", "url": "https://github.com/apache/flink/pull/12460#pullrequestreview-423488044", "createdAt": "2020-06-03T12:10:36Z", "commit": {"oid": "2c474b2b93166fff8a2cbcb635480a2dcda9202a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMDozNlrOGeY7sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjo1NTowOVrOGeafQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODk2MA==", "bodyText": "Are you sure this is a safe delete? AlternatingCheckpointBarrierHandler is for example using this method to clean up state of the previous handler before switching to another.", "url": "https://github.com/apache/flink/pull/12460#discussion_r434518960", "createdAt": "2020-06-03T12:10:36Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -117,17 +117,6 @@\n \t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(channelStateWriter), this);\n \t}\n \n-\t@Override\n-\tpublic void releaseBlocksAndResetBarriers() {\n-\t\tif (isCheckpointPending()) {\n-\t\t\t// make sure no additional data is persisted\n-\t\t\tArrays.fill(hasInflightBuffers, false);\n-\t\t\t// the next barrier that comes must assume it is the first\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n-\t\tthreadSafeUnaligner.resetReceivedBarriers(currentConsumedCheckpointId);\n-\t}\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c474b2b93166fff8a2cbcb635480a2dcda9202a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI0NA==", "bodyText": "Have we lost this log message?", "url": "https://github.com/apache/flink/pull/12460#discussion_r434521244", "createdAt": "2020-06-03T12:15:00Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -154,46 +154,51 @@ public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex)\n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tlong cancelledId = cancelBarrier.getCheckpointId();\n-\t\tif (LOG.isDebugEnabled()) {\n-\t\t\tLOG.debug(\"{}: Checkpoint {} canceled, aborting alignment.\", taskName, cancelledId);\n-\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ==", "bodyText": "I don't fully understand this boolean shouldAbort2. What are the conditions when it's set to true while shouldAbort1 is false? Why do we have those two sources of truth?", "url": "https://github.com/apache/flink/pull/12460#discussion_r434527285", "createdAt": "2020-06-03T12:25:55Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -154,46 +154,51 @@ public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex)\n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tlong cancelledId = cancelBarrier.getCheckpointId();\n-\t\tif (LOG.isDebugEnabled()) {\n-\t\t\tLOG.debug(\"{}: Checkpoint {} canceled, aborting alignment.\", taskName, cancelledId);\n-\t\t}\n-\n-\t\tif (currentConsumedCheckpointId >= cancelledId && !isCheckpointPending()) {\n-\t\t\treturn;\n-\t\t}\n+\t\t// tag whether we should abort checkpoint from task thread view\n+\t\tboolean shouldAbort1 = false;\n \n-\t\tif (isCheckpointPending()) {\n+\t\tif (cancelledId > currentConsumedCheckpointId) {\n+\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\t\tshouldAbort1 = true;\n+\t\t} else if (cancelledId == currentConsumedCheckpointId && isCheckpointPending()) {\n \t\t\tLOG.warn(\"{}: Received cancellation barrier for checkpoint {} before completing current checkpoint {}. \" +\n \t\t\t\t\t\"Skipping current checkpoint.\",\n \t\t\t\ttaskName,\n \t\t\t\tcancelledId,\n \t\t\t\tcurrentConsumedCheckpointId);\n \n \t\t\tresetConsumedBarriers();\n+\t\t\tshouldAbort1 = true;\n+\t\t}\n+\n+\t\t// tag whether we should abort checkpoint from threadSafeUnaligner view\n+\t\tboolean shouldAbort2 = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA==", "bodyText": "I'm not sure if this is working properly and even if it is, I'm not sure if it's a good way to solve the problem.\nAs far as I understand it works like this:\n\nwe trigger checkpoint from netty thread and enqueue notifyCheckpoint in the mailbox\nwe receive channel closed/end of partition event before notifyCheckpoint starts executing in the task thread from mailbox. This will lead us to this method and enqueuing notifyAbort after notifyCheckpoint in the mailbox\nwe are still going to execute notifyCheckpoint callback and trigger the checkpoint, despite it was already (partially?) aborted (for example resetReceivedBarriers() has already been called.\nnotifyAbort will clean up the checkpoint started in 3.\n\nBesides being quite complicated and hard to reason about, I'm not sure if it's correct and what could be the side effects of doing this in so many stages. It also might be unnecessarily using resources for starting a checkpoint that we already know will not happen.\nWhy can not it work like that:\n\nas before\nwe receive channel closed/end of partition event before notifyCheckpoint starts executing in the task thread from mailbox. We mark the correct checkpoints as cancelled (by bumping the cancelled/current checkpoint ids) in the ThreadSafeUnaligner and we abort the checkpoint immediately (assuming we are in the task thead, but I think we are always).\nif notifyCheckpoint starts executing it should check if the checkpoint it's suppose to notify wasn't cancelled.", "url": "https://github.com/apache/flink/pull/12460#discussion_r434542740", "createdAt": "2020-06-03T12:52:24Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -409,5 +416,15 @@ synchronized long getCurrentCheckpointId() {\n \t\tboolean isCheckpointPending() {\n \t\t\treturn numBarriersReceived > 0;\n \t\t}\n+\n+\t\tprivate void resetReceivedBarriers() {\n+\t\t\tArrays.fill(storeNewBuffers, false);\n+\t\t\tnumBarriersReceived = 0;\n+\t\t}\n+\n+\t\tprivate void notifyAbort(CheckpointException exception) throws IOException {\n+\t\t\tlong currentCheckpointId = currentReceivedCheckpointId;\n+\t\t\thandler.executeInTaskThread(() -> handler.notifyAbort(currentCheckpointId, exception), \"notifyAbort\");\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0NDQ1MA==", "bodyText": "I think something is missing in the:\n\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n\t\t\tsuper.notifyCheckpoint(barrier, 0);\n\t\t}\n\t}\n\n? As it is now, after cancelling/closing checkpoint, the above method would still trigger the checkpoint, as barrier.getId() would be equal to currentReceivedCheckpointId", "url": "https://github.com/apache/flink/pull/12460#discussion_r434544450", "createdAt": "2020-06-03T12:55:09Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -387,12 +378,28 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n \t\t}\n \n-\t\tsynchronized void setCurrentReceivedCheckpointId(long currentReceivedCheckpointId) {\n-\t\t\tthis.currentReceivedCheckpointId = Math.max(currentReceivedCheckpointId, this.currentReceivedCheckpointId);\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;\n+\t\t\tif (canceledCheckpointId > currentReceivedCheckpointId) {\n+\t\t\t\tcurrentReceivedCheckpointId = canceledCheckpointId;\n+\t\t\t\tshouldAbort = true;\n+\n+\t\t\t} else if (canceledCheckpointId == currentReceivedCheckpointId && isCheckpointPending()) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tshouldAbort = true;\n+\t\t\t}\n+\t\t\treturn shouldAbort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5cd95ae65bac7ad1104754921c99390d02e73745", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/5cd95ae65bac7ad1104754921c99390d02e73745", "committedDate": "2020-06-04T05:17:20Z", "message": "fix the issues for AlternatingCheckpointBarrierHandler"}, "afterCommit": {"oid": "1d838c03d2b9f9744cae6fc03a919db72cc0efd9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/1d838c03d2b9f9744cae6fc03a919db72cc0efd9", "committedDate": "2020-06-04T05:32:21Z", "message": "fix the issues for AlternatingCheckpointBarrierHandler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDUzMjg1", "url": "https://github.com/apache/flink/pull/12460#pullrequestreview-425053285", "createdAt": "2020-06-05T07:21:24Z", "commit": {"oid": "2c474b2b93166fff8a2cbcb635480a2dcda9202a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzoyMToyNVrOGfjJPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozMjoxM1rOGfjdSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDg0NQ==", "bodyText": "If we change how this method is used, I'd consider it more than a hotfix. Then I'd also like to see the reason for the removal in the commit message (I don't understand it from this commit's perspective).", "url": "https://github.com/apache/flink/pull/12460#discussion_r435734845", "createdAt": "2020-06-05T07:21:25Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -117,17 +117,6 @@\n \t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(channelStateWriter), this);\n \t}\n \n-\t@Override\n-\tpublic void releaseBlocksAndResetBarriers() {\n-\t\tif (isCheckpointPending()) {\n-\t\t\t// make sure no additional data is persisted\n-\t\t\tArrays.fill(hasInflightBuffers, false);\n-\t\t\t// the next barrier that comes must assume it is the first\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n-\t\tthreadSafeUnaligner.resetReceivedBarriers(currentConsumedCheckpointId);\n-\t}\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODk2MA=="}, "originalCommit": {"oid": "2c474b2b93166fff8a2cbcb635480a2dcda9202a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng==", "bodyText": "A bit unrelated to your change, but shouldn't that also be synchronized?\nAlso is it necessary to move the method?", "url": "https://github.com/apache/flink/pull/12460#discussion_r435735886", "createdAt": "2020-06-05T07:23:50Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -404,8 +400,14 @@ synchronized int getNumOpenChannels() {\n \t\t\treturn numOpenChannels;\n \t\t}\n \n+\t\t@VisibleForTesting\n \t\tsynchronized long getCurrentCheckpointId() {\n \t\t\treturn currentReceivedCheckpointId;\n \t\t}\n+\n+\t\t@VisibleForTesting\n+\t\tboolean isCheckpointPending() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d714d44e2c2dd271baeec7cc9a7519ce7eb309e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNzMzOA==", "bodyText": "Can't we move this abort always to the caller side? Then the return value of onChannelClosed is more like shouldBeAborted and would be symmetric to processCancellationBarrier.", "url": "https://github.com/apache/flink/pull/12460#discussion_r435737338", "createdAt": "2020-06-05T07:26:52Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -387,12 +378,28 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTk3OQ==", "bodyText": "I think adding a guard in handler.executeInTaskThread(() -> handler.notifyCheckpoint(barrier), \"notifyCheckpoint\"); against executing a cancelled checkpoint is always a good idea. But I'm also seeing that it is not enough.", "url": "https://github.com/apache/flink/pull/12460#discussion_r435739979", "createdAt": "2020-06-05T07:32:13Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -409,5 +416,15 @@ synchronized long getCurrentCheckpointId() {\n \t\tboolean isCheckpointPending() {\n \t\t\treturn numBarriersReceived > 0;\n \t\t}\n+\n+\t\tprivate void resetReceivedBarriers() {\n+\t\t\tArrays.fill(storeNewBuffers, false);\n+\t\t\tnumBarriersReceived = 0;\n+\t\t}\n+\n+\t\tprivate void notifyAbort(CheckpointException exception) throws IOException {\n+\t\t\tlong currentCheckpointId = currentReceivedCheckpointId;\n+\t\t\thandler.executeInTaskThread(() -> handler.notifyAbort(currentCheckpointId, exception), \"notifyAbort\");\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA=="}, "originalCommit": {"oid": "c3f3aca669da2619d58190e684479c3fadd7026f"}, "originalPosition": 144}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2c4d6aaf78612e7214cc49d22e2b90fe29b93b6", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/b2c4d6aaf78612e7214cc49d22e2b90fe29b93b6", "committedDate": "2020-06-04T05:47:09Z", "message": "[hotfix][checkpointing] Fix the method of AlternatingCheckpointBarrierHandler#getAlignmentDurationNanos"}, "afterCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/31da2083df6221fd36c6ed5674927eed1cc68088", "committedDate": "2020-06-05T11:10:05Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MjE0OTI1", "url": "https://github.com/apache/flink/pull/12460#pullrequestreview-425214925", "createdAt": "2020-06-05T11:24:45Z", "commit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyNDo0NlrOGfqq8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozMzozNFrOGfq5sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1ODE2MQ==", "bodyText": "nit: weird newline", "url": "https://github.com/apache/flink/pull/12460#discussion_r435858161", "createdAt": "2020-06-05T11:24:46Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -379,12 +376,38 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;\n+\t\t\tif (canceledCheckpointId > currentReceivedCheckpointId) {\n+\t\t\t\tcurrentReceivedCheckpointId = canceledCheckpointId;\n+\t\t\t\tshouldAbort = true;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1ODQ2MQ==", "bodyText": "nit: shouldAbort can be inlined for improved readability (in my eyes).", "url": "https://github.com/apache/flink/pull/12460#discussion_r435858461", "createdAt": "2020-06-05T11:25:23Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -379,12 +376,38 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTc5OQ==", "bodyText": "nit: extract DEFAULT_CHECKPOINT_ID?", "url": "https://github.com/apache/flink/pull/12460#discussion_r435859799", "createdAt": "2020-06-05T11:28:30Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {\n+\t\tfinal long checkpointId = 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MDk0Mg==", "bodyText": "Would it make sense to extract these assertions in separate test cases? There might be a bias in the implementation, when the checkpoint has already been canceled. It would only add two test cases afaik.", "url": "https://github.com/apache/flink/pull/12460#discussion_r435860942", "createdAt": "2020-06-05T11:31:13Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\tThreadSafeUnaligner unaligner = handler.getThreadSafeUnaligner();\n+\t\t// should trigger respective checkpoint\n+\t\tunaligner.notifyBarrierReceived(buildCheckpointBarrier(checkpointId), new InputChannelInfo(0, 0));\n+\n+\t\tassertFalse(handler.isCheckpointPending());\n+\t\tassertTrue(unaligner.isCheckpointPending());\n+\t\tassertEquals(-1L, handler.getLatestCheckpointId());\n+\t\tassertEquals(checkpointId, unaligner.getCurrentCheckpointId());\n+\n+\t\ttestProcessCancellationBarrier(handler, invokable, checkpointId);\n+\t}\n+\n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link CheckpointBarrierUnaligner#processBarrier(CheckpointBarrier, int)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint2() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\t// should trigger respective checkpoint\n+\t\thandler.processBarrier(buildCheckpointBarrier(checkpointId), 0);\n+\n+\t\tassertTrue(handler.isCheckpointPending());\n+\t\tassertTrue(handler.getThreadSafeUnaligner().isCheckpointPending());\n+\t\tassertEquals(checkpointId, handler.getLatestCheckpointId());\n+\t\tassertEquals(checkpointId, handler.getThreadSafeUnaligner().getCurrentCheckpointId());\n+\n+\t\ttestProcessCancellationBarrier(handler, invokable, checkpointId);\n+\t}\n+\n+\t@Test\n+\tpublic void testProcessCancellationBarrierBeforeProcessAndReceiveBarrier() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(checkpointId));\n+\n+\t\tverifyTriggeredCheckpoint(handler, invokable, checkpointId);\n+\n+\t\t// it would not trigger checkpoint since the respective cancellation barrier already happened before\n+\t\thandler.processBarrier(buildCheckpointBarrier(checkpointId), 0);\n+\t\thandler.getThreadSafeUnaligner().notifyBarrierReceived(buildCheckpointBarrier(checkpointId), new InputChannelInfo(0, 0));\n+\n+\t\tverifyTriggeredCheckpoint(handler, invokable, checkpointId);\n+\t}\n+\n+\tprivate void testProcessCancellationBarrier(\n+\t\t\tCheckpointBarrierUnaligner handler,\n+\t\t\tValidatingCheckpointInvokable invokable,\n+\t\t\tlong currentCheckpointId) throws Exception {\n+\n+\t\t// should abort current checkpoint while processing CancelCheckpointMarker\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(currentCheckpointId));\n+\t\tverifyTriggeredCheckpoint(handler, invokable, currentCheckpointId);\n+\n+\t\tfinal long canceledCheckpointId = 1L;\n+\t\t// should update current checkpoint id and abort notification while processing CancelCheckpointMarker\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(canceledCheckpointId));\n+\t\tverifyTriggeredCheckpoint(handler, invokable, canceledCheckpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTU2OA==", "bodyText": "typo: witch -> with", "url": "https://github.com/apache/flink/pull/12460#discussion_r435861568", "createdAt": "2020-06-05T11:32:40Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTkzNw==", "bodyText": "How about naming it testProcessCancellationBarrierAfterNotifyBarrierReceived and the other test testProcessCancellationBarrierAfterProcessBarrier?", "url": "https://github.com/apache/flink/pull/12460#discussion_r435861937", "createdAt": "2020-06-05T11:33:34Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTU2OA=="}, "originalCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/31da2083df6221fd36c6ed5674927eed1cc68088", "committedDate": "2020-06-05T11:10:05Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "5729182fd15a074bebba7f878113781c2b119fd3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/5729182fd15a074bebba7f878113781c2b119fd3", "committedDate": "2020-06-05T15:49:45Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5729182fd15a074bebba7f878113781c2b119fd3", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/5729182fd15a074bebba7f878113781c2b119fd3", "committedDate": "2020-06-05T15:49:45Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "committedDate": "2020-06-06T14:43:16Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "committedDate": "2020-06-06T14:43:16Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "committedDate": "2020-06-08T08:47:55Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "committedDate": "2020-06-08T08:47:55Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "4e9a8fe1fd21982c769c435bd82579d09ee3db40", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4e9a8fe1fd21982c769c435bd82579d09ee3db40", "committedDate": "2020-06-08T12:27:28Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e9a8fe1fd21982c769c435bd82579d09ee3db40", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4e9a8fe1fd21982c769c435bd82579d09ee3db40", "committedDate": "2020-06-08T12:27:28Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "2c4ec033b0c3870b7235dc5f595eb453eee3f634", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2c4ec033b0c3870b7235dc5f595eb453eee3f634", "committedDate": "2020-06-08T15:15:14Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c4ec033b0c3870b7235dc5f595eb453eee3f634", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/2c4ec033b0c3870b7235dc5f595eb453eee3f634", "committedDate": "2020-06-08T15:15:14Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "6778e65c398f92632a811a5ac5cea1989cc9d970", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/6778e65c398f92632a811a5ac5cea1989cc9d970", "committedDate": "2020-06-09T04:30:28Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d69d47ccb7715f55ce6a285179ea7a3754d31197", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/d69d47ccb7715f55ce6a285179ea7a3754d31197", "committedDate": "2020-06-09T04:47:15Z", "message": "[hotfix][checkpointing] Add VisibleForTesting annotation for related methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e1eff24e36073ea1028a9029d14c77a7cf5336e", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/4e1eff24e36073ea1028a9029d14c77a7cf5336e", "committedDate": "2020-06-09T04:47:21Z", "message": "[FLINK-18063][checkpointing][refactoring] Implement default #isBlocked method in CheckpointBarrierHandler\n\nSimplify the implementations of CheckpointBarrierTracker and CheckpointBarrierUnaligner to reuse the parent default implementation.\n\nThis closes #12460."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "111011af4265cbf4c61fefcf7f5014a2e37c19e9", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/111011af4265cbf4c61fefcf7f5014a2e37c19e9", "committedDate": "2020-06-09T04:47:27Z", "message": "[FLINK-18063][checkpointing] Fix the invalid implementation of AlternatingCheckpointBarrierHandler#getAlignmentDurationNanos\n\nWe should take the value from active handler instead of aligned handler, because aligned handler is only used for savepoint and in\nmost cases the unaligned alignment duration should always be 0.\n\nThis cloese #12460."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/edfd5e47336b6a9b3339db90946cc580d6c23425", "committedDate": "2020-06-09T04:47:33Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6778e65c398f92632a811a5ac5cea1989cc9d970", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/6778e65c398f92632a811a5ac5cea1989cc9d970", "committedDate": "2020-06-09T04:30:28Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}, "afterCommit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425", "author": {"user": {"login": "zhijiangW", "name": "zhijiang"}}, "url": "https://github.com/apache/flink/commit/edfd5e47336b6a9b3339db90946cc580d6c23425", "committedDate": "2020-06-09T04:47:33Z", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODg2ODI2", "url": "https://github.com/apache/flink/pull/12460#pullrequestreview-426886826", "createdAt": "2020-06-09T08:06:42Z", "commit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODowNjo0MlrOGg9fTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODoxMTozNVrOGg9qrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTA1NQ==", "bodyText": "&& numBarriersReceived == 0 -> !isCheckpointPending()?", "url": "https://github.com/apache/flink/pull/12460#discussion_r437215055", "createdAt": "2020-06-09T08:06:42Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTM5OA==", "bodyText": "!isCheckpointPending()?", "url": "https://github.com/apache/flink/pull/12460#discussion_r437215398", "createdAt": "2020-06-09T08:07:18Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentReceivedCheckpointId = cancelledId;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tsynchronized void tryAbortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n+\t\t\tif (checkpointId > currentReceivedCheckpointId && resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(currentReceivedCheckpointId, exception);\n+\t\t\t}\n \t\t}\n \n-\t\tsynchronized void setCurrentReceivedCheckpointId(long currentReceivedCheckpointId) {\n-\t\t\tthis.currentReceivedCheckpointId = Math.max(currentReceivedCheckpointId, this.currentReceivedCheckpointId);\n+\t\tprivate boolean resetPendingCheckpoint() {\n+\t\t\tif (numBarriersReceived == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNjc0OQ==", "bodyText": "Would it make sense to return the value of resetPendingCheckpoint instead of always true?", "url": "https://github.com/apache/flink/pull/12460#discussion_r437216749", "createdAt": "2020-06-09T08:09:41Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentReceivedCheckpointId = cancelledId;\n+\t\t\treturn true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNzk2Ng==", "bodyText": "I'd prefer to use this method in main code instead of spreading the knowledge in many places. If I read isCheckpointPending, I understand it much quicker than numBarriersReceived > 0.\nBut it's more a personal taste, so up to you.", "url": "https://github.com/apache/flink/pull/12460#discussion_r437217966", "createdAt": "2020-06-09T08:11:35Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -404,8 +400,14 @@ synchronized int getNumOpenChannels() {\n \t\t\treturn numOpenChannels;\n \t\t}\n \n+\t\t@VisibleForTesting\n \t\tsynchronized long getCurrentCheckpointId() {\n \t\t\treturn currentReceivedCheckpointId;\n \t\t}\n+\n+\t\t@VisibleForTesting\n+\t\tboolean isCheckpointPending() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng=="}, "originalCommit": {"oid": "8d714d44e2c2dd271baeec7cc9a7519ce7eb309e"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4247, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}