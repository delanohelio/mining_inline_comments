{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMzkwNTYy", "number": 13443, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo0NTo0OFrOEmo0oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NTo1OVrOEm8Jqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTUwMTc2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo0NTo0OFrOHWyL-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo0NTo0OFrOHWyL-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1Mjk4NQ==", "bodyText": "I think this should be a checkState(). An IllegalStateException sounds more appropriate than a NPE.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493652985", "createdAt": "2020-09-23T14:45:48Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java", "diffHunk": "@@ -556,11 +558,13 @@ protected void reportOrForwardLatencyMarker(LatencyMarker marker) {\n \t\t}\n \t\t@SuppressWarnings(\"unchecked\")\n \t\tInternalTimeServiceManager<K> keyedTimeServiceHandler = (InternalTimeServiceManager<K>) timeServiceManager;\n+\t\tKeyedStateBackend<K> keyedStateBackend = getKeyedStateBackend();\n+\t\tcheckNotNull(keyedStateBackend, \"Timers can only be used on keyed operators.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTUwNDE1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo0NjoyMFrOHWyNfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo0NjoyMFrOHWyNfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1MzM3NA==", "bodyText": "Same as in previous comment.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493653374", "createdAt": "2020-09-23T14:46:20Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java", "diffHunk": "@@ -455,12 +457,16 @@ protected void reportOrForwardLatencyMarker(LatencyMarker marker) {\n \t\tif (timeServiceManager == null) {\n \t\t\tthrow new RuntimeException(\"The timer service has not been initialized.\");\n \t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n \t\tInternalTimeServiceManager<K> keyedTimeServiceHandler = (InternalTimeServiceManager<K>) timeServiceManager;\n+\t\tKeyedStateBackend<K> keyedStateBackend = getKeyedStateBackend();\n+\t\tcheckNotNull(keyedStateBackend, \"Timers can only be used on keyed operators.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTUzMzg0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimerServiceSerializationProxy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1MjowMVrOHWygIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzoxNDoxOVrOHW4jFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1ODE0Nw==", "bodyText": "It would be nice if here we could use the interface rather than the concrete implementation. Maybe by adding a new interface that include the missing methods and let the implementation implement both the InternalTimeServiceManager and the \"new\" interface?\nAlthough I have not tried it and it may look even uglier the solution I propose.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493658147", "createdAt": "2020-09-23T14:52:01Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimerServiceSerializationProxy.java", "diffHunk": "@@ -38,7 +38,7 @@\n \tpublic static final int VERSION = 2;\n \n \t/** The key-group timer services to write / read. */\n-\tprivate final InternalTimeServiceManager<K> timerServicesManager;\n+\tprivate final InternalTimeServiceManagerImpl<K> timerServicesManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NzIwNg==", "bodyText": "The thing though is, this \"proxy\" is used exclusively in the a private method of the InternalTimerServiceManagerImpl and is specific for that particular implementation. Therefore I think it is fine to use the *impl calss directly.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493757206", "createdAt": "2020-09-23T17:14:19Z", "author": {"login": "dawidwys"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimerServiceSerializationProxy.java", "diffHunk": "@@ -38,7 +38,7 @@\n \tpublic static final int VERSION = 2;\n \n \t/** The key-group timer services to write / read. */\n-\tprivate final InternalTimeServiceManager<K> timerServicesManager;\n+\tprivate final InternalTimeServiceManagerImpl<K> timerServicesManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1ODE0Nw=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTUzODkyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1MzowMlrOHWyjPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzowOToxOVrOHW4XUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1ODk0MQ==", "bodyText": "Is this comment correct ?", "url": "https://github.com/apache/flink/pull/13443#discussion_r493658941", "createdAt": "2020-09-23T14:53:02Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n-\t\t\tKeyContext keyContext,\n-\t\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n-\t\t\tProcessingTimeService processingTimeService,\n-\t\t\tboolean useLegacySynchronousSnapshots) {\n-\n-\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n-\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n-\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n-\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n-\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n-\n-\t\tthis.timerServices = new HashMap<>();\n-\t}\n-\n-\tpublic <N> InternalTimerService<N> getInternalTimerService(\n-\t\t\tString name,\n-\t\t\tTypeSerializer<N> namespaceSerializer,\n-\t\t\tTriggerable<K, N> triggerable,\n-\t\t\tKeyedStateBackend<K> keyedStateBackend) {\n-\t\tcheckNotNull(keyedStateBackend, \"Timers can only be used on keyed operators.\");\n-\n-\t\tTypeSerializer<K> keySerializer = keyedStateBackend.getKeySerializer();\n-\t\t// the following casting is to overcome type restrictions.\n-\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n-\t\treturn getInternalTimerService(name, timerSerializer, triggerable);\n-\t}\n-\n-\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */\n+\t<N> InternalTimerService<N> getInternalTimerService(\n \t\tString name,\n-\t\tTimerSerializer<K, N> timerSerializer,\n-\t\tTriggerable<K, N> triggerable) {\n-\n-\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n-\n-\t\ttimerService.startTimerService(\n-\t\t\ttimerSerializer.getKeySerializer(),\n-\t\t\ttimerSerializer.getNamespaceSerializer(),\n-\t\t\ttriggerable);\n-\n-\t\treturn timerService;\n-\t}\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n-\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n-\t\tif (timerService == null) {\n-\n-\t\t\ttimerService = new InternalTimerServiceImpl<>(\n-\t\t\t\tlocalKeyGroupRange,\n-\t\t\t\tkeyContext,\n-\t\t\t\tprocessingTimeService,\n-\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n-\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n-\n-\t\t\ttimerServices.put(name, timerService);\n-\t\t}\n-\t\treturn timerService;\n-\t}\n-\n-\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n-\t\treturn Collections.unmodifiableMap(timerServices);\n-\t}\n-\n-\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n-\t\tString name,\n-\t\tTimerSerializer<K, N> timerSerializer) {\n-\t\treturn priorityQueueSetFactory.create(\n-\t\t\tname,\n-\t\t\ttimerSerializer);\n-\t}\n-\n-\tpublic void advanceWatermark(Watermark watermark) throws Exception {\n-\t\tfor (InternalTimerServiceImpl<?, ?> service : timerServices.values()) {\n-\t\t\tservice.advanceWatermark(watermark.getTimestamp());\n-\t\t}\n-\t}\n-\n-\t//////////////////\t\t\t\tFault Tolerance Methods\t\t\t\t///////////////////\n-\n-\tpublic void snapshotState(StateSnapshotContext context, String operatorName) throws Exception {\n-\t\t//TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots\n-\t\tif (useLegacySynchronousSnapshots) {\n-\t\t\tKeyedStateCheckpointOutputStream out;\n-\t\t\ttry {\n-\t\t\t\tout = context.getRawKeyedOperatorStateOutput();\n-\t\t\t} catch (Exception exception) {\n-\t\t\t\tthrow new Exception(\"Could not open raw keyed operator state stream for \" +\n-\t\t\t\t\toperatorName + '.', exception);\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tKeyGroupsList allKeyGroups = out.getKeyGroupList();\n-\t\t\t\tfor (int keyGroupIdx : allKeyGroups) {\n-\t\t\t\t\tout.startNewKeyGroup(keyGroupIdx);\n-\n-\t\t\t\t\tsnapshotStateForKeyGroup(\n-\t\t\t\t\t\tnew DataOutputViewStreamWrapper(out), keyGroupIdx);\n-\t\t\t\t}\n-\t\t\t} catch (Exception exception) {\n-\t\t\t\tthrow new Exception(\"Could not write timer service of \" + operatorName +\n-\t\t\t\t\t\" to checkpoint state stream.\", exception);\n-\t\t\t} finally {\n-\t\t\t\ttry {\n-\t\t\t\t\tout.close();\n-\t\t\t\t} catch (Exception closeException) {\n-\t\t\t\t\tLOG.warn(\"Could not close raw keyed operator state stream for {}. This \" +\n-\t\t\t\t\t\t\"might have prevented deleting some state data.\", operatorName, closeException);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void snapshotStateForKeyGroup(DataOutputView stream, int keyGroupIdx) throws IOException {\n-\t\tInternalTimerServiceSerializationProxy<K> serializationProxy =\n-\t\t\tnew InternalTimerServiceSerializationProxy<>(this, keyGroupIdx);\n-\n-\t\tserializationProxy.write(stream);\n-\t}\n-\n-\tpublic void restoreStateForKeyGroup(\n-\t\t\tInputStream stream,\n-\t\t\tint keyGroupIdx,\n-\t\t\tClassLoader userCodeClassLoader) throws IOException {\n-\n-\t\tInternalTimerServiceSerializationProxy<K> serializationProxy =\n-\t\t\tnew InternalTimerServiceSerializationProxy<>(\n-\t\t\t\tthis,\n-\t\t\t\tuserCodeClassLoader,\n-\t\t\t\tkeyGroupIdx);\n-\n-\t\tserializationProxy.read(stream);\n-\t}\n-\n-\t////////////////////\t\t\tMethods used ONLY IN TESTS\t\t\t\t////////////////////\n-\n-\t@VisibleForTesting\n-\tpublic int numProcessingTimeTimers() {\n-\t\tint count = 0;\n-\t\tfor (InternalTimerServiceImpl<?, ?> timerService : timerServices.values()) {\n-\t\t\tcount += timerService.numProcessingTimeTimers();\n-\t\t}\n-\t\treturn count;\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int numEventTimeTimers() {\n-\t\tint count = 0;\n-\t\tfor (InternalTimerServiceImpl<?, ?> timerService : timerServices.values()) {\n-\t\t\tcount += timerService.numEventTimeTimers();\n-\t\t}\n-\t\treturn count;\n+\t\tTypeSerializer<K> keySerializer,\n+\t\tTypeSerializer<N> namespaceSerializer,\n+\t\tTriggerable<K, N> triggerable);\n+\n+\t/**\n+\t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n+\t * potentially firing the event time timers.\n+\t */\n+\tvoid advanceWatermark(Watermark watermark) throws Exception;\n+\n+\t/**\n+\t * Snapshots the timers in the keyed state.\n+\t *\n+\t * <p><b>TODO:</b> This can be removed once heap-based timers are integrated with RocksDB\n+\t * incremental snapshots.\n+\t */\n+\tvoid snapshotState(\n+\t\tStateSnapshotContext context,\n+\t\tString operatorName) throws Exception;\n+\n+\t/**\n+\t * A provider pattern for creating an instance of a {@link InternalTimeServiceManager}.\n+\t * Allows substituting the manager that will be used in the runtime.\n+\t */\n+\t@FunctionalInterface\n+\tinterface Provider {\n+\t\t<K> InternalTimeServiceManager<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NDE5Mw==", "bodyText": "actually it is (in the implementation) ;), but true it is misleading in the interface", "url": "https://github.com/apache/flink/pull/13443#discussion_r493754193", "createdAt": "2020-09-23T17:09:19Z", "author": {"login": "dawidwys"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n-\t\t\tKeyContext keyContext,\n-\t\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n-\t\t\tProcessingTimeService processingTimeService,\n-\t\t\tboolean useLegacySynchronousSnapshots) {\n-\n-\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n-\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n-\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n-\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n-\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n-\n-\t\tthis.timerServices = new HashMap<>();\n-\t}\n-\n-\tpublic <N> InternalTimerService<N> getInternalTimerService(\n-\t\t\tString name,\n-\t\t\tTypeSerializer<N> namespaceSerializer,\n-\t\t\tTriggerable<K, N> triggerable,\n-\t\t\tKeyedStateBackend<K> keyedStateBackend) {\n-\t\tcheckNotNull(keyedStateBackend, \"Timers can only be used on keyed operators.\");\n-\n-\t\tTypeSerializer<K> keySerializer = keyedStateBackend.getKeySerializer();\n-\t\t// the following casting is to overcome type restrictions.\n-\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n-\t\treturn getInternalTimerService(name, timerSerializer, triggerable);\n-\t}\n-\n-\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */\n+\t<N> InternalTimerService<N> getInternalTimerService(\n \t\tString name,\n-\t\tTimerSerializer<K, N> timerSerializer,\n-\t\tTriggerable<K, N> triggerable) {\n-\n-\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n-\n-\t\ttimerService.startTimerService(\n-\t\t\ttimerSerializer.getKeySerializer(),\n-\t\t\ttimerSerializer.getNamespaceSerializer(),\n-\t\t\ttriggerable);\n-\n-\t\treturn timerService;\n-\t}\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n-\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n-\t\tif (timerService == null) {\n-\n-\t\t\ttimerService = new InternalTimerServiceImpl<>(\n-\t\t\t\tlocalKeyGroupRange,\n-\t\t\t\tkeyContext,\n-\t\t\t\tprocessingTimeService,\n-\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n-\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n-\n-\t\t\ttimerServices.put(name, timerService);\n-\t\t}\n-\t\treturn timerService;\n-\t}\n-\n-\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n-\t\treturn Collections.unmodifiableMap(timerServices);\n-\t}\n-\n-\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n-\t\tString name,\n-\t\tTimerSerializer<K, N> timerSerializer) {\n-\t\treturn priorityQueueSetFactory.create(\n-\t\t\tname,\n-\t\t\ttimerSerializer);\n-\t}\n-\n-\tpublic void advanceWatermark(Watermark watermark) throws Exception {\n-\t\tfor (InternalTimerServiceImpl<?, ?> service : timerServices.values()) {\n-\t\t\tservice.advanceWatermark(watermark.getTimestamp());\n-\t\t}\n-\t}\n-\n-\t//////////////////\t\t\t\tFault Tolerance Methods\t\t\t\t///////////////////\n-\n-\tpublic void snapshotState(StateSnapshotContext context, String operatorName) throws Exception {\n-\t\t//TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots\n-\t\tif (useLegacySynchronousSnapshots) {\n-\t\t\tKeyedStateCheckpointOutputStream out;\n-\t\t\ttry {\n-\t\t\t\tout = context.getRawKeyedOperatorStateOutput();\n-\t\t\t} catch (Exception exception) {\n-\t\t\t\tthrow new Exception(\"Could not open raw keyed operator state stream for \" +\n-\t\t\t\t\toperatorName + '.', exception);\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tKeyGroupsList allKeyGroups = out.getKeyGroupList();\n-\t\t\t\tfor (int keyGroupIdx : allKeyGroups) {\n-\t\t\t\t\tout.startNewKeyGroup(keyGroupIdx);\n-\n-\t\t\t\t\tsnapshotStateForKeyGroup(\n-\t\t\t\t\t\tnew DataOutputViewStreamWrapper(out), keyGroupIdx);\n-\t\t\t\t}\n-\t\t\t} catch (Exception exception) {\n-\t\t\t\tthrow new Exception(\"Could not write timer service of \" + operatorName +\n-\t\t\t\t\t\" to checkpoint state stream.\", exception);\n-\t\t\t} finally {\n-\t\t\t\ttry {\n-\t\t\t\t\tout.close();\n-\t\t\t\t} catch (Exception closeException) {\n-\t\t\t\t\tLOG.warn(\"Could not close raw keyed operator state stream for {}. This \" +\n-\t\t\t\t\t\t\"might have prevented deleting some state data.\", operatorName, closeException);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void snapshotStateForKeyGroup(DataOutputView stream, int keyGroupIdx) throws IOException {\n-\t\tInternalTimerServiceSerializationProxy<K> serializationProxy =\n-\t\t\tnew InternalTimerServiceSerializationProxy<>(this, keyGroupIdx);\n-\n-\t\tserializationProxy.write(stream);\n-\t}\n-\n-\tpublic void restoreStateForKeyGroup(\n-\t\t\tInputStream stream,\n-\t\t\tint keyGroupIdx,\n-\t\t\tClassLoader userCodeClassLoader) throws IOException {\n-\n-\t\tInternalTimerServiceSerializationProxy<K> serializationProxy =\n-\t\t\tnew InternalTimerServiceSerializationProxy<>(\n-\t\t\t\tthis,\n-\t\t\t\tuserCodeClassLoader,\n-\t\t\t\tkeyGroupIdx);\n-\n-\t\tserializationProxy.read(stream);\n-\t}\n-\n-\t////////////////////\t\t\tMethods used ONLY IN TESTS\t\t\t\t////////////////////\n-\n-\t@VisibleForTesting\n-\tpublic int numProcessingTimeTimers() {\n-\t\tint count = 0;\n-\t\tfor (InternalTimerServiceImpl<?, ?> timerService : timerServices.values()) {\n-\t\t\tcount += timerService.numProcessingTimeTimers();\n-\t\t}\n-\t\treturn count;\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int numEventTimeTimers() {\n-\t\tint count = 0;\n-\t\tfor (InternalTimerServiceImpl<?, ?> timerService : timerServices.values()) {\n-\t\t\tcount += timerService.numEventTimeTimers();\n-\t\t}\n-\t\treturn count;\n+\t\tTypeSerializer<K> keySerializer,\n+\t\tTypeSerializer<N> namespaceSerializer,\n+\t\tTriggerable<K, N> triggerable);\n+\n+\t/**\n+\t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n+\t * potentially firing the event time timers.\n+\t */\n+\tvoid advanceWatermark(Watermark watermark) throws Exception;\n+\n+\t/**\n+\t * Snapshots the timers in the keyed state.\n+\t *\n+\t * <p><b>TODO:</b> This can be removed once heap-based timers are integrated with RocksDB\n+\t * incremental snapshots.\n+\t */\n+\tvoid snapshotState(\n+\t\tStateSnapshotContext context,\n+\t\tString operatorName) throws Exception;\n+\n+\t/**\n+\t * A provider pattern for creating an instance of a {@link InternalTimeServiceManager}.\n+\t * Allows substituting the manager that will be used in the runtime.\n+\t */\n+\t@FunctionalInterface\n+\tinterface Provider {\n+\t\t<K> InternalTimeServiceManager<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1ODk0MQ=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTU0MTg5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1MzozNVrOHWylFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1MzozNVrOHWylFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTQxMw==", "bodyText": "Is this comment correct?", "url": "https://github.com/apache/flink/pull/13443#discussion_r493659413", "createdAt": "2020-09-23T14:53:35Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTU0Mzk1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1NDowMFrOHWymUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzo0MzowOFrOHX4mVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTcyOA==", "bodyText": "All the args can fit in the same line here.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493659728", "createdAt": "2020-09-23T14:54:00Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1ODc0OQ==", "bodyText": "Personally I prefer:\n\nEither all arguments fit in a single line with the function name (whole signature in a single line)\nIf not 1. -> chop down all parameters.\n\nI will add an identation though.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493758749", "createdAt": "2020-09-23T17:16:43Z", "author": {"login": "dawidwys"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTcyOA=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNDkxOQ==", "bodyText": "Yes, I was proposing you option 1.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494804919", "createdAt": "2020-09-25T07:39:27Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTcyOA=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNjYxNQ==", "bodyText": "The thing is it does not fit in one line. ;)\nIt does in the line above which I fixed.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494806615", "createdAt": "2020-09-25T07:43:08Z", "author": {"login": "dawidwys"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTcyOA=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTU0NDgwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1NDowOVrOHWym1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzo0MzoxNFrOHX4meg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTg2MA==", "bodyText": "Same here.", "url": "https://github.com/apache/flink/pull/13443#discussion_r493659860", "createdAt": "2020-09-23T14:54:09Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,\n+\t\tTimerSerializer<K, N> timerSerializer) {\n+\t\treturn priorityQueueSetFactory.create(\n+\t\t\tname,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNjY1MA==", "bodyText": "updated.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494806650", "createdAt": "2020-09-25T07:43:14Z", "author": {"login": "dawidwys"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the\n+ * {@link AbstractStreamOperator}. Right now, this is only a\n+ * {@link InternalTimerServiceImpl timer services}.\n+ *\n+ * <b>NOTE:</b> These services are only available to keyed operators.\n+ *\n+ * @param <K> The type of keys used for the timers and the registry.\n+ */\n+@Internal\n+public class InternalTimeServiceManagerImpl<K> implements InternalTimeServiceManager<K> {\n+\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManagerImpl.class);\n+\n+\t@VisibleForTesting\n+\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n+\t@VisibleForTesting\n+\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n+\t@VisibleForTesting\n+\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n+\n+\tprivate final KeyGroupRange localKeyGroupRange;\n+\tprivate final KeyContext keyContext;\n+\n+\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n+\n+\tprivate final boolean useLegacySynchronousSnapshots;\n+\n+\tprivate InternalTimeServiceManagerImpl(\n+\t\tKeyGroupRange localKeyGroupRange,\n+\t\tKeyContext keyContext,\n+\t\tPriorityQueueSetFactory priorityQueueSetFactory,\n+\t\tProcessingTimeService processingTimeService, boolean useLegacySynchronousSnapshots) {\n+\n+\t\tthis.localKeyGroupRange = Preconditions.checkNotNull(localKeyGroupRange);\n+\t\tthis.priorityQueueSetFactory = Preconditions.checkNotNull(priorityQueueSetFactory);\n+\t\tthis.keyContext = Preconditions.checkNotNull(keyContext);\n+\t\tthis.processingTimeService = Preconditions.checkNotNull(processingTimeService);\n+\t\tthis.useLegacySynchronousSnapshots = useLegacySynchronousSnapshots;\n+\n+\t\tthis.timerServices = new HashMap<>();\n+\t}\n+\n+\t/**\n+\t * A factory method for creating the {@link InternalTimeServiceManagerImpl}.\n+\t *\n+\t * <p><b>IMPORTANT:</b> Keep in sync with {@link InternalTimeServiceManager.Provider}.\n+\t */\n+\tpublic static <K> InternalTimeServiceManagerImpl<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {\n+\n+\t\tif (keyedStatedBackend == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tfinal KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange();\n+\t\tfinal boolean requiresSnapshotLegacyTimers = keyedStatedBackend instanceof AbstractKeyedStateBackend &&\n+\t\t\t((AbstractKeyedStateBackend<K>) keyedStatedBackend).requiresLegacySynchronousTimerSnapshots();\n+\n+\t\tfinal InternalTimeServiceManagerImpl<K> timeServiceManager = new InternalTimeServiceManagerImpl<>(\n+\t\t\tkeyGroupRange,\n+\t\t\tkeyContext,\n+\t\t\tkeyedStatedBackend,\n+\t\t\tprocessingTimeService,\n+\t\t\trequiresSnapshotLegacyTimers);\n+\n+\t\t// and then initialize the timer services\n+\t\tfor (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {\n+\t\t\tint keyGroupIdx = streamProvider.getKeyGroupId();\n+\n+\t\t\tPreconditions.checkArgument(keyGroupRange.contains(keyGroupIdx),\n+\t\t\t\t\"Key Group \" + keyGroupIdx + \" does not belong to the local range.\");\n+\n+\t\t\ttimeServiceManager.restoreStateForKeyGroup(\n+\t\t\t\tstreamProvider.getStream(),\n+\t\t\t\tkeyGroupIdx,\n+\t\t\t\tuserClassloader);\n+\t\t}\n+\n+\t\treturn timeServiceManager;\n+\t}\n+\n+\t@Override\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tcheckNotNull(keySerializer, \"Timers can only be used on keyed operators.\");\n+\n+\t\t// the following casting is to overcome type restrictions.\n+\t\tTimerSerializer<K, N> timerSerializer = new TimerSerializer<>(keySerializer, namespaceSerializer);\n+\n+\t\tInternalTimerServiceImpl<K, N> timerService = registerOrGetTimerService(name, timerSerializer);\n+\n+\t\ttimerService.startTimerService(\n+\t\t\ttimerSerializer.getKeySerializer(),\n+\t\t\ttimerSerializer.getNamespaceSerializer(),\n+\t\t\ttriggerable);\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t<N> InternalTimerServiceImpl<K, N> registerOrGetTimerService(String name, TimerSerializer<K, N> timerSerializer) {\n+\t\tInternalTimerServiceImpl<K, N> timerService = (InternalTimerServiceImpl<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\n+\t\t\ttimerService = new InternalTimerServiceImpl<>(\n+\t\t\t\tlocalKeyGroupRange,\n+\t\t\t\tkeyContext,\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\tcreateTimerPriorityQueue(PROCESSING_TIMER_PREFIX + name, timerSerializer),\n+\t\t\t\tcreateTimerPriorityQueue(EVENT_TIMER_PREFIX + name, timerSerializer));\n+\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\t\treturn timerService;\n+\t}\n+\n+\tMap<String, InternalTimerServiceImpl<K, ?>> getRegisteredTimerServices() {\n+\t\treturn Collections.unmodifiableMap(timerServices);\n+\t}\n+\n+\tprivate <N> KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> createTimerPriorityQueue(\n+\t\tString name,\n+\t\tTimerSerializer<K, N> timerSerializer) {\n+\t\treturn priorityQueueSetFactory.create(\n+\t\t\tname,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTg2MA=="}, "originalCommit": {"oid": "f296a95b73f36126203e2cbe9e6ee288227ffed2"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY1MzQ2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0MjowN1rOHXQCRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0MjowN1rOHXQCRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MjAyMw==", "bodyText": "Maybe When a timer fires the given {@link Triggerable} will be invoked..", "url": "https://github.com/apache/flink/pull/13443#discussion_r494142023", "createdAt": "2020-09-24T08:42:07Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY1NjE5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0Mjo0OFrOHXQEBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0Mjo0OFrOHXQEBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MjQ2OA==", "bodyText": "I think we don't even need to mention the relation to the operators here.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494142468", "createdAt": "2020-09-24T08:42:48Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY1ODQ4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0MzoyNFrOHXQFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0MzoyNFrOHXQFbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MjgzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n          \n          \n            \n            \t * potentially firing the event time timers.\n          \n          \n            \n            \t * Advances the Watermark of all managed {@link InternalTimerService timer services},\n          \n          \n            \n            \t * potentially firing event time timers.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494142830", "createdAt": "2020-09-24T08:43:24Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */\n+\t<N> InternalTimerService<N> getInternalTimerService(\n+\t\tString name,\n+\t\tTypeSerializer<K> keySerializer,\n+\t\tTypeSerializer<N> namespaceSerializer,\n+\t\tTriggerable<K, N> triggerable);\n+\n+\t/**\n+\t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n+\t * potentially firing the event time timers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY2MTM1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NDoxNVrOHXQHTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NDoxNVrOHXQHTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MzMxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Snapshots the timers in the keyed state.\n          \n          \n            \n            \t * Snapshots the timers to keyed state.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494143310", "createdAt": "2020-09-24T08:44:15Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */\n+\t<N> InternalTimerService<N> getInternalTimerService(\n+\t\tString name,\n+\t\tTypeSerializer<K> keySerializer,\n+\t\tTypeSerializer<N> namespaceSerializer,\n+\t\tTriggerable<K, N> triggerable);\n+\n+\t/**\n+\t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n+\t * potentially firing the event time timers.\n+\t */\n+\tvoid advanceWatermark(Watermark watermark) throws Exception;\n+\n+\t/**\n+\t * Snapshots the timers in the keyed state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY2MjQ0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NDozNVrOHXQICg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NDozNVrOHXQICg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MzQ5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/**\n          \n          \n            \n            \t * A provider pattern for creating an instance of a {@link InternalTimeServiceManager}.\n          \n          \n            \n            \t * Allows substituting the manager that will be used in the runtime.\n          \n          \n            \n            \t */\n          \n          \n            \n            \t/**\n          \n          \n            \n            \t * A provider pattern for creating an instance of a {@link InternalTimeServiceManager}.\n          \n          \n            \n            \t * Allows substituting the manager that will be used at runtime.\n          \n          \n            \n            \t */", "url": "https://github.com/apache/flink/pull/13443#discussion_r494143498", "createdAt": "2020-09-24T08:44:35Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManager.java", "diffHunk": "@@ -19,214 +19,62 @@\n package org.apache.flink.streaming.api.operators;\n \n import org.apache.flink.annotation.Internal;\n-import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n-import org.apache.flink.core.memory.DataOutputView;\n-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n-import org.apache.flink.runtime.state.KeyGroupRange;\n-import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n-import org.apache.flink.runtime.state.KeyGroupsList;\n-import org.apache.flink.runtime.state.KeyedStateBackend;\n-import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n-import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n import org.apache.flink.runtime.state.StateSnapshotContext;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n-import org.apache.flink.util.Preconditions;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n  * An entity keeping all the time-related services available to all operators extending the\n- * {@link AbstractStreamOperator}. Right now, this is only a\n- * {@link InternalTimerServiceImpl timer services}.\n+ * {@link AbstractStreamOperator} or {@link AbstractStreamOperatorV2}.\n  *\n  * <b>NOTE:</b> These services are only available to keyed operators.\n  *\n  * @param <K> The type of keys used for the timers and the registry.\n  */\n @Internal\n-public class InternalTimeServiceManager<K> {\n-\tprotected static final Logger LOG = LoggerFactory.getLogger(InternalTimeServiceManager.class);\n-\n-\t@VisibleForTesting\n-\tstatic final String TIMER_STATE_PREFIX = \"_timer_state\";\n-\t@VisibleForTesting\n-\tstatic final String PROCESSING_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/processing_\";\n-\t@VisibleForTesting\n-\tstatic final String EVENT_TIMER_PREFIX = TIMER_STATE_PREFIX + \"/event_\";\n-\n-\tprivate final KeyGroupRange localKeyGroupRange;\n-\tprivate final KeyContext keyContext;\n-\n-\tprivate final PriorityQueueSetFactory priorityQueueSetFactory;\n-\tprivate final ProcessingTimeService processingTimeService;\n-\n-\tprivate final Map<String, InternalTimerServiceImpl<K, ?>> timerServices;\n-\n-\tprivate final boolean useLegacySynchronousSnapshots;\n-\n-\tInternalTimeServiceManager(\n-\t\t\tKeyGroupRange localKeyGroupRange,\n+public interface InternalTimeServiceManager<K> {\n+\t/**\n+\t * Creates an {@link InternalTimerService} for handling a group of timers identified by\n+\t * the given {@code name}. The timers are scoped to a key and namespace.\n+\t *\n+\t * <p>When the timer is due it will call the given {@link Triggerable}.\n+\t */\n+\t<N> InternalTimerService<N> getInternalTimerService(\n+\t\tString name,\n+\t\tTypeSerializer<K> keySerializer,\n+\t\tTypeSerializer<N> namespaceSerializer,\n+\t\tTriggerable<K, N> triggerable);\n+\n+\t/**\n+\t * It advances the Watermark of all managed {@link InternalTimerService timer services},\n+\t * potentially firing the event time timers.\n+\t */\n+\tvoid advanceWatermark(Watermark watermark) throws Exception;\n+\n+\t/**\n+\t * Snapshots the timers in the keyed state.\n+\t *\n+\t * <p><b>TODO:</b> This can be removed once heap-based timers are integrated with RocksDB\n+\t * incremental snapshots.\n+\t */\n+\tvoid snapshotState(\n+\t\tStateSnapshotContext context,\n+\t\tString operatorName) throws Exception;\n+\n+\t/**\n+\t * A provider pattern for creating an instance of a {@link InternalTimeServiceManager}.\n+\t * Allows substituting the manager that will be used in the runtime.\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjY2ODU5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NTo1OVrOHXQLzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwODo0NTo1OVrOHXQLzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0NDQ2MA==", "bodyText": "Here I also think we don't need to mention the operators.", "url": "https://github.com/apache/flink/pull/13443#discussion_r494144460", "createdAt": "2020-09-24T08:45:59Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InternalTimeServiceManagerImpl.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;\n+import org.apache.flink.runtime.state.AbstractKeyedStateBackend;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.KeyGroupsList;\n+import org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream;\n+import org.apache.flink.runtime.state.PriorityQueueSetFactory;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An entity keeping all the time-related services available to all operators extending the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4542d771f6e20366b3937386707e2774c5a316d1"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 316, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}