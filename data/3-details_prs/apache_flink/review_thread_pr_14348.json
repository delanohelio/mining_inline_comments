{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1MTg0Nzc4", "number": 14348, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzo1Nzo1NVrOFC8A5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo1OTo0NVrOFGrC3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjI0NzQyOnYy", "diffSide": "LEFT", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMzo1Nzo1NVrOICV6Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzo1Nzo0MVrOIF9mRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNzAzNA==", "bodyText": "Drawback of removing such timeout is, that if there are multiple deadlocks in single azure build, test level timeout would show all of them. Azure level would show just the first one. Secondly won't the Azure level timeout would take longer to kick in?\nI'm not saying I'm strictly against removing it. But I'm just pointing this out. Having test level timeout is also sometimes annoying during debugging, so all in all I'm +/- 0 for this change.", "url": "https://github.com/apache/flink/pull/14348#discussion_r539327034", "createdAt": "2020-12-09T13:57:55Z", "author": {"login": "pnowojski"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -103,11 +101,6 @@\n \t@Rule\n \tpublic final TemporaryFolder temp = new TemporaryFolder();\n \n-\t@Rule\n-\tpublic final Timeout timeout = Timeout.builder()\n-\t\t.withTimeout(300, TimeUnit.SECONDS)\n-\t\t.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyMzAxMw==", "bodyText": "Yes, that was the reason why I added it initially. But we then have a timeout rule which prints the stack traces (just what JUnit5 does).", "url": "https://github.com/apache/flink/pull/14348#discussion_r543123013", "createdAt": "2020-12-15T07:57:41Z", "author": {"login": "AHeise"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -103,11 +101,6 @@\n \t@Rule\n \tpublic final TemporaryFolder temp = new TemporaryFolder();\n \n-\t@Rule\n-\tpublic final Timeout timeout = Timeout.builder()\n-\t\t.withTimeout(300, TimeUnit.SECONDS)\n-\t\t.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNzAzNA=="}, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjI3ODA1OnYy", "diffSide": "RIGHT", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDowMzo1MVrOICWMZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwOTo0ODozOVrOIGCEsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA==", "bodyText": "Simplify to just Thread.sleep(1)?", "url": "https://github.com/apache/flink/pull/14348#discussion_r539331684", "createdAt": "2020-12-09T14:03:51Z", "author": {"login": "pnowojski"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "diffHunk": "@@ -321,7 +321,7 @@ public void invoke(Long value, Context context) throws Exception {\n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n \t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(0, 100_000);\n+\t\t\t\t\tThread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzNDUyOA==", "bodyText": "With modified Thread.sleep() I presume CPU usage went down, right?\nBut what about test duration? Has it increased? If so maybe\nif (random.nextInt(100) == 42) {\n\tThread.sleep(1);\n}\n\nis better?\nNote that previous Thread.sleep(0, 100_000); was basically an equivalent of Thread.sleep(0); which in turn was burning 100% cpu. In other words\nif (random() % 100 == 0) {\n  Thread.sleep(1);\n}\n\nworks usually much better and more like you would be expecting compared to\nThread.sleep(0, 100_000);\n\nwhich is for the most purposes just broken and not sleeping at all.", "url": "https://github.com/apache/flink/pull/14348#discussion_r539334528", "createdAt": "2020-12-09T14:07:33Z", "author": {"login": "pnowojski"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "diffHunk": "@@ -321,7 +321,7 @@ public void invoke(Long value, Context context) throws Exception {\n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n \t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(0, 100_000);\n+\t\t\t\t\tThread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNDIzOA==", "bodyText": "Test duration was lower altogether because of the source throttling. In the worst case, with this change, a checkpoint needs 100+100 ms compared to the ideal time of 100 ms. But since the test is much more resource friendly now, it was effectively lower on my 8-core machine.\nThe issue with your proposition is now that there may be runs without any backpressure, which may or may not be beneficial.", "url": "https://github.com/apache/flink/pull/14348#discussion_r543124238", "createdAt": "2020-12-15T08:00:03Z", "author": {"login": "AHeise"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "diffHunk": "@@ -321,7 +321,7 @@ public void invoke(Long value, Context context) throws Exception {\n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n \t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(0, 100_000);\n+\t\t\t\t\tThread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NjMzOQ==", "bodyText": "Err, I meant to say that two instances of backpressure may not occur that I like to see covered:\n\nBackpressure results in full buffers to be snapshotted and restored. If we just accumulate 100 record, then with the current record size and the min buffer size (4kb), it's likely that only a few bytes are snapshotted and restored and also only individual buffers and not multiples. So, we may never see in the ITCase if multiple buffers are snapshotted/recovered at all and in the correct order.\nConsequently, we may also not see backpressure in all exchanges, but just the last exchange. But I think it's important to cover all exchanges to test the different kinds of recovery, especially during rescaling (to come). It's also good to cover backpressure being propagated to the source ultimately.", "url": "https://github.com/apache/flink/pull/14348#discussion_r543196339", "createdAt": "2020-12-15T09:48:39Z", "author": {"login": "AHeise"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "diffHunk": "@@ -321,7 +321,7 @@ public void invoke(Long value, Context context) throws Exception {\n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n \t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(0, 100_000);\n+\t\t\t\t\tThread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}, "originalCommit": {"oid": "a64501c9e87e70f3093abc558d57d370e0645e8c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTQxMDIyOnYy", "diffSide": "RIGHT", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo1OTo0NVrOIHyVhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNToyNjoyNFrOIH68lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNTY1NQ==", "bodyText": "why ~?", "url": "https://github.com/apache/flink/pull/14348#discussion_r545035655", "createdAt": "2020-12-17T11:59:45Z", "author": {"login": "pnowojski"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -219,14 +219,17 @@ public InputStatus pollNext(ReaderOutput<Long> output) throws InterruptedExcepti\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n \t\t\t\tthrottle = split.numCompletedCheckpoints >= minCheckpoints;\n-\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (? attempt)\", split, split.nextNumber % split.increment);\n+\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (~{} attempt)\", split, split.nextNumber % split.increment, numRestarts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5ff197d8a692bf2baa24e47c2548dc1be956ac"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE3NjcyNQ==", "bodyText": "Good catch. It was approximate in the first version, but now it's not anymore.", "url": "https://github.com/apache/flink/pull/14348#discussion_r545176725", "createdAt": "2020-12-17T15:26:24Z", "author": {"login": "AHeise"}, "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -219,14 +219,17 @@ public InputStatus pollNext(ReaderOutput<Long> output) throws InterruptedExcepti\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n \t\t\t\tthrottle = split.numCompletedCheckpoints >= minCheckpoints;\n-\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (? attempt)\", split, split.nextNumber % split.increment);\n+\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (~{} attempt)\", split, split.nextNumber % split.increment, numRestarts);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNTY1NQ=="}, "originalCommit": {"oid": "7d5ff197d8a692bf2baa24e47c2548dc1be956ac"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4606, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}