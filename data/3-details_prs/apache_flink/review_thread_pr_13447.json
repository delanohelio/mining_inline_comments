{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjYyODQx", "number": 13447, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMjo1Mjo1OFrOEmEZeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoxMTowMlrOEmE4JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzUzNDAwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingResultPartition.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMjo1Mjo1OFrOHV4gvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo1MzozMFrOHWovJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwODAzMA==", "bodyText": "Just to double check: We do not want this to be the default behavior in BufferWritingResultPartition, because this would finish the partial buffers for streaming/pipelined cases as well, which we don't want.\nI think this logic may be confusing for future developers. What we could do is the following:\n\nBufferWritingResultPartition leaves the void flush(int) and flushAll() methods abstract.\nInstead it offers protected void flushSubpartition(int partition, boolean finishProducers) and protected void flushAllSubpartitions(boolean finishProducers). That makes it clear that there is a producer that may or may not be finished, so the caller has to be aware of this behavior.\nThe BoundedBlockingResultPartition then implements flushAll() { flushAllSubpartitions(true); } and the PipelinedResultPartition implements flushAll() { flushAllSubpartitions(false); }", "url": "https://github.com/apache/flink/pull/13447#discussion_r492708030", "createdAt": "2020-09-22T12:52:58Z", "author": {"login": "StephanEwen"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingResultPartition.java", "diffHunk": "@@ -63,6 +63,22 @@ public BoundedBlockingResultPartition(\n \t\t\tbufferPoolFactory);\n \t}\n \n+\t@Override\n+\tpublic void flush(int targetSubpartition) {\n+\t\tfinishBroadcastBufferBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f98909f2c50173758f29167fcd176010a937d284"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1OTgzNg==", "bodyText": "This logic is already in BoundedBlockingResultPartition and should have no impact on streaming/pipelined cases. I guess the source file name is misread?", "url": "https://github.com/apache/flink/pull/13447#discussion_r493159836", "createdAt": "2020-09-23T02:27:31Z", "author": {"login": "wsry"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingResultPartition.java", "diffHunk": "@@ -63,6 +63,22 @@ public BoundedBlockingResultPartition(\n \t\t\tbufferPoolFactory);\n \t}\n \n+\t@Override\n+\tpublic void flush(int targetSubpartition) {\n+\t\tfinishBroadcastBufferBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwODAzMA=="}, "originalCommit": {"oid": "f98909f2c50173758f29167fcd176010a937d284"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyOTE4Mg==", "bodyText": "Maybe it was like that before, but we can still make it more intuitive to understand.", "url": "https://github.com/apache/flink/pull/13447#discussion_r493429182", "createdAt": "2020-09-23T10:34:39Z", "author": {"login": "StephanEwen"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingResultPartition.java", "diffHunk": "@@ -63,6 +63,22 @@ public BoundedBlockingResultPartition(\n \t\t\tbufferPoolFactory);\n \t}\n \n+\t@Override\n+\tpublic void flush(int targetSubpartition) {\n+\t\tfinishBroadcastBufferBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwODAzMA=="}, "originalCommit": {"oid": "f98909f2c50173758f29167fcd176010a937d284"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5ODE1MQ==", "bodyText": "Fixed", "url": "https://github.com/apache/flink/pull/13447#discussion_r493498151", "createdAt": "2020-09-23T11:53:30Z", "author": {"login": "wsry"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingResultPartition.java", "diffHunk": "@@ -63,6 +63,22 @@ public BoundedBlockingResultPartition(\n \t\t\tbufferPoolFactory);\n \t}\n \n+\t@Override\n+\tpublic void flush(int targetSubpartition) {\n+\t\tfinishBroadcastBufferBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwODAzMA=="}, "originalCommit": {"oid": "f98909f2c50173758f29167fcd176010a937d284"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzYxMjUyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoxMTowMlrOHV5Qvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToyMToxMVrOHWnCLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyMDMxOQ==", "bodyText": "It would be really great if this method were not public. Ideally we can remove this completely, because all tests that use this bypass some crucial logic of this class and may result in meaningless tests.\nThis method is used in three places:\n\nThe occurrence in SingleInputGateTest can be replaced with emitting a record.\nThe occurrence in TestPartitionProducer could be removed by adjusting TestProducerSource to produce ByteBuffer instead of BufferConsumer, which looks like a nice change that might even simplify things.\nIf the change for PartitionTestUtils could in theory be kept, and the visibility of the method be reduced to package-private.", "url": "https://github.com/apache/flink/pull/13447#discussion_r492720319", "createdAt": "2020-09-22T13:11:02Z", "author": {"login": "StephanEwen"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java", "diffHunk": "@@ -109,89 +94,58 @@\n \t\t}\n \t}\n \n-\tprotected void emit(T record, int targetChannel) throws IOException, InterruptedException {\n+\tprotected void emit(T record, int targetSubpartition) throws IOException {\n \t\tcheckErroneous();\n \n-\t\tserializer.serializeRecord(record);\n-\n-\t\t// Make sure we don't hold onto the large intermediate serialization buffer for too long\n-\t\tcopyFromSerializerToTargetChannel(targetChannel);\n-\t}\n-\n-\t/**\n-\t * @param targetChannel\n-\t * @return <tt>true</tt> if the intermediate serialization buffer should be pruned\n-\t */\n-\tprotected boolean copyFromSerializerToTargetChannel(int targetChannel) throws IOException, InterruptedException {\n-\t\t// We should reset the initial position of the intermediate serialization buffer before\n-\t\t// copying, so the serialization results can be copied to multiple target buffers.\n-\t\tserializer.reset();\n-\n-\t\tboolean pruneTriggered = false;\n-\t\tBufferBuilder bufferBuilder = getBufferBuilder(targetChannel);\n-\t\tSerializationResult result = serializer.copyToBufferBuilder(bufferBuilder);\n-\t\twhile (result.isFullBuffer()) {\n-\t\t\tfinishBufferBuilder(bufferBuilder);\n-\n-\t\t\t// If this was a full record, we are done. Not breaking out of the loop at this point\n-\t\t\t// will lead to another buffer request before breaking out (that would not be a\n-\t\t\t// problem per se, but it can lead to stalls in the pipeline).\n-\t\t\tif (result.isFullRecord()) {\n-\t\t\t\tpruneTriggered = true;\n-\t\t\t\temptyCurrentBufferBuilder(targetChannel);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n-\t\t\tbufferBuilder = requestNewBufferBuilder(targetChannel);\n-\t\t\tresult = serializer.copyToBufferBuilder(bufferBuilder);\n-\t\t}\n-\t\tcheckState(!serializer.hasSerializedData(), \"All data should be written at once\");\n+\t\ttargetPartition.emitRecord(serializeRecord(serializer, record), targetSubpartition);\n \n \t\tif (flushAlways) {\n-\t\t\tflushTargetPartition(targetChannel);\n+\t\t\ttargetPartition.flush(targetSubpartition);\n \t\t}\n-\t\treturn pruneTriggered;\n \t}\n \n \tpublic void broadcastEvent(AbstractEvent event) throws IOException {\n \t\tbroadcastEvent(event, false);\n \t}\n \n \tpublic void broadcastEvent(AbstractEvent event, boolean isPriorityEvent) throws IOException {\n-\t\ttry (BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(event)) {\n-\t\t\tfor (int targetChannel = 0; targetChannel < numberOfChannels; targetChannel++) {\n-\t\t\t\ttryFinishCurrentBufferBuilder(targetChannel);\n-\n-\t\t\t\t// Retain the buffer so that it can be recycled by each channel of targetPartition\n-\t\t\t\ttargetPartition.addBufferConsumer(eventBufferConsumer.copy(), targetChannel, isPriorityEvent);\n-\t\t\t}\n+\t\ttargetPartition.broadcastEvent(event, isPriorityEvent);\n \n-\t\t\tif (flushAlways) {\n-\t\t\t\tflushAll();\n-\t\t\t}\n+\t\tif (flushAlways) {\n+\t\t\tflushAll();\n \t\t}\n \t}\n \n-\tpublic void flushAll() {\n-\t\ttargetPartition.flushAll();\n+\t@VisibleForTesting\n+\tpublic static ByteBuffer serializeRecord(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f95779273fd0c8ca9ec4eeaf8a4dc232ecb6788a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3MDI1Mg==", "bodyText": "I  removed BufferWritingResultPartition#addBufferConsumer completely.", "url": "https://github.com/apache/flink/pull/13447#discussion_r493470252", "createdAt": "2020-09-23T11:21:11Z", "author": {"login": "wsry"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java", "diffHunk": "@@ -109,89 +94,58 @@\n \t\t}\n \t}\n \n-\tprotected void emit(T record, int targetChannel) throws IOException, InterruptedException {\n+\tprotected void emit(T record, int targetSubpartition) throws IOException {\n \t\tcheckErroneous();\n \n-\t\tserializer.serializeRecord(record);\n-\n-\t\t// Make sure we don't hold onto the large intermediate serialization buffer for too long\n-\t\tcopyFromSerializerToTargetChannel(targetChannel);\n-\t}\n-\n-\t/**\n-\t * @param targetChannel\n-\t * @return <tt>true</tt> if the intermediate serialization buffer should be pruned\n-\t */\n-\tprotected boolean copyFromSerializerToTargetChannel(int targetChannel) throws IOException, InterruptedException {\n-\t\t// We should reset the initial position of the intermediate serialization buffer before\n-\t\t// copying, so the serialization results can be copied to multiple target buffers.\n-\t\tserializer.reset();\n-\n-\t\tboolean pruneTriggered = false;\n-\t\tBufferBuilder bufferBuilder = getBufferBuilder(targetChannel);\n-\t\tSerializationResult result = serializer.copyToBufferBuilder(bufferBuilder);\n-\t\twhile (result.isFullBuffer()) {\n-\t\t\tfinishBufferBuilder(bufferBuilder);\n-\n-\t\t\t// If this was a full record, we are done. Not breaking out of the loop at this point\n-\t\t\t// will lead to another buffer request before breaking out (that would not be a\n-\t\t\t// problem per se, but it can lead to stalls in the pipeline).\n-\t\t\tif (result.isFullRecord()) {\n-\t\t\t\tpruneTriggered = true;\n-\t\t\t\temptyCurrentBufferBuilder(targetChannel);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n-\t\t\tbufferBuilder = requestNewBufferBuilder(targetChannel);\n-\t\t\tresult = serializer.copyToBufferBuilder(bufferBuilder);\n-\t\t}\n-\t\tcheckState(!serializer.hasSerializedData(), \"All data should be written at once\");\n+\t\ttargetPartition.emitRecord(serializeRecord(serializer, record), targetSubpartition);\n \n \t\tif (flushAlways) {\n-\t\t\tflushTargetPartition(targetChannel);\n+\t\t\ttargetPartition.flush(targetSubpartition);\n \t\t}\n-\t\treturn pruneTriggered;\n \t}\n \n \tpublic void broadcastEvent(AbstractEvent event) throws IOException {\n \t\tbroadcastEvent(event, false);\n \t}\n \n \tpublic void broadcastEvent(AbstractEvent event, boolean isPriorityEvent) throws IOException {\n-\t\ttry (BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(event)) {\n-\t\t\tfor (int targetChannel = 0; targetChannel < numberOfChannels; targetChannel++) {\n-\t\t\t\ttryFinishCurrentBufferBuilder(targetChannel);\n-\n-\t\t\t\t// Retain the buffer so that it can be recycled by each channel of targetPartition\n-\t\t\t\ttargetPartition.addBufferConsumer(eventBufferConsumer.copy(), targetChannel, isPriorityEvent);\n-\t\t\t}\n+\t\ttargetPartition.broadcastEvent(event, isPriorityEvent);\n \n-\t\t\tif (flushAlways) {\n-\t\t\t\tflushAll();\n-\t\t\t}\n+\t\tif (flushAlways) {\n+\t\t\tflushAll();\n \t\t}\n \t}\n \n-\tpublic void flushAll() {\n-\t\ttargetPartition.flushAll();\n+\t@VisibleForTesting\n+\tpublic static ByteBuffer serializeRecord(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyMDMxOQ=="}, "originalCommit": {"oid": "f95779273fd0c8ca9ec4eeaf8a4dc232ecb6788a"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 319, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}