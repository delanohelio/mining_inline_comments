{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3NDM1NDYw", "number": 13722, "title": "[FLINK-19636][coordination] Add DeclarativeSlotPool ", "bodyText": "Adds the DeclarativeSlotPool, a slot pool supporting declarative resource management.\nThis pool will for the time being not be used directly, as this will require proper integration into the scheduler. Instead, a wrapper will be added in FLINK-19314 that bridges the existing SlotRequest-based protocol to the declarative one.\nDeclarativeSlotPool\nThis pool no longer accepts slot requests but only in-/decrements to the requirements, which it accumulators, with the resulting total requirements being announced to the ResourceManager through a listener interface.\nSlots that are offered by TaskExecutors are matched against these requirements; any slot not matching any requirement will be rejected.\nThe Scheduler then can make use of these slots by iterating over the free slots returned by the pool and reserving them.\nThe slot will remain reserved until it is either\na) freed by the Scheduler, in which case it will remain in the pool for future use\nb) explicitly released, usually due to a failed allocated or TaskExecutor shutting down.\nFreed slots remain in the pool so long as they correspond to a requirement; a slot that has been free for the idleTimeout and is required will be released. This action is periodically triggered from the outside.\nAs mentioned above, when slots are offered to the SlotPool they are matched against the declared requirements to figure out whether we actually need the slot.\nHowever, this mapping between slots and the fulfilled requirement is mostly theoretical; the scheduler is free to use a slot to fulfill another requirement, e.g., because the locality of the slot makes it a desirable choice, despite potentially wasting resources.\nTo prevent deadlocks where the scheduler reserves slots in such a way that the requirements could no longer be fulfilled, the SlotPool automatically adjusts the requirements.\nAs an example, assume we have 2 types of resource profiles (small/large), where the large one can also be used for the small profile.\nThe job requires 1 of each, the slot pool is offered one of each, and it does a perfect match between the offered slots and requirements:\nRequirements:\nlarge: 1\nsmall: 1\n\nMapping:\nlargeSlot <-> largeRequirement\nsmallSlot <-> smallRequirement\n\nThe scheduler may now decide to use the large slot to fulfill the small requirement. Without any further action, the job would not able to run since it is missing a large slot.\nWe prevent this by adjusting the requirements such that we need 1 more large slot (since we used up the other one) and one less small slot (since we fulfilled this requirement with the large one). The currently allocated small slot is hence no longer needed, and could be released:\nRequirements:\nlarge: 2\nsmall: 0\n\nMapping:\nlargeSlot <-> smallRequirement\n\nOnce the second large slot is allocated and offered to the pool it will be matched against the outstanding large requirement, and the slot can start running.\nResourceCounter\nThe ResourceCounter is an immutable version of the existing org.apache.flink.runtime.slots.ResourceCounter, it being immutable due to being exposed at various points in the API.\nAutoRequirementDecrementingSlotPoolWrapper\nThe current resource allocation protocol will be bridged to the declarative one by mapping SlotRequests to requirement increases, and slot freeing/releases to requirement reductions.\nThe increments will be done explicitly in the wrapper that we'll introduce in FLINK-19314, whereas the reductions will be handled in the AutoRequirementDecrementingSlotPoolWrapper.", "createdAt": "2020-10-21T10:41:25Z", "url": "https://github.com/apache/flink/pull/13722", "merged": true, "mergeCommit": {"oid": "c1b96de2702098a93ac210e8983bb1b7df3097c2"}, "closed": true, "closedAt": "2020-12-03T09:42:57Z", "author": {"login": "zentol"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUuQSwgFqTUxMzc1MTgzNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdiV3regBqjQwNjQ1NjQ2ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzUxODM2", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513751836", "createdAt": "2020-10-21T14:29:09Z", "commit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOTowOVrOHlvdgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOTowOVrOHlvdgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNjk2MQ==", "bodyText": "Optional is unnecessary; the returned ResourceCounter could just be empty", "url": "https://github.com/apache/flink/pull/13722#discussion_r509336961", "createdAt": "2020-10-21T14:29:09Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot\n+\t * with allocationId exists, then the call is ignored.\n+\t *\n+\t * <p>Whether the freed slot is returned to the owning TaskExecutor is implementation\n+\t * dependent.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to release\n+\t * @param cause cause for releasing the slot; can be {@code null}\n+\t * @param currentTime currentTime when the slot was released\n+\t * @return info about freed slot, if a reserved slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzUxOTU0", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513751954", "createdAt": "2020-10-21T14:29:15Z", "commit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOToxNlrOHlvd3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOToxNlrOHlvd3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNzA1Mg==", "bodyText": "same as above", "url": "https://github.com/apache/flink/pull/13722#discussion_r509337052", "createdAt": "2020-10-21T14:29:16Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot\n+\t * with allocationId exists, then the call is ignored.\n+\t *\n+\t * <p>Whether the freed slot is returned to the owning TaskExecutor is implementation\n+\t * dependent.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to release\n+\t * @param cause cause for releasing the slot; can be {@code null}\n+\t * @param currentTime currentTime when the slot was released\n+\t * @return info about freed slot, if a reserved slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime);\n+\n+\t/**\n+\t * Releases all slots belonging to the owning TaskExecutor if it has been registered.\n+\t *\n+\t * @param owner owner identifying the owning TaskExecutor\n+\t * @param cause cause for failing the slots\n+\t * @return info about released slot\n+\t */\n+\tResourceCounter releaseSlots(ResourceID owner, Exception cause);\n+\n+\t/**\n+\t * Releases the slot specified by allocationId if one exists.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to fail\n+\t * @param cause cause for failing the slot\n+\t * @return info about released slot, if a slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzUyNjcx", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513752671", "createdAt": "2020-10-21T14:29:52Z", "commit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOTo1MlrOHlvf8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDoyOTo1MlrOHlvf8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNzU4Nw==", "bodyText": "It could make sense to instead pass a Collection, to stay in sync with the RM side of things", "url": "https://github.com/apache/flink/pull/13722#discussion_r509337587", "createdAt": "2020-10-21T14:29:52Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzU0ODQ5", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513754849", "createdAt": "2020-10-21T14:31:46Z", "commit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMTo0NlrOHlvmvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMTo0NlrOHlvmvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTMyNw==", "bodyText": "I would prefer it we would use the mutable ResourceCounter implementation here so the fields can be final, but as long as it's exposed in the API this would just create confusion.", "url": "https://github.com/apache/flink/pull/13722#discussion_r509339327", "createdAt": "2020-10-21T14:31:46Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzU1MzA0", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513755304", "createdAt": "2020-10-21T14:32:10Z", "commit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMjoxMFrOHlvoCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMjoxMFrOHlvoCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTY1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t//order?", "url": "https://github.com/apache/flink/pull/13722#discussion_r509339659", "createdAt": "2020-10-21T14:32:10Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tfinal Collection<SlotOfferMatching> slotOfferMatchings = matchOffersWithOutstandingRequirements(Collections.singleton(allocatedSlotToSlotOffer(allocatedSlot)));\n+\n+\t\tfor (SlotOfferMatching slotOfferMatching : slotOfferMatchings) {\n+\t\t\tif (slotOfferMatching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = slotOfferMatching.getMatching().get();\n+\n+\t\t\t\tupdateSlotToRequirementProfileMapping(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}\n+\n+\t@Nonnull\n+\tprivate SlotOffer allocatedSlotToSlotOffer(AllocatedSlot allocatedSlot) {\n+\t\treturn new SlotOffer(allocatedSlot.getAllocationId(), allocatedSlot.getPhysicalSlotNumber(), allocatedSlot.getResourceProfile());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tfinal Collection<AllocatedSlot> removedSlots = slotPool.removeSlots(owner);\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = getFulfilledRequirements(removedSlots);\n+\n+\t\treleasePayload(removedSlots, cause);\n+\t\treleaseSlots(removedSlots, cause);\n+\n+\t\treturn previouslyFulfilledRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(allocationId);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = removedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\tremovedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\treleaseSlots(Collections.singleton(allocatedSlot), cause);\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void releasePayload(Iterable<? extends AllocatedSlot> allocatedSlots, Throwable cause) {\n+\t\tfor (AllocatedSlot allocatedSlot : allocatedSlots) {\n+\t\t\tallocatedSlot.releasePayload(cause);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseIdleSlots(long currentTimeMillis) {\n+\t\tfinal Collection<AllocatedSlotPool.FreeSlotInfo> freeSlotsInformation = slotPool.getFreeSlotsInformation();\n+\n+\t\t//order?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 351}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzU2NjU0", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513756654", "createdAt": "2020-10-21T14:33:20Z", "commit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMzoyMFrOHlvr-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozMzoyMFrOHlvr-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MDY2NA==", "bodyText": "we could probably combine this loop with the matching of requirements", "url": "https://github.com/apache/flink/pull/13722#discussion_r509340664", "createdAt": "2020-10-21T14:33:20Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzU4Njc4", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513758678", "createdAt": "2020-10-21T14:35:11Z", "commit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozNToxMlrOHlvyHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozNToxMlrOHlvyHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ==", "bodyText": "It may make sense to replace this with a JobScopedResourceTracker to keep the matching logic in sync with the RM side.", "url": "https://github.com/apache/flink/pull/13722#discussion_r509342239", "createdAt": "2020-10-21T14:35:12Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzYxNDYw", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-513761460", "createdAt": "2020-10-21T14:37:44Z", "commit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozNzo0NFrOHlv6kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDozNzo0NFrOHlv6kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0NDQwMw==", "bodyText": "this could be skipped if the profiles match", "url": "https://github.com/apache/flink/pull/13722#discussion_r509344403", "createdAt": "2020-10-21T14:37:44Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 261}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODg5MjQ5", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-516889249", "createdAt": "2020-10-26T15:20:51Z", "commit": {"oid": "e378973cf6cb21f9da36c6fa9d9b9a7d326c2185"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMDo1MlrOHoUtlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMDo1MlrOHoUtlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NDQzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n          \n          \n            \n            \t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was", "url": "https://github.com/apache/flink/pull/13722#discussion_r512044439", "createdAt": "2020-10-26T15:20:52Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e378973cf6cb21f9da36c6fa9d9b9a7d326c2185"}, "originalPosition": 258}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDQ3NzE3", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-518047717", "createdAt": "2020-10-27T19:05:29Z", "commit": {"oid": "fa82dd23b082fc0b4d82de8217831b6ec7624947"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTowNTozMFrOHpMR_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTowNTozMFrOHpMR_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1NDg3Nw==", "bodyText": "It may actually be better to inline and decreases into the wrapper introduced in FLINK-19314; as it is we're just spreading things around, and create weird inconsistencies where the wrapper does decrease requirements when releasing a pending requests, but does not decrease requirements when releasing an allocated slot.", "url": "https://github.com/apache/flink/pull/13722#discussion_r512954877", "createdAt": "2020-10-27T19:05:30Z", "author": {"login": "zentol"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa82dd23b082fc0b4d82de8217831b6ec7624947"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MjY1NjQx", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-516265641", "createdAt": "2020-10-24T09:59:42Z", "commit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTo1OTo0MlrOHnrwpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjowNTo0NlrOHsK63Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MzQ3Nw==", "bodyText": "Hmm, the JobScopedResourceTracker does a bit more than this simple map here.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511373477", "createdAt": "2020-10-24T09:59:42Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ=="}, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MzU5MQ==", "bodyText": "But I agree that the matching should be in sync between the RM and the JM side.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511373591", "createdAt": "2020-10-24T10:00:00Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ=="}, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NDM5OQ==", "bodyText": "I have to admit that I prefer it as is because of the following reasons: Making the ResourceCounter immutable simplifies its operations (e.g. adding or subtracting will result into a new value). Moreover, in this class it is correctly shown that the totalResourceRequirements field is mutable. If it were final then it would not be obvious whether this field represents a static value or can be changed.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511374399", "createdAt": "2020-10-24T10:02:39Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTMyNw=="}, "originalCommit": {"oid": "60ab11bd57d914c712c70aab3b33181aadd1e133"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NTIwMg==", "bodyText": "one could factor this out into a separate method.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511375202", "createdAt": "2020-10-24T10:04:47Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NTc1Ng==", "bodyText": "But then, we couldn't reuse matchOffersWithOutstandingRequirements in tryToFulfillResourceRequirement.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511375756", "createdAt": "2020-10-24T10:06:18Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MDY2NA=="}, "originalCommit": {"oid": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NjA3Mw==", "bodyText": "Maybe: Could be factored out as well.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511376073", "createdAt": "2020-10-24T10:07:23Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NzMwNA==", "bodyText": "Shouldn't we also adjust unfulfilledResources here? Concretely, I think we should write unfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1); or move it out of the two branches and unify it.", "url": "https://github.com/apache/flink/pull/13722#discussion_r511377304", "createdAt": "2020-10-24T10:10:37Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3Nzk2Mw==", "bodyText": "typo: is not in line", "url": "https://github.com/apache/flink/pull/13722#discussion_r511377963", "createdAt": "2020-10-24T10:12:32Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0NTM0OQ==", "bodyText": "nit: remove \"a\"", "url": "https://github.com/apache/flink/pull/13722#discussion_r516045349", "createdAt": "2020-11-02T15:20:51Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MjQxMg==", "bodyText": "I really like to rethink whether we need this mapping in this class or whether it could live in the wrapper. It somehow feels wrong that the DefaultDeclarativeSlotPool needs to track for which ResourceProfile a given slot has been reserved.", "url": "https://github.com/apache/flink/pull/13722#discussion_r516052412", "createdAt": "2020-11-02T15:30:26Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1NjYxMg==", "bodyText": "Related to one of my previous comments: I am wondering whether this functionality is really necessary to keep in the DefaultDeclarativeSlotPool. I would hope that this is really only needed by the FutureSlotPool.", "url": "https://github.com/apache/flink/pull/13722#discussion_r516056612", "createdAt": "2020-11-02T15:36:10Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tfinal Collection<SlotOfferMatching> slotOfferMatchings = matchOffersWithOutstandingRequirements(Collections.singleton(allocatedSlotToSlotOffer(allocatedSlot)));\n+\n+\t\tfor (SlotOfferMatching slotOfferMatching : slotOfferMatchings) {\n+\t\t\tif (slotOfferMatching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = slotOfferMatching.getMatching().get();\n+\n+\t\t\t\tupdateSlotToRequirementProfileMapping(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ==", "bodyText": "Why are we decreasing the requirements if releaseSlots is called? I think this should be called if a TM's heartbeat times out.", "url": "https://github.com/apache/flink/pull/13722#discussion_r516077791", "createdAt": "2020-11-02T16:05:01Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\tbackingSlotPool.increaseResourceRequirementsBy(increment);\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(decrement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\treturn backingSlotPool.getResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime) {\n+\t\treturn backingSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, currentTime);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotInfoWithUtilization> getFreeSlotsInformation() {\n+\t\treturn backingSlotPool.getFreeSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<? extends SlotInfo> getAllSlotsInformation() {\n+\t\treturn backingSlotPool.getAllSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\treturn backingSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = backingSlotPool.freeReservedSlot(allocationId, cause, currentTime);\n+\t\tpreviouslyFulfilledRequirement\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = backingSlotPool.releaseSlots(owner, cause);\n+\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0d0cc61b72e86cdbca8f29684148e364a11240"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3ODA0Mw==", "bodyText": "Same here, shouldn't releaseSlot keep the requirements constant?", "url": "https://github.com/apache/flink/pull/13722#discussion_r516078043", "createdAt": "2020-11-02T16:05:23Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\tbackingSlotPool.increaseResourceRequirementsBy(increment);\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(decrement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\treturn backingSlotPool.getResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime) {\n+\t\treturn backingSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, currentTime);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotInfoWithUtilization> getFreeSlotsInformation() {\n+\t\treturn backingSlotPool.getFreeSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<? extends SlotInfo> getAllSlotsInformation() {\n+\t\treturn backingSlotPool.getAllSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\treturn backingSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = backingSlotPool.freeReservedSlot(allocationId, cause, currentTime);\n+\t\tpreviouslyFulfilledRequirement\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = backingSlotPool.releaseSlots(owner, cause);\n+\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirements = backingSlotPool.releaseSlot(allocationId, cause);\n+\t\tpreviouslyFulfilledRequirements\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirements;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0d0cc61b72e86cdbca8f29684148e364a11240"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3ODMwMQ==", "bodyText": "Yes, I think this might be cleaner.", "url": "https://github.com/apache/flink/pull/13722#discussion_r516078301", "createdAt": "2020-11-02T16:05:46Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1NDg3Nw=="}, "originalCommit": {"oid": "fa82dd23b082fc0b4d82de8217831b6ec7624947"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDIwODk0", "url": "https://github.com/apache/flink/pull/13722#pullrequestreview-531420894", "createdAt": "2020-11-16T15:19:58Z", "commit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNToxOTo1OFrOH0DiWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNTo0NTo0M1rOH0Exrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0NTk0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link #freeReservedSlot released}.\n          \n          \n            \n             * {@link #freeReservedSlot freed}.\n          \n      \n    \n    \n  \n\nbc release is used in the API and means that we remove the slot from the pool.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524345947", "createdAt": "2020-11-16T15:19:58Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0OTMxNA==", "bodyText": "The error message is missing.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524349314", "createdAt": "2020-11-16T15:24:27Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0OTgwNg==", "bodyText": "We could log on debug which offers are matching with which requirements.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524349806", "createdAt": "2020-11-16T15:25:00Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDI0MA==", "bodyText": "Add debug logging which tells about the requirements adjustment.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350240", "createdAt": "2020-11-16T15:25:33Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDYwOQ==", "bodyText": "Let's be consistent with the terms and use Free reserved slot {}. here.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350609", "createdAt": "2020-11-16T15:26:04Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDgxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n          \n          \n            \n            \t\tfinal Optional<AllocatedSlot> freedSlot = slotPool.freeReservedSlot(allocationId, currentTime);", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350816", "createdAt": "2020-11-16T15:26:18Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NzY4OQ==", "bodyText": "maybe log on debug the cause.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524357689", "createdAt": "2020-11-16T15:35:01Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement.orElseGet(ResourceCounter::empty);\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tmatchOfferWithOutstandingRequirements(allocatedSlotToSlotOffer(allocatedSlot), allocatedSlot.getTaskManagerLocation(), allocatedSlot.getTaskManagerGateway());\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}\n+\n+\t@Nonnull\n+\tprivate SlotOffer allocatedSlotToSlotOffer(AllocatedSlot allocatedSlot) {\n+\t\treturn new SlotOffer(allocatedSlot.getAllocationId(), allocatedSlot.getPhysicalSlotNumber(), allocatedSlot.getResourceProfile());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tfinal Collection<AllocatedSlot> removedSlots = slotPool.removeSlots(owner);\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = getFulfilledRequirements(removedSlots);\n+\n+\t\treleasePayload(removedSlots, cause);\n+\t\treleaseSlots(removedSlots, cause);\n+\n+\t\treturn previouslyFulfilledRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(allocationId);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = removedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\tremovedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\treleaseSlots(Collections.singleton(allocatedSlot), cause);\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement.orElseGet(ResourceCounter::empty);\n+\t}\n+\n+\tprivate void releasePayload(Iterable<? extends AllocatedSlot> allocatedSlots, Throwable cause) {\n+\t\tfor (AllocatedSlot allocatedSlot : allocatedSlots) {\n+\t\t\tallocatedSlot.releasePayload(cause);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseIdleSlots(long currentTimeMillis) {\n+\t\tfinal Collection<AllocatedSlotPool.FreeSlotInfo> freeSlotsInformation = slotPool.getFreeSlotsInformation();\n+\n+\t\tResourceCounter excessResources = fulfilledResourceRequirements.subtract(totalResourceRequirements);\n+\n+\t\tfinal Iterator<AllocatedSlotPool.FreeSlotInfo> freeSlotIterator = freeSlotsInformation.iterator();\n+\n+\t\tfinal Collection<AllocatedSlot> slotsToReturnToOwner = new ArrayList<>();\n+\n+\t\twhile (!excessResources.isEmpty() && freeSlotIterator.hasNext()) {\n+\t\t\tfinal AllocatedSlotPool.FreeSlotInfo idleSlot = freeSlotIterator.next();\n+\n+\t\t\tif (currentTimeMillis >= idleSlot.getFreeSince() + idleSlotTimeout.toMilliseconds()) {\n+\t\t\t\tfinal ResourceProfile matchingProfile = getMatchingResourceProfile(idleSlot.getAllocationId());\n+\n+\t\t\t\tif (excessResources.containsResource(matchingProfile)) {\n+\t\t\t\t\texcessResources = excessResources.subtract(matchingProfile, 1);\n+\t\t\t\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(idleSlot.getAllocationId());\n+\n+\t\t\t\t\tfinal AllocatedSlot allocatedSlot = removedSlot.orElseThrow(() -> new IllegalStateException(String.format(\"Could not find slot for allocation id %s.\", idleSlot.getAllocationId())));\n+\t\t\t\t\tslotsToReturnToOwner.add(allocatedSlot);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treleaseSlots(slotsToReturnToOwner, new FlinkException(\"Returning idle slots to their owners.\"));\n+\t}\n+\n+\tprivate void releaseSlots(Iterable<AllocatedSlot> slotsToReturnToOwner, Throwable cause) {\n+\t\tfor (AllocatedSlot slotToReturn : slotsToReturnToOwner) {\n+\t\t\tPreconditions.checkState(!slotToReturn.isUsed(), \"Free slot must not be used.\");\n+\n+\t\t\tLOG.info(\"Releasing slot [{}].\", slotToReturn.getAllocationId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NDk4MQ==", "bodyText": "Maybe better to call this test testReleaseSlotDecreasesFulfilledResourceRequirements.", "url": "https://github.com/apache/flink/pull/13722#discussion_r524364981", "createdAt": "2020-11-16T15:44:12Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NTMzMQ==", "bodyText": "testReleaseSlotReturnsSlot", "url": "https://github.com/apache/flink/pull/13722#discussion_r524365331", "createdAt": "2020-11-16T15:44:35Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NjE1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// the pending requirement should be fulfilled by the released slot --> rejecting new slot offers\n          \n          \n            \n            \t\t// the pending requirement should be fulfilled by the freed slot --> rejecting new slot offers", "url": "https://github.com/apache/flink/pull/13722#discussion_r524366153", "createdAt": "2020-11-16T15:45:35Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal AllocationID freedSlot = Iterables.getOnlyElement(freeSlotConsumer.drainFreedSlots());\n+\n+\t\tassertThat(freedSlot, is(physicalSlot.getAllocationId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReturnIdleSlotsAfterTimeout() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\t// decrease the resource requirements so that slots are no longer needed\n+\t\tslotPool.decreaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(freedSlots, containsInAnyOrder(acceptedSlots.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t\tassertNoAvailableAndRequiredResources(slotPool);\n+\t}\n+\n+\tprivate void assertNoAvailableAndRequiredResources(DefaultDeclarativeSlotPool slotPool) {\n+\t\tassertTrue(slotPool.getFulfilledResourceRequirements().isEmpty());\n+\t\tassertTrue(slotPool.getResourceRequirements().isEmpty());\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnlyReturnExcessIdleSlots() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal ResourceCounter requiredResources = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter excessRequirements = resourceRequirements.subtract(requiredResources);\n+\t\tslotPool.decreaseResourceRequirementsBy(excessRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(requiredResources));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter initialRequirements = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, initialRequirements, null);\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\t\tfinal PhysicalSlot newSlot = Iterables.getOnlyElement(newSlots);\n+\n+\t\tslotPool.reserveFreeSlot(newSlot.getAllocationId(), RESOURCE_PROFILE_1);\n+\t\tslotPool.freeReservedSlot(newSlot.getAllocationId(), null, 0);\n+\n+\t\tfinal Collection<PhysicalSlot> recycledSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(Iterables.getOnlyElement(recycledSlots), sameInstance(newSlot));\n+\n+\t\tfinal Collection<SlotOffer> newSlotOffers = createSlotOffersForResourceRequirements(initialRequirements);\n+\n+\t\t// the pending requirement should be fulfilled by the released slot --> rejecting new slot offers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NjI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {\n          \n          \n            \n            \tpublic void testFreedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {", "url": "https://github.com/apache/flink/pull/13722#discussion_r524366254", "createdAt": "2020-11-16T15:45:43Z", "author": {"login": "tillrohrmann"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal AllocationID freedSlot = Iterables.getOnlyElement(freeSlotConsumer.drainFreedSlots());\n+\n+\t\tassertThat(freedSlot, is(physicalSlot.getAllocationId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReturnIdleSlotsAfterTimeout() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\t// decrease the resource requirements so that slots are no longer needed\n+\t\tslotPool.decreaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(freedSlots, containsInAnyOrder(acceptedSlots.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t\tassertNoAvailableAndRequiredResources(slotPool);\n+\t}\n+\n+\tprivate void assertNoAvailableAndRequiredResources(DefaultDeclarativeSlotPool slotPool) {\n+\t\tassertTrue(slotPool.getFulfilledResourceRequirements().isEmpty());\n+\t\tassertTrue(slotPool.getResourceRequirements().isEmpty());\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnlyReturnExcessIdleSlots() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal ResourceCounter requiredResources = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter excessRequirements = resourceRequirements.subtract(requiredResources);\n+\t\tslotPool.decreaseResourceRequirementsBy(excessRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(requiredResources));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886"}, "originalPosition": 337}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d270f9a8685dc9d2184de39a4c26b70d68552886", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/d270f9a8685dc9d2184de39a4c26b70d68552886", "committedDate": "2020-11-05T10:43:49Z", "message": "adjust comment"}, "afterCommit": {"oid": "2f59bf5d7da389a1f208497fec6d4453bee129de", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/2f59bf5d7da389a1f208497fec6d4453bee129de", "committedDate": "2020-12-01T14:22:04Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91068790a648e9a9d3a7da310e0bd69d8929730d", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/91068790a648e9a9d3a7da310e0bd69d8929730d", "committedDate": "2020-12-02T21:59:13Z", "message": "[FLINK-19636][coordination] Refactor matching logic to make it re-usable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "547fd643bcee8a22d48697b952efeeebdc68a1f3", "author": {"user": {"login": "tillrohrmann", "name": "Till Rohrmann"}}, "url": "https://github.com/apache/flink/commit/547fd643bcee8a22d48697b952efeeebdc68a1f3", "committedDate": "2020-12-02T21:59:13Z", "message": "[FLINK-19636][coordination] Add DeclarativeSlotPool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "committedDate": "2020-12-02T21:59:13Z", "message": "[FLINK-19715][coordination] Fix inefficiencies in assignment of excess resources"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f59bf5d7da389a1f208497fec6d4453bee129de", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/2f59bf5d7da389a1f208497fec6d4453bee129de", "committedDate": "2020-12-01T14:22:04Z", "message": "address comments"}, "afterCommit": {"oid": "948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "author": {"user": {"login": "zentol", "name": "Chesnay Schepler"}}, "url": "https://github.com/apache/flink/commit/948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "committedDate": "2020-12-02T21:59:13Z", "message": "[FLINK-19715][coordination] Fix inefficiencies in assignment of excess resources"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2971, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}