{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTk4MjU0", "number": 12112, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMjo1ODoxNlrOD8tw8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxNzoyMFrOD8t8Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkwOTYyOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMjo1ODoxNlrOGV01fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMjo1ODoxNlrOGV01fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzODk0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c`\u56fe\u5f62`\u6d41\u662f\u4e00\u4e2akeyed stream\uff0c\u6240\u4ee5\u6211\u4eec\u4e66\u5199\u7684\u4ee3\u7801\u5982\u4e0b\uff1a\n          \n          \n            \n            \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c`\u56fe\u5f62`\u6d41\u662f\u4e00\u4e2a keyed stream\uff0c\u6240\u4ee5\u6211\u4eec\u4e66\u5199\u7684\u4ee3\u7801\u5982\u4e0b\uff1a", "url": "https://github.com/apache/flink/pull/12112#discussion_r425538940", "createdAt": "2020-05-15T02:58:16Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -25,96 +25,78 @@ under the License.\n * ToC\n {:toc}\n \n-[Working with State](state.html) describes operator state which upon restore is either evenly distributed among the \n-parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.\n+\u4f60\u5c06\u5728\u672c\u8282\u4e2d\u4e86\u89e3\u5230\u5982\u4f55\u5b9e\u9645\u4f7f\u7528 broadcast state\u3002\u60f3\u4e86\u89e3\u66f4\u591a\u6709\u72b6\u6001\u6d41\u5904\u7406\u7684\u6982\u5ff5\uff0c\u8bf7\u53c2\u8003\n+[Stateful Stream Processing]({% link concepts/stateful-stream-processing.zh.md %})\u3002\n \n-A third type of supported *operator state* is the *Broadcast State*. Broadcast state was introduced to support use cases\n-where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally\n-and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a \n-natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all \n-elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest \n-of operator states in that:\n- 1. it has a map format,\n- 2. it is only available to specific operators that have as inputs a *broadcasted* stream and a *non-broadcasted* one, and\n- 3. such an operator can have *multiple broadcast states* with different names.\n+## \u63d0\u4f9b\u7684 API\n \n-## Provided APIs\n+\u5728\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u4f8b\u5b50\u6765\u5c55\u73b0 broadcast state \u63d0\u4f9b\u7684\u63a5\u53e3\u3002\u5047\u8bbe\u5b58\u5728\u4e00\u4e2a\u5e8f\u5217\uff0c\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\u662f\u5177\u6709\u4e0d\u540c\u989c\u8272\u4e0e\u5f62\u72b6\u7684\u56fe\u5f62\uff0c\u6211\u4eec\u5e0c\u671b\u5728\u5e8f\u5217\u91cc\u76f8\u540c\u989c\u8272\u7684\u56fe\u5f62\u4e2d\u5bfb\u627e\u6ee1\u8db3\u4e00\u5b9a\u987a\u5e8f\u6a21\u5f0f\u7684\u56fe\u5f62\u5bf9\uff08\u6bd4\u5982\u5728\u7ea2\u8272\u7684\u56fe\u5f62\u91cc\uff0c\u6709\u4e00\u4e2a\u957f\u65b9\u5f62\u8ddf\u7740\u4e00\u4e2a\u4e09\u89d2\u5f62\uff09\u3002\n+\u540c\u65f6\uff0c\u6211\u4eec\u5e0c\u671b\u5bfb\u627e\u7684\u6a21\u5f0f\u4e5f\u4f1a\u968f\u7740\u65f6\u95f4\u800c\u6539\u53d8\u3002\n \n-To show the provided APIs, we will start with an example before presenting their full functionality. As our running \n-example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs\n-of objects of the same color that follow a certain pattern, *e.g.* a rectangle followed by a triangle. We assume that\n-the set of interesting patterns evolves over time. \n+\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e24\u4e2a\u6d41\uff0c\u4e00\u4e2a\u6d41\u5305\u542b`\u56fe\u5f62(Item)`\uff0c\u5177\u6709`\u989c\u8272`\u548c`\u5f62\u72b6`\u4e24\u4e2a\u5c5e\u6027\u3002\u53e6\u4e00\u4e2a\u6d41\u5305\u542b\u7279\u5b9a\u7684`\u89c4\u5219(Rule)`\uff0c\u4ee3\u8868\u5e0c\u671b\u5bfb\u627e\u7684\u6a21\u5f0f\u3002\n \n-In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other\n-stream will contain the `Rules`.\n-\n-Starting from the stream of `Items`, we just need to *key it* by `Color`, as we want pairs of the same color. This will\n-make sure that elements of the same color end up on the same physical machine.\n+\u5728`\u56fe\u5f62`\u6d41\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u9996\u5148\u4f7f\u7528`\u989c\u8272`\u5c06\u6d41\u8fdb\u884c\u8fdb\u884c\u5206\u533a(keyBy)\uff0c\u8fd9\u80fd\u786e\u4fdd\u76f8\u540c\u989c\u8272\u7684\u56fe\u5f62\u4f1a\u6d41\u8f6c\u5230\u76f8\u540c\u7684\u7269\u7406\u673a\u4e0a\u3002\n \n {% highlight java %}\n-// key the items by color\n+// \u5c06\u56fe\u5f62\u4f7f\u7528\u989c\u8272\u8fdb\u884c\u5212\u5206\n KeyedStream<Item, Color> colorPartitionedStream = itemStream\n                         .keyBy(new KeySelector<Item, Color>(){...});\n {% endhighlight %}\n \n-Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks \n-should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast \n-the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules\n-will be stored.\n+\u5bf9\u4e8e`\u89c4\u5219`\u6d41\uff0c\u5b83\u5e94\u8be5\u88ab\u5e7f\u64ad\u5230\u6240\u6709\u7684\u4e0b\u6e38 task \u4e2d\uff0c\u4e0b\u6e38 task \u5e94\u5f53\u5b58\u50a8\u8fd9\u4e9b\u89c4\u5219\u5e76\u6839\u636e\u5b83\u5bfb\u627e\u6ee1\u8db3\u89c4\u5219\u7684\u56fe\u5f62\u5bf9\u3002\u4e0b\u9762\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u5b8c\u6210\uff1a\n+i)  \u5c06`\u89c4\u5219`\u5e7f\u64ad\u7ed9\u6240\u6709\u4e0b\u6e38 task\uff1b\n+ii) \u4f7f\u7528 `MapStateDescriptor` \u6765\u63cf\u8ff0\u5e76\u521b\u5efa broadcast state \u5728\u4e0b\u6e38\u7684\u5b58\u50a8\u7ed3\u6784\n \n {% highlight java %}\n \n-// a map descriptor to store the name of the rule (string) and the rule itself.\n+// \u4e00\u4e2a map descriptor\uff0c\u5b83\u63cf\u8ff0\u4e86\u7528\u4e8e\u5b58\u50a8\u89c4\u5219\u540d\u79f0\u4e0e\u89c4\u5219\u672c\u8eab\u7684 map \u5b58\u50a8\u7ed3\u6784\n MapStateDescriptor<String, Rule> ruleStateDescriptor = new MapStateDescriptor<>(\n \t\t\t\"RulesBroadcastState\",\n \t\t\tBasicTypeInfo.STRING_TYPE_INFO,\n \t\t\tTypeInformation.of(new TypeHint<Rule>() {}));\n \t\t\n-// broadcast the rules and create the broadcast state\n+// \u5e7f\u64ad\u6d41\uff0c\u5e7f\u64ad\u89c4\u5219\u5e76\u4e14\u521b\u5efa broadcast state\n BroadcastStream<Rule> ruleBroadcastStream = ruleStream\n                         .broadcast(ruleStateDescriptor);\n {% endhighlight %}\n \n-Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:\n- 1. connect the two streams, and\n- 2. specify our match detecting logic.\n+\u6700\u7ec8\uff0c\u4e3a\u4e86\u4f7f\u7528`\u89c4\u5219`\u6765\u7b5b\u9009`\u56fe\u5f62`\u5e8f\u5217\uff0c\u6211\u4eec\u9700\u8981\uff1a\n+ 1. \u5c06\u4e24\u4e2a\u6d41\u5173\u8054\u8d77\u6765\n+ 2. \u5b8c\u6210\u6211\u4eec\u7684\u6a21\u5f0f\u8bc6\u522b\u903b\u8f91\n+\n+\u4e3a\u4e86\u5173\u8054\u4e00\u4e2a\u975e\u5e7f\u64ad\u6d41 (keyed \u6216\u8005 non-keyed) \u4e0e\u4e00\u4e2a\u5e7f\u64ad\u6d41 `BroadcastStream`\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u975e\u5e7f\u64ad\u6d41\u7684\u65b9\u6cd5 `connect()`\uff0c\u5e76\u5c06 `BroadcastStream` \u5f53\u505a\u53c2\u6570\u4f20\u5165\u3002\n+\u8fd9\u4e2a\u65b9\u6cd5\u7684\u8fd4\u56de\u53c2\u6570\u662f `BroadcastConnectedStream`\uff0c\u5177\u6709\u7c7b\u578b\u65b9\u6cd5 `process()`\uff0c\u4f20\u5165\u4e00\u4e2a\u7279\u6b8a\u7684 `CoProcessFunction` \u6765\u4e66\u5199\u6211\u4eec\u7684\u6a21\u5f0f\u8bc6\u522b\u903b\u8f91\u3002\n+\u5177\u4f53\u4f20\u5165 `process()` \u7684\u662f\u54ea\u4e2a\u7c7b\u578b\u53d6\u51b3\u4e8e\u975e\u5e7f\u64ad\u6d41\u7684\u7c7b\u578b\uff1a\n+ - \u5982\u679c\u6d41\u662f\u4e00\u4e2a **keyed** \u6d41\uff0c\u90a3\u5c31\u662f `KeyedBroadcastProcessFunction` \u7c7b\u578b\uff1b\n+ - \u5982\u679c\u6d41\u662f\u4e00\u4e2a **non-keyed** \u6d41\uff0c\u90a3\u5c31\u662f `BroadcastProcessFunction` \u7c7b\u578b\u3002\n \n-Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the \n-non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on \n-which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. \n-The exact type of the function depends on the type of the non-broadcasted stream: \n- - if that is **keyed**, then the function is a `KeyedBroadcastProcessFunction`. \n- - if it is **non-keyed**, the function is a `BroadcastProcessFunction`. \n- \n- Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:\n+\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c`\u56fe\u5f62`\u6d41\u662f\u4e00\u4e2akeyed stream\uff0c\u6240\u4ee5\u6211\u4eec\u4e66\u5199\u7684\u4ee3\u7801\u5982\u4e0b\uff1a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkxNjMzOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowMjowOVrOGV05Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowMjowOVrOGV05Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzOTkxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a\n          \n          \n            \n            \u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u5904\u7406\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a", "url": "https://github.com/apache/flink/pull/12112#discussion_r425539914", "createdAt": "2020-05-15T03:02:09Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -136,66 +118,50 @@ public abstract class KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> {\n }\n {% endhighlight %}\n \n-The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method \n-for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. \n-\n-The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the \n-broadcasted side has a `Context`. \n+\u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkyMTEzOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowNToxM1rOGV08Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowNToxM1rOGV08Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MDY2Mw==", "bodyText": "\u201c\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u533a\u522b\u5728\u4e8e\u5bf9 broadcast state \u7684\u8bbf\u95ee\u6743\u9650\u4e0d\u540c\u201d", "url": "https://github.com/apache/flink/pull/12112#discussion_r425540663", "createdAt": "2020-05-15T03:05:13Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -136,66 +118,50 @@ public abstract class KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> {\n }\n {% endhighlight %}\n \n-The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method \n-for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. \n-\n-The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the \n-broadcasted side has a `Context`. \n+\u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a\n+ 1. \u5f97\u5230\u5e7f\u64ad\u6d41\u7684\u5b58\u50a8\u72b6\u6001\uff1a`ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n+ 2. \u67e5\u8be2\u5143\u7d20\u7684\u65f6\u95f4\u6233\uff1a`ctx.timestamp()`\n+ 3. \u67e5\u8be2\u76ee\u524d\u7684Watermark\uff1a`ctx.currentWatermark()`\n+ 4. \u76ee\u524d\u7684\u5904\u7406\u65f6\u95f4(processing time)\uff1a`ctx.currentProcessingTime()`\n+ 5. \u4ea7\u751f\u65c1\u8def\u8f93\u51fa\uff1a`ctx.output(OutputTag<X> outputTag, X value)`\n \n-Both of these contexts (`ctx` in the following enumeration):\n- 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n- 2. allow to query the timestamp of the element: `ctx.timestamp()`, \n- 3. get the current watermark: `ctx.currentWatermark()`\n- 4. get the current processing time: `ctx.currentProcessingTime()`, and \n- 5. emit elements to side-outputs: `ctx.output(OutputTag<X> outputTag, X value)`. \n+\u5728 `getBroadcastState()` \u65b9\u6cd5\u4e2d\u4f20\u5165\u7684 `stateDescriptor` \u5e94\u8be5\u4e0e\u8c03\u7528 `.broadcast(ruleStateDescriptor)` \u7684\u53c2\u6570\u76f8\u540c\u3002\n \n-The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` \n-above.\n-\n-The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has \n-**read-write access** to it, while the non-broadcast side has **read-only access** (thus the names). The reason for this\n-is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the\n-same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the\n-same elements across all tasks, and we require the computation on each incoming element on that side to be identical \n-across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and \n-often difficult to debug results.\n+\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u533a\u522b\u5c31\u662f\u5bf9\u4e8e broadcast state \u7684\u8bbf\u95ee\u6743\u9650\u4e0d\u540c\u3002\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\uff0c\u662f**\u5177\u6709\u8bfb\u5199\u6743\u9650\u7684**\uff0c\u800c\u5bf9\u4e8e\u5904\u7406\u975e\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\u662f**\u53ea\u8bfb**\u7684\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkyNDkyOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowNzo0MVrOGV0-nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowNzo0MVrOGV0-nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MTI3Nw==", "bodyText": "\u201c\u53ef\u4ee5\u6ce8\u518c\u4e8b\u4ef6\u6216\u8005\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\u201d \u8fd9\u91cc\u80fd\u5426\u628a \"event-time \u548c processing-time \u5355\u72ec\u63cf\u8ff0\u4e0b\u201c\n\u5f53\u5b9a\u65f6\u5668\u89e6\u53d1\u65f6\uff0c\u4f1a\u8c03\u7528 onTimer() \u65b9\u6cd5", "url": "https://github.com/apache/flink/pull/12112#discussion_r425541277", "createdAt": "2020-05-15T03:07:41Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -136,66 +118,50 @@ public abstract class KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> {\n }\n {% endhighlight %}\n \n-The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method \n-for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. \n-\n-The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the \n-broadcasted side has a `Context`. \n+\u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a\n+ 1. \u5f97\u5230\u5e7f\u64ad\u6d41\u7684\u5b58\u50a8\u72b6\u6001\uff1a`ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n+ 2. \u67e5\u8be2\u5143\u7d20\u7684\u65f6\u95f4\u6233\uff1a`ctx.timestamp()`\n+ 3. \u67e5\u8be2\u76ee\u524d\u7684Watermark\uff1a`ctx.currentWatermark()`\n+ 4. \u76ee\u524d\u7684\u5904\u7406\u65f6\u95f4(processing time)\uff1a`ctx.currentProcessingTime()`\n+ 5. \u4ea7\u751f\u65c1\u8def\u8f93\u51fa\uff1a`ctx.output(OutputTag<X> outputTag, X value)`\n \n-Both of these contexts (`ctx` in the following enumeration):\n- 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n- 2. allow to query the timestamp of the element: `ctx.timestamp()`, \n- 3. get the current watermark: `ctx.currentWatermark()`\n- 4. get the current processing time: `ctx.currentProcessingTime()`, and \n- 5. emit elements to side-outputs: `ctx.output(OutputTag<X> outputTag, X value)`. \n+\u5728 `getBroadcastState()` \u65b9\u6cd5\u4e2d\u4f20\u5165\u7684 `stateDescriptor` \u5e94\u8be5\u4e0e\u8c03\u7528 `.broadcast(ruleStateDescriptor)` \u7684\u53c2\u6570\u76f8\u540c\u3002\n \n-The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` \n-above.\n-\n-The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has \n-**read-write access** to it, while the non-broadcast side has **read-only access** (thus the names). The reason for this\n-is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the\n-same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the\n-same elements across all tasks, and we require the computation on each incoming element on that side to be identical \n-across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and \n-often difficult to debug results.\n+\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u533a\u522b\u5c31\u662f\u5bf9\u4e8e broadcast state \u7684\u8bbf\u95ee\u6743\u9650\u4e0d\u540c\u3002\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\uff0c\u662f**\u5177\u6709\u8bfb\u5199\u6743\u9650\u7684**\uff0c\u800c\u5bf9\u4e8e\u5904\u7406\u975e\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\u662f**\u53ea\u8bfb**\u7684\u3002\n+\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\uff0cFlink \u4e2d\u662f\u4e0d\u5b58\u5728\u8de8 task \u901a\u8baf\u7684\u3002\u6240\u4ee5\u4e3a\u4e86\u4fdd\u8bc1 broadcast state \u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u662f\u4e00\u81f4\u7684\uff0c\u6211\u4eec\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65f6\u5019\u7ed9\u4e88\u5199\u6743\u9650\uff0c\u5728\u6240\u6709\u7684 task \u4e2d\u5747\u53ef\u4ee5\u770b\u5230\u8fd9\u4e9b\u5143\u7d20\uff0c\u5e76\u4e14\u8981\u6c42\u5bf9\u8fd9\u4e9b\u5143\u7d20\u5904\u7406\u662f\u4e00\u81f4\u7684\uff0c\n+\u90a3\u4e48\u6700\u7ec8\u6240\u6709 task \u5f97\u5230\u7684 broadcast state \u662f\u4e00\u81f4\u7684\u3002\n \n <div class=\"alert alert-info\">\n-  <strong>Attention:</strong> The logic implemented in `processBroadcast()` must have the same deterministic behavior\n-  across all parallel instances!\n+  <strong>\u6ce8\u610f\uff1a</strong>`processBroadcastElement()` \u7684\u5b9e\u73b0\u5fc5\u987b\u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u5177\u6709\u786e\u5b9a\u6027\u7684\u7ed3\u679c\u3002\n </div>\n \n-Finally, due to the fact that the `KeyedBroadcastProcessFunction` is operating on a keyed stream, it \n-exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:\n- 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink's underlying timer service, which allows\n-  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an \n-  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus \n-   - the ability to ask if the timer that fired was an event or processing time one and \n-   - to query the key associated with the timer.\n- 2. the `Context` in the `processBroadcastElement()` method contains the method \n- `applyToKeyedState(StateDescriptor<S, VS> stateDescriptor, KeyedStateFunction<KS, S> function)`. This allows to \n-  register a `KeyedStateFunction` to be **applied to all states of all keys** associated with the provided `stateDescriptor`. \n+\u540c\u65f6\uff0c`KeyedBroadcastProcessFunction` \u5728 Keyed Stream \u4e0a\u5de5\u4f5c\uff0c\u6240\u4ee5\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e9b `BroadcastProcessFunction` \u6ca1\u6709\u7684\u529f\u80fd:\n+ 1. `processElement()` \u7684\u53c2\u6570 `ReadOnlyContext` \u63d0\u4f9b\u4e86\u65b9\u6cd5\u80fd\u591f\u8bbf\u95ee Flink \u7684\u5b9a\u65f6\u5668\u670d\u52a1\uff0c\u53ef\u4ee5\u6ce8\u518c\u4e8b\u4ef6\u6216\u8005\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\u3002\u5f53\u5b9a\u65f6\u5668\u89e6\u53d1\u65f6\uff0c`onTimer()` \u65b9\u6cd5\u4f1a\u88ab\u8c03\u7528\uff0c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkyOTEwOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMDoxN1rOGV1BBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMDoxN1rOGV1BBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MTg5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             \u8fd9\u4e2a\u65b9\u6cd5\u4f7f\u7528\u4e00\u4e2a `KeyedStateFunction` \u80fd\u591f\u5bf9 `stateDescriptor` \u5bf9\u5e94\u7684 state \u7684**\u6240\u6709key\u6240\u6709\u5b58\u50a8\u7684\u72b6\u6001**\u8fdb\u884c\u67d0\u4e9b\u64cd\u4f5c\u3002\n          \n          \n            \n             \u8fd9\u4e2a\u65b9\u6cd5\u4f7f\u7528\u4e00\u4e2a `KeyedStateFunction` \u80fd\u591f\u5bf9 `stateDescriptor` \u5bf9\u5e94\u7684 state \u7684**\u6240\u6709 key \u7684\u5b58\u50a8\u72b6\u6001**\u8fdb\u884c\u67d0\u4e9b\u64cd\u4f5c\u3002", "url": "https://github.com/apache/flink/pull/12112#discussion_r425541894", "createdAt": "2020-05-15T03:10:17Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -136,66 +118,50 @@ public abstract class KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> {\n }\n {% endhighlight %}\n \n-The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method \n-for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. \n-\n-The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the \n-broadcasted side has a `Context`. \n+\u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a\n+ 1. \u5f97\u5230\u5e7f\u64ad\u6d41\u7684\u5b58\u50a8\u72b6\u6001\uff1a`ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n+ 2. \u67e5\u8be2\u5143\u7d20\u7684\u65f6\u95f4\u6233\uff1a`ctx.timestamp()`\n+ 3. \u67e5\u8be2\u76ee\u524d\u7684Watermark\uff1a`ctx.currentWatermark()`\n+ 4. \u76ee\u524d\u7684\u5904\u7406\u65f6\u95f4(processing time)\uff1a`ctx.currentProcessingTime()`\n+ 5. \u4ea7\u751f\u65c1\u8def\u8f93\u51fa\uff1a`ctx.output(OutputTag<X> outputTag, X value)`\n \n-Both of these contexts (`ctx` in the following enumeration):\n- 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n- 2. allow to query the timestamp of the element: `ctx.timestamp()`, \n- 3. get the current watermark: `ctx.currentWatermark()`\n- 4. get the current processing time: `ctx.currentProcessingTime()`, and \n- 5. emit elements to side-outputs: `ctx.output(OutputTag<X> outputTag, X value)`. \n+\u5728 `getBroadcastState()` \u65b9\u6cd5\u4e2d\u4f20\u5165\u7684 `stateDescriptor` \u5e94\u8be5\u4e0e\u8c03\u7528 `.broadcast(ruleStateDescriptor)` \u7684\u53c2\u6570\u76f8\u540c\u3002\n \n-The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` \n-above.\n-\n-The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has \n-**read-write access** to it, while the non-broadcast side has **read-only access** (thus the names). The reason for this\n-is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the\n-same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the\n-same elements across all tasks, and we require the computation on each incoming element on that side to be identical \n-across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and \n-often difficult to debug results.\n+\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u533a\u522b\u5c31\u662f\u5bf9\u4e8e broadcast state \u7684\u8bbf\u95ee\u6743\u9650\u4e0d\u540c\u3002\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\uff0c\u662f**\u5177\u6709\u8bfb\u5199\u6743\u9650\u7684**\uff0c\u800c\u5bf9\u4e8e\u5904\u7406\u975e\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\u662f**\u53ea\u8bfb**\u7684\u3002\n+\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\uff0cFlink \u4e2d\u662f\u4e0d\u5b58\u5728\u8de8 task \u901a\u8baf\u7684\u3002\u6240\u4ee5\u4e3a\u4e86\u4fdd\u8bc1 broadcast state \u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u662f\u4e00\u81f4\u7684\uff0c\u6211\u4eec\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65f6\u5019\u7ed9\u4e88\u5199\u6743\u9650\uff0c\u5728\u6240\u6709\u7684 task \u4e2d\u5747\u53ef\u4ee5\u770b\u5230\u8fd9\u4e9b\u5143\u7d20\uff0c\u5e76\u4e14\u8981\u6c42\u5bf9\u8fd9\u4e9b\u5143\u7d20\u5904\u7406\u662f\u4e00\u81f4\u7684\uff0c\n+\u90a3\u4e48\u6700\u7ec8\u6240\u6709 task \u5f97\u5230\u7684 broadcast state \u662f\u4e00\u81f4\u7684\u3002\n \n <div class=\"alert alert-info\">\n-  <strong>Attention:</strong> The logic implemented in `processBroadcast()` must have the same deterministic behavior\n-  across all parallel instances!\n+  <strong>\u6ce8\u610f\uff1a</strong>`processBroadcastElement()` \u7684\u5b9e\u73b0\u5fc5\u987b\u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u5177\u6709\u786e\u5b9a\u6027\u7684\u7ed3\u679c\u3002\n </div>\n \n-Finally, due to the fact that the `KeyedBroadcastProcessFunction` is operating on a keyed stream, it \n-exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:\n- 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink's underlying timer service, which allows\n-  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an \n-  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus \n-   - the ability to ask if the timer that fired was an event or processing time one and \n-   - to query the key associated with the timer.\n- 2. the `Context` in the `processBroadcastElement()` method contains the method \n- `applyToKeyedState(StateDescriptor<S, VS> stateDescriptor, KeyedStateFunction<KS, S> function)`. This allows to \n-  register a `KeyedStateFunction` to be **applied to all states of all keys** associated with the provided `stateDescriptor`. \n+\u540c\u65f6\uff0c`KeyedBroadcastProcessFunction` \u5728 Keyed Stream \u4e0a\u5de5\u4f5c\uff0c\u6240\u4ee5\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e9b `BroadcastProcessFunction` \u6ca1\u6709\u7684\u529f\u80fd:\n+ 1. `processElement()` \u7684\u53c2\u6570 `ReadOnlyContext` \u63d0\u4f9b\u4e86\u65b9\u6cd5\u80fd\u591f\u8bbf\u95ee Flink \u7684\u5b9a\u65f6\u5668\u670d\u52a1\uff0c\u53ef\u4ee5\u6ce8\u518c\u4e8b\u4ef6\u6216\u8005\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\u3002\u5f53\u5b9a\u65f6\u5668\u89e6\u53d1\u65f6\uff0c`onTimer()` \u65b9\u6cd5\u4f1a\u88ab\u8c03\u7528\uff0c\n+ \u63d0\u4f9b\u4e86 `OnTimerContext`\uff0c\u5b83\u5177\u6709 `ReadOnlyContext` \u7684\u5168\u90e8\u529f\u80fd\uff0c\u5e76\u4e14\u63d0\u4f9b\uff1a\n+  - \u67e5\u8be2\u5f53\u524d\u89e6\u53d1\u7684\u662f\u4e00\u4e2a\u4e8b\u4ef6\u8fd8\u662f\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\n+  - \u67e5\u8be2\u5b9a\u65f6\u5668\u5173\u8054\u7684key\n+ 2. `processBroadcastElement()` \u65b9\u6cd5\u4e2d\u7684\u53c2\u6570 `Context` \u4f1a\u63d0\u4f9b\u65b9\u6cd5 `applyToKeyedState(StateDescriptor<S, VS> stateDescriptor, KeyedStateFunction<KS, S> function)`\u3002\n+ \u8fd9\u4e2a\u65b9\u6cd5\u4f7f\u7528\u4e00\u4e2a `KeyedStateFunction` \u80fd\u591f\u5bf9 `stateDescriptor` \u5bf9\u5e94\u7684 state \u7684**\u6240\u6709key\u6240\u6709\u5b58\u50a8\u7684\u72b6\u6001**\u8fdb\u884c\u67d0\u4e9b\u64cd\u4f5c\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkyOTkxOnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMDo0OVrOGV1Big==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMDo0OVrOGV1Big==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MjAyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              \u5728 `processBroadcastElement()` \u65b9\u6cd5\u4e2d\u4e0d\u80fd\u6ce8\u518c\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u5e7f\u64ad\u7684\u5143\u7d20\u4e2d\u5e76\u6ca1\u6709\u5173\u8054\u7684key\u3002\n          \n          \n            \n              \u5728 `processBroadcastElement()` \u65b9\u6cd5\u4e2d\u4e0d\u80fd\u6ce8\u518c\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u5e7f\u64ad\u7684\u5143\u7d20\u4e2d\u5e76\u6ca1\u6709\u5173\u8054\u7684 key\u3002", "url": "https://github.com/apache/flink/pull/12112#discussion_r425542026", "createdAt": "2020-05-15T03:10:49Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -136,66 +118,50 @@ public abstract class KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> {\n }\n {% endhighlight %}\n \n-The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method \n-for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. \n-\n-The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the \n-broadcasted side has a `Context`. \n+\u9700\u8981\u6ce8\u610f\u7684\u662f `processBroadcastElement()` \u662f\u5904\u7406\u7684\u5e7f\u64ad\u6d41\u7684\u5143\u7d20\uff0c\u800c `processElement()` \u5904\u7406\u7684\u662f\u53e6\u4e00\u4e2a\u6d41\u7684\u5143\u7d20\u3002\u4e24\u4e2a\u65b9\u6cd5\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570(Context)\u4e0d\u540c\uff0c\u5747\u6709\u4ee5\u4e0b\u65b9\u6cd5\uff1a\n+ 1. \u5f97\u5230\u5e7f\u64ad\u6d41\u7684\u5b58\u50a8\u72b6\u6001\uff1a`ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n+ 2. \u67e5\u8be2\u5143\u7d20\u7684\u65f6\u95f4\u6233\uff1a`ctx.timestamp()`\n+ 3. \u67e5\u8be2\u76ee\u524d\u7684Watermark\uff1a`ctx.currentWatermark()`\n+ 4. \u76ee\u524d\u7684\u5904\u7406\u65f6\u95f4(processing time)\uff1a`ctx.currentProcessingTime()`\n+ 5. \u4ea7\u751f\u65c1\u8def\u8f93\u51fa\uff1a`ctx.output(OutputTag<X> outputTag, X value)`\n \n-Both of these contexts (`ctx` in the following enumeration):\n- 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor<K, V> stateDescriptor)`\n- 2. allow to query the timestamp of the element: `ctx.timestamp()`, \n- 3. get the current watermark: `ctx.currentWatermark()`\n- 4. get the current processing time: `ctx.currentProcessingTime()`, and \n- 5. emit elements to side-outputs: `ctx.output(OutputTag<X> outputTag, X value)`. \n+\u5728 `getBroadcastState()` \u65b9\u6cd5\u4e2d\u4f20\u5165\u7684 `stateDescriptor` \u5e94\u8be5\u4e0e\u8c03\u7528 `.broadcast(ruleStateDescriptor)` \u7684\u53c2\u6570\u76f8\u540c\u3002\n \n-The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` \n-above.\n-\n-The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has \n-**read-write access** to it, while the non-broadcast side has **read-only access** (thus the names). The reason for this\n-is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the\n-same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the\n-same elements across all tasks, and we require the computation on each incoming element on that side to be identical \n-across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and \n-often difficult to debug results.\n+\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u533a\u522b\u5c31\u662f\u5bf9\u4e8e broadcast state \u7684\u8bbf\u95ee\u6743\u9650\u4e0d\u540c\u3002\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\uff0c\u662f**\u5177\u6709\u8bfb\u5199\u6743\u9650\u7684**\uff0c\u800c\u5bf9\u4e8e\u5904\u7406\u975e\u5e7f\u64ad\u6d41\u5143\u7d20\u8fd9\u7aef\u662f**\u53ea\u8bfb**\u7684\u3002\n+\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\uff0cFlink \u4e2d\u662f\u4e0d\u5b58\u5728\u8de8 task \u901a\u8baf\u7684\u3002\u6240\u4ee5\u4e3a\u4e86\u4fdd\u8bc1 broadcast state \u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u662f\u4e00\u81f4\u7684\uff0c\u6211\u4eec\u5728\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65f6\u5019\u7ed9\u4e88\u5199\u6743\u9650\uff0c\u5728\u6240\u6709\u7684 task \u4e2d\u5747\u53ef\u4ee5\u770b\u5230\u8fd9\u4e9b\u5143\u7d20\uff0c\u5e76\u4e14\u8981\u6c42\u5bf9\u8fd9\u4e9b\u5143\u7d20\u5904\u7406\u662f\u4e00\u81f4\u7684\uff0c\n+\u90a3\u4e48\u6700\u7ec8\u6240\u6709 task \u5f97\u5230\u7684 broadcast state \u662f\u4e00\u81f4\u7684\u3002\n \n <div class=\"alert alert-info\">\n-  <strong>Attention:</strong> The logic implemented in `processBroadcast()` must have the same deterministic behavior\n-  across all parallel instances!\n+  <strong>\u6ce8\u610f\uff1a</strong>`processBroadcastElement()` \u7684\u5b9e\u73b0\u5fc5\u987b\u5728\u6240\u6709\u7684\u5e76\u53d1\u5b9e\u4f8b\u4e2d\u5177\u6709\u786e\u5b9a\u6027\u7684\u7ed3\u679c\u3002\n </div>\n \n-Finally, due to the fact that the `KeyedBroadcastProcessFunction` is operating on a keyed stream, it \n-exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:\n- 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink's underlying timer service, which allows\n-  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an \n-  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus \n-   - the ability to ask if the timer that fired was an event or processing time one and \n-   - to query the key associated with the timer.\n- 2. the `Context` in the `processBroadcastElement()` method contains the method \n- `applyToKeyedState(StateDescriptor<S, VS> stateDescriptor, KeyedStateFunction<KS, S> function)`. This allows to \n-  register a `KeyedStateFunction` to be **applied to all states of all keys** associated with the provided `stateDescriptor`. \n+\u540c\u65f6\uff0c`KeyedBroadcastProcessFunction` \u5728 Keyed Stream \u4e0a\u5de5\u4f5c\uff0c\u6240\u4ee5\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e9b `BroadcastProcessFunction` \u6ca1\u6709\u7684\u529f\u80fd:\n+ 1. `processElement()` \u7684\u53c2\u6570 `ReadOnlyContext` \u63d0\u4f9b\u4e86\u65b9\u6cd5\u80fd\u591f\u8bbf\u95ee Flink \u7684\u5b9a\u65f6\u5668\u670d\u52a1\uff0c\u53ef\u4ee5\u6ce8\u518c\u4e8b\u4ef6\u6216\u8005\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\u3002\u5f53\u5b9a\u65f6\u5668\u89e6\u53d1\u65f6\uff0c`onTimer()` \u65b9\u6cd5\u4f1a\u88ab\u8c03\u7528\uff0c\n+ \u63d0\u4f9b\u4e86 `OnTimerContext`\uff0c\u5b83\u5177\u6709 `ReadOnlyContext` \u7684\u5168\u90e8\u529f\u80fd\uff0c\u5e76\u4e14\u63d0\u4f9b\uff1a\n+  - \u67e5\u8be2\u5f53\u524d\u89e6\u53d1\u7684\u662f\u4e00\u4e2a\u4e8b\u4ef6\u8fd8\u662f\u5904\u7406\u65f6\u95f4\u7684\u5b9a\u65f6\u5668\n+  - \u67e5\u8be2\u5b9a\u65f6\u5668\u5173\u8054\u7684key\n+ 2. `processBroadcastElement()` \u65b9\u6cd5\u4e2d\u7684\u53c2\u6570 `Context` \u4f1a\u63d0\u4f9b\u65b9\u6cd5 `applyToKeyedState(StateDescriptor<S, VS> stateDescriptor, KeyedStateFunction<KS, S> function)`\u3002\n+ \u8fd9\u4e2a\u65b9\u6cd5\u4f7f\u7528\u4e00\u4e2a `KeyedStateFunction` \u80fd\u591f\u5bf9 `stateDescriptor` \u5bf9\u5e94\u7684 state \u7684**\u6240\u6709key\u6240\u6709\u5b58\u50a8\u7684\u72b6\u6001**\u8fdb\u884c\u67d0\u4e9b\u64cd\u4f5c\u3002\n \n <div class=\"alert alert-info\">\n-  <strong>Attention:</strong> Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`\n-  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the \n-  broadcasted elements.\n+  <strong>\u6ce8\u610f\uff1a</strong>\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668\u53ea\u80fd\u5728 `KeyedBroadcastProcessFunction` \u7684 `processElement()` \u65b9\u6cd5\u4e2d\u8fdb\u884c\u3002\n+  \u5728 `processBroadcastElement()` \u65b9\u6cd5\u4e2d\u4e0d\u80fd\u6ce8\u518c\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u5e7f\u64ad\u7684\u5143\u7d20\u4e2d\u5e76\u6ca1\u6709\u5173\u8054\u7684key\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkzMTk3OnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMjozNFrOGV1C1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMjozNFrOGV1C1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MjM1OQ==", "bodyText": "\u8fd9\u91cc\u8981\u63cf\u8ff0\u51fa \"only\" \u4e5f\u5c31\u662f\u53ea\u6709 broadcast stream \u53ef\u4ee5\u4fee\u6539\uff0c\u975e broadcast stream \u4e0d\u53ef\u4ee5\u4fee\u6539 broadcast state", "url": "https://github.com/apache/flink/pull/12112#discussion_r425542359", "createdAt": "2020-05-15T03:12:34Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -249,31 +215,20 @@ new KeyedBroadcastProcessFunction<Color, Item, Rule, String>() {\n }\n {% endhighlight %}\n \n-## Important Considerations\n+## \u91cd\u8981\u6ce8\u610f\u4e8b\u9879\n \n-After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast \n-state. These are:\n+\u8fd9\u91cc\u6709\u4e00\u4e9b broadcast state \u7684\u91cd\u8981\u6ce8\u610f\u4e8b\u9879\uff0c\u5728\u4f7f\u7528\u5b83\u65f6\u9700\u8981\u65f6\u523b\u6e05\u695a\uff1a\n \n-  - **There is no cross-task communication:** As stated earlier, this is the reason why only the broadcast side of a \n-`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make \n-sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,\n-different tasks might have different contents, leading to inconsistent results.\n+  - **\u6ca1\u6709\u8de8 task \u901a\u8baf\uff1a**\u5982\u4e0a\u6240\u8ff0\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728 `(Keyed)-BroadcastProcessFunction` \u4e2d\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65b9\u6cd5\u91cc\u53ef\u4ee5\u66f4\u6539 broadcast state \u7684\u5185\u5bb9\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkzMzE4OnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMzoyMVrOGV1Diw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxMzoyMVrOGV1Diw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MjUzOQ==", "bodyText": "\u987a\u5e8f\u662f\u4e0d\u540c\u7684 -> \"\u987a\u5e8f\u53ef\u80fd\u662f\u4e0d\u540c\u7684\"", "url": "https://github.com/apache/flink/pull/12112#discussion_r425542539", "createdAt": "2020-05-15T03:13:21Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -249,31 +215,20 @@ new KeyedBroadcastProcessFunction<Color, Item, Rule, String>() {\n }\n {% endhighlight %}\n \n-## Important Considerations\n+## \u91cd\u8981\u6ce8\u610f\u4e8b\u9879\n \n-After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast \n-state. These are:\n+\u8fd9\u91cc\u6709\u4e00\u4e9b broadcast state \u7684\u91cd\u8981\u6ce8\u610f\u4e8b\u9879\uff0c\u5728\u4f7f\u7528\u5b83\u65f6\u9700\u8981\u65f6\u523b\u6e05\u695a\uff1a\n \n-  - **There is no cross-task communication:** As stated earlier, this is the reason why only the broadcast side of a \n-`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make \n-sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,\n-different tasks might have different contents, leading to inconsistent results.\n+  - **\u6ca1\u6709\u8de8 task \u901a\u8baf\uff1a**\u5982\u4e0a\u6240\u8ff0\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728 `(Keyed)-BroadcastProcessFunction` \u4e2d\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65b9\u6cd5\u91cc\u53ef\u4ee5\u66f4\u6539 broadcast state \u7684\u5185\u5bb9\u3002\n+  \u540c\u65f6\uff0c\u7528\u6237\u9700\u8981\u4fdd\u8bc1\u6240\u6709 task \u5bf9\u4e8e broadcast state \u7684\u5904\u7406\u65b9\u5f0f\u662f\u4e00\u81f4\u7684\uff0c\u5426\u5219\u4f1a\u9020\u6210\u4e0d\u540c task \u8bfb\u53d6 broadcast state \u65f6\u5185\u5bb9\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff0c\u6700\u7ec8\u5bfc\u81f4\u7ed3\u679c\u4e0d\u4e00\u81f4\u3002\n \n-  - **Order of events in Broadcast State may differ across tasks:** Although broadcasting the elements of a stream \n-guarantees that all elements will (eventually) go to all downstream tasks, elements may arrive in a different order \n-to each task. So the state updates for each incoming element *MUST NOT depend on the ordering* of the incoming\n-events.\n+  - **broadcast state \u5728\u4e0d\u540c\u7684 task \u7684\u4e8b\u4ef6\u987a\u5e8f\u662f\u4e0d\u540c\u7684\uff1a**\u867d\u7136\u5e7f\u64ad\u6d41\u4e2d\u5143\u7d20\u7684\u8fc7\u7a0b\u80fd\u591f\u4fdd\u8bc1\u6240\u6709\u7684\u4e0b\u6e38 task \u5168\u90e8\u80fd\u591f\u6536\u5230\uff0c\u4f46\u5728\u4e0d\u540c task \u4e2d\u5143\u7d20\u7684\u5230\u8fbe\u987a\u5e8f\u53ef\u80fd\u4e0d\u540c\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkzNTY5OnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxNTowNVrOGV1FIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxNTowNVrOGV1FIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0Mjk0NQ==", "bodyText": "\u201d\u5e76\u53d1\u5ea6\u4e0a\u5347\u201c \u6539\u6210 \u201d\u589e\u5927\u5e76\u53d1\u201c\uff1f", "url": "https://github.com/apache/flink/pull/12112#discussion_r425542945", "createdAt": "2020-05-15T03:15:05Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -249,31 +215,20 @@ new KeyedBroadcastProcessFunction<Color, Item, Rule, String>() {\n }\n {% endhighlight %}\n \n-## Important Considerations\n+## \u91cd\u8981\u6ce8\u610f\u4e8b\u9879\n \n-After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast \n-state. These are:\n+\u8fd9\u91cc\u6709\u4e00\u4e9b broadcast state \u7684\u91cd\u8981\u6ce8\u610f\u4e8b\u9879\uff0c\u5728\u4f7f\u7528\u5b83\u65f6\u9700\u8981\u65f6\u523b\u6e05\u695a\uff1a\n \n-  - **There is no cross-task communication:** As stated earlier, this is the reason why only the broadcast side of a \n-`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make \n-sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,\n-different tasks might have different contents, leading to inconsistent results.\n+  - **\u6ca1\u6709\u8de8 task \u901a\u8baf\uff1a**\u5982\u4e0a\u6240\u8ff0\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728 `(Keyed)-BroadcastProcessFunction` \u4e2d\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65b9\u6cd5\u91cc\u53ef\u4ee5\u66f4\u6539 broadcast state \u7684\u5185\u5bb9\u3002\n+  \u540c\u65f6\uff0c\u7528\u6237\u9700\u8981\u4fdd\u8bc1\u6240\u6709 task \u5bf9\u4e8e broadcast state \u7684\u5904\u7406\u65b9\u5f0f\u662f\u4e00\u81f4\u7684\uff0c\u5426\u5219\u4f1a\u9020\u6210\u4e0d\u540c task \u8bfb\u53d6 broadcast state \u65f6\u5185\u5bb9\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff0c\u6700\u7ec8\u5bfc\u81f4\u7ed3\u679c\u4e0d\u4e00\u81f4\u3002\n \n-  - **Order of events in Broadcast State may differ across tasks:** Although broadcasting the elements of a stream \n-guarantees that all elements will (eventually) go to all downstream tasks, elements may arrive in a different order \n-to each task. So the state updates for each incoming element *MUST NOT depend on the ordering* of the incoming\n-events.\n+  - **broadcast state \u5728\u4e0d\u540c\u7684 task \u7684\u4e8b\u4ef6\u987a\u5e8f\u662f\u4e0d\u540c\u7684\uff1a**\u867d\u7136\u5e7f\u64ad\u6d41\u4e2d\u5143\u7d20\u7684\u8fc7\u7a0b\u80fd\u591f\u4fdd\u8bc1\u6240\u6709\u7684\u4e0b\u6e38 task \u5168\u90e8\u80fd\u591f\u6536\u5230\uff0c\u4f46\u5728\u4e0d\u540c task \u4e2d\u5143\u7d20\u7684\u5230\u8fbe\u987a\u5e8f\u53ef\u80fd\u4e0d\u540c\u3002\n+  \u6240\u4ee5 broadcast state \u7684\u66f4\u65b0*\u4e0d\u80fd\u4f9d\u8d56\u4e8e\u6d41\u4e2d\u5143\u7d20\u7684\u5230\u8fbe\u987a\u5e8f*\u3002\n \n-  - **All tasks checkpoint their broadcast state:** Although all tasks have the same elements in their broadcast state\n-when a checkpoint takes place (checkpoint barriers do not overpass elements), all tasks checkpoint their broadcast state, \n-and not just one of them. This is a design decision to avoid having all tasks read from the same file during a restore \n-(thus avoiding hotspots), although it comes at the expense of increasing the size of the checkpointed state by a factor \n-of p (= parallelism). Flink guarantees that upon restoring/rescaling there will be **no duplicates** and **no missing data**. \n-In case of recovery with the same or smaller parallelism, each task reads its checkpointed state. Upon scaling up, each\n-task reads its own state, and the remaining tasks (`p_new`-`p_old`) read checkpoints of previous tasks in a round-robin\n-manner.\n+  - **\u6240\u6709\u7684 task \u5747\u4f1a\u5bf9 broadcast state \u8fdb\u884c checkpoint\uff1a**\u867d\u7136\u6240\u6709 task \u4e2d\u7684 broadcast state \u662f\u4e00\u81f4\u7684\uff0c\u4f46\u5f53 checkpoint \u6765\u4e34\u65f6\u6240\u6709 task \u5747\u4f1a\u5bf9 broadcast state \u505a checkpoint\u3002\n+  \u8fd9\u4e2a\u8bbe\u8ba1\u662f\u4e3a\u4e86\u9632\u6b62\u5728\u4f5c\u4e1a\u6062\u590d\u540e\u8bfb\u6587\u4ef6\u9020\u6210\u7684\u6587\u4ef6\u70ed\u70b9\u3002\u5f53\u7136\u8fd9\u79cd\u65b9\u5f0f\u4f1a\u9020\u6210 checkpoint \u4e00\u5b9a\u7a0b\u5ea6\u7684\u5199\u653e\u5927\uff0c\u653e\u5927\u500d\u6570\u4e3a p (=\u5e76\u884c\u5ea6)\u3002Flink \u4f1a\u4fdd\u8bc1\u5728\u6062\u590d\u72b6\u6001/\u6539\u53d8\u5e76\u53d1\u7684\u65f6\u5019\u6570\u636e**\u6ca1\u6709\u91cd\u590d**\u4e14**\u6ca1\u6709\u7f3a\u5931**\u3002\n+  \u5728\u4f5c\u4e1a\u6062\u590d\u65f6\uff0c\u5982\u679c\u4e0e\u4e4b\u524d\u5177\u6709\u76f8\u540c\u6216\u66f4\u5c0f\u7684\u5e76\u53d1\u5ea6\uff0c\u6240\u6709\u7684 task \u8bfb\u53d6\u4e4b\u524d\u5df2\u7ecf checkpoint \u8fc7\u7684 state\u3002\u5728\u5e76\u53d1\u5ea6\u4e0a\u5347\u7684\u60c5\u51b5\u4e0b\uff0ctask \u4f1a\u8bfb\u53d6\u672c\u8eab\u7684 state\uff0c\u591a\u51fa\u6765\u7684\u5e76\u53d1 (`p_new` - `p_old`) \u4f1a\u4f7f\u7528\u8f6e\u8be2\u8c03\u5ea6\u7b97\u6cd5\u8bfb\u53d6\u4e4b\u524d task \u7684 state\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTkzODY3OnYy", "diffSide": "RIGHT", "path": "docs/dev/stream/state/broadcast_state.zh.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxNzoyMFrOGV1G7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoxNzoyMFrOGV1G7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0MzQwNQ==", "bodyText": "\u8fd9\u91cc\u662f\u8bf4\u5bf9\u6240\u6709\u7684 \u201dOperator State\u201d \u90fd\u8fd9\u6837\uff0c Broadcast state \u662f\u4e00\u79cd\u7279\u6b8a\u7684 operator state", "url": "https://github.com/apache/flink/pull/12112#discussion_r425543405", "createdAt": "2020-05-15T03:17:20Z", "author": {"login": "klion26"}, "path": "docs/dev/stream/state/broadcast_state.zh.md", "diffHunk": "@@ -249,31 +215,20 @@ new KeyedBroadcastProcessFunction<Color, Item, Rule, String>() {\n }\n {% endhighlight %}\n \n-## Important Considerations\n+## \u91cd\u8981\u6ce8\u610f\u4e8b\u9879\n \n-After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast \n-state. These are:\n+\u8fd9\u91cc\u6709\u4e00\u4e9b broadcast state \u7684\u91cd\u8981\u6ce8\u610f\u4e8b\u9879\uff0c\u5728\u4f7f\u7528\u5b83\u65f6\u9700\u8981\u65f6\u523b\u6e05\u695a\uff1a\n \n-  - **There is no cross-task communication:** As stated earlier, this is the reason why only the broadcast side of a \n-`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make \n-sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,\n-different tasks might have different contents, leading to inconsistent results.\n+  - **\u6ca1\u6709\u8de8 task \u901a\u8baf\uff1a**\u5982\u4e0a\u6240\u8ff0\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728 `(Keyed)-BroadcastProcessFunction` \u4e2d\u5904\u7406\u5e7f\u64ad\u6d41\u5143\u7d20\u7684\u65b9\u6cd5\u91cc\u53ef\u4ee5\u66f4\u6539 broadcast state \u7684\u5185\u5bb9\u3002\n+  \u540c\u65f6\uff0c\u7528\u6237\u9700\u8981\u4fdd\u8bc1\u6240\u6709 task \u5bf9\u4e8e broadcast state \u7684\u5904\u7406\u65b9\u5f0f\u662f\u4e00\u81f4\u7684\uff0c\u5426\u5219\u4f1a\u9020\u6210\u4e0d\u540c task \u8bfb\u53d6 broadcast state \u65f6\u5185\u5bb9\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff0c\u6700\u7ec8\u5bfc\u81f4\u7ed3\u679c\u4e0d\u4e00\u81f4\u3002\n \n-  - **Order of events in Broadcast State may differ across tasks:** Although broadcasting the elements of a stream \n-guarantees that all elements will (eventually) go to all downstream tasks, elements may arrive in a different order \n-to each task. So the state updates for each incoming element *MUST NOT depend on the ordering* of the incoming\n-events.\n+  - **broadcast state \u5728\u4e0d\u540c\u7684 task \u7684\u4e8b\u4ef6\u987a\u5e8f\u662f\u4e0d\u540c\u7684\uff1a**\u867d\u7136\u5e7f\u64ad\u6d41\u4e2d\u5143\u7d20\u7684\u8fc7\u7a0b\u80fd\u591f\u4fdd\u8bc1\u6240\u6709\u7684\u4e0b\u6e38 task \u5168\u90e8\u80fd\u591f\u6536\u5230\uff0c\u4f46\u5728\u4e0d\u540c task \u4e2d\u5143\u7d20\u7684\u5230\u8fbe\u987a\u5e8f\u53ef\u80fd\u4e0d\u540c\u3002\n+  \u6240\u4ee5 broadcast state \u7684\u66f4\u65b0*\u4e0d\u80fd\u4f9d\u8d56\u4e8e\u6d41\u4e2d\u5143\u7d20\u7684\u5230\u8fbe\u987a\u5e8f*\u3002\n \n-  - **All tasks checkpoint their broadcast state:** Although all tasks have the same elements in their broadcast state\n-when a checkpoint takes place (checkpoint barriers do not overpass elements), all tasks checkpoint their broadcast state, \n-and not just one of them. This is a design decision to avoid having all tasks read from the same file during a restore \n-(thus avoiding hotspots), although it comes at the expense of increasing the size of the checkpointed state by a factor \n-of p (= parallelism). Flink guarantees that upon restoring/rescaling there will be **no duplicates** and **no missing data**. \n-In case of recovery with the same or smaller parallelism, each task reads its checkpointed state. Upon scaling up, each\n-task reads its own state, and the remaining tasks (`p_new`-`p_old`) read checkpoints of previous tasks in a round-robin\n-manner.\n+  - **\u6240\u6709\u7684 task \u5747\u4f1a\u5bf9 broadcast state \u8fdb\u884c checkpoint\uff1a**\u867d\u7136\u6240\u6709 task \u4e2d\u7684 broadcast state \u662f\u4e00\u81f4\u7684\uff0c\u4f46\u5f53 checkpoint \u6765\u4e34\u65f6\u6240\u6709 task \u5747\u4f1a\u5bf9 broadcast state \u505a checkpoint\u3002\n+  \u8fd9\u4e2a\u8bbe\u8ba1\u662f\u4e3a\u4e86\u9632\u6b62\u5728\u4f5c\u4e1a\u6062\u590d\u540e\u8bfb\u6587\u4ef6\u9020\u6210\u7684\u6587\u4ef6\u70ed\u70b9\u3002\u5f53\u7136\u8fd9\u79cd\u65b9\u5f0f\u4f1a\u9020\u6210 checkpoint \u4e00\u5b9a\u7a0b\u5ea6\u7684\u5199\u653e\u5927\uff0c\u653e\u5927\u500d\u6570\u4e3a p (=\u5e76\u884c\u5ea6)\u3002Flink \u4f1a\u4fdd\u8bc1\u5728\u6062\u590d\u72b6\u6001/\u6539\u53d8\u5e76\u53d1\u7684\u65f6\u5019\u6570\u636e**\u6ca1\u6709\u91cd\u590d**\u4e14**\u6ca1\u6709\u7f3a\u5931**\u3002\n+  \u5728\u4f5c\u4e1a\u6062\u590d\u65f6\uff0c\u5982\u679c\u4e0e\u4e4b\u524d\u5177\u6709\u76f8\u540c\u6216\u66f4\u5c0f\u7684\u5e76\u53d1\u5ea6\uff0c\u6240\u6709\u7684 task \u8bfb\u53d6\u4e4b\u524d\u5df2\u7ecf checkpoint \u8fc7\u7684 state\u3002\u5728\u5e76\u53d1\u5ea6\u4e0a\u5347\u7684\u60c5\u51b5\u4e0b\uff0ctask \u4f1a\u8bfb\u53d6\u672c\u8eab\u7684 state\uff0c\u591a\u51fa\u6765\u7684\u5e76\u53d1 (`p_new` - `p_old`) \u4f1a\u4f7f\u7528\u8f6e\u8be2\u8c03\u5ea6\u7b97\u6cd5\u8bfb\u53d6\u4e4b\u524d task \u7684 state\u3002\n \n-  - **No RocksDB state backend:** Broadcast state is kept in-memory at runtime and memory provisioning should be done \n-accordingly. This holds for all operator states.\n+  - **\u4e0d\u4f7f\u7528 RocksDB state backend\uff1a** broadcast state \u5728\u8fd0\u884c\u65f6\u4fdd\u5b58\u5728\u5185\u5b58\u4e2d\uff0c\u9700\u8981\u4fdd\u8bc1\u5185\u5b58\u5145\u8db3\u3002\u8fd9\u4e00\u7279\u6027\u540c\u6837\u9002\u7528\u4e8e Operator State\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caebbb2978136a5c36059cef6dcfde1b97f26456"}, "originalPosition": 270}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1431, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}