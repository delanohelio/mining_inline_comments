{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDkyNzc5", "number": 12260, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODo0NDozMFrOD-haBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzoyMTozNFrOD_QIPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODg1NjM5OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/sources/TableSourceUtil.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODo0NDozMFrOGYrEfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjo0ODowOFrOGYxgjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDY3MA==", "bodyText": "Actually proctime(    ) should also work, i'm thinking if we can use the Sqlparser to parse the expr first, if we got one SqlUnresolvedFunction with no operands and its name matches proctime, the we can go ahead.", "url": "https://github.com/apache/flink/pull/12260#discussion_r428524670", "createdAt": "2020-05-21T08:44:30Z", "author": {"login": "danny0405"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/sources/TableSourceUtil.scala", "diffHunk": "@@ -238,6 +250,14 @@ object TableSourceUtil {\n     }\n   }\n \n+  private def containsTimeAttribute(tableSchema: TableSchema): Boolean = {\n+    tableSchema.getWatermarkSpecs.nonEmpty || tableSchema.getTableColumns.exists(isProctime)\n+  }\n+\n+  private def isProctime(column: TableColumn): Boolean = {\n+    toScala(column.getExpr).exists(_.equalsIgnoreCase(\"proctime()\"))\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87d0b478bf38fc74639f8ac2c065e4e6d2fc2156"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNDI2NQ==", "bodyText": "It is hard to get Sqlparser too. Obtain parser also creates a circular dependency. It is hard to break it.\nI will remove \" \" for checking.", "url": "https://github.com/apache/flink/pull/12260#discussion_r428534265", "createdAt": "2020-05-21T09:04:49Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/sources/TableSourceUtil.scala", "diffHunk": "@@ -238,6 +250,14 @@ object TableSourceUtil {\n     }\n   }\n \n+  private def containsTimeAttribute(tableSchema: TableSchema): Boolean = {\n+    tableSchema.getWatermarkSpecs.nonEmpty || tableSchema.getTableColumns.exists(isProctime)\n+  }\n+\n+  private def isProctime(column: TableColumn): Boolean = {\n+    toScala(column.getExpr).exists(_.equalsIgnoreCase(\"proctime()\"))\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDY3MA=="}, "originalCommit": {"oid": "87d0b478bf38fc74639f8ac2c065e4e6d2fc2156"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMTIwNA==", "bodyText": "I think this is error-prone. The string compare is not a general solution, I can come up with some corner cases:\n`proctime()`  // quoted\nproctime // function identifier\n\nI think a more general solution is pass a SqlExprToRexConverterFactory (which can creates a SqlExprToRexConverter to get the correct type of an expression) into the CatalogSchemaTable. I know it's verbose to pass it into CatalogSchemaTable, but I don't find other reasonable ways.", "url": "https://github.com/apache/flink/pull/12260#discussion_r428601204", "createdAt": "2020-05-21T11:40:45Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/sources/TableSourceUtil.scala", "diffHunk": "@@ -238,6 +250,14 @@ object TableSourceUtil {\n     }\n   }\n \n+  private def containsTimeAttribute(tableSchema: TableSchema): Boolean = {\n+    tableSchema.getWatermarkSpecs.nonEmpty || tableSchema.getTableColumns.exists(isProctime)\n+  }\n+\n+  private def isProctime(column: TableColumn): Boolean = {\n+    toScala(column.getExpr).exists(_.equalsIgnoreCase(\"proctime()\"))\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDY3MA=="}, "originalCommit": {"oid": "87d0b478bf38fc74639f8ac2c065e4e6d2fc2156"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzMDE1OQ==", "bodyText": "done", "url": "https://github.com/apache/flink/pull/12260#discussion_r428630159", "createdAt": "2020-05-21T12:48:08Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/sources/TableSourceUtil.scala", "diffHunk": "@@ -238,6 +250,14 @@ object TableSourceUtil {\n     }\n   }\n \n+  private def containsTimeAttribute(tableSchema: TableSchema): Boolean = {\n+    tableSchema.getWatermarkSpecs.nonEmpty || tableSchema.getTableColumns.exists(isProctime)\n+  }\n+\n+  private def isProctime(column: TableColumn): Boolean = {\n+    toScala(column.getExpr).exists(_.equalsIgnoreCase(\"proctime()\"))\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDY3MA=="}, "originalCommit": {"oid": "87d0b478bf38fc74639f8ac2c065e4e6d2fc2156"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NjUxMTMzOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/CatalogCalciteSchema.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzoyMTozNFrOGZzz8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzoyMTozNFrOGZzz8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcxNjQ2NQ==", "bodyText": "Could you add a short comment for this field to explain why we need this? The same to CatalogManagerCalciteSchema, CatalogSchemaTable, DatabaseCalciteSchema. For example:\nThe SQL expression converter factory is used to derive correct result type of computed column, because the date type of computed column from catalog table is not trusted.", "url": "https://github.com/apache/flink/pull/12260#discussion_r429716465", "createdAt": "2020-05-25T03:21:34Z", "author": {"login": "wuchong"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/CatalogCalciteSchema.java", "diffHunk": "@@ -42,10 +43,16 @@\n \tprivate final CatalogManager catalogManager;\n \t// Flag that tells if the current planner should work in a batch or streaming mode.\n \tprivate final boolean isStreamingMode;\n+\tprivate final SqlExprToRexConverterFactory converterFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "081a62a66ef0a1b687b10e6b41ed8066b0c7992d"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4527, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}