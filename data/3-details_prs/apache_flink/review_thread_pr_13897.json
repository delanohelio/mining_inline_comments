{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NTE1MjEz", "number": 13897, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzo1MToyOFrOE1iOtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzo1MToyOFrOE1iOtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTcwODA1OnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/MultipleInputNodeCreationProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzo1MToyOFrOHt3CbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzo1MToyOFrOHt3CbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg0OTcwOA==", "bodyText": "a wrapper is the output node if the wrapper is the root of its group ?", "url": "https://github.com/apache/flink/pull/13897#discussion_r517849708", "createdAt": "2020-11-05T07:51:28Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/MultipleInputNodeCreationProcessor.java", "diffHunk": "@@ -283,6 +283,102 @@ private void optimizeMultipleInputGroups(List<ExecNodeWrapper> orderedWrappers)\n \t\t\t\twrapper.removeFromGroup();\n \t\t\t}\n \t\t}\n+\n+\t\t// wrappers are checked in topological order from sinks to sources\n+\t\tfor (ExecNodeWrapper wrapper : orderedWrappers) {\n+\t\t\tMultipleInputGroup group = wrapper.group;\n+\t\t\tif (group == null) {\n+\t\t\t\t// we only consider nodes currently in a multiple input group\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tif (isOutputOfMultipleInputGroup(wrapper) && wrapper.execNode instanceof Union) {\n+\t\t\t\t// optimization 5. this optimization remove redundant union at the output of a\n+\t\t\t\t// multiple input, consider the following graph:\n+\t\t\t\t//\n+\t\t\t\t// source -> exchange -> agg ---\\\n+\t\t\t\t// source -> exchange -> agg --> union ->\n+\t\t\t\t// source -> exchange -> join --/\n+\t\t\t\t// source -> exchange --/\n+\t\t\t\t//\n+\t\t\t\t// we'll initially put aggs, the join and the union into a multiple input, while\n+\t\t\t\t// the union here is actually redundant.\n+\t\t\t\tint numberOfUsefulInputs = 0;\n+\t\t\t\tList<Integer> uselessBranches = new ArrayList<>();\n+\t\t\t\tList<List<ExecNodeWrapper>> sameGroupWrappersList = new ArrayList<>();\n+\n+\t\t\t\t// an input branch is useful if it contains a node with two or more inputs other\n+\t\t\t\t// than union. we shall keep the union if it has two or more useful input branches,\n+\t\t\t\t// as this may benefit source chaining. consider the following example:\n+\t\t\t\t//\n+\t\t\t\t// chainable source -> join -\\\n+\t\t\t\t//                     /      \\\n+\t\t\t\t// chainable source --<        union\n+\t\t\t\t//                     \\      /\n+\t\t\t\t// chainable source -> join -/\n+\t\t\t\tfor (int i = 0; i < wrapper.inputs.size(); i++) {\n+\t\t\t\t\tExecNodeWrapper inputWrapper = wrapper.inputs.get(i);\n+\t\t\t\t\tList<ExecNodeWrapper> sameGroupWrappers = getInputWrappersInSameGroup(inputWrapper, wrapper.group);\n+\t\t\t\t\tsameGroupWrappersList.add(sameGroupWrappers);\n+\t\t\t\t\tlong numberOfValuableNodes = sameGroupWrappers.stream()\n+\t\t\t\t\t\t.filter(w -> w.inputs.size() >= 2 && !(w.execNode instanceof Union))\n+\t\t\t\t\t\t.count();\n+\t\t\t\t\tif (numberOfValuableNodes > 0) {\n+\t\t\t\t\t\tnumberOfUsefulInputs++;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tuselessBranches.add(i);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (numberOfUsefulInputs < 2) {\n+\t\t\t\t\t// remove this union and its useless branches from multiple input\n+\t\t\t\t\tfor (int branch : uselessBranches) {\n+\t\t\t\t\t\tList<ExecNodeWrapper> sameGroupWrappers = sameGroupWrappersList.get(branch);\n+\t\t\t\t\t\tfor (ExecNodeWrapper w : sameGroupWrappers) {\n+\t\t\t\t\t\t\tif (w.group != null) {\n+\t\t\t\t\t\t\t\tw.removeFromGroup();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\twrapper.removeFromGroup();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate List<ExecNodeWrapper> getInputWrappersInSameGroup(ExecNodeWrapper wrapper, MultipleInputGroup group) {\n+\t\tList<ExecNodeWrapper> ret = new ArrayList<>();\n+\t\tQueue<ExecNodeWrapper> queue = new LinkedList<>();\n+\t\tSet<ExecNodeWrapper> visited = new HashSet<>();\n+\t\tqueue.add(wrapper);\n+\t\tvisited.add(wrapper);\n+\n+\t\twhile (!queue.isEmpty()) {\n+\t\t\tExecNodeWrapper w = queue.poll();\n+\t\t\tif (w.group != group) {\n+\t\t\t\t// if a wrapper is not in the required group than its inputs will\n+\t\t\t\t// also not be in the group, so we can just skip it\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tret.add(w);\n+\n+\t\t\tfor (ExecNodeWrapper inputWrapper : w.inputs) {\n+\t\t\t\tif (visited.contains(inputWrapper)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tqueue.add(inputWrapper);\n+\t\t\t\tvisited.add(inputWrapper);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn ret;\n+\t}\n+\n+\tprivate boolean isOutputOfMultipleInputGroup(ExecNodeWrapper wrapper) {\n+\t\tPreconditions.checkNotNull(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458abd54a7cfa9a7a71bdf2f304db0ab65ca2e1f"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4900, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}