{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3OTMxMzg2", "number": 13735, "title": "[FLINK-19533][checkpoint] Add channel state reassignment for unaligned checkpoints.", "bodyText": "What is the purpose of the change\nCurrently, recovery with rescaled channel state is failing. This PR enhances StateAssignmentOperation to reassignment channel state and create a channel state mapping, where channels before rescaling are mapped to channels after rescaling.\nBrief change log\n\nRefactors StateAssignmentOperation in preparation. In particular, it adds a two pass approach such that vertex may assign state of other vertexes.\nAdds ChannelStateRescaler to define rescaling behavior of in-flight data.\nAdds two properties to StreamPartitioner to return the ChannelStateRescaler for upstream and downstream side.\nAdd upstream and downstream ChannelStateRescalers to JobEdge, such that it is accessible to StateAssignmentOperation.\nAdding channel reassignment to StateAssignmentOperation.\n\nVerifying this change\nAdded unit tests. The final rescale PRs will also adapt UnalignedCheckpointITCase to cover rescaling.\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented) (not finished yet)", "createdAt": "2020-10-22T00:09:31Z", "url": "https://github.com/apache/flink/pull/13735", "merged": true, "mergeCommit": {"oid": "a2267fa28a44c4cf4cc906859c5531c94e994bac"}, "closed": true, "closedAt": "2020-11-06T07:03:58Z", "author": {"login": "AHeise"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdU7q3-gBqjM5MDcyMjM2MTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZxdeUgBqjM5NjU4MjMwNjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e081fecba324a0e35017f4b89cc0499c9112a768", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/e081fecba324a0e35017f4b89cc0499c9112a768", "committedDate": "2020-10-21T23:59:47Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "ee73393a13c999be626f7b8b98a170be88a093d9", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/ee73393a13c999be626f7b8b98a170be88a093d9", "committedDate": "2020-10-22T06:06:43Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee73393a13c999be626f7b8b98a170be88a093d9", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/ee73393a13c999be626f7b8b98a170be88a093d9", "committedDate": "2020-10-22T06:06:43Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "committedDate": "2020-10-22T13:37:30Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "committedDate": "2020-10-22T13:37:30Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "committedDate": "2020-10-23T09:12:54Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "committedDate": "2020-10-23T09:12:54Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "458aee4e1d6779beb640f563c7c9b5a65e645237", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/458aee4e1d6779beb640f563c7c9b5a65e645237", "committedDate": "2020-10-23T09:21:24Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "458aee4e1d6779beb640f563c7c9b5a65e645237", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/458aee4e1d6779beb640f563c7c9b5a65e645237", "committedDate": "2020-10-23T09:21:24Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "committedDate": "2020-10-23T09:40:34Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "committedDate": "2020-10-23T09:40:34Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "1b1a34de33af36c301266d175cb72151b1bc51c4", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/1b1a34de33af36c301266d175cb72151b1bc51c4", "committedDate": "2020-10-23T10:29:09Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b1a34de33af36c301266d175cb72151b1bc51c4", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/1b1a34de33af36c301266d175cb72151b1bc51c4", "committedDate": "2020-10-23T10:29:09Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "committedDate": "2020-10-23T13:09:04Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "committedDate": "2020-10-23T13:09:04Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "470d466cfe4455aefd5a302cedd92b57750f2c57", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/470d466cfe4455aefd5a302cedd92b57750f2c57", "committedDate": "2020-10-23T18:44:06Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "470d466cfe4455aefd5a302cedd92b57750f2c57", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/470d466cfe4455aefd5a302cedd92b57750f2c57", "committedDate": "2020-10-23T18:44:06Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "5e5340241b5811243463f96dda7455b2869cf268", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/5e5340241b5811243463f96dda7455b2869cf268", "committedDate": "2020-10-24T10:31:51Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e5340241b5811243463f96dda7455b2869cf268", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/5e5340241b5811243463f96dda7455b2869cf268", "committedDate": "2020-10-24T10:31:51Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "cbc3b0ca32cfbfbf57ab34f85ae12e4f8c0ee4aa", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/cbc3b0ca32cfbfbf57ab34f85ae12e4f8c0ee4aa", "committedDate": "2020-10-24T11:23:36Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "810ab1d9ae47af3e49ae6e3d8d28eaafc7bdf843", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/810ab1d9ae47af3e49ae6e3d8d28eaafc7bdf843", "committedDate": "2020-10-24T18:10:53Z", "message": "Test fix for failing job submissions."}, "afterCommit": {"oid": "88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "committedDate": "2020-10-24T18:15:36Z", "message": "Test fix for failing job submissions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "committedDate": "2020-10-24T18:15:36Z", "message": "Test fix for failing job submissions."}, "afterCommit": {"oid": "25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "committedDate": "2020-10-24T20:22:19Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDMwNjYz", "url": "https://github.com/apache/flink/pull/13735#pullrequestreview-517030663", "createdAt": "2020-10-26T17:47:02Z", "commit": {"oid": "4915d3dded86843b8cfd204433e71c0b6f82c138"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzo0NzowMlrOHobZow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODowMToyNlrOHob91g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1NDAxOQ==", "bodyText": "Removal of @Nonnull is controversial by some. Some people prefer it as cheap, debug mode only assertion. This is because as far as I know, @Nonnull in debug mode, is adding checkNonNull(...) equivalents.\nI personally would be fine by not using them, and I personally I'm not adding them in a new code, but because of the above reason, I would be actually against removing them from a code that someone added (otherwise, we can end up in a ping pong situation when you are removing them and someone else re-adding).", "url": "https://github.com/apache/flink/pull/13735#discussion_r512154019", "createdAt": "2020-10-26T17:47:02Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -63,31 +61,25 @@\n \t/**\n \t * Snapshot from the {@link org.apache.flink.runtime.state.OperatorStateBackend}.\n \t */\n-\t@Nonnull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4915d3dded86843b8cfd204433e71c0b6f82c138"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1ODE0Mw==", "bodyText": "What is the relation between this method/interface and #rescaleIntersections from the Partitioner? Why one returns  int[] and the other BitSet?", "url": "https://github.com/apache/flink/pull/13735#discussion_r512158143", "createdAt": "2020-10-26T17:53:26Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/ChannelRescaler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.api.writer;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import java.io.Serializable;\n+import java.util.BitSet;\n+\n+/**\n+ * The {@link ChannelRescaler} narrows down the channels that need to be read during rescaling to recover from a\n+ * particular channel when in-flight data has been stored in the checkpoint.\n+ */\n+@Internal\n+public interface ChannelRescaler extends Serializable {\n+\t/**\n+\t * Returns all old channel indexes that need to be read to restore all buffers for the given new channel index on\n+\t * rescale.\n+\t */\n+\tBitSet rescaleIntersections(int newChannelIndex, int oldNumberOfChannels, int newNumberOfChannels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51ced4ccaf306b05185f5332983c378cecf73330"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MzI4Ng==", "bodyText": "We need this to support CustomPartitionerWrapper, right? This is @Public interface :( I think we need to think twice before we commit ourselves to such change. Let's sync offline again whether this is really the best/the only way of solving our problem.", "url": "https://github.com/apache/flink/pull/13735#discussion_r512163286", "createdAt": "2020-10-26T18:01:26Z", "author": {"login": "pnowojski"}, "path": "flink-core/src/main/java/org/apache/flink/api/common/functions/Partitioner.java", "diffHunk": "@@ -37,4 +40,20 @@\n \t * @return The partition index.\n \t */\n \tint partition(K key, int numPartitions);\n+\n+\t/**\n+\t * Returns all partitions that need to be read to restore the given new partition. The partitioner is then\n+\t * applied on the key of the restored record to filter all irrelevant records.\n+\t *\n+\t * <p>In particular, to create a partition X after rescaling, all partitions returned by this method are fully read\n+\t * and the key of each record is then fed into {@link #partition(Object, int)} to check if it belongs to X.\n+\t *\n+\t * <p>The default implementation states that all partitions need to be scanned and should be overwritten to improve\n+\t * performance.\n+\t */\n+\t@PublicEvolving\n+\tdefault int[] rescaleIntersections(int newPartition, int oldNumPartitions, int newNumPartitions) {\n+\t\t// any old partition may contain a record that should be in the new partition after rescaling\n+\t\treturn IntStream.range(0, oldNumPartitions).toArray();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51ced4ccaf306b05185f5332983c378cecf73330"}, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "committedDate": "2020-10-24T20:22:19Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "committedDate": "2020-11-03T12:04:45Z", "message": "fixup! [FLINK-19533][runtime/streaming] Add ChannelRescaler to the JobEdge to determine mapping between old and new partitions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "committedDate": "2020-11-03T12:04:45Z", "message": "fixup! [FLINK-19533][runtime/streaming] Add ChannelRescaler to the JobEdge to determine mapping between old and new partitions."}, "afterCommit": {"oid": "626fed37b9dec18c343e10e65308088c532c0dd5", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/626fed37b9dec18c343e10e65308088c532c0dd5", "committedDate": "2020-11-03T12:05:08Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "626fed37b9dec18c343e10e65308088c532c0dd5", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/626fed37b9dec18c343e10e65308088c532c0dd5", "committedDate": "2020-11-03T12:05:08Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/9cbbcb24751268c0b5289b86606eb28baa1287eb", "committedDate": "2020-11-03T12:10:47Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ee428f903154ba04b7e68378252710181d6ea50", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/0ee428f903154ba04b7e68378252710181d6ea50", "committedDate": "2020-11-03T20:18:51Z", "message": "[hotfix][deployment] Fix exceptional control flow in TaskDeploymentDescriptorFactory."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODA4ODA3", "url": "https://github.com/apache/flink/pull/13735#pullrequestreview-522808807", "createdAt": "2020-11-03T19:23:53Z", "commit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyMzo1M1rOHs9QJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDoxOTozNFrOHs_D1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjk1MQ==", "bodyText": "Is it actually channel mapping? I think it actually remaps operator state, doesn't it?\nserialVersionUID?\nI'd rather move this class to a separate file", "url": "https://github.com/apache/flink/pull/13735#discussion_r516902951", "createdAt": "2020-11-03T19:23:53Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDc2OA==", "bodyText": "Why bitsets are used here and throughout the PR?\nI think just Set<Integer> would be\na) more readable\nb) more efficient (no need for extra words if only high bits are sets)", "url": "https://github.com/apache/flink/pull/13735#discussion_r516904768", "createdAt": "2020-11-03T19:27:11Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjU1MQ==", "bodyText": "To me, list isn't an obvious choice to provide index-based access.\nArray or hashtable would be more readable to me and guarantee O(1) time.", "url": "https://github.com/apache/flink/pull/13735#discussion_r516906551", "createdAt": "2020-11-03T19:30:16Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwODE1OQ==", "bodyText": "PartitionMapping associates with the ResultPartition, but this class maps input channels and subPartitions, right? How about RescaledChannelsMapping?\nserialVersionUID?\nnit: I'd extract this class too", "url": "https://github.com/apache/flink/pull/13735#discussion_r516908159", "createdAt": "2020-11-03T19:33:18Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;\n+\n+\t\tpublic VirtualChannelMapping(BitSet oldTaskInstances, List<PartitionMapping> partitionMappings) {\n+\t\t\tthis.oldTaskInstances = oldTaskInstances;\n+\t\t\tthis.partitionMappings = partitionMappings;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tfinal VirtualChannelMapping that = (VirtualChannelMapping) o;\n+\t\t\treturn oldTaskInstances.equals(that.oldTaskInstances) &&\n+\t\t\t\tpartitionMappings.equals(that.partitionMappings);\n+\t\t}\n+\n+\t\tpublic int[] getOldTaskInstances(int defaultSubtask) {\n+\t\t\treturn oldTaskInstances.equals(NO_SUBTASKS) ?\n+\t\t\t\tnew int[] {defaultSubtask} :\n+\t\t\t\toldTaskInstances.stream().toArray();\n+\t\t}\n+\n+\t\tpublic PartitionMapping getPartitionMapping(int partitionIndex) {\n+\t\t\tif (partitionMappings.isEmpty()) {\n+\t\t\t\treturn NO_CHANNEL_MAPPING;\n+\t\t\t}\n+\t\t\treturn partitionMappings.get(partitionIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(oldTaskInstances, partitionMappings);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"VirtualChannelMapping{\" +\n+\t\t\t\t\"oldTaskInstances=\" + oldTaskInstances +\n+\t\t\t\t\", partitionMappings=\" + partitionMappings +\n+\t\t\t\t'}';\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+\t */\n+\tpublic static class PartitionMapping implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTI2Ng==", "bodyText": "Again, the choice of data structures isn't obvious. Why not Map<Int, Int>?\n(ditto oldToNewChannelIndexes)", "url": "https://github.com/apache/flink/pull/13735#discussion_r516909266", "createdAt": "2020-11-03T19:35:17Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;\n+\n+\t\tpublic VirtualChannelMapping(BitSet oldTaskInstances, List<PartitionMapping> partitionMappings) {\n+\t\t\tthis.oldTaskInstances = oldTaskInstances;\n+\t\t\tthis.partitionMappings = partitionMappings;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tfinal VirtualChannelMapping that = (VirtualChannelMapping) o;\n+\t\t\treturn oldTaskInstances.equals(that.oldTaskInstances) &&\n+\t\t\t\tpartitionMappings.equals(that.partitionMappings);\n+\t\t}\n+\n+\t\tpublic int[] getOldTaskInstances(int defaultSubtask) {\n+\t\t\treturn oldTaskInstances.equals(NO_SUBTASKS) ?\n+\t\t\t\tnew int[] {defaultSubtask} :\n+\t\t\t\toldTaskInstances.stream().toArray();\n+\t\t}\n+\n+\t\tpublic PartitionMapping getPartitionMapping(int partitionIndex) {\n+\t\t\tif (partitionMappings.isEmpty()) {\n+\t\t\t\treturn NO_CHANNEL_MAPPING;\n+\t\t\t}\n+\t\t\treturn partitionMappings.get(partitionIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(oldTaskInstances, partitionMappings);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"VirtualChannelMapping{\" +\n+\t\t\t\t\"oldTaskInstances=\" + oldTaskInstances +\n+\t\t\t\t\", partitionMappings=\" + partitionMappings +\n+\t\t\t\t'}';\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+\t */\n+\tpublic static class PartitionMapping implements Serializable {\n+\n+\t\t/**\n+\t\t * For each new channel (=index), all old channels are set.\n+\t\t */\n+\t\tprivate final List<BitSet> newToOldChannelIndexes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzE4Mw==", "bodyText": "IIUC, this is a cache, right?\nI doubt that we really need it: it's only used on re/starts and can save maybe hundreds of ms with DOP=1K. And without it, the code would be much simpler.\nWDYT?", "url": "https://github.com/apache/flink/pull/13735#discussion_r516913183", "createdAt": "2020-11-03T19:42:34Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -67,29 +83,33 @@\n \tprivate final long restoreCheckpointId;\n \tprivate final boolean allowNonRestoredState;\n \n+\tprivate final Map<IntermediateResult, TaskStateAssignment> consumerAssignment = new HashMap<>();\n+\tprivate final Map<ChannelStateRescaler, ChannelRescalerRepartitioner<Object>> rescalerRepartitioners =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDc3OA==", "bodyText": "I wonder if this put can override existing assignment (e.g. with a UnionGate).\nIntermediateResult use as a key doesn't override equals/hashCode - is it intentional?", "url": "https://github.com/apache/flink/pull/13735#discussion_r516914778", "createdAt": "2020-11-03T19:45:30Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -99,32 +119,40 @@ public void assignStates() {\n \t\t\t\t\t\toperatorID,\n \t\t\t\t\t\texecutionJobVertex.getParallelism(),\n \t\t\t\t\t\texecutionJobVertex.getMaxParallelism());\n-\t\t\t\t} else if (operatorState.getNumberCollectedStates() > 0) {\n-\t\t\t\t\tstatelessSubTasks = false;\n \t\t\t\t}\n-\t\t\t\toperatorStates.add(operatorState);\n+\t\t\t\toperatorStates.put(operatorIDPair.getGeneratedOperatorID(), operatorState);\n \t\t\t}\n-\t\t\tif (!statelessSubTasks) { // skip tasks where no operator has any state\n-\t\t\t\tassignAttemptState(executionJobVertex, operatorStates);\n+\n+\t\t\tfinal TaskStateAssignment stateAssignment = new TaskStateAssignment(executionJobVertex,\toperatorStates);\n+\t\t\tvertexAssignments.put(executionJobVertex, stateAssignment);\n+\t\t\tfor (final IntermediateResult producedDataSet : executionJobVertex.getInputs()) {\n+\t\t\t\tconsumerAssignment.put(producedDataSet, stateAssignment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA==", "bodyText": "It would ease review if this class was introduced in a separate refactoring commit (though it's probably too difficult at this stage)\nCan we extract this class to a separate file?", "url": "https://github.com/apache/flink/pull/13735#discussion_r516916568", "createdAt": "2020-11-03T19:48:57Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -620,18 +758,112 @@ private static void checkStateMappingCompleteness(\n \t\t\tchainOpParallelStates,\n \t\t\toldParallelism,\n \t\t\tnewParallelism);\n+\t}\n+\n+\tstatic class TaskStateAssignment {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 631}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODU2Mw==", "bodyText": "This doesn't compile (cannot find symbol getInputChannelMappings)\nProbably makes sense to extract testing methods (unless it's a temporary method)", "url": "https://github.com/apache/flink/pull/13735#discussion_r516918563", "createdAt": "2020-11-03T19:52:32Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -725,6 +727,15 @@ public void deploy() throws JobException {\n \t\t\tLOG.info(\"Deploying {} (attempt #{}) with attempt id {} to {} with allocation id {}\", vertex.getTaskNameWithSubtaskIndex(),\n \t\t\t\tattemptNumber, vertex.getCurrentExecutionAttempt().getAttemptId(), getAssignedResourceLocation(), slot.getAllocationId());\n \n+\t\t\tif (taskRestore != null) {\n+\t\t\t\tcheckState(taskRestore.getTaskStateSnapshot().getSubtaskStateMappings().stream().allMatch(entry ->\n+\t\t\t\t\tentry.getValue().getInputChannelMappings().stream()\n+\t\t\t\t\t\t.allMatch(mapping -> mapping.equals(OperatorSubtaskState.VirtualChannelMapping.NO_MAPPING)) &&\n+\t\t\t\t\t\tentry.getValue().getOutputChannelMappings().stream()\n+\t\t\t\t\t\t\t.allMatch(mapping -> mapping.equals(OperatorSubtaskState.VirtualChannelMapping.NO_MAPPING))\n+\t\t\t\t), \"Rescaling from unaligned checkpoint is not yet supported.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzg1NQ==", "bodyText": "You probably should serialize this field and add it to the equals/hashCode.", "url": "https://github.com/apache/flink/pull/13735#discussion_r516923855", "createdAt": "2020-11-03T20:02:09Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/state/AbstractChannelStateHandle.java", "diffHunk": "@@ -46,6 +46,11 @@\n \tprivate final List<Long> offsets;\n \tprivate final long size;\n \n+\t/**\n+\t * The original subtask index before rescaling recovery.\n+\t */\n+\tprivate int originalSubtaskIndex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNTgwOA==", "bodyText": "Why isn't channel state distributed to the same subtask as before (or 1st if out of range)?\n(ditto upstream)\nShouldn't recovered buffers sent from the upstream match what is on the downstream?", "url": "https://github.com/apache/flink/pull/13735#discussion_r516925808", "createdAt": "2020-11-03T20:05:55Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/ForwardPartitioner.java", "diffHunk": "@@ -43,4 +44,14 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \tpublic String toString() {\n \t\treturn \"FORWARD\";\n \t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getUpstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;\n+\t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.ROUND_ROBIN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyODk1Nw==", "bodyText": "How about storing a reference to the downstream/upstream TaskStateAssignment and get the mappings from there?\nI think it would be more readable.", "url": "https://github.com/apache/flink/pull/13735#discussion_r516928957", "createdAt": "2020-11-03T20:12:07Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -620,18 +758,112 @@ private static void checkStateMappingCompleteness(\n \t\t\tchainOpParallelStates,\n \t\t\toldParallelism,\n \t\t\tnewParallelism);\n+\t}\n+\n+\tstatic class TaskStateAssignment {\n+\t\tfinal ExecutionJobVertex executionJobVertex;\n+\t\tfinal Map<OperatorID, OperatorState> oldState;\n+\t\tfinal boolean hasState;\n+\t\tfinal int newParallelism;\n+\t\tfinal OperatorID inputOperatorID;\n+\t\tfinal OperatorID outputOperatorID;\n+\n+\t\tfinal Map<OperatorInstanceID, List<OperatorStateHandle>> subManagedOperatorState;\n+\t\tfinal Map<OperatorInstanceID, List<OperatorStateHandle>> subRawOperatorState;\n+\t\tfinal Map<OperatorInstanceID, List<KeyedStateHandle>> subManagedKeyedState;\n+\t\tfinal Map<OperatorInstanceID, List<KeyedStateHandle>> subRawKeyedState;\n+\n+\t\tfinal Map<OperatorInstanceID, List<InputChannelStateHandle>> inputChannelStates;\n+\t\tfinal Map<OperatorInstanceID, List<ResultSubpartitionStateHandle>> resultSubpartitionStates;\n+\t\t/** The subpartitions mappings per partition set when the output operator for a partition was rescaled. */\n+\t\tList<BitSet> outputOperatorInstanceMappings = emptyList();\n+\t\t/** The input channel mappings per input set when the input operator for a gate was rescaled. */\n+\t\tList<BitSet> inputOperatorInstanceMappings = emptyList();\n+\t\t/** The subpartitions mappings of the upstream task per input set when its output operator was rescaled. */\n+\t\tfinal Map<Integer, List<BitSet>> upstreamVirtualChannels;\n+\t\t/** The input channel mappings of the downstream task per partition set when its input operator was rescaled. */\n+\t\tfinal Map<Integer, List<BitSet>> downStreamVirtualChannels;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 653}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMDYzNQ==", "bodyText": "I'm probably misunderstanding it, but it seems it should be the opposite:\nupstream: ROUND_ROBING (or both FIRST)\ndownstream: FIRST_CHANNEL", "url": "https://github.com/apache/flink/pull/13735#discussion_r516930635", "createdAt": "2020-11-03T20:15:26Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/GlobalPartitioner.java", "diffHunk": "@@ -40,6 +41,16 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \t\treturn this;\n \t}\n \n+\t@Override\n+\tpublic ChannelStateRescaler getUpstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;\n+\t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.ROUND_ROBIN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMjU2Ng==", "bodyText": "OK now I see why the Rescalers used seemed inverted to me :)\nSo why is it inverted here? (maybe add a comment?)", "url": "https://github.com/apache/flink/pull/13735#discussion_r516932566", "createdAt": "2020-11-03T20:19:34Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -692,6 +692,8 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \t\t}\n \t\t// set strategy name so that web interface can show it.\n \t\tjobEdge.setShipStrategyName(partitioner.toString());\n+\t\tjobEdge.setDownstreamChannelStateRescaler(partitioner.getUpstreamChannelStateRescaler());\n+\t\tjobEdge.setUpstreamChannelStateRescaler(partitioner.getDownstreamChannelStateRescaler());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f3def2083865476155570e53910962f3ecd1b56", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/0f3def2083865476155570e53910962f3ecd1b56", "committedDate": "2020-11-03T20:51:36Z", "message": "[hotfix][tests] Remove unused methods in ChannelPersistenceITCase."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbbf00c155253f4b646d529186533bbb0a9b97d6", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/cbbf00c155253f4b646d529186533bbb0a9b97d6", "committedDate": "2020-11-03T20:51:39Z", "message": "[hotfix][util] Fix Precondition#checkNotNull annotations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e28739d48218fe1c085a4eb6aee8c52e2b08fd9", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/6e28739d48218fe1c085a4eb6aee8c52e2b08fd9", "committedDate": "2020-11-03T20:51:39Z", "message": "[hotfix][tests] Chain unexpected exception to assertion error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7139e2595f2dd3415c5cc30877fc9dd1aa003a43", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7139e2595f2dd3415c5cc30877fc9dd1aa003a43", "committedDate": "2020-11-03T20:51:39Z", "message": "[hotfix][core] InstantiationUtil#serializeObject creates ObjectOutputStream only when necessary."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59aa5bcf5e346746b68ca08d7bf7c9f1b94bd08a", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/59aa5bcf5e346746b68ca08d7bf7c9f1b94bd08a", "committedDate": "2020-11-04T23:56:36Z", "message": "[hotfix][checkpoint/test] Don't swallow the original exception when cleanup fails as well."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ee4d7726fedfffea6c37939111ab5bfe09d41d7", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/2ee4d7726fedfffea6c37939111ab5bfe09d41d7", "committedDate": "2020-11-04T23:56:49Z", "message": "[FLINK-19533][checkpoint] Rewrite StateAssignmentOperation to only use generated OperatorID."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "261321d5f60428d1375f824f8cf368acef43542e", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/261321d5f60428d1375f824f8cf368acef43542e", "committedDate": "2020-11-04T23:56:49Z", "message": "[FLINK-19533][checkpoint] Introduce builder for OperatorSubtaskState.\n\nThe builder will make it easier to add more fields to OperatorSubtaskState in future commits."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0842a69cf1832599e0259c456398b18577137dc1", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/0842a69cf1832599e0259c456398b18577137dc1", "committedDate": "2020-11-04T23:56:49Z", "message": "[hotfix][checkpoint] Remove NonNull annotations and remove trivial doc in OperatorSubtaskState."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/9cbbcb24751268c0b5289b86606eb28baa1287eb", "committedDate": "2020-11-03T12:10:47Z", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "committedDate": "2020-11-05T00:50:14Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MTUwMDU1", "url": "https://github.com/apache/flink/pull/13735#pullrequestreview-524150055", "createdAt": "2020-11-05T11:03:35Z", "commit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMTowMzozNVrOHt-LYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMToyMjo0NVrOHt-1RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk2NjY5MQ==", "bodyText": "This will not distribute state to the newer tasks in case of up-scaling, right?\nI think it can cause problems if the user-supplied partitioner relies on the new DOP.\nOTH, if not supported officially, we can leave it as it.\nWDYT?", "url": "https://github.com/apache/flink/pull/13735#discussion_r517966691", "createdAt": "2020-11-05T11:03:35Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/CustomPartitionerWrapper.java", "diffHunk": "@@ -55,6 +56,14 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \t\treturn partitioner.partition(key, numberOfChannels);\n \t}\n \n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\t// fully rely on filtering downstream\n+\t\t// note that custom partitioners are not officially supported - the user has to force rescaling\n+\t\t// in that case, we assume that the custom partitioner is deterministic\n+\t\treturn ChannelStateRescaler.BROADCAST;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3MzczMA==", "bodyText": "Is FIRST_CHANNEL here (i.e. during the assignment) the same as in selectChannel (i.e. during sending the data)?\nIn other words, I think this will put all InputChannel state into a single subtask, while it should go to the same subtasks as before the rescaling.\nWDYT?", "url": "https://github.com/apache/flink/pull/13735#discussion_r517973730", "createdAt": "2020-11-05T11:16:05Z", "author": {"login": "rkhachatryan"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/ForwardPartitioner.java", "diffHunk": "@@ -43,4 +44,9 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \tpublic String toString() {\n \t\treturn \"FORWARD\";\n \t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NDY3Mw==", "bodyText": "I think this field needs to be (de)serialized by MetadataSerializer as other fields are.\n(ditto outputRescalingDescriptor)", "url": "https://github.com/apache/flink/pull/13735#discussion_r517974673", "createdAt": "2020-11-05T11:17:52Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -64,81 +61,64 @@\n \t/**\n \t * Snapshot from the {@link org.apache.flink.runtime.state.OperatorStateBackend}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<OperatorStateHandle> managedOperatorState;\n \n \t/**\n \t * Snapshot written using {@link org.apache.flink.runtime.state.OperatorStateCheckpointOutputStream}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<OperatorStateHandle> rawOperatorState;\n \n \t/**\n \t * Snapshot from {@link org.apache.flink.runtime.state.KeyedStateBackend}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<KeyedStateHandle> managedKeyedState;\n \n \t/**\n \t * Snapshot written using {@link org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<KeyedStateHandle> rawKeyedState;\n \n-\t@Nonnull\n \tprivate final StateObjectCollection<InputChannelStateHandle> inputChannelState;\n \n-\t@Nonnull\n \tprivate final StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState;\n \n \t/**\n-\t * The state size. This is also part of the deserialized state handle.\n-\t * We store it here in order to not deserialize the state handle when\n-\t * gathering stats.\n+\t * The subpartitions mappings per partition set when the output operator for a partition was rescaled. The key is\n+\t * the partition id and the value contains all subtask indexes of the output operator before rescaling.\n \t */\n-\tprivate final long stateSize;\n+\tprivate final InflightDataRescalingDescriptor inputRescalingDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NTg0MA==", "bodyText": "nit:\nThis field makes this class non-thread-safe, which is not obvious for a pre-computed mapping.\nSo I'd mark this class @NotThreadSafe.", "url": "https://github.com/apache/flink/pull/13735#discussion_r517975840", "createdAt": "2020-11-05T11:19:59Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/RescaledChannelsMapping.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+ */\n+public class RescaledChannelsMapping implements Serializable {\n+\tpublic static final RescaledChannelsMapping NO_CHANNEL_MAPPING = new RescaledChannelsMapping(emptyMap());\n+\n+\tprivate static final long serialVersionUID = -8719670050630674631L;\n+\n+\t/**\n+\t * For each new channel (=index), all old channels are set.\n+\t */\n+\tprivate final Map<Integer, Set<Integer>> newToOldChannelIndexes;\n+\n+\t/**\n+\t * For each old channel (=index), all new channels are set. Lazily calculated to keep {@link OperatorSubtaskState}\n+\t * small in terms of serialization cost.\n+\t */\n+\tprivate transient Map<Integer, Set<Integer>> oldToNewChannelIndexes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzQxMw==", "bodyText": "nit:\nAfter removing the higher level cache, this field can also be computed eagerly think (as it will be used anyways if the is being object is constructed).", "url": "https://github.com/apache/flink/pull/13735#discussion_r517977413", "createdAt": "2020-11-05T11:22:45Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ChannelRescalerRepartitioner.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.io.network.api.writer.ChannelStateRescaler;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * A repartitioner that assigns the same channel state to multiple subtasks according to some mapping.\n+ *\n+ * <p>The replicated data will then be filtered before processing the record.\n+ *\n+ * <p>Note that channel mappings are cached for the same parallelism changes.\n+ */\n+public class ChannelRescalerRepartitioner<T> implements OperatorStateRepartitioner<T> {\n+\tprivate final ChannelStateRescaler channelStateRescaler;\n+\tprivate final Map<Tuple2<Integer, Integer>, Map<Integer, Set<Integer>>> newToOldMappingCache = new HashMap<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjc0MzA5", "url": "https://github.com/apache/flink/pull/13735#pullrequestreview-524274309", "createdAt": "2020-11-05T13:46:43Z", "commit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo0Njo0M1rOHuD-xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo0Njo0M1rOHuD-xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA2MTc2Ng==", "bodyText": "(nit) I was a bit confused by this method. Maybe this version would be more readable:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Map<Integer, Set<Integer>> newToOldMapping = getNewToOldMapping(oldParallelism, newParallelism);\n          \n          \n            \n            \t\treturn IntStream.range(0, newParallelism)\n          \n          \n            \n            \t\t\t.mapToObj(newIndex -> getOldState(previousParallelSubtaskStates, newToOldMapping.get(newIndex)))\n          \n          \n            \n            \t\t\t.collect(Collectors.toList());\n          \n          \n            \n            \t\treturn getNewToOldMapping(oldParallelism, newParallelism)\n          \n          \n            \n            \t\t\t.entrySet().stream()\n          \n          \n            \n            \t\t\t.sorted(Comparator.comparingInt(Map.Entry::getKey)).map(Map.Entry::getValue)\n          \n          \n            \n            \t\t\t.map(oldIndices -> getOldState(previousParallelSubtaskStates, oldIndices))\n          \n          \n            \n            \t\t\t.collect(Collectors.toList());", "url": "https://github.com/apache/flink/pull/13735#discussion_r518061766", "createdAt": "2020-11-05T13:46:43Z", "author": {"login": "rkhachatryan"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ChannelRescalerRepartitioner.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.io.network.api.writer.ChannelStateRescaler;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * A repartitioner that assigns the same channel state to multiple subtasks according to some mapping.\n+ *\n+ * <p>The replicated data will then be filtered before processing the record.\n+ *\n+ * <p>Note that channel mappings are cached for the same parallelism changes.\n+ */\n+public class ChannelRescalerRepartitioner<T> implements OperatorStateRepartitioner<T> {\n+\tprivate final ChannelStateRescaler channelStateRescaler;\n+\tprivate final Map<Tuple2<Integer, Integer>, Map<Integer, Set<Integer>>> newToOldMappingCache = new HashMap<>(2);\n+\n+\tpublic ChannelRescalerRepartitioner(ChannelStateRescaler channelStateRescaler) {\n+\t\tthis.channelStateRescaler = channelStateRescaler;\n+\t}\n+\n+\tprivate static <T> List<T> getOldState(List<List<T>> previousParallelSubtaskStates, Set<Integer> oldIndexes) {\n+\t\tswitch (oldIndexes.size()) {\n+\t\t\tcase 0:\n+\t\t\t\treturn Collections.emptyList();\n+\t\t\tcase 1:\n+\t\t\t\treturn previousParallelSubtaskStates.get(Iterables.getOnlyElement(oldIndexes));\n+\t\t\tdefault:\n+\t\t\t\treturn oldIndexes.stream()\n+\t\t\t\t\t.flatMap(oldIndex -> previousParallelSubtaskStates.get(oldIndex).stream())\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t}\n+\t}\n+\n+\tprotected Map<Integer, Set<Integer>> createNewToOldMapping(int oldParallelism, int newParallelism) {\n+\t\treturn IntStream.range(0, newParallelism).boxed().\n+\t\t\tcollect(Collectors.toMap(\n+\t\t\t\tFunction.identity(),\n+\t\t\t\tchannelIndex -> channelStateRescaler.getOldChannels(\n+\t\t\t\t\tchannelIndex,\n+\t\t\t\t\toldParallelism,\n+\t\t\t\t\tnewParallelism)));\n+\t}\n+\n+\t@Override\n+\tpublic List<List<T>> repartitionState(\n+\t\t\tList<List<T>> previousParallelSubtaskStates,\n+\t\t\tint oldParallelism,\n+\t\t\tint newParallelism) {\n+\t\tfinal Map<Integer, Set<Integer>> newToOldMapping = getNewToOldMapping(oldParallelism, newParallelism);\n+\t\treturn IntStream.range(0, newParallelism)\n+\t\t\t.mapToObj(newIndex -> getOldState(previousParallelSubtaskStates, newToOldMapping.get(newIndex)))\n+\t\t\t.collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406c9c98283632db5387f39783cab997c1a7e39c", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/406c9c98283632db5387f39783cab997c1a7e39c", "committedDate": "2020-11-05T16:37:14Z", "message": "[FLINK-19533][runtime/streaming] Add SubtaskStateMapper to determine mapping between old and new subtasks.\n\nEach partitioner has a unique way to partition data. Only the partitioner can narrow down the state of old subtasks needed to recover the data on upstream and downstream side.\n\nNote that the mapper may create non-unique mappings during unaligned checkpoint rescaling. The replicated data will then be filtered by the partitioner downstream during recovery."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7575c9ee7672e5ea2eed72d6ca035e78720a662c", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/7575c9ee7672e5ea2eed72d6ca035e78720a662c", "committedDate": "2020-11-05T16:37:14Z", "message": "[FLINK-19533][checkpoint] Adding subtask index to channel state handles.\n\nDuring downscaled recovery of in-flight data, multiple channel state handles are recovered at the same subtask and the subtask index is needed to distinguish between them."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8af2e7d13178bc0cfebbbb98d9768cc03095a9a6", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/8af2e7d13178bc0cfebbbb98d9768cc03095a9a6", "committedDate": "2020-11-05T16:37:14Z", "message": "[FLINK-19533][checkpoint] Add TaskStateAssignment to capture all intermediate state of StateAssignmentOperation.\n\nTaskStateAssignment encapsulates the state of one task and is ultimately transformed into an OperatorSubtaskState.\n\nNote this commit also removes ChannelStateNoRescalingPartitionerTest since it's not valid at the end of the PR anymore."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8777cdb0c35cd13da2c8688959a177cb2f668513", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/8777cdb0c35cd13da2c8688959a177cb2f668513", "committedDate": "2020-11-05T16:37:14Z", "message": "[FLINK-19533][checkpoint] Add multipass StateAssignmentOperation.\n\nThis change allows StateAssignmentOperation to update the state assignment of one task while processing another task. The next commit will use it to set rescaling descriptor of upstream/downstream nodes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "committedDate": "2020-11-05T00:50:14Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR."}, "afterCommit": {"oid": "c95db355becc1079be6287aa7d165e7590f9fcf6", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/c95db355becc1079be6287aa7d165e7590f9fcf6", "committedDate": "2020-11-05T16:37:14Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NzUxNjAz", "url": "https://github.com/apache/flink/pull/13735#pullrequestreview-524751603", "createdAt": "2020-11-05T23:26:47Z", "commit": {"oid": "c95db355becc1079be6287aa7d165e7590f9fcf6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "031ba1603f4a06de8a7f22aa44c1413eed29d342", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/031ba1603f4a06de8a7f22aa44c1413eed29d342", "committedDate": "2020-11-06T07:02:41Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41eec32a668007731ae1bf33fa0fe7feb5224d07", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/41eec32a668007731ae1bf33fa0fe7feb5224d07", "committedDate": "2020-11-06T07:02:17Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling."}, "afterCommit": {"oid": "031ba1603f4a06de8a7f22aa44c1413eed29d342", "author": {"user": {"login": "AHeise", "name": "Arvid Heise"}}, "url": "https://github.com/apache/flink/commit/031ba1603f4a06de8a7f22aa44c1413eed29d342", "committedDate": "2020-11-06T07:02:41Z", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3007, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}