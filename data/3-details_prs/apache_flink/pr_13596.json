{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNjU1Njc3", "number": 13596, "title": "[FLINK-19475] Implement a time service for the batch execution mode", "bodyText": "What is the purpose of the change\nI introduce a BatchExecutionInternalTimeServiceManager and\nBatchExecutionInternalTimeService which can be used in the batch\nexecution mode along with the BatchExecutionStateBackend. These services\nonly ever keep state for a single key at a time. They assume a perfect\nWatermark and fire timers only upon switching the current key. Therefore\nthey require the input to be sorted/grouped by the key.\nVerifying this change\nThis change added tests and can be verified as follows:\n\ntests in BatchExecutionInternalTimeServiceTest\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-10-12T15:36:02Z", "url": "https://github.com/apache/flink/pull/13596", "merged": true, "mergeCommit": {"oid": "eda211154f6735eca3e0c9c70ae617c388ef057c"}, "closed": true, "closedAt": "2020-10-14T10:55:16Z", "author": {"login": "dawidwys"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSDirgAFqTUwNzE0NjQ0OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSYVXkABqjM4NzUxOTMxNjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTQ2NDQ5", "url": "https://github.com/apache/flink/pull/13596#pullrequestreview-507146449", "createdAt": "2020-10-13T07:34:56Z", "commit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzozNDo1NlrOHgZNaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzozNDo1NlrOHgZNaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ==", "bodyText": "This relies on setCurrentKey only being called for key changes, not on every element, right?", "url": "https://github.com/apache/flink/pull/13596#discussion_r503729515", "createdAt": "2020-10-13T07:34:56Z", "author": {"login": "aljoscha"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeService.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimerHeapInternalTimer;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.function.BiConsumerWithException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An implementation of a {@link InternalTimerService} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeService<K, N> implements InternalTimerService<N> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\t/**\n+\t * Processing time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> processingTimeTimersQueue;\n+\n+\t/**\n+\t * Event time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> eventTimeTimersQueue;\n+\n+\t/**\n+\t * The local event time, as denoted by the last received\n+\t * {@link org.apache.flink.streaming.api.watermark.Watermark Watermark}.\n+\t */\n+\tprivate long currentWatermark = Long.MIN_VALUE;\n+\n+\tprivate final Triggerable<K, N> triggerTarget;\n+\n+\tprivate K currentKey;\n+\n+\tBatchExecutionInternalTimeService(\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tTriggerable<K, N> triggerTarget) {\n+\n+\t\tthis.processingTimeService = checkNotNull(processingTimeService);\n+\t\tthis.triggerTarget = checkNotNull(triggerTarget);\n+\n+\t\tthis.processingTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t\tthis.eventTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic long currentProcessingTime() {\n+\t\treturn processingTimeService.getCurrentProcessingTime();\n+\t}\n+\n+\t@Override\n+\tpublic long currentWatermark() {\n+\t\treturn currentWatermark;\n+\t}\n+\n+\t@Override\n+\tpublic void registerProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void registerEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void forEachEventTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\t@Override\n+\tpublic void forEachProcessingTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\tpublic void setCurrentKey(K currentKey) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MjUzOTM3", "url": "https://github.com/apache/flink/pull/13596#pullrequestreview-507253937", "createdAt": "2020-10-13T09:41:49Z", "commit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo0MTo1MFrOHgeTjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo0ODo1OVrOHgemKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzAwNg==", "bodyText": "I would add a checkNotNull().", "url": "https://github.com/apache/flink/pull/13596#discussion_r503813006", "createdAt": "2020-10-13T09:41:50Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -174,6 +176,14 @@ public StateBackend getStateBackend() {\n \t\treturn this.stateBackend;\n \t}\n \n+\tpublic InternalTimeServiceManager.Provider getTimerServiceProvider() {\n+\t\treturn timerServiceProvider;\n+\t}\n+\n+\tpublic void setTimerServiceProvider(InternalTimeServiceManager.Provider timerServiceProvider) {\n+\t\tthis.timerServiceProvider = timerServiceProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzY5Mw==", "bodyText": "What about a checkNotNull?", "url": "https://github.com/apache/flink/pull/13596#discussion_r503813693", "createdAt": "2020-10-13T09:42:52Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeServiceManager.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyedStateBackend;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.operators.InternalTimeServiceManager;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.KeyContext;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.WrappingRuntimeException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of a {@link InternalTimeServiceManager} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeServiceManager<K> implements InternalTimeServiceManager<K>,\n+\t\tKeyedStateBackend.KeySelectionListener<K> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\tprivate final Map<String, BatchExecutionInternalTimeService<K, ?>> timerServices = new HashMap<>();\n+\n+\tpublic BatchExecutionInternalTimeServiceManager(ProcessingTimeService processingTimeService) {\n+\t\tthis.processingTimeService = processingTimeService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNDA3Mw==", "bodyText": "This could be a checkState right?", "url": "https://github.com/apache/flink/pull/13596#discussion_r503814073", "createdAt": "2020-10-13T09:43:28Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeServiceManager.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyedStateBackend;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.operators.InternalTimeServiceManager;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.KeyContext;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.WrappingRuntimeException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of a {@link InternalTimeServiceManager} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeServiceManager<K> implements InternalTimeServiceManager<K>,\n+\t\tKeyedStateBackend.KeySelectionListener<K> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\tprivate final Map<String, BatchExecutionInternalTimeService<K, ?>> timerServices = new HashMap<>();\n+\n+\tpublic BatchExecutionInternalTimeServiceManager(ProcessingTimeService processingTimeService) {\n+\t\tthis.processingTimeService = processingTimeService;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tBatchExecutionInternalTimeService<K, N> timerService =\n+\t\t\t(BatchExecutionInternalTimeService<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\t\t\ttimerService = new BatchExecutionInternalTimeService<>(\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\ttriggerable\n+\t\t\t);\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@Override\n+\tpublic void advanceWatermark(Watermark watermark) {\n+\t\tif (watermark.getTimestamp() == Long.MAX_VALUE) {\n+\t\t\tkeySelected(null);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void snapshotState(\n+\t\t\tStateSnapshotContext context,\n+\t\t\tString operatorName) throws Exception {\n+\t\tthrow new UnsupportedOperationException(\"Checkpoints are not supported in BATCH execution\");\n+\t}\n+\n+\tpublic static <K> InternalTimeServiceManager<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) {\n+\t\tif (!(keyedStatedBackend instanceof BatchExecutionKeyedStateBackend)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNzc2OA==", "bodyText": "Had the same comment as @aljoscha plus, shouldn't we here prevent the user-code from registering any new timers? If not, it looks like we risk ending up in a loop where every fired timer will register a new one, right?\nWe can simply add in the register timer if(watermark ==Long.MAX) -> ignore or sth like that. Same for processing time (and I think it is ok to check again the watermark).\nIn addition, we are relying on each key being processed in its entirety and then move to the next, which is totally valid. In this case, I think we should somehow disable the DataStreamUtils.reinterpretAsKeyedStream() for batch because, if I am not mistaken, it messes things up, right? Maybe at another ticket @dawidwys ?", "url": "https://github.com/apache/flink/pull/13596#discussion_r503817768", "createdAt": "2020-10-13T09:48:59Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeService.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimerHeapInternalTimer;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.function.BiConsumerWithException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An implementation of a {@link InternalTimerService} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeService<K, N> implements InternalTimerService<N> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\t/**\n+\t * Processing time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> processingTimeTimersQueue;\n+\n+\t/**\n+\t * Event time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> eventTimeTimersQueue;\n+\n+\t/**\n+\t * The local event time, as denoted by the last received\n+\t * {@link org.apache.flink.streaming.api.watermark.Watermark Watermark}.\n+\t */\n+\tprivate long currentWatermark = Long.MIN_VALUE;\n+\n+\tprivate final Triggerable<K, N> triggerTarget;\n+\n+\tprivate K currentKey;\n+\n+\tBatchExecutionInternalTimeService(\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tTriggerable<K, N> triggerTarget) {\n+\n+\t\tthis.processingTimeService = checkNotNull(processingTimeService);\n+\t\tthis.triggerTarget = checkNotNull(triggerTarget);\n+\n+\t\tthis.processingTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t\tthis.eventTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic long currentProcessingTime() {\n+\t\treturn processingTimeService.getCurrentProcessingTime();\n+\t}\n+\n+\t@Override\n+\tpublic long currentWatermark() {\n+\t\treturn currentWatermark;\n+\t}\n+\n+\t@Override\n+\tpublic void registerProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void registerEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void forEachEventTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\t@Override\n+\tpublic void forEachProcessingTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\tpublic void setCurrentKey(K currentKey) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, "originalCommit": {"oid": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "458bdafc59be2f0cb3173dbfe9bc25c18f5f7a00", "author": {"user": {"login": "dawidwys", "name": "Dawid Wysakowicz"}}, "url": "https://github.com/apache/flink/commit/458bdafc59be2f0cb3173dbfe9bc25c18f5f7a00", "committedDate": "2020-10-13T13:02:59Z", "message": "Comments addressed"}, "afterCommit": {"oid": "c312c540329ba186a8c43e54f917f93486c6370e", "author": {"user": {"login": "dawidwys", "name": "Dawid Wysakowicz"}}, "url": "https://github.com/apache/flink/commit/c312c540329ba186a8c43e54f917f93486c6370e", "committedDate": "2020-10-14T07:24:49Z", "message": "Comments addressed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDcxNTQy", "url": "https://github.com/apache/flink/pull/13596#pullrequestreview-508071542", "createdAt": "2020-10-14T07:37:53Z", "commit": {"oid": "c312c540329ba186a8c43e54f917f93486c6370e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNzozNzo1M1rOHhGErQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNzozNzo1M1rOHhGErQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ2NDU1Nw==", "bodyText": "I think that these can become:\nwhile ((timer = eventTimeTimersQueue.poll()) != null) {\n\t\t\ttriggerTarget.onEventTime(timer);\n\t\t}\n\nand the same for the processing time.", "url": "https://github.com/apache/flink/pull/13596#discussion_r504464557", "createdAt": "2020-10-14T07:37:53Z", "author": {"login": "kl0u"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeService.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimerHeapInternalTimer;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.function.BiConsumerWithException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An implementation of a {@link InternalTimerService} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeService<K, N> implements InternalTimerService<N> {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BatchExecutionInternalTimeService.class);\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\t/**\n+\t * Processing time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> processingTimeTimersQueue;\n+\n+\t/**\n+\t * Event time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> eventTimeTimersQueue;\n+\n+\t/**\n+\t * The local event time, as denoted by the last received\n+\t * {@link org.apache.flink.streaming.api.watermark.Watermark Watermark}.\n+\t */\n+\tprivate long currentWatermark = Long.MIN_VALUE;\n+\n+\tprivate final Triggerable<K, N> triggerTarget;\n+\n+\tprivate K currentKey;\n+\n+\tBatchExecutionInternalTimeService(\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tTriggerable<K, N> triggerTarget) {\n+\n+\t\tthis.processingTimeService = checkNotNull(processingTimeService);\n+\t\tthis.triggerTarget = checkNotNull(triggerTarget);\n+\n+\t\tthis.processingTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t\tthis.eventTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic long currentProcessingTime() {\n+\t\treturn processingTimeService.getCurrentProcessingTime();\n+\t}\n+\n+\t@Override\n+\tpublic long currentWatermark() {\n+\t\treturn currentWatermark;\n+\t}\n+\n+\t@Override\n+\tpublic void registerProcessingTimeTimer(N namespace, long time) {\n+\t\t// the currentWatermark == Long.MAX_VALUE indicates the timer was registered from the callback\n+\t\t// we quiesce the TimerService to prohibit infinite loops at the end of a key\n+\t\tif (currentWatermark == Long.MAX_VALUE) {\n+\t\t\tLOG.warn(\"Timer service is quiesced. Processing time timer for timestamp '{}' will be ignored.\", time);\n+\t\t\treturn;\n+\t\t}\n+\t\tprocessingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void registerEventTimeTimer(N namespace, long time) {\n+\t\t// the currentWatermark == Long.MAX_VALUE indicates the timer was registered from the callback\n+\t\t// we quiesce the TimerService to prohibit infinite loops at the end of a key\n+\t\tif (currentWatermark == Long.MAX_VALUE) {\n+\t\t\tLOG.warn(\"Timer service is quiesced. Event time timer for timestamp '{}' will be ignored.\", time);\n+\t\t\treturn;\n+\t\t}\n+\t\teventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void forEachEventTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\t@Override\n+\tpublic void forEachProcessingTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\tpublic void setCurrentKey(K currentKey) throws Exception {\n+\t\tif (currentKey != null && currentKey.equals(this.currentKey)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcurrentWatermark = Long.MAX_VALUE;\n+\t\tInternalTimer<K, N> timer;\n+\t\twhile ((timer = eventTimeTimersQueue.peek()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c312c540329ba186a8c43e54f917f93486c6370e"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDcxOTg0", "url": "https://github.com/apache/flink/pull/13596#pullrequestreview-508071984", "createdAt": "2020-10-14T07:38:28Z", "commit": {"oid": "c312c540329ba186a8c43e54f917f93486c6370e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87182aba60f671ef6acfff0bd8b28aeb811ca75b", "author": {"user": {"login": "dawidwys", "name": "Dawid Wysakowicz"}}, "url": "https://github.com/apache/flink/commit/87182aba60f671ef6acfff0bd8b28aeb811ca75b", "committedDate": "2020-10-14T07:48:35Z", "message": "[FLINK-19475] Implement a time service for the batch execution mode\n\nI introduce a BatchExecutionInternalTimeServiceManager and\nBatchExecutionInternalTimeService which can be used in the batch\nexecution mode along with the BatchExecutionStateBackend. These services\nonly ever keep state for a single key at a time. They assume a perfect\nWatermark and fire timers only upon switching the current key. Therefore\nthey require the input to be sorted/grouped by the key."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c312c540329ba186a8c43e54f917f93486c6370e", "author": {"user": {"login": "dawidwys", "name": "Dawid Wysakowicz"}}, "url": "https://github.com/apache/flink/commit/c312c540329ba186a8c43e54f917f93486c6370e", "committedDate": "2020-10-14T07:24:49Z", "message": "Comments addressed"}, "afterCommit": {"oid": "87182aba60f671ef6acfff0bd8b28aeb811ca75b", "author": {"user": {"login": "dawidwys", "name": "Dawid Wysakowicz"}}, "url": "https://github.com/apache/flink/commit/87182aba60f671ef6acfff0bd8b28aeb811ca75b", "committedDate": "2020-10-14T07:48:35Z", "message": "[FLINK-19475] Implement a time service for the batch execution mode\n\nI introduce a BatchExecutionInternalTimeServiceManager and\nBatchExecutionInternalTimeService which can be used in the batch\nexecution mode along with the BatchExecutionStateBackend. These services\nonly ever keep state for a single key at a time. They assume a perfect\nWatermark and fire timers only upon switching the current key. Therefore\nthey require the input to be sorted/grouped by the key."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3168, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}