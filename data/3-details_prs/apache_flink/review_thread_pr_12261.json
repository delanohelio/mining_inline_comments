{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDk2ODU2", "number": 12261, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNToyODowN1rOD-EDDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzoyMDo1OVrOD-URJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDA0NjIzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNToyODowN1rOGX7xJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzoxMTozMVrOGYyM7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA==", "bodyText": "I guess it's theoretically impossible that we get a null buffer here with your changes in releaseAllResources, which seems to solve two cases you mentioned in description. So.. this check is just for other unknown bad cases?", "url": "https://github.com/apache/flink/pull/12261#discussion_r427749670", "createdAt": "2020-05-20T05:28:07Z", "author": {"login": "Jiayi-Liao"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzOTEwNw==", "bodyText": "I guess it can probably happen in practice. When the canceler thread already released the respective input channel, but the task thread might still call getNextBuffer in the case of released receivedBuffers, then it can get the null buffer.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428139107", "createdAt": "2020-05-20T16:16:39Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3OTM4Mw==", "bodyText": "What do you mean @zhijiangW ? At first glance I would agree with @Jiayi-Liao, that it shouldn't happen after your fix in this commit in this class below.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428179383", "createdAt": "2020-05-20T17:18:28Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMDY1MQ==", "bodyText": "Let me further explain it.\nThe canceler thread will close the InputGate in advance so the task thread might be aware of the released state to exit early. When the canceler thread called RemoteInputChannel#releaseAllResources before, then all the buffers in receivedBuffers would be drained and recycled.\nBut the task thread was not aware of this then, and it would probably call getNextBuffer to get a null buffer here. We only expect the null buffer in the case of released channel, so we throw the expected CancelTaskException to make task thread exit. If not released case, there must be some logic bugs. E.g this channel notifies gate of available data by fault.  So we throw IllegalStateException for such case, to avoid the misleading NullPointerException when reference with the buffer below.\nMy fix in #releaseAllResources is only for avoiding concurrent pulling receivedBuffers by both task thread and canceler thread, which might cause recycle the same buffer twice and misleading exception thrown by netty stack.\nAnother option for modifying the logic in #getNextBuffer like below:\n                  synchronized (receivedBuffers) {\n\t\t\tif (isReleased.get()) {\n\t\t\t\tthrow new CancelTaskException(\"Queried for a buffer after channel has been released.\");\n\t\t\t}\n\t\t\tnext = receivedBuffers.poll();\n\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n\t\t}\n\nBut it might still make sense to also judge whether the buffer is null out of the synchronized, which is not the race condition case, and only for avoiding potential logic bugs in data notification logic to cause misleading NPE.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428430651", "createdAt": "2020-05-21T03:52:25Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMTY3OA==", "bodyText": "FYI: before my changes, we can reproduce these two potential issues in my below introduced unit tests stable. One case is throwing NPE exception sometimes, and another case is throwing netty stack exception when same buffer recycled twice.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428431678", "createdAt": "2020-05-21T03:56:46Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ0Njk3Mg==", "bodyText": "Get it! Thanks for the explaination!", "url": "https://github.com/apache/flink/pull/12261#discussion_r428446972", "createdAt": "2020-05-21T05:07:55Z", "author": {"login": "Jiayi-Liao"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0MTUxNg==", "bodyText": "Ops, sorry, yes it's obvious, I don't know why I've missed it \ud83d\ude33", "url": "https://github.com/apache/flink/pull/12261#discussion_r428641516", "createdAt": "2020-05-21T13:11:31Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjcwMzc0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzoyMDo1OVrOGYWFiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMzowMTo0OFrOGZJNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ==", "bodyText": "I think we could have tested this bug without concurrency/multi threading by just calling releaseAllResources before getNextBuffer. Test would be much easier to understand and debug and this would be worth a bit worse testing coverage - especially that we still have ITCases, and in the long run we are planning/hoping to make releasing resources go through mailbox.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428180875", "createdAt": "2020-05-20T17:20:59Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1010,6 +1011,56 @@ public void testConcurrentRecycleAndRelease2() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testConcurrentGetNextBufferAndRelease() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzNjg3Ng==", "bodyText": "I am not quite sure whether ITCase can stable reproduce the concurrent issues if not constructed well.\nE.g. we need to guarantee that when the canceler thread is releasing the channel, this channel must already be queued into the input gate with data in receivedBuffers, then it can simulate the scenario of executing releaseAllResources and getNextBuffers concurrently.\nUnit test can work on these two methods directly to stable reproduce the potential bugs, but ITCase might be hard to control and it might never have the chance to enter this path in practice.\nI found most of the previous race condition bugs in core codes was just missing such concurrent unit tests before, and simply verify the results by executing related methods by sequence, not concurrently.\nE.g. If we execute the #releaseAllResources() in different steps of #getNextBuffer, it would have different effects. So maybe only unit test can cover all the potential possibilities if we are not sure ITCase can achieve it.\nOptional<BufferAndAvailability> getNextBuffer() {\n                 1. execute #releaseAllResources() here\n  \n\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n\n\t\tcheckError();\n\n\t\tfinal Buffer next;\n\t\tfinal boolean moreAvailable;\n\n                 2. execute #releaseAllResources() here\n\n\t\tsynchronized (receivedBuffers) {\n\t\t\tnext = receivedBuffers.poll();\n\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n\t\t}\n\n                 3. execute #releaseAllResources() here\n\n\t\tnumBytesIn.inc(next.getSize());\n\t\tnumBuffersIn.inc();\n\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable, 0));\n\t}\n\n\nMaybe it seems complex to let unit tests handle such scenarios. If ITCase can handle this work well, i am happy to make only simple unit tests.", "url": "https://github.com/apache/flink/pull/12261#discussion_r428436876", "createdAt": "2020-05-21T04:21:24Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1010,6 +1011,56 @@ public void testConcurrentRecycleAndRelease2() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testConcurrentGetNextBufferAndRelease() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0MzA3NQ==", "bodyText": "I'm not a fan of such concurrency tests, I wouldn't be personally adding them I think, but you are right - single threaded unit test wouldn't reproduce this issue because of checkState(!isReleased.get()).\nLGTM", "url": "https://github.com/apache/flink/pull/12261#discussion_r428643075", "createdAt": "2020-05-21T13:14:29Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1010,6 +1011,56 @@ public void testConcurrentRecycleAndRelease2() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testConcurrentGetNextBufferAndRelease() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxODU2OA==", "bodyText": "I thought of some other considerations for this issue to share.\nIn the ITCase, even though we can reproduce some potential concurrent bugs, it is hard to debug and find the root cause, because it is involved in all the components. I really have such feeling when debugging the UnalignedCheckpointITCase these days.\nReversely, unit test only works on two concurrent methods directly, so it is easy to find the bugs by limiting the scopes/components. We already had 6 unit tests written by concurrent way in RemoteInputChannelTest before, to guarantee the stability among different concurrent methods executed by task thread, netty thread, canceler thread separately.  If replaced by ITCase, we need to debug among all these methods to find the potential root cause.\nIn general, it is better for unit tests only focus on one component or less, otherwise we should rely on ITCase. In this case, we only limit the scope inside RemoteInputChannel component, so it also makes sense from this aspect.\nAnyway besides the pros I mentioned above for unit tests, I also agree that the cons you concerned, merely the pros are a bit more than cons on my side. :)", "url": "https://github.com/apache/flink/pull/12261#discussion_r429018568", "createdAt": "2020-05-22T03:01:48Z", "author": {"login": "zhijiangW"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1010,6 +1011,56 @@ public void testConcurrentRecycleAndRelease2() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testConcurrentGetNextBufferAndRelease() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}, "originalCommit": {"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4529, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}