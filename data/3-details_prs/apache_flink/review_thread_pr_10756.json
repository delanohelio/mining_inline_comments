{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4ODgyNTg2", "number": 10756, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMDozNDoxMVrODVoVxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMDozNDoxMVrODVoVxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDA3NjIwOnYy", "diffSide": "RIGHT", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/hashtable/BaseHybridHashTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMDozNDoxMVrOFZ9asg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwMjo1NjowN1rOFaUfpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc2NDk3OA==", "bodyText": "@JingsongLi Thanks a lot for bringing this up.\nI agree with you that this is computationally efficient.\nHowever, according to my experince, this may not be a good hash function. In practice, we usually encounter small integers (with most high bits equal to 0), so we have hash >>> 16 == 0, and hash ^ (hash >>> 16) will be equal to hash.\nIMO, hash ^ (hash << 16) is much better, as it maps small integers uniformly into the space of all integers.\nThat being that, this is just my personal suggestion. The final choice should be dependent on the real scenario.", "url": "https://github.com/apache/flink/pull/10756#discussion_r362764978", "createdAt": "2020-01-03T10:34:11Z", "author": {"login": "liyafan82"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/hashtable/BaseHybridHashTable.java", "diffHunk": "@@ -516,4 +511,10 @@ public static int hash(int hashCode, int level) {\n \t\treturn code >= 0 ? code : -(code + 1);\n \t}\n \n+\t/**\n+\t * Partition level hash again, for avoid two layer hash conflict.\n+\t */\n+\tstatic int partitionLevelHash(int hash) {\n+\t\treturn hash ^ (hash >>> 16);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82ff8a76280af02f98613526b8b309ae6d4f2e94"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE0MzA3OA==", "bodyText": "Thanks for involving this.\n\nwith most high bits equal to 0\n\nGood point, but it should not.\n\nIn BinaryHashTable: HashCode is from murmurhash, it is good.\nIn LongHybridHashTable: HashCode is from hashLong, it is good too.\n\nhash ^ (hash >>> 16) is just from HashMap.hash, I think it is OK.", "url": "https://github.com/apache/flink/pull/10756#discussion_r363143078", "createdAt": "2020-01-06T02:56:07Z", "author": {"login": "JingsongLi"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/hashtable/BaseHybridHashTable.java", "diffHunk": "@@ -516,4 +511,10 @@ public static int hash(int hashCode, int level) {\n \t\treturn code >= 0 ? code : -(code + 1);\n \t}\n \n+\t/**\n+\t * Partition level hash again, for avoid two layer hash conflict.\n+\t */\n+\tstatic int partitionLevelHash(int hash) {\n+\t\treturn hash ^ (hash >>> 16);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc2NDk3OA=="}, "originalCommit": {"oid": "82ff8a76280af02f98613526b8b309ae6d4f2e94"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1272, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}