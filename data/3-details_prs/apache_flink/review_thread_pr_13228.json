{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNDc5MTI0", "number": 13228, "reviewThreads": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo1MzowM1rOEcFGpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NTowOFrOEmJoDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODc5MjA2OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo1MzowM1rOHGZK0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODozNTo1MFrOHGk2Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ==", "bodyText": "nit: it was a bit confusing for me for a moment which code paths are doing what. IMO it would be easier to follow it, if the shorter branch would be first, and if the more complicated part would have one lever of nesting less:\nif (!insertAsHead) {\n  buffers.add(bufferConsumer);\n  return;\n}\n//rest of the code\n\nin that case it's more obvious that !insertAsHead is a trivial case and that it doesn't interact with the other branch at all.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476465875", "createdAt": "2020-08-25T13:53:03Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tbuffers.add(bufferConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1NzIzMQ==", "bodyText": "Yes, good idea. In general that change looks a bit odd, because it's isolated from the upcoming changes (I had to split somewhere and probably didn't hit the sweet spot everywhere).", "url": "https://github.com/apache/flink/pull/13228#discussion_r476657231", "createdAt": "2020-08-25T18:35:50Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tbuffers.add(bufferConsumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ=="}, "originalCommit": {"oid": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODgxMTMxOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo1Njo1MlrOHGZWPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0MDoxN1rOHGk_1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw==", "bodyText": "Why do we need this change? In what scenarios are you expecting more than one priority event in the output buffer?  (if there is a reason that I'm forgetting about, please add it to the commit message)\nedit: (after reading commit message a couple of times) Or you are just re-using here a class, that you are mostly intending to use later in the future (on the inputs?)? If so maybe it needs some more explanation in the commit message?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476468797", "createdAt": "2020-08-25T13:56:52Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1OTY2OQ==", "bodyText": "In general, I wanted to drop the assumption that there is only one priority event going on at any given time. That's especially true when we make cancellation events also a priority and we have a more or less fully blocked channel.\nSpecifically, this change had following motivations:\n\ndrop the assumption that all priority events are unaligned checkpoints.\ndrop the assumption that the new priority event is always at position 0.\na small performance improvement where buffers are only copied after it's clear that they are not containing an event.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476659669", "createdAt": "2020-08-25T18:40:17Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw=="}, "originalCommit": {"oid": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODg4OTI1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoxMjoxOVrOHGaFXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoxMjoxOVrOHGaFXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MDg2Mg==", "bodyText": "nit: add a javadoc explaining the returned value?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476480862", "createdAt": "2020-08-25T14:12:19Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f944eae8129d84d25b81e1d97ef573c15456ccb3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODg5NDA5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoxMzozMlrOHGaIkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0MjoxMlrOHGlEFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ==", "bodyText": "hmmm, maybe add another enum type for this purpose, instead of having null? (I'm not sure, just brain storming)", "url": "https://github.com/apache/flink/pull/13228#discussion_r476481681", "createdAt": "2020-08-25T14:13:32Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n+\t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\t\treturn nextDataType;\n \t\t}\n+\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f944eae8129d84d25b81e1d97ef573c15456ccb3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDc1OA==", "bodyText": "An enum type NONE would work for me and might make the code a bit clearer. However, be aware that this is mostly a copy&replace; I don't think it would simplify any code path.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660758", "createdAt": "2020-08-25T18:42:12Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n+\t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\t\treturn nextDataType;\n \t\t}\n+\t\treturn null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ=="}, "originalCommit": {"oid": "f944eae8129d84d25b81e1d97ef573c15456ccb3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTAwMTIzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDozNToyMVrOHGbKPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0MjoyOVrOHGlEuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA==", "bodyText": "maybe if the result variable rename and adding continue branch had happened in an independent \"refactor\" commit, It would have saved me a couple of minutes while reading this code while I was trying to understand the change :(\nmaybe not, as I can see how the changes are a bit interconnected.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476498494", "createdAt": "2020-08-25T14:35:21Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -621,61 +626,84 @@ public boolean isFinished() {\n \t\treturn Optional.of(transformToBufferOrEvent(\n \t\t\tinputWithData.data.buffer(),\n \t\t\tinputWithData.moreAvailable,\n-\t\t\tinputWithData.input));\n+\t\t\tinputWithData.input,\n+\t\t\tinputWithData.morePriorityEvents));\n \t}\n \n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> inputChannelOpt = getChannel(blocking);\n+\t\t\tif (!inputChannelOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n \n \t\t\t// Do not query inputChannel under the lock, to avoid potential deadlocks coming from\n \t\t\t// notifications.\n-\t\t\tOptional<BufferAndAvailability> result = inputChannel.get().getNextBuffer();\n+\t\t\tfinal InputChannel inputChannel = inputChannelOpt.get();\n+\t\t\tOptional<BufferAndAvailability> bufferAndAvailabilityOpt = inputChannel.getNextBuffer();\n \n \t\t\tsynchronized (inputChannelsWithData) {\n-\t\t\t\tif (result.isPresent() && result.get().moreAvailable()) {\n+\t\t\t\tif (!bufferAndAvailabilityOpt.isPresent()) {\n+\t\t\t\t\tif (inputChannelsWithData.isEmpty()) {\n+\t\t\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDkyMQ==", "bodyText": "Sry, I will split.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660921", "createdAt": "2020-08-25T18:42:29Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -621,61 +626,84 @@ public boolean isFinished() {\n \t\treturn Optional.of(transformToBufferOrEvent(\n \t\t\tinputWithData.data.buffer(),\n \t\t\tinputWithData.moreAvailable,\n-\t\t\tinputWithData.input));\n+\t\t\tinputWithData.input,\n+\t\t\tinputWithData.morePriorityEvents));\n \t}\n \n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> inputChannelOpt = getChannel(blocking);\n+\t\t\tif (!inputChannelOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n \n \t\t\t// Do not query inputChannel under the lock, to avoid potential deadlocks coming from\n \t\t\t// notifications.\n-\t\t\tOptional<BufferAndAvailability> result = inputChannel.get().getNextBuffer();\n+\t\t\tfinal InputChannel inputChannel = inputChannelOpt.get();\n+\t\t\tOptional<BufferAndAvailability> bufferAndAvailabilityOpt = inputChannel.getNextBuffer();\n \n \t\t\tsynchronized (inputChannelsWithData) {\n-\t\t\t\tif (result.isPresent() && result.get().moreAvailable()) {\n+\t\t\t\tif (!bufferAndAvailabilityOpt.isPresent()) {\n+\t\t\t\t\tif (inputChannelsWithData.isEmpty()) {\n+\t\t\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA=="}, "originalCommit": {"oid": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTA2NjQxOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDo0ODozNlrOHGbyNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0NDo0NFrOHGlJsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw==", "bodyText": "Heh, there are quite a bit more of corner/edge cases now.\nI wonder if there is maybe some other way to express the priority events, that would simplify the input gates code?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476508727", "createdAt": "2020-08-25T14:48:36Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -770,34 +808,50 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MjE5Mg==", "bodyText": "Well this change is less about expressing priority events and more about making sure that channels with priority events are always polled first. It's some kind of potential double notification, where the priority notification overrides the normal data available notification.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476662192", "createdAt": "2020-08-25T18:44:44Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -770,34 +808,50 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw=="}, "originalCommit": {"oid": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTE1MDUyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTowNjoxNVrOHGcm6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo1MDo0N1rOHGlXKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg==", "bodyText": "shouldn't we remove also obsolete values from this map? (to prevent a potential memory leak?)", "url": "https://github.com/apache/flink/pull/13228#discussion_r476522216", "createdAt": "2020-08-25T15:06:15Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2NTY0MA==", "bodyText": "Good catch, a leak could happen when the checkpoint is cancelled through another channel. The map itself is rather small, but it could add up over all channels and gates.\nI don't have a good idea on how to properly abstract this cleanup except by adding some kind of checkpoint-cancelled hook though.\nAlternatively, checkpoint barrier handler becomes more aware of the buffers to be spilled. So instead of calling channel.spillInflightBuffers, it could be channel.getSpilledBuffers().forEach(channelStateWriter::write) on a good checkpoint and channel.getSpilledBuffers().forEach(Buffer::recycle) on cancelled checkpoints, where getSpilledBuffers always cleans up this map.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476665640", "createdAt": "2020-08-25T18:50:47Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTE2NDQwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTowOToxM1rOHGcveA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTowOToxM1rOHGcveA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNDQwOA==", "bodyText": "numRecordsOvertaken -> numBuffersOvertaken?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476524408", "createdAt": "2020-08-25T15:09:13Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTE4MTk1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNToxMzoxN1rOHGc6wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo1NTozMVrOHGlh5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng==", "bodyText": "Do I understand it correctly? Currently there is a fragile contract, that numRecordsOvertaken value wouldn't change between onBuffer(...) where we are setting it and this spillInflightBuffers(...) call? In other words, it assumes that between enqueueing of the priority event and the spillInflightBuffers(...), task thread is not allowed to process any buffers?\nMaybe it would be better to embed the numRecordsOvertaken value in the priority event that would be processed by the task thread?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476527296", "createdAt": "2020-08-25T15:13:17Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2ODM5MQ==", "bodyText": "It's not a fragile contract if you think about it. We are setting the values under buffer lock and we will poll the barrier as the first thing under buffer lock. Any buffer that has been pulled by the task before the barrier cannot be overtaken. The buffer after the barrier overtakes is always the barrier itself.\nHowever, now that I think about it. It is not working correctly when there is another priority event being inserted between the barrier and the overtaken buffers. The fix is simple though thanks to the simpler threading model: only count non-priority buffers.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476668391", "createdAt": "2020-08-25T18:55:31Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTMwNjQ2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo0MDo0M1rOHGeI6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTowNDowMFrOHGl1Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA==", "bodyText": "Again, do I understand this correctly? Is this assuming that nobody polls anything between completing getPriorityEventAvailableFuture and executing this::processPriorityEvents? Isn't that a bit fragile?\n\n\nWhat was the motivation for no passing the priority events to the StreamTaskNetworkInput?\n\n\nWhat about processing priority events as part of pollNext()?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476547304", "createdAt": "2020-08-25T15:40:43Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+\n+\t\t// re-enqueue mail to process priority events\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\tprivate void waitForPriorityEvents(InputGate inputGate, MailboxExecutor mailboxExecutor) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputGate.getPriorityEventAvailableFuture();\n+\t\tpriorityEventAvailableFuture.thenRun(() -> {\n+\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority even @ gate %s\", inputGate);\n+\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3MzM1NQ==", "bodyText": "Nope, this assumption does not hold. That's why the first thing that processPriorityEvents does is to check if the future is still completed. If the task polled the only priority event in the meantime, the future has been reset. During the execution of processPriorityEvents in the task thread, the task cannot concurrently pull the priority event, so this is safe.\n2.+3. The basic idea of not involving StreamTaskNetworkInput#emitNext or using pollNext() is to not make non-blocking output more complicated. Currently, emitNext or pollNext are only called when an output buffer is available. In the meantime only mails are processed. Hence, I used a mail to perform processPriorityEvents.\nNote that the assumption here is that no priority event ever need to be handled in emitNext (which currently only handles EndOfPartitionEvent)", "url": "https://github.com/apache/flink/pull/13228#discussion_r476673355", "createdAt": "2020-08-25T19:04:00Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+\n+\t\t// re-enqueue mail to process priority events\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\tprivate void waitForPriorityEvents(InputGate inputGate, MailboxExecutor mailboxExecutor) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputGate.getPriorityEventAvailableFuture();\n+\t\tpriorityEventAvailableFuture.thenRun(() -> {\n+\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority even @ gate %s\", inputGate);\n+\t\t});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTMzMzU1OnYy", "diffSide": "LEFT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo0NzoxNlrOHGeZ_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTowNToxNFrOHGl31A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw==", "bodyText": "Isn't it changing the semantic slightly? Am I right, that the only case on the master branch which actually causes another iteration of this loop is\nbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n\nand all of the other cases were exiting the loop? Are now all of the cases exiting always?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476551677", "createdAt": "2020-08-25T15:47:16Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NDAwNA==", "bodyText": "Yes, it's changing semantics (as I had written in commit message). I have not found a good reason why it's not always exited and it makes things easier especially since this method can now be used to process priority events.\nBtw I think it also changes semantics for all event that are not handled at all, but I'm not sure which events survive at this point (Superstep?).", "url": "https://github.com/apache/flink/pull/13228#discussion_r476674004", "createdAt": "2020-08-25T19:05:14Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTM3MDQyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo1NTo1M1rOHGewtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0MTowOFrOHWAlxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg==", "bodyText": "As I understand it, it assumes that this pollNext() can not return anything else besides a priority event?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476557492", "createdAt": "2020-08-25T15:55:53Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTA5Ng==", "bodyText": "Yes, first this method checks if there is at least one priority event (priority future completed). If there is at least one, it starts processing the first one. At this point, it relies on BufferOrEvent::morePriorityEvents to be correct in both directions (no false positives or negatives; although a false negative would just be a tad slower).", "url": "https://github.com/apache/flink/pull/13228#discussion_r476675096", "createdAt": "2020-08-25T19:07:20Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MDM5MQ==", "bodyText": "maybe add a checkState, that we are not loosing some unexpected data?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492840391", "createdAt": "2020-09-22T15:41:08Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTM4MjQ0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo1ODo0OFrOHGe4kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjo1MjoyM1rOHSinoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ==", "bodyText": "Is this spit into processBuffer and processEvent relevant?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476559505", "createdAt": "2020-08-25T15:58:48Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3ODkwMw==", "bodyText": "Nope, it's a refactoring that I should move out. We could also revert back. I had an intermediate version where processEvent signaled if the loop should be broken or not and there the split made more sense.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476678903", "createdAt": "2020-08-25T19:14:32Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzkzMA==", "bodyText": "Could you ether pull it to another commit or revert? This\n\nUse futures to listen to priority events and handle them in StreamTaskNetworkInput.\n\ncommit has a couple of other irrelevant changes", "url": "https://github.com/apache/flink/pull/13228#discussion_r487967930", "createdAt": "2020-09-14T14:19:34Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwMzYxNg==", "bodyText": "Sorry I haven't pulled that change out, since it's more than a refactoring; it's the core change that modifies the semantics to always return on events.\nExcept for that change, everything else is more or less directly related to passing the priority future, so I'm not sure what to pull out.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489203616", "createdAt": "2020-09-16T06:52:23Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTM5MzEwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowMTowMFrOHGe_DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOToxMjo0NFrOHGmHJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA==", "bodyText": "for now in this commit, this is just a NO-OP call?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476561164", "createdAt": "2020-08-25T16:01:00Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {\n-\t\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n+\tpublic Optional<BufferOrEvent> pollNext() throws IOException, InterruptedException {\n+\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n \n-\t\t\tif (!next.isPresent()) {\n-\t\t\t\treturn handleEmptyBuffer();\n-\t\t\t}\n+\t\tif (!next.isPresent()) {\n+\t\t\treturn handleEmptyBuffer();\n+\t\t}\n \n-\t\t\tBufferOrEvent bufferOrEvent = next.get();\n-\t\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n+\t\tBufferOrEvent bufferOrEvent = next.get();\n+\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n \n-\t\t\tif (bufferOrEvent.isBuffer()) {\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();\n-\t\t\t\tbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelInfo());\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {\n-\t\t\t\tbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class) {\n-\t\t\t\t\tbarrierHandler.processEndOfPartition();\n-\t\t\t\t}\n-\t\t\t\treturn next;\n-\t\t\t}\n+\t\tif (bufferOrEvent.isEvent()) {\n+\t\t\thandleEvent(bufferOrEvent);\n+\t\t} else {\n+\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NzkyNQ==", "bodyText": "Yes, it's used in the next commit to persist in-flight data (replaces notifyBufferReceived).", "url": "https://github.com/apache/flink/pull/13228#discussion_r476677925", "createdAt": "2020-08-25T19:12:44Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {\n-\t\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n+\tpublic Optional<BufferOrEvent> pollNext() throws IOException, InterruptedException {\n+\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n \n-\t\t\tif (!next.isPresent()) {\n-\t\t\t\treturn handleEmptyBuffer();\n-\t\t\t}\n+\t\tif (!next.isPresent()) {\n+\t\t\treturn handleEmptyBuffer();\n+\t\t}\n \n-\t\t\tBufferOrEvent bufferOrEvent = next.get();\n-\t\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n+\t\tBufferOrEvent bufferOrEvent = next.get();\n+\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n \n-\t\t\tif (bufferOrEvent.isBuffer()) {\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();\n-\t\t\t\tbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelInfo());\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {\n-\t\t\t\tbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class) {\n-\t\t\t\t\tbarrierHandler.processEndOfPartition();\n-\t\t\t\t}\n-\t\t\t\treturn next;\n-\t\t\t}\n+\t\tif (bufferOrEvent.isEvent()) {\n+\t\t\thandleEvent(bufferOrEvent);\n+\t\t} else {\n+\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA=="}, "originalCommit": {"oid": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTQxNzIxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowNjoyM1rOHGfNqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOToyMjozNlrOHGmclw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ==", "bodyText": "Here, we are persisting in-flight buffers, only as they are being processed? Doesn't it mean, that unaligned checkpoint will be completed only after we process all of the buffers, making unaligned checkpoint just as quick as aligned?", "url": "https://github.com/apache/flink/pull/13228#discussion_r476564905", "createdAt": "2020-08-25T16:06:23Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -92,306 +90,173 @@\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\t\thasInflightBuffers = Arrays.stream(inputGates)\n+\t\tthis.inputGates = inputGates;\n+\t\tstoreNewBuffers = Arrays.stream(inputGates)\n \t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n \t\t\t.collect(Collectors.toMap(Function.identity(), info -> false));\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(checkNotNull(checkpointCoordinator), this, inputGates);\n+\t\tnumOpenChannels = storeNewBuffers.size();\n+\t\tthis.checkpointCoordinator = checkpointCoordinator;\n \t}\n \n-\t/**\n-\t * We still need to trigger checkpoint via {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}\n-\t * while reading the first barrier from one channel, because this might happen\n-\t * earlier than the previous async trigger via mailbox by netty thread.\n-\t *\n-\t * <p>Note this is also suitable for the trigger case of local input channel.\n-\t */\n \t@Override\n-\tpublic void processBarrier(CheckpointBarrier receivedBarrier, InputChannelInfo channelInfo) throws IOException {\n-\t\tlong barrierId = receivedBarrier.getId();\n-\t\tif (currentConsumedCheckpointId > barrierId || (currentConsumedCheckpointId == barrierId && !isCheckpointPending())) {\n+\tpublic void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelInfo) throws IOException {\n+\t\tlong barrierId = barrier.getId();\n+\t\tif (currentCheckpointId > barrierId || (currentCheckpointId == barrierId && !isCheckpointPending())) {\n \t\t\t// ignore old and cancelled barriers\n \t\t\treturn;\n \t\t}\n-\t\tif (currentConsumedCheckpointId < barrierId) {\n-\t\t\tcurrentConsumedCheckpointId = barrierId;\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(true));\n+\t\tif (currentCheckpointId < barrierId) {\n+\t\t\thandleNewCheckpoint(barrier);\n+\t\t\tnotifyCheckpoint(barrier, 0);\n \t\t}\n-\t\tif (currentConsumedCheckpointId == barrierId) {\n-\t\t\thasInflightBuffers.put(channelInfo, false);\n-\t\t\tnumBarrierConsumed++;\n+\t\tif (currentCheckpointId == barrierId) {\n+\t\t\tif (storeNewBuffers.put(channelInfo, false)) {\n+\t\t\t\tLOG.debug(\"{}: Received barrier from channel {} @ {}.\", taskName, channelInfo, barrierId);\n+\n+\t\t\t\tinputGates[channelInfo.getGateIdx()].getChannel(channelInfo.getInputChannelIdx())\n+\t\t\t\t\t.spillInflightBuffers(barrierId, checkpointCoordinator.getChannelStateWriter());\n+\n+\t\t\t\tif (++numBarriersReceived == numOpenChannels) {\n+\t\t\t\t\tallBarriersReceivedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tthreadSafeUnaligner.notifyBarrierReceived(receivedBarrier, channelInfo);\n \t}\n \n \t@Override\n \tpublic void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n-\t\tthreadSafeUnaligner.tryAbortPendingCheckpoint(checkpointId, exception);\n+\t\ttryAbortPendingCheckpoint(checkpointId, exception);\n \n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(checkpointId);\n+\t\tif (checkpointId > currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws IOException {\n \t\tfinal long cancelledId = cancelBarrier.getCheckpointId();\n-\t\tboolean shouldAbort = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);\n+\t\tboolean shouldAbort = setCancelledCheckpointId(cancelledId);\n \t\tif (shouldAbort) {\n \t\t\tnotifyAbort(\n \t\t\t\tcancelledId,\n \t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));\n \t\t}\n \n-\t\tif (cancelledId >= currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(cancelledId);\n-\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\tif (cancelledId >= currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentCheckpointId = cancelledId;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processEndOfPartition() throws IOException {\n-\t\tthreadSafeUnaligner.onChannelClosed();\n-\t\tresetPendingCheckpoint(-1L);\n+\t\tnumOpenChannels--;\n+\n+\t\tresetPendingCheckpoint();\n+\t\tnotifyAbort(\n+\t\t\tcurrentCheckpointId,\n+\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n \t}\n \n-\tprivate void resetPendingCheckpoint(long checkpointId) {\n-\t\tif (isCheckpointPending()) {\n-\t\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) {} before completing current checkpoint {}. \" +\n-\t\t\t\t\t\"Skipping current checkpoint.\",\n-\t\t\t\ttaskName,\n-\t\t\t\tcheckpointId,\n-\t\t\t\tcurrentConsumedCheckpointId);\n+\tprivate void resetPendingCheckpoint() {\n+\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) before completing current checkpoint {}. \" +\n+\t\t\t\t\"Skipping current checkpoint.\",\n+\t\t\ttaskName,\n+\t\t\tcurrentCheckpointId);\n \n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(false));\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n+\t\tstoreNewBuffers.entrySet().forEach(storeNewBuffer -> storeNewBuffer.setValue(false));\n+\t\tnumBarriersReceived = 0;\n \t}\n \n \t@Override\n \tpublic long getLatestCheckpointId() {\n-\t\treturn currentConsumedCheckpointId;\n+\t\treturn currentCheckpointId;\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentConsumedCheckpointId);\n+\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentCheckpointId);\n \t}\n \n \t@Override\n \tpublic void close() throws IOException {\n \t\tsuper.close();\n-\t\tthreadSafeUnaligner.close();\n-\t}\n-\n-\t@Override\n-\tpublic boolean hasInflightData(long checkpointId, InputChannelInfo channelInfo) {\n-\t\tif (checkpointId < currentConsumedCheckpointId) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn hasInflightBuffers.get(channelInfo);\n-\t}\n-\n-\t@Override\n-\tpublic CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {\n-\t\treturn threadSafeUnaligner.getAllBarriersReceivedFuture(checkpointId);\n-\t}\n-\n-\t@Override\n-\tpublic Optional<BufferReceivedListener> getBufferReceivedListener() {\n-\t\treturn Optional.of(threadSafeUnaligner);\n+\t\tallBarriersReceivedFuture.cancel(false);\n \t}\n \n \t@Override\n \tprotected boolean isCheckpointPending() {\n-\t\treturn numBarrierConsumed > 0;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumOpenChannels() {\n-\t\treturn threadSafeUnaligner.getNumOpenChannels();\n-\t}\n-\n-\t@VisibleForTesting\n-\tThreadSafeUnaligner getThreadSafeUnaligner() {\n-\t\treturn threadSafeUnaligner;\n+\t\treturn numBarriersReceived > 0;\n \t}\n \n-\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n-\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n-\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n-\t\t\tsuper.notifyCheckpoint(barrier, 0);\n+\t@Override\n+\tpublic void processBuffer(Buffer buffer, InputChannelInfo channelInfo) {\n+\t\tif (storeNewBuffers.get(channelInfo)) {\n+\t\t\tcheckpointCoordinator.getChannelStateWriter().addInputData(\n+\t\t\t\tcurrentCheckpointId,\n+\t\t\t\tchannelInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9836d4919062fa63212d16bc88a071cc31fc3977"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4MzQxNQ==", "bodyText": "Let me sketch the most general data flow:\n\nWe have couple of buffers in our input channel.\nCheckpoint is triggered by another channel. *\nAll buffers that are now pulled by CheckpointedInputGate from the first channel get persisted by above function.\nThen the barrier comes in. *\nIt overtakes all buffers and is now at the head. *\nCheckpointedInputGate gets priority notification and polls the barrier.\nUpon dispatching, it calls Unaligner, which spills additionally all overtaken buffers.\nFurther buffers are not persisted.\n\nAll steps marked with * are performed in a different thread (other task thread / netty).\nFor me this is equivalent to the current behavior, but maybe I missed something.", "url": "https://github.com/apache/flink/pull/13228#discussion_r476683415", "createdAt": "2020-08-25T19:22:36Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -92,306 +90,173 @@\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\t\thasInflightBuffers = Arrays.stream(inputGates)\n+\t\tthis.inputGates = inputGates;\n+\t\tstoreNewBuffers = Arrays.stream(inputGates)\n \t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n \t\t\t.collect(Collectors.toMap(Function.identity(), info -> false));\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(checkNotNull(checkpointCoordinator), this, inputGates);\n+\t\tnumOpenChannels = storeNewBuffers.size();\n+\t\tthis.checkpointCoordinator = checkpointCoordinator;\n \t}\n \n-\t/**\n-\t * We still need to trigger checkpoint via {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}\n-\t * while reading the first barrier from one channel, because this might happen\n-\t * earlier than the previous async trigger via mailbox by netty thread.\n-\t *\n-\t * <p>Note this is also suitable for the trigger case of local input channel.\n-\t */\n \t@Override\n-\tpublic void processBarrier(CheckpointBarrier receivedBarrier, InputChannelInfo channelInfo) throws IOException {\n-\t\tlong barrierId = receivedBarrier.getId();\n-\t\tif (currentConsumedCheckpointId > barrierId || (currentConsumedCheckpointId == barrierId && !isCheckpointPending())) {\n+\tpublic void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelInfo) throws IOException {\n+\t\tlong barrierId = barrier.getId();\n+\t\tif (currentCheckpointId > barrierId || (currentCheckpointId == barrierId && !isCheckpointPending())) {\n \t\t\t// ignore old and cancelled barriers\n \t\t\treturn;\n \t\t}\n-\t\tif (currentConsumedCheckpointId < barrierId) {\n-\t\t\tcurrentConsumedCheckpointId = barrierId;\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(true));\n+\t\tif (currentCheckpointId < barrierId) {\n+\t\t\thandleNewCheckpoint(barrier);\n+\t\t\tnotifyCheckpoint(barrier, 0);\n \t\t}\n-\t\tif (currentConsumedCheckpointId == barrierId) {\n-\t\t\thasInflightBuffers.put(channelInfo, false);\n-\t\t\tnumBarrierConsumed++;\n+\t\tif (currentCheckpointId == barrierId) {\n+\t\t\tif (storeNewBuffers.put(channelInfo, false)) {\n+\t\t\t\tLOG.debug(\"{}: Received barrier from channel {} @ {}.\", taskName, channelInfo, barrierId);\n+\n+\t\t\t\tinputGates[channelInfo.getGateIdx()].getChannel(channelInfo.getInputChannelIdx())\n+\t\t\t\t\t.spillInflightBuffers(barrierId, checkpointCoordinator.getChannelStateWriter());\n+\n+\t\t\t\tif (++numBarriersReceived == numOpenChannels) {\n+\t\t\t\t\tallBarriersReceivedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tthreadSafeUnaligner.notifyBarrierReceived(receivedBarrier, channelInfo);\n \t}\n \n \t@Override\n \tpublic void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n-\t\tthreadSafeUnaligner.tryAbortPendingCheckpoint(checkpointId, exception);\n+\t\ttryAbortPendingCheckpoint(checkpointId, exception);\n \n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(checkpointId);\n+\t\tif (checkpointId > currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws IOException {\n \t\tfinal long cancelledId = cancelBarrier.getCheckpointId();\n-\t\tboolean shouldAbort = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);\n+\t\tboolean shouldAbort = setCancelledCheckpointId(cancelledId);\n \t\tif (shouldAbort) {\n \t\t\tnotifyAbort(\n \t\t\t\tcancelledId,\n \t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));\n \t\t}\n \n-\t\tif (cancelledId >= currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(cancelledId);\n-\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\tif (cancelledId >= currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentCheckpointId = cancelledId;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processEndOfPartition() throws IOException {\n-\t\tthreadSafeUnaligner.onChannelClosed();\n-\t\tresetPendingCheckpoint(-1L);\n+\t\tnumOpenChannels--;\n+\n+\t\tresetPendingCheckpoint();\n+\t\tnotifyAbort(\n+\t\t\tcurrentCheckpointId,\n+\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n \t}\n \n-\tprivate void resetPendingCheckpoint(long checkpointId) {\n-\t\tif (isCheckpointPending()) {\n-\t\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) {} before completing current checkpoint {}. \" +\n-\t\t\t\t\t\"Skipping current checkpoint.\",\n-\t\t\t\ttaskName,\n-\t\t\t\tcheckpointId,\n-\t\t\t\tcurrentConsumedCheckpointId);\n+\tprivate void resetPendingCheckpoint() {\n+\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) before completing current checkpoint {}. \" +\n+\t\t\t\t\"Skipping current checkpoint.\",\n+\t\t\ttaskName,\n+\t\t\tcurrentCheckpointId);\n \n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(false));\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n+\t\tstoreNewBuffers.entrySet().forEach(storeNewBuffer -> storeNewBuffer.setValue(false));\n+\t\tnumBarriersReceived = 0;\n \t}\n \n \t@Override\n \tpublic long getLatestCheckpointId() {\n-\t\treturn currentConsumedCheckpointId;\n+\t\treturn currentCheckpointId;\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentConsumedCheckpointId);\n+\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentCheckpointId);\n \t}\n \n \t@Override\n \tpublic void close() throws IOException {\n \t\tsuper.close();\n-\t\tthreadSafeUnaligner.close();\n-\t}\n-\n-\t@Override\n-\tpublic boolean hasInflightData(long checkpointId, InputChannelInfo channelInfo) {\n-\t\tif (checkpointId < currentConsumedCheckpointId) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn hasInflightBuffers.get(channelInfo);\n-\t}\n-\n-\t@Override\n-\tpublic CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {\n-\t\treturn threadSafeUnaligner.getAllBarriersReceivedFuture(checkpointId);\n-\t}\n-\n-\t@Override\n-\tpublic Optional<BufferReceivedListener> getBufferReceivedListener() {\n-\t\treturn Optional.of(threadSafeUnaligner);\n+\t\tallBarriersReceivedFuture.cancel(false);\n \t}\n \n \t@Override\n \tprotected boolean isCheckpointPending() {\n-\t\treturn numBarrierConsumed > 0;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumOpenChannels() {\n-\t\treturn threadSafeUnaligner.getNumOpenChannels();\n-\t}\n-\n-\t@VisibleForTesting\n-\tThreadSafeUnaligner getThreadSafeUnaligner() {\n-\t\treturn threadSafeUnaligner;\n+\t\treturn numBarriersReceived > 0;\n \t}\n \n-\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n-\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n-\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n-\t\t\tsuper.notifyCheckpoint(barrier, 0);\n+\t@Override\n+\tpublic void processBuffer(Buffer buffer, InputChannelInfo channelInfo) {\n+\t\tif (storeNewBuffers.get(channelInfo)) {\n+\t\t\tcheckpointCoordinator.getChannelStateWriter().addInputData(\n+\t\t\t\tcurrentCheckpointId,\n+\t\t\t\tchannelInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ=="}, "originalCommit": {"oid": "9836d4919062fa63212d16bc88a071cc31fc3977"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTg0NDI1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOTo1MjowN1rOHQX4nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNToyOTozN1rOHVqswQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA==", "bodyText": "Is this a fix for an existing bug on the master branch? Or are you changing the behaviour/contract of this unregisterSourceReader call in some later commit?\nWould it be worthwhile/easy adding a test?", "url": "https://github.com/apache/flink/pull/13228#discussion_r486930588", "createdAt": "2020-09-11T09:52:07Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "diffHunk": "@@ -261,8 +260,7 @@ void registerSourceReader(ReaderInfo readerInfo) {\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n-\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n+\t\tregisteredReaders.remove(subtaskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2286a09f24b69151445a0c75c52d83f9e6dd5120"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDc3OQ==", "bodyText": "It's a bug that I discovered in my UC ITCase and confirmed with Becket and Stephan. I added a small (trivial) test case.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489230779", "createdAt": "2020-09-16T07:44:08Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "diffHunk": "@@ -261,8 +260,7 @@ void registerSourceReader(ReaderInfo readerInfo) {\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n-\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n+\t\tregisteredReaders.remove(subtaskId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}, "originalCommit": {"oid": "2286a09f24b69151445a0c75c52d83f9e6dd5120"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4MTcyOQ==", "bodyText": "Added a ticket and referenced it properly https://issues.apache.org/jira/browse/FLINK-19338 .", "url": "https://github.com/apache/flink/pull/13228#discussion_r492481729", "createdAt": "2020-09-22T05:29:37Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "diffHunk": "@@ -261,8 +260,7 @@ void registerSourceReader(ReaderInfo readerInfo) {\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n-\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n+\t\tregisteredReaders.remove(subtaskId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}, "originalCommit": {"oid": "2286a09f24b69151445a0c75c52d83f9e6dd5120"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ3NzQyOnYy", "diffSide": "LEFT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowMzoxOFrOHQd8hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo0OTowNlrOHSkdBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw==", "bodyText": "nit: maybe it's worth keeping this comment?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487029893", "createdAt": "2020-09-11T13:03:18Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMzY3MQ==", "bodyText": "Moved the removal to the commit that spills immediately.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489233671", "createdAt": "2020-09-16T07:49:06Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw=="}, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ4MzU3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowNTowN1rOHQeALA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowNTowN1rOHQeALA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMDgyOA==", "bodyText": "nit: pos -> numberOfPriorityEvents? It would make the following line:\nIterators.advance(iterator, pos + 1);\n\nmore readable.", "url": "https://github.com/apache/flink/pull/13228#discussion_r487030828", "createdAt": "2020-09-11T13:05:07Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjUyOTk1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzoxNzo0OFrOHQeddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1MjowMFrOHSkkQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw==", "bodyText": "this method is only isCheckpointBarrier and it seems to not care if it's aligned or not, right?\nBesides, do we really need to deserialise the event? Previously we were snapshotting in-flight data every time we were inserting buffer as a head. I think it was just as not elegant, but simpler.\nI guess this is currently a dead code, but would change if we ever want to have priority cancelation markers? If that's a sole motivation, I would revisit this problem in the future. Who knows if we will need this with checkpoint abort RPC. And if we will do, there is also another option:\nInserting priority UC barrier, could go through a separate method , that would return overtaken in-flight data:\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nwhich would also eliminate the currently existing assumption/hack that requestInflightBufferSnapshot has to be always called immediately after inserting as a head.", "url": "https://github.com/apache/flink/pull/13228#discussion_r487038327", "createdAt": "2020-09-11T13:17:48Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\tif (unalignedCheckpoint) {\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n \t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n+\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n+\t\tboolean unalignedCheckpoint;\n+\t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n+\t\t\tBuffer buffer = bc.build();\n+\t\t\ttry {\n+\t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n+\t\t\t} finally {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n \t\t}\n+\t\treturn unalignedCheckpoint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNTUyMQ==", "bodyText": "Moved this method to the commit that spills immediately. We need it in that method to retrieve the checkpoint id to spill correctly.\nDeserialization is only necessary for priority events, which are very rare and rather cheap (30 bytes). I'd argue that adding a new call chain just to optimize it is not warranted.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489235521", "createdAt": "2020-09-16T07:52:00Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\tif (unalignedCheckpoint) {\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n \t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n+\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n+\t\tboolean unalignedCheckpoint;\n+\t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n+\t\t\tBuffer buffer = bc.build();\n+\t\t\ttry {\n+\t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n+\t\t\t} finally {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n \t\t}\n+\t\treturn unalignedCheckpoint;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw=="}, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjU0MjAyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzoyMTowMVrOHQelAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzo1Mzo1MlrOHSkonQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ==", "bodyText": "is this method being used? I think at least not in this commit", "url": "https://github.com/apache/flink/pull/13228#discussion_r487040259", "createdAt": "2020-09-11T13:21:01Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+/**\n+ * A deque-like data structure that supports prioritization of elements, such they will be polled before any\n+ * non-priority elements.\n+ *\n+ * <p>{@implNote The current implementation deliberately does not implement the respective interface to minimize the maintenance\n+ * effort. Furthermore, it's optimized for handling non-priority elements, such that all operations for adding priority\n+ * elements are much slower than the non-priority counter-parts.}\n+ *\n+ * <p>Note that all element tests are performed by identity.\n+ *\n+ * @param <T> the element type.\n+ */\n+@Internal\n+public final class PrioritizedDeque<T> implements Iterable<T> {\n+\tprivate final Deque<T> deque = new ArrayDeque<>();\n+\tprivate int numPriorityElements;\n+\n+\t/**\n+\t * Adds a priority element to this deque, such that it will be polled after all existing priority elements but\n+\t * before any non-priority element.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void addPriorityElement(T element) {\n+\t\t// priority elements are rather rare and short-lived, so most of there are none\n+\t\tif (numPriorityElements == 0) {\n+\t\t\tdeque.addFirst(element);\n+\t\t} else if (numPriorityElements == deque.size()) {\n+\t\t\t// no non-priority elements\n+\t\t\tdeque.add(element);\n+\t\t} else {\n+\t\t\t// remove all priority elements\n+\t\t\tfinal ArrayDeque<T> priorPriority = new ArrayDeque<>(numPriorityElements);\n+\t\t\tfor (int index = 0; index < numPriorityElements; index++) {\n+\t\t\t\tpriorPriority.addFirst(deque.poll());\n+\t\t\t}\n+\t\t\tdeque.addFirst(element);\n+\t\t\t// readd them before the newly added element\n+\t\t\tfor (final T priorityEvent : priorPriority) {\n+\t\t\t\tdeque.addFirst(priorityEvent);\n+\t\t\t}\n+\t\t}\n+\t\tnumPriorityElements++;\n+\t}\n+\n+\t/**\n+\t * Adds a non-priority element to this deque, which will be polled last.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void add(T element) {\n+\t\tdeque.add(element);\n+\t}\n+\n+\t/**\n+\t * Convenience method for adding an element with optional priority and prior removal.\n+\t *\n+\t * @param element the element to add\n+\t * @param priority flag indicating if it's a priority or non-priority element\n+\t * @param alreadyContained flag that hints that the element is already in this deque, potentially as non-priority element.\n+\t */\n+\tpublic void add(T element, boolean priority, boolean alreadyContained) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjYzNw==", "bodyText": "I'm moving it to the commit that starts using it.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489236637", "createdAt": "2020-09-16T07:53:52Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+/**\n+ * A deque-like data structure that supports prioritization of elements, such they will be polled before any\n+ * non-priority elements.\n+ *\n+ * <p>{@implNote The current implementation deliberately does not implement the respective interface to minimize the maintenance\n+ * effort. Furthermore, it's optimized for handling non-priority elements, such that all operations for adding priority\n+ * elements are much slower than the non-priority counter-parts.}\n+ *\n+ * <p>Note that all element tests are performed by identity.\n+ *\n+ * @param <T> the element type.\n+ */\n+@Internal\n+public final class PrioritizedDeque<T> implements Iterable<T> {\n+\tprivate final Deque<T> deque = new ArrayDeque<>();\n+\tprivate int numPriorityElements;\n+\n+\t/**\n+\t * Adds a priority element to this deque, such that it will be polled after all existing priority elements but\n+\t * before any non-priority element.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void addPriorityElement(T element) {\n+\t\t// priority elements are rather rare and short-lived, so most of there are none\n+\t\tif (numPriorityElements == 0) {\n+\t\t\tdeque.addFirst(element);\n+\t\t} else if (numPriorityElements == deque.size()) {\n+\t\t\t// no non-priority elements\n+\t\t\tdeque.add(element);\n+\t\t} else {\n+\t\t\t// remove all priority elements\n+\t\t\tfinal ArrayDeque<T> priorPriority = new ArrayDeque<>(numPriorityElements);\n+\t\t\tfor (int index = 0; index < numPriorityElements; index++) {\n+\t\t\t\tpriorPriority.addFirst(deque.poll());\n+\t\t\t}\n+\t\t\tdeque.addFirst(element);\n+\t\t\t// readd them before the newly added element\n+\t\t\tfor (final T priorityEvent : priorPriority) {\n+\t\t\t\tdeque.addFirst(priorityEvent);\n+\t\t\t}\n+\t\t}\n+\t\tnumPriorityElements++;\n+\t}\n+\n+\t/**\n+\t * Adds a non-priority element to this deque, which will be polled last.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void add(T element) {\n+\t\tdeque.add(element);\n+\t}\n+\n+\t/**\n+\t * Convenience method for adding an element with optional priority and prior removal.\n+\t *\n+\t * @param element the element to add\n+\t * @param priority flag indicating if it's a priority or non-priority element\n+\t * @param alreadyContained flag that hints that the element is already in this deque, potentially as non-priority element.\n+\t */\n+\tpublic void add(T element, boolean priority, boolean alreadyContained) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ=="}, "originalCommit": {"oid": "2da72acf839999a2d722325913e033c3b606f149"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjU3ODk4OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzozMDo0MlrOHQe8BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowNzo1OVrOHSlJ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA==", "bodyText": "nit: you've broken a comment reference (L125):\n#isAvailable(BufferAndBacklog)\n\nreplace it with javadoc's {@link}?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046148", "createdAt": "2020-09-11T13:30:42Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTE2Ng==", "bodyText": "I added an implNote in the javadoc.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489245166", "createdAt": "2020-09-16T08:07:59Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA=="}, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjU4Mjg1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzozMTo1MFrOHQe-lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzozMTo1MFrOHQe-lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjgwNQ==", "bodyText": "or {@link DataType.NONE}", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046805", "createdAt": "2020-09-11T13:31:50Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjU5MTA3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzozNDoyNlrOHQfEHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxMDozMFrOHSlQEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA==", "bodyText": "It's hard to say now, what does it mean it should be kept in sync, as they return very different things. On the other hand, this comment is valuable, so would be nice to keep it?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487048220", "createdAt": "2020-09-11T13:34:26Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjczNw==", "bodyText": "I expanded the comment (now javadoc) to clearly state the contract.", "url": "https://github.com/apache/flink/pull/13228#discussion_r489246737", "createdAt": "2020-09-16T08:10:30Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA=="}, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjYyNjI2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzo0MzoxMVrOHQfZkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzo0MzoxMVrOHQfZkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MzcxMg==", "bodyText": "nit: whitespace?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487053712", "createdAt": "2020-09-11T13:43:11Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java", "diffHunk": "@@ -109,14 +113,14 @@ private void setupInputChannels() {\n \t\t\t\t\tbufferBuilder.finish();\n \n \t\t\t\t\t// Call getCurrentBuffer to ensure size is set\n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), nextType, 0));\n \t\t\t\t} else if (input != null && input.isEvent()) {\n \t\t\t\t\tAbstractEvent event = input.getEvent();\n \t\t\t\t\tif (event instanceof EndOfPartitionEvent) {\n \t\t\t\t\t\tinputChannels[channelIndex].setReleased();\n \t\t\t\t\t}\n \n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), nextType,\t0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f16a0d23693561aaa75940915aae90f08d1e3633"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjY0MTYzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzo0Njo0N1rOHQfi_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzo0Njo0N1rOHQfi_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NjEyNQ==", "bodyText": "good to know that it returns something :)", "url": "https://github.com/apache/flink/pull/13228#discussion_r487056125", "createdAt": "2020-09-11T13:46:47Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -290,6 +294,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \t/**\n \t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n \t * returns null in all other cases.\n+\t * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjcwMDc5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDowMToxOVrOHQgHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDowMToxOVrOHQgHfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTQ3MQ==", "bodyText": "add java doc what does it return?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487065471", "createdAt": "2020-09-11T14:01:19Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;\n \t\tCompletableFuture<?> toNotify = null;\n \n \t\tsynchronized (inputChannelsWithData) {\n-\t\t\tif (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) {\n+\t\t\t// do not enqueue if the channel is currently polled because priority event could have been polled already\n+\t\t\t// let #waitAndGetNextData re-enqueue the channel correctly instead\n+\t\t\tif (priority && selectedChannel == channel) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tavailableChannels = inputChannelsWithData.size();\n \n-\t\t\tinputChannelsWithData.add(channel);\n-\t\t\tenqueuedInputChannelsWithData.set(channel.getChannelIndex());\n+\t\t\tif (!queueChannelUnsafe(channel, priority)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\t\tif (availableChannels == 0) {\n+\t\t\tif (priority && inputChannelsWithData.getNumPriorityElements() == 1) {\n+\t\t\t\ttoNotifyPriority = priorityAvailabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t}\n+\t\t\tif (inputChannelsWithData.size() == 1) {\n \t\t\t\tinputChannelsWithData.notifyAll();\n \t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n \t\t\t}\n \t\t}\n \n+\t\tif (toNotifyPriority != null) {\n+\t\t\ttoNotifyPriority.complete(null);\n+\t\t}\n \t\tif (toNotify != null) {\n \t\t\ttoNotify.complete(null);\n \t\t}\n \t}\n \n+\tprivate boolean queueChannelUnsafe(InputChannel channel, boolean priority) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjcxODg5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDowNjowM1rOHQgTFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDowNjowM1rOHQgTFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2ODQzNw==", "bodyText": "nit: extract everything below to:\nreturn Optional.of(processBufferOrEvent(nextOpt.get()));\n\n?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487068437", "createdAt": "2020-09-11T14:06:03Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -186,34 +203,47 @@ public boolean isFinished() {\n \tprivate Optional<InputWithData<IndexedInputGate, BufferOrEvent>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<IndexedInputGate> inputGate = getInputGate(blocking);\n-\t\t\tif (!inputGate.isPresent()) {\n+\t\t\tOptional<IndexedInputGate> inputGateOpt = getInputGate(blocking);\n+\t\t\tif (!inputGateOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n+\t\t\tfinal IndexedInputGate inputGate = inputGateOpt.get();\n \n \t\t\t// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.\n \t\t\t// Do not poll the gate under inputGatesWithData lock, since this can trigger notifications\n \t\t\t// that could deadlock because of wrong locks taking order.\n-\t\t\tOptional<BufferOrEvent> bufferOrEvent = inputGate.get().pollNext();\n+\t\t\tOptional<BufferOrEvent> nextOpt = inputGate.pollNext();\n+\t\t\tif (!nextOpt.isPresent()) {\n+\t\t\t\tinputGate.getAvailableFuture().thenRun(() -> queueInputGate(inputGate, false));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfinal BufferOrEvent bufferOrEvent = nextOpt.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjczNjgwOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxMDozMFrOHQgeHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0NTozMlrOHVwFaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw==", "bodyText": "optional nit:\nextract toNotify and toNotifyPriority pair to some simple inner class `\npublic static class DataNotification() {\n  @Nullable\n  CompletableFuture<?> toNotifyPriority = null;\n  @Nullable\n  CompletableFuture<?> toNotify = null;\n\n  // two setters\n  setXYZ(...);\n\n  void complete() {\n \t\tif (toNotifyPriority != null) {\n\t\t\ttoNotifyPriority.complete(null);\n\t\t}\n\t\tif (toNotify != null) {\n\t\t\ttoNotify.complete(null);\n\t\t}\n  }\n}\n\nand re-use in UnionInputGate as well?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487071263", "createdAt": "2020-09-11T14:10:30Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2OTk2MA==", "bodyText": "Extracted into GateNotificationHelper, please check if it's actually helping to reduce complexity.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492569960", "createdAt": "2020-09-22T08:45:32Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw=="}, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzIyNzM0OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNToxMFrOHQlNwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDo1MDoxMVrOHTDuVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA==", "bodyText": "I haven't fully understood this part yet. Maybe let's sync later off-line?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487148994", "createdAt": "2020-09-11T16:15:10Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -89,6 +92,14 @@\n \t */\n \tprivate final int[] inputGateChannelIndexOffsets;\n \n+\t/**\n+\t * The channel from which is currently polled, which allows interleaving of\n+\t * {@link #queueInputGate(IndexedInputGate, boolean)} and {@link #pollNext()} (FLINK-12510 (Deadlock when reading from InputGates)).\n+\t */\n+\t@GuardedBy(\"inputGatesWithData\")\n+\t@Nullable\n+\tprivate IndexedInputGate currentInputGate;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NjAwNw==", "bodyText": "Removed thanks to alternative fix of FLINK-12510 (see previous commit now).", "url": "https://github.com/apache/flink/pull/13228#discussion_r489746007", "createdAt": "2020-09-16T20:50:11Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -89,6 +92,14 @@\n \t */\n \tprivate final int[] inputGateChannelIndexOffsets;\n \n+\t/**\n+\t * The channel from which is currently polled, which allows interleaving of\n+\t * {@link #queueInputGate(IndexedInputGate, boolean)} and {@link #pollNext()} (FLINK-12510 (Deadlock when reading from InputGates)).\n+\t */\n+\t@GuardedBy(\"inputGatesWithData\")\n+\t@Nullable\n+\tprivate IndexedInputGate currentInputGate;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA=="}, "originalCommit": {"oid": "0ca6de6b7301067733c435729a078f5b5f0a89fb"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzIzNjI3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNzo0NlrOHQlTLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0NjowOFrOHVwG3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw==", "bodyText": "could you elaborate a bit more in the commit message, what has been simplified, why and what are the benefits?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487150383", "createdAt": "2020-09-11T16:17:46Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java", "diffHunk": "@@ -34,11 +30,8 @@\n \tvoid notifyDataAvailable();\n \n \t/**\n-\t * Allows the listener to react to a priority event before it is added to the outgoing buffer queue.\n-\t *\n-\t * @return true if the event has been fully processed and should not be added to the buffer queue.\n+\t * Called when the first priority event is added to the head of the buffer queue.\n \t */\n-\tdefault boolean notifyPriorityEvent(BufferConsumer eventBufferConsumer) throws IOException {\n-\t\treturn false;\n+\tdefault void notifyPriorityEvent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1a1448b0654865a3dfd404b7027ad764790d76"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDMzNA==", "bodyText": "Added a few thoughts. Let me know if it makes things clearer.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492570334", "createdAt": "2020-09-22T08:46:08Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java", "diffHunk": "@@ -34,11 +30,8 @@\n \tvoid notifyDataAvailable();\n \n \t/**\n-\t * Allows the listener to react to a priority event before it is added to the outgoing buffer queue.\n-\t *\n-\t * @return true if the event has been fully processed and should not be added to the buffer queue.\n+\t * Called when the first priority event is added to the head of the buffer queue.\n \t */\n-\tdefault boolean notifyPriorityEvent(BufferConsumer eventBufferConsumer) throws IOException {\n-\t\treturn false;\n+\tdefault void notifyPriorityEvent() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw=="}, "originalCommit": {"oid": "5f1a1448b0654865a3dfd404b7027ad764790d76"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzAzNDA4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoxNzozMlrOHRXEMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0ODo0MVrOHVwNMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ==", "bodyText": "This is an intermediate code that is being replaced later. Can you squash those changes?", "url": "https://github.com/apache/flink/pull/13228#discussion_r487965745", "createdAt": "2020-09-14T14:17:32Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -147,6 +148,14 @@ else if (configuredInput instanceof SourceInputConfig) {\n \t\treturn anyInputAvailable;\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn CompletableFuture.anyOf(\n+\t\t\tArrays.stream(inputProcessors)\n+\t\t\t\t.map(inputProcessor -> inputProcessor.taskInput.getPriorityEventAvailableFuture())\n+\t\t\t\t.toArray(CompletableFuture[]::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9fe248c39645e93e5210430417cef3bdc2ed6e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MTk1Mg==", "bodyText": "Commit is removed.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492571952", "createdAt": "2020-09-22T08:48:41Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -147,6 +148,14 @@ else if (configuredInput instanceof SourceInputConfig) {\n \t\treturn anyInputAvailable;\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn CompletableFuture.anyOf(\n+\t\t\tArrays.stream(inputProcessors)\n+\t\t\t\t.map(inputProcessor -> inputProcessor.taskInput.getPriorityEventAvailableFuture())\n+\t\t\t\t.toArray(CompletableFuture[]::new));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ=="}, "originalCommit": {"oid": "0b9fe248c39645e93e5210430417cef3bdc2ed6e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzA2MTA4OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoyMTowNlrOHRXTrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoyMTowNlrOHRXTrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2OTcwOA==", "bodyText": "As we discussed online there is a bit of duplicated code here.", "url": "https://github.com/apache/flink/pull/13228#discussion_r487969708", "createdAt": "2020-09-14T14:21:06Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -371,12 +371,16 @@ protected void processInput(MailboxDefaultAction.Controller controller) throws E\n \t */\n \t@VisibleForTesting\n \tCompletableFuture<?> getInputOutputJointFuture(InputStatus status) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputProcessor.getPriorityEventAvailableFuture();\n \t\tif (status == InputStatus.NOTHING_AVAILABLE && !recordWriter.isAvailable()) {\n-\t\t\treturn CompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture());\n+\t\t\treturn CompletableFuture.anyOf(\n+\t\t\t\tpriorityEventAvailableFuture,\n+\t\t\t\tCompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture()));\n \t\t} else if (status == InputStatus.NOTHING_AVAILABLE) {\n-\t\t\treturn inputProcessor.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(inputProcessor.getAvailableFuture(),\n+\t\t\t\tpriorityEventAvailableFuture);\n \t\t} else {\n-\t\t\treturn recordWriter.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(priorityEventAvailableFuture, recordWriter.getAvailableFuture());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9fe248c39645e93e5210430417cef3bdc2ed6e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzE2NTAxOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDo0MToxMlrOHRYT8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyMDozOFrOHVxZdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw==", "bodyText": "Again I would point to the previous comment:\n#13228 (comment)\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nmight be a better option. (It might not, as I haven't tried to implement it)", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986163", "createdAt": "2020-09-14T14:41:12Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTQ3OA==", "bodyText": "Not relevant in the final version where the channel spills by itself (no return value on this method). I can make it clearer in the commit message if you want.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492591478", "createdAt": "2020-09-22T09:20:38Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzE2NzAzOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDo0MTozOVrOHRYVMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNTozOToxOVrOHVq2dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ==", "bodyText": "This is again modifying code that I have already reviewed in the previous commit :(", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986481", "createdAt": "2020-09-14T14:41:39Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n \t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NDIxNA==", "bodyText": "Hm I have a hard time coming up with a better code structure. I could add checkpoint parsing and the if in addBuffer already in the first commit [FLINK-19026][network] Adding PrioritizedDeque and use it in PipelinedSubpartition.. Then this diff would be only about persisting itself.\nBut I was convinced that you would be confused why we need to parse the barrier at that commit.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492484214", "createdAt": "2020-09-22T05:39:19Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n \t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzI1MzM3OnYy", "diffSide": "LEFT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDo1OTowMVrOHRZJxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNTo1MDoyN1rOHVrBpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw==", "bodyText": "Are you sure it's going in the right direction this change? Previously spilling was explicit on demand, now it's happening magically (implicitly) inside LocalInputChannel.", "url": "https://github.com/apache/flink/pull/13228#discussion_r487999943", "createdAt": "2020-09-14T14:59:01Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -232,19 +232,16 @@ public int getInputIndex() {\n \t\t\tChannelStateWriter channelStateWriter,\n \t\t\tlong checkpointId) throws IOException {\n \t\tfor (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {\n-\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n-\n-\t\t\t// Assumption for retrieving buffers = one concurrent checkpoint\n \t\t\tRecordDeserializer<?> deserializer = recordDeserializers[channelIndex];\n \t\t\tif (deserializer != null) {\n+\t\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n+\n \t\t\t\tchannelStateWriter.addInputData(\n \t\t\t\t\tcheckpointId,\n \t\t\t\t\tchannel.getChannelInfo(),\n \t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n \t\t\t\t\tdeserializer.getUnconsumedBuffer());\n \t\t\t}\n-\n-\t\t\tcheckpointedInputGate.spillInflightBuffers(checkpointId, channelIndex, channelStateWriter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzA3OQ==", "bodyText": "We discussed offline, but let me summarize the main point. When spilling in main thread, buffers would be spilled rather late as you pointed out initially.\nOne solution is to trigger the channel spilling in task thread as soon as possible and then resume spilling from netty until barrier arrives. However, that results in a complex threading model with lots of race condition as we found out in the version in master.\nAnother solution is to spill in task thread and use any poll to discover new buffers and spill them. It's slightly slower and also requires lots of internal knowledge at the Unaligner about the channels to work well (mark all spilled channels). It's probably also suboptimal as new buffers are usually enqueued right after the head is polled, so one buffer is enqueued in the channel but not persisted until the new head is polled.\nThe proposed solution is to spill in netty thread entirely. That's the fastest possible solution with an comparably easy threading model. Downside is the added complexity on channel-side, but the general idea is that upstream and downstream side of a channel is now self-contained.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487079", "createdAt": "2020-09-22T05:50:27Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -232,19 +232,16 @@ public int getInputIndex() {\n \t\t\tChannelStateWriter channelStateWriter,\n \t\t\tlong checkpointId) throws IOException {\n \t\tfor (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {\n-\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n-\n-\t\t\t// Assumption for retrieving buffers = one concurrent checkpoint\n \t\t\tRecordDeserializer<?> deserializer = recordDeserializers[channelIndex];\n \t\t\tif (deserializer != null) {\n+\t\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n+\n \t\t\t\tchannelStateWriter.addInputData(\n \t\t\t\t\tcheckpointId,\n \t\t\t\t\tchannel.getChannelInfo(),\n \t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n \t\t\t\t\tdeserializer.getUnconsumedBuffer());\n \t\t\t}\n-\n-\t\t\tcheckpointedInputGate.spillInflightBuffers(checkpointId, channelIndex, channelStateWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzMxNjgyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNToxMTozMVrOHRZyFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyNDoxOFrOHVxikQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA==", "bodyText": "Are you spilling only on polling the buffer? (I think RemoteInputChannel is working better in this regard)", "url": "https://github.com/apache/flink/pull/13228#discussion_r488010260", "createdAt": "2020-09-14T15:11:31Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -210,15 +221,25 @@ public void spillInflightBuffers(long checkpointId, ChannelStateWriter channelSt\n \t\t}\n \n \t\tBuffer buffer = next.buffer();\n-\t\tCheckpointBarrier notifyReceivedBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\tif (notifyReceivedBarrier != null) {\n-\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t} else if (receivedCheckpointId < lastRequestedCheckpointId && buffer.isBuffer()) {\n-\t\t\tinputGate.getBufferReceivedListener().notifyBufferReceived(buffer.retainBuffer(), channelInfo);\n-\t\t}\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n+\t\tif (buffer.isBuffer()) {\n+\t\t\tfor (final long barrierId : pendingCheckpointBarriers) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MzgwOQ==", "bodyText": "LocalInputChannel only spills when it awaits barrier. So it spills the buffer on first sight and it cannot be better on downsteam level. We could of course also move spilling lingering buffers to the upstream. It might also be an improvement for later, but it adds quite a bit of complexity as barriers also need to be propagated upstream.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492593809", "createdAt": "2020-09-22T09:24:18Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -210,15 +221,25 @@ public void spillInflightBuffers(long checkpointId, ChannelStateWriter channelSt\n \t\t}\n \n \t\tBuffer buffer = next.buffer();\n-\t\tCheckpointBarrier notifyReceivedBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\tif (notifyReceivedBarrier != null) {\n-\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t} else if (receivedCheckpointId < lastRequestedCheckpointId && buffer.isBuffer()) {\n-\t\t\tinputGate.getBufferReceivedListener().notifyBufferReceived(buffer.retainBuffer(), channelInfo);\n-\t\t}\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n+\t\tif (buffer.isBuffer()) {\n+\t\t\tfor (final long barrierId : pendingCheckpointBarriers) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzM2ODk3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNToyMjo0NlrOHRaSKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyNjozNVrOHVxocQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA==", "bodyText": "I don't think it's worth complicating the code with support for multiple concurrent checkpoints. It's not likely to be implemented soon, if ever.", "url": "https://github.com/apache/flink/pull/13228#discussion_r488018474", "createdAt": "2020-09-14T15:22:46Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -89,17 +96,15 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n+\tprivate final BufferManager bufferManager;\n \n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n+\t/** Stores #overtaken buffers when a checkpoint barrier is received before task thread started checkpoint. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Map<Long, Integer> numBuffersOvertaken = new HashMap<>();\n \n-\tprivate final BufferManager bufferManager;\n+\t/** All started checkpoints where a barrier has not been received yet. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Deque<Long> pendingCheckpointBarriers = new ArrayDeque<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTMxMw==", "bodyText": "Changed it to support only one concurrent checkpoint. I also extracted the whole logic into one helper class that can be used by both LocalInputChannel and RemoteInputChannel (with syncrhonization).", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595313", "createdAt": "2020-09-22T09:26:35Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -89,17 +96,15 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n+\tprivate final BufferManager bufferManager;\n \n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n+\t/** Stores #overtaken buffers when a checkpoint barrier is received before task thread started checkpoint. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Map<Long, Integer> numBuffersOvertaken = new HashMap<>();\n \n-\tprivate final BufferManager bufferManager;\n+\t/** All started checkpoints where a barrier has not been received yet. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Deque<Long> pendingCheckpointBarriers = new ArrayDeque<>(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzM4Mzg1OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNToyNTo1NlrOHRabXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyNjo1M1rOHVxpFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ==", "bodyText": "This method has grown too large.", "url": "https://github.com/apache/flink/pull/13228#discussion_r488020829", "createdAt": "2020-09-14T15:25:56Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTQ3Nw==", "bodyText": "Much smaller now thanks to the helper class.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595477", "createdAt": "2020-09-22T09:26:53Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQyNTI5OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozMjo0OFrOHRa2fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyODozOVrOHVxs7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ==", "bodyText": "nitty nit: writeInFlightBuffers? (write as Romand picked writer for the \"spilling\" nomenclature)", "url": "https://github.com/apache/flink/pull/13228#discussion_r488027775", "createdAt": "2020-09-14T15:32:48Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n \n \t\t\t++expectedSequenceNumber;\n \n+\t\t\tif (firstPriorityEvent) {\n+\t\t\t\tnotifyPriorityEvent();\n+\t\t\t}\n \t\t\tif (wasEmpty) {\n \t\t\t\tnotifyChannelNonEmpty();\n \t\t\t}\n \n \t\t\tif (backlog >= 0) {\n \t\t\t\tonSenderBacklog(backlog);\n \t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n \t\t} finally {\n \t\t\tif (recycleBuffer) {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Spills all queued buffers on checkpoint start. If barrier has already been received (and reordered), spill only\n+\t * the overtaken buffers.\n+\t */\n+\tpublic void checkpointStarted(CheckpointBarrier barrier) {\n+\t\tcheckState(channelStateWriter != null, \"Channel state writer not injected\");\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tfinal Integer numBuffers = numBuffersOvertaken.get(barrier.getId());\n+\t\t\tif (numBuffers != null) {\n+\t\t\t\t// already received barrier before the task thread picked up the barrier of this or another channel\n+\t\t\t\tspillBuffers(barrier.getId(), numBuffers);\n+\t\t\t} else {\n+\t\t\t\t// barrier not yet received, spill all current and future buffers\n+\t\t\t\tspillBuffers(barrier.getId(), receivedBuffers.getNumUnprioritizedElements());\n+\t\t\t\tpendingCheckpointBarriers.add(barrier.getId());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void checkpointStopped(long checkpointId) {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tnumBuffersOvertaken.remove(checkpointId);\n+\t\t\tpendingCheckpointBarriers.remove(checkpointId);\n+\t\t}\n+\t}\n+\n+\tprivate void spillBuffers(long checkpointId, int numBuffers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NjQ2Mg==", "bodyText": "I added a helper class ChannelStatePersister and used persist everywhere to have a clear separation of the two names. Persister is more on the logical level and Writer on the physical implementation.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492596462", "createdAt": "2020-09-22T09:28:39Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n \n \t\t\t++expectedSequenceNumber;\n \n+\t\t\tif (firstPriorityEvent) {\n+\t\t\t\tnotifyPriorityEvent();\n+\t\t\t}\n \t\t\tif (wasEmpty) {\n \t\t\t\tnotifyChannelNonEmpty();\n \t\t\t}\n \n \t\t\tif (backlog >= 0) {\n \t\t\t\tonSenderBacklog(backlog);\n \t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n \t\t} finally {\n \t\t\tif (recycleBuffer) {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Spills all queued buffers on checkpoint start. If barrier has already been received (and reordered), spill only\n+\t * the overtaken buffers.\n+\t */\n+\tpublic void checkpointStarted(CheckpointBarrier barrier) {\n+\t\tcheckState(channelStateWriter != null, \"Channel state writer not injected\");\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tfinal Integer numBuffers = numBuffersOvertaken.get(barrier.getId());\n+\t\t\tif (numBuffers != null) {\n+\t\t\t\t// already received barrier before the task thread picked up the barrier of this or another channel\n+\t\t\t\tspillBuffers(barrier.getId(), numBuffers);\n+\t\t\t} else {\n+\t\t\t\t// barrier not yet received, spill all current and future buffers\n+\t\t\t\tspillBuffers(barrier.getId(), receivedBuffers.getNumUnprioritizedElements());\n+\t\t\t\tpendingCheckpointBarriers.add(barrier.getId());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void checkpointStopped(long checkpointId) {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tnumBuffersOvertaken.remove(checkpointId);\n+\t\t\tpendingCheckpointBarriers.remove(checkpointId);\n+\t\t}\n+\t}\n+\n+\tprivate void spillBuffers(long checkpointId, int numBuffers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQyNzMwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozMzoyMFrOHRa32g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNTo1MToyNlrOHVrClQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/apache/flink/pull/13228#discussion_r488028122", "createdAt": "2020-09-14T15:33:20Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -314,6 +315,21 @@ protected StreamTask(\n \t\t}\n \n \t\tthis.channelIOExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"channel-state-unspilling\"));\n+\n+\t\tinjectChannelStateWriterIntoChannels();\n+\t}\n+\n+\tprivate void injectChannelStateWriterIntoChannels() {\n+\t\tfinal Environment env = getEnvironment();\n+\t\tfinal ChannelStateWriter channelStateWriter = subtaskCheckpointCoordinator.getChannelStateWriter();\n+\t\tfor (final InputGate gate : env.getAllInputGates()) {\n+\t\t\tgate.setChannelStateWriter(channelStateWriter);\n+\t\t}\n+\t\tfor (ResultPartitionWriter writer : env.getAllWriters()) {\n+\t\t\tif (writer instanceof ChannelStateHolder) {\n+\t\t\t\t((ChannelStateHolder) writer).setChannelStateWriter(channelStateWriter);\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzMxNw==", "bodyText": "Happy for any other suggestion. I think the cast itself is in line with recent changes done by Stephan.\nThe proper solution would be to inject in ctor but that will not happen until we merge runtime and streaming.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487317", "createdAt": "2020-09-22T05:51:26Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -314,6 +315,21 @@ protected StreamTask(\n \t\t}\n \n \t\tthis.channelIOExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"channel-state-unspilling\"));\n+\n+\t\tinjectChannelStateWriterIntoChannels();\n+\t}\n+\n+\tprivate void injectChannelStateWriterIntoChannels() {\n+\t\tfinal Environment env = getEnvironment();\n+\t\tfinal ChannelStateWriter channelStateWriter = subtaskCheckpointCoordinator.getChannelStateWriter();\n+\t\tfor (final InputGate gate : env.getAllInputGates()) {\n+\t\t\tgate.setChannelStateWriter(channelStateWriter);\n+\t\t}\n+\t\tfor (ResultPartitionWriter writer : env.getAllWriters()) {\n+\t\t\tif (writer instanceof ChannelStateHolder) {\n+\t\t\t\t((ChannelStateHolder) writer).setChannelStateWriter(channelStateWriter);\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg=="}, "originalCommit": {"oid": "d06c7130a74dc1259994a7abb91296a6893361c5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQzNjcyOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozNToyMlrOHRa9pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNTo1ODo1N1rOHVrKKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg==", "bodyText": "Is the code in a working state before:\n\nRemove synchronization from CheckpointBarrierUnaligner.\n\ncommit? It looks like data are spilled in two places, right?", "url": "https://github.com/apache/flink/pull/13228#discussion_r488029606", "createdAt": "2020-09-14T15:35:22Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -22,13 +22,10 @@\n import org.apache.flink.annotation.VisibleForTesting;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e3eafcdf62ecbe7e67f2b50b66f12a3b56af99e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4OTI1OA==", "bodyText": "I admit that it's an awkward cut.\nHowever, it's only spilled in one place as the BufferReceivedListener methods are effectively not called in the previous commits anymore. I will make a later pass to see that all tests pass though.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492489258", "createdAt": "2020-09-22T05:58:57Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -22,13 +22,10 @@\n import org.apache.flink.annotation.VisibleForTesting;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg=="}, "originalCommit": {"oid": "6e3eafcdf62ecbe7e67f2b50b66f12a3b56af99e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ0ODU3OnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozNzo1NlrOHRbEzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozNzo1NlrOHRbEzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMTQzOA==", "bodyText": "A minor rebasing/squashing mistake?", "url": "https://github.com/apache/flink/pull/13228#discussion_r488031438", "createdAt": "2020-09-14T15:37:56Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java", "diffHunk": "@@ -122,8 +121,8 @@ public void close() throws Exception {\n \t}\n \n \t@Override\n-\tpublic void registerBufferReceivedListener(BufferReceivedListener listener) {\n-\t\tinputGate.registerBufferReceivedListener(listener);\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn inputGate.getPriorityEventAvailableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d47325cba6cafc4b69e300f56261f6c8157d7cf9"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ1NjM0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozOTo0MVrOHRbJjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNTo1Njo0NFrOHVrH_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ==", "bodyText": "Why has this test and CheckpointBarrierTrackerTest.java changed in this commit? Rebasing/squashing mistake, or am I missing something about this commit (I thought it's a pure clean up without functional changes).", "url": "https://github.com/apache/flink/pull/13228#discussion_r488032655", "createdAt": "2020-09-14T15:39:41Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -369,9 +369,7 @@ public void testMissingCancellationBarriers() throws Exception {\n \t\tinputGate = createBarrierBuffer(2, sequence, validator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d47325cba6cafc4b69e300f56261f6c8157d7cf9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4ODcwMg==", "bodyText": "A side-effect of this commit is that all events are handed over from CheckpointedInputGate to StreamTaskNetworkInput and break up the poll loop. However, since events are rare, it should have no visible impact on the throughput.\n\nThe changes to the tests are now handling the additionally emitted events. Imho tests are easier to read now (no magically disappearing buffers in the sequence).", "url": "https://github.com/apache/flink/pull/13228#discussion_r492488702", "createdAt": "2020-09-22T05:56:44Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -369,9 +369,7 @@ public void testMissingCancellationBarriers() throws Exception {\n \t\tinputGate = createBarrierBuffer(2, sequence, validator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ=="}, "originalCommit": {"oid": "d47325cba6cafc4b69e300f56261f6c8157d7cf9"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ4OTI1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0NzowNVrOHRbeCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozNjoyNVrOHVx--A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw==", "bodyText": "nit: add StreamMultipleInputProcessor to the mail's name?", "url": "https://github.com/apache/flink/pull/13228#discussion_r488037897", "createdAt": "2020-09-14T15:47:05Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n+\t\t\t}, \"priority event {}\", index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTA4MA==", "bodyText": "Commit removed; on CheckpointedInputGate, I'm adding the gate.toString().", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601080", "createdAt": "2020-09-22T09:36:25Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n+\t\t\t}, \"priority event {}\", index);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw=="}, "originalCommit": {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzUwMjY5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1MDowOFrOHRbmSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozNzoxM1rOHVyA-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA==", "bodyText": "Can not you maybe handle the priority message directly here, in this mail? Instead of relaying on the processDefaultAction to pick this up?\n(I'm asking/loudly thinking)", "url": "https://github.com/apache/flink/pull/13228#discussion_r488040010", "createdAt": "2020-09-14T15:50:08Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTU5NA==", "bodyText": "Moved it even further up towards CheckpointedInputGate. At this point, we need to make sure that a priority event is really at the top (hence the optimistic lock protocol for notification).", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601594", "createdAt": "2020-09-22T09:37:13Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA=="}, "originalCommit": {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzUyNDg2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1NToxMFrOHRb0FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozODo0M1rOHVyETw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA==", "bodyText": "What's the story behind this change?\n\nit seems it differs only by a single line numBarriersReceived = 0;, so at the very least we should deduplicate some code here\ncan you explain what's the functional change?\naren't we missing a unit test for that? It would help answer point 2., and if there was a bug discovered in e2e test, it would be nice to have a faster unit test for that as well.", "url": "https://github.com/apache/flink/pull/13228#discussion_r488043540", "createdAt": "2020-09-14T15:55:10Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -113,7 +113,11 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \n \t\t\tif (++numBarriersReceived == numOpenChannels) {\n \t\t\t\tallBarriersReceivedFuture.complete(null);\n-\t\t\t\tresetPendingCheckpoint(barrierId);\n+\t\t\t\tfor (final InputGate gate : inputGates) {\n+\t\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n+\t\t\t\t\t\tgate.getChannel(index).checkpointStopped(currentCheckpointId);\n+\t\t\t\t\t}\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa3e495b6ba201769d908adea420e4944ddd7643"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjQ0Nw==", "bodyText": "Sorry that was just a test commit to see if the stuck e2e failed because of this change. I removed it. The original change is covered by a few unit tests already.", "url": "https://github.com/apache/flink/pull/13228#discussion_r492602447", "createdAt": "2020-09-22T09:38:43Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -113,7 +113,11 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \n \t\t\tif (++numBarriersReceived == numOpenChannels) {\n \t\t\t\tallBarriersReceivedFuture.complete(null);\n-\t\t\t\tresetPendingCheckpoint(barrierId);\n+\t\t\t\tfor (final InputGate gate : inputGates) {\n+\t\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n+\t\t\t\t\t\tgate.getChannel(index).checkpointStopped(currentCheckpointId);\n+\t\t\t\t\t}\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA=="}, "originalCommit": {"oid": "fa3e495b6ba201769d908adea420e4944ddd7643"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDMwNDIyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyNzoyMVrOHV_8mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyNzoyMVrOHV_8mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyOTg1MQ==", "bodyText": "nit: move to a separate processCheckpointBarrier method?\nor maybe also one step further:\n\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n\t\tassert Thread.holdsLock(buffers);\t\n\t\tif (bufferConsumer.getDataType().hasPriority()) {\n\t\t\tprocessPriorityBuffer(bufferConsumer);\n\t\t}\n\t\tbuffers.add(bufferConsumer);\n\t\treturn false;\n\t}\n\nto highlight that on the hot path, (without priority) we are skipping this whole code?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492829851", "createdAt": "2020-09-22T15:27:21Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -177,32 +187,53 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tbuffers.addPriorityElement(bufferConsumer);\n \t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \n-\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n-\t\tIterators.advance(iterator, numPriorityElements);\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tBufferConsumer buffer = iterator.next();\n-\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, numPriorityElements);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (!inflightBuffers.isEmpty()) {\n+\t\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\t\tbarrier.getId(),\n+\t\t\t\t\tsubpartitionInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n+\t\t\t}\n \t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM0MTEyOnYy", "diffSide": "RIGHT", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozNTowMVrOHWATew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMDo1MDoyNVrOHWL4uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw==", "bodyText": "This doesn't seem to fit in the ChannelStatePersister interface. Maybe move those methods somewhere else? As static methods to InputChannel?\nAlso, aren't they duplicating the same logic as somewhere on the output sides?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492835707", "createdAt": "2020-09-22T15:35:01Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -361,4 +360,89 @@ public String toString() {\n \t\t\t\t'}';\n \t\t}\n \t}\n+\n+\t/**\n+\t * Helper class for persisting channel state via {@link ChannelStateWriter}.\n+\t */\n+\t@NotThreadSafe\n+\tprotected final class ChannelStatePersister {\n+\t\tprivate static final long CHECKPOINT_COMPLETED = -1;\n+\n+\t\tprivate static final long BARRIER_RECEIVED = -2;\n+\n+\t\t/** All started checkpoints where a barrier has not been received yet. */\n+\t\tprivate long pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\n+\t\t/** Writer must be initialized before usage. {@link #startPersisting(long, List)} enforces this invariant. */\n+\t\t@Nullable\n+\t\tprivate final ChannelStateWriter channelStateWriter;\n+\n+\t\tpublic ChannelStatePersister(@Nullable ChannelStateWriter channelStateWriter) {\n+\t\t\tthis.channelStateWriter = channelStateWriter;\n+\t\t}\n+\n+\t\tprotected void startPersisting(long barrierId, List<Buffer> knownBuffers) {\n+\t\t\tcheckState(isInitialized(), \"Channel state writer not injected\");\n+\n+\t\t\tif (pendingCheckpointBarrierId != BARRIER_RECEIVED) {\n+\t\t\t\tpendingCheckpointBarrierId = barrierId;\n+\t\t\t}\n+\t\t\tif (knownBuffers.size() > 0) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tchannelInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.fromList(knownBuffers, Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean isInitialized() {\n+\t\t\treturn channelStateWriter != null;\n+\t\t}\n+\n+\t\tprotected void stopPersisting() {\n+\t\t\tpendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\t\t}\n+\n+\t\tprotected void maybePersist(Buffer buffer) {\n+\t\t\tif (pendingCheckpointBarrierId >= 0 && buffer.isBuffer()) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tpendingCheckpointBarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean checkForBarrier(Buffer buffer) throws IOException {\n+\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n+\t\t * returns null in all other cases.\n+\t\t */\n+\t\t@Nullable\n+\t\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n+\t\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n+\t\t\t// we can further improve to avoid double deserialization in the future.\n+\t\t\tbuffer.setReaderIndex(0);\n+\t\t\treturn event;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAyNTQ2NA==", "bodyText": "It's only used in this class and thus I inlined it. As is, it really looks like an interface of the Persister.\nThere is similar code for BufferConsumer on output side, but the implementation is too different to align (copy buffer vs. reader index reset, different EventSerializer.fromBuffer overloads).", "url": "https://github.com/apache/flink/pull/13228#discussion_r493025464", "createdAt": "2020-09-22T20:50:25Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -361,4 +360,89 @@ public String toString() {\n \t\t\t\t'}';\n \t\t}\n \t}\n+\n+\t/**\n+\t * Helper class for persisting channel state via {@link ChannelStateWriter}.\n+\t */\n+\t@NotThreadSafe\n+\tprotected final class ChannelStatePersister {\n+\t\tprivate static final long CHECKPOINT_COMPLETED = -1;\n+\n+\t\tprivate static final long BARRIER_RECEIVED = -2;\n+\n+\t\t/** All started checkpoints where a barrier has not been received yet. */\n+\t\tprivate long pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\n+\t\t/** Writer must be initialized before usage. {@link #startPersisting(long, List)} enforces this invariant. */\n+\t\t@Nullable\n+\t\tprivate final ChannelStateWriter channelStateWriter;\n+\n+\t\tpublic ChannelStatePersister(@Nullable ChannelStateWriter channelStateWriter) {\n+\t\t\tthis.channelStateWriter = channelStateWriter;\n+\t\t}\n+\n+\t\tprotected void startPersisting(long barrierId, List<Buffer> knownBuffers) {\n+\t\t\tcheckState(isInitialized(), \"Channel state writer not injected\");\n+\n+\t\t\tif (pendingCheckpointBarrierId != BARRIER_RECEIVED) {\n+\t\t\t\tpendingCheckpointBarrierId = barrierId;\n+\t\t\t}\n+\t\t\tif (knownBuffers.size() > 0) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tchannelInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.fromList(knownBuffers, Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean isInitialized() {\n+\t\t\treturn channelStateWriter != null;\n+\t\t}\n+\n+\t\tprotected void stopPersisting() {\n+\t\t\tpendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\t\t}\n+\n+\t\tprotected void maybePersist(Buffer buffer) {\n+\t\t\tif (pendingCheckpointBarrierId >= 0 && buffer.isBuffer()) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tpendingCheckpointBarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean checkForBarrier(Buffer buffer) throws IOException {\n+\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n+\t\t * returns null in all other cases.\n+\t\t */\n+\t\t@Nullable\n+\t\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n+\t\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n+\t\t\t// we can further improve to avoid double deserialization in the future.\n+\t\t\tbuffer.setReaderIndex(0);\n+\t\t\treturn event;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw=="}, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM0OTAxOnYy", "diffSide": "LEFT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozNjozOVrOHWAYLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToxMDo0NVrOHWMhWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA==", "bodyText": "why was this test removed?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492836908", "createdAt": "2020-09-22T15:36:39Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java", "diffHunk": "@@ -120,67 +112,10 @@ public void testNoDataProcessedAfterCheckpointBarrier() throws Exception {\n \t\tassertEquals(0, output.getNumberOfEmittedRecords());\n \t}\n \n-\t@Test\n-\tpublic void testSnapshotWithTwoInputGates() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNTg2Ng==", "bodyText": "I added this test for FLINK-18139 - input gate index issues in Unaligner#hasInflightData, which is called by StreamTaskNetworkInput, hence the test here.\nHowever, in this commit, hasInflightData is removed. Spilling is fully encapsulated in InputChannel + CheckpointBarrierUnaligner/CheckpointedInputGate and this interaction is already covered in tests at CheckpointBarrierUnalignerTest.", "url": "https://github.com/apache/flink/pull/13228#discussion_r493035866", "createdAt": "2020-09-22T21:10:45Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java", "diffHunk": "@@ -120,67 +112,10 @@ public void testNoDataProcessedAfterCheckpointBarrier() throws Exception {\n \t\tassertEquals(0, output.getNumberOfEmittedRecords());\n \t}\n \n-\t@Test\n-\tpublic void testSnapshotWithTwoInputGates() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA=="}, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM1ODI0OnYy", "diffSide": "LEFT", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozODoyNFrOHWAdog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToxOTowN1rOHWMw8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg==", "bodyText": "Can you double check if indeed all of those test should be removed? I don't see how things like testPartitionNotFoundExceptionWhileGetNextBuffer should be related to this commit/PR?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492838306", "createdAt": "2020-09-22T15:38:24Z", "author": {"login": "pnowojski"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -812,242 +788,13 @@ public void testQueuedBuffers() throws Exception {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testBufferReceivedListener() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzOTg1Ng==", "bodyText": "Good catch, my intent was to delete testBufferReceivedListener and testPartitionNotFoundExceptionWhileGetNextBuffer but not the test in between them.\ntestBufferReceivedListener tests BufferReceivedListener which this commits renders useless (and is later removed).\ntestPartitionNotFoundExceptionWhileGetNextBuffer tests concurrent spilling of lingering buffers and receiving of such lingering buffers. Both now happens in the same thread, so the test does not make any sense.", "url": "https://github.com/apache/flink/pull/13228#discussion_r493039856", "createdAt": "2020-09-22T21:19:07Z", "author": {"login": "AHeise"}, "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -812,242 +788,13 @@ public void testQueuedBuffers() throws Exception {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testBufferReceivedListener() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg=="}, "originalCommit": {"oid": "51273f0b1235e5f095014ef1243d6776e297e225"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM5MDUzOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NTowOFrOHWAxew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyOTowM1rOHWNC9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw==", "bodyText": "add checkState(!inputGate.getPriorityEventAvailableFuture().isDone())?", "url": "https://github.com/apache/flink/pull/13228#discussion_r492843387", "createdAt": "2020-09-22T15:45:08Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -62,9 +65,37 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tif (inputGate.getPriorityEventAvailableFuture().isDone()) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69cd2be36ce52a0de0be43602ebce454644897a6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NDQ3MA==", "bodyText": "Good idea, I solved it in the following way:\n\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n\t\tboolean hasPriorityEvent = inputGate.getPriorityEventAvailableFuture().isDone();\n\t\twhile (hasPriorityEvent) {\n\t\t\t// process as many priority events as possible\n\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n\t\t\tbufferOrEventOpt.ifPresent(bufferOrEvent ->\n\t\t\t\tcheckState(bufferOrEvent.hasPriority(), \"Should only poll priority events\"));\n\t\t\thasPriorityEvent = bufferOrEventOpt.map(BufferOrEvent::morePriorityEvents).orElse(false);\n\t\t}\n\ncheckState(!inputGate.getPriorityEventAvailableFuture().isDone()) might be failing if netty receives a new priority event and triggers this available future while the task thread polled the last priority event. This case should happen quite often when the first barrier arrives (at that time the only priority event, morePriorityEvents = false) and triggers the whole checkpointing process. The second barrier would then complete the getPriorityEventAvailableFuture causing a more or less immediate re-execution of this method.", "url": "https://github.com/apache/flink/pull/13228#discussion_r493044470", "createdAt": "2020-09-22T21:29:03Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -62,9 +65,37 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tif (inputGate.getPriorityEventAvailableFuture().isDone()) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw=="}, "originalCommit": {"oid": "69cd2be36ce52a0de0be43602ebce454644897a6"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 514, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}