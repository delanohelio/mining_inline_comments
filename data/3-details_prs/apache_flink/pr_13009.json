{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3ODgyNzQ1", "number": 13009, "title": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy", "bodyText": "What is the purpose of the change\nThis PR introduces ExecutionSlotSharingGroup, SlotSharingStrategy and implements LocalInputPreferredSlotSharingStrategy.\nThe default SlotSharingStrategy would be LocalInputPreferredSlotSharingStrategy. It will try to reduce remote data exchanges. Subtasks, which are connected and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\nBrief change log\n\nIntroduce ExecutionSlotSharingGroup and SlotSharingStrategy interface\nImplement LocalInputPreferredSlotSharingStrategy\n\nVerifying this change\n\nAdded unit tests for LocalInputPreferredSlotSharingStrategy\n\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (yes / no)\nThe serializers: (yes / no / don't know)\nThe runtime per-record code paths (performance sensitive): (yes / no / don't know)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: (yes / no / don't know)\nThe S3 file system connector: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)", "createdAt": "2020-07-28T15:22:46Z", "url": "https://github.com/apache/flink/pull/13009", "merged": true, "mergeCommit": {"oid": "cfda0e0bb743ac2573d51476ece35d3441a8018f"}, "closed": true, "closedAt": "2020-08-05T02:42:46Z", "author": {"login": "zhuzhurk"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5YPQWgFqTQ1Njc1NzM3NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7ofqYAFqTQ2MDkzNDYyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzU3Mzc1", "url": "https://github.com/apache/flink/pull/13009#pullrequestreview-456757375", "createdAt": "2020-07-28T15:34:08Z", "commit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTozNDowOFrOG4SffQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTozNDowOFrOG4SffQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3NjQxMw==", "bodyText": "One known defect is the grouping of execution vertices from brother job vertices are possible suboptimal because it does not take connections to consumers vertices into account.\nExample: A(parallelism=4) --forward--> C(parallelism=4), B(parallelism=2) --rescale--> C\nExecution edges are: A1->C1, A2->C2, A3->C3, A4->C4; B1->C1, B1->C2, B2->C3,B2->C4\nOptimal grouping: {A1,B1,C1}{A2,C2}{A3,B2,C3}{A4,C4}     ->   there would be 2 remote edges\nCurrent grouping result: {A1,B1,C1} {A2,B2,C2}  {A3,C3}  {A4,C4}     ->   there would be 3 remote edges", "url": "https://github.com/apache/flink/pull/13009#discussion_r461676413", "createdAt": "2020-07-28T15:34:08Z", "author": {"login": "zhuzhurk"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MjE3OTg3", "url": "https://github.com/apache/flink/pull/13009#pullrequestreview-458217987", "createdAt": "2020-07-30T09:02:16Z", "commit": {"oid": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTowMjoxNlrOG5ad2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoyNDoxMlrOG5qhXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NTY0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tinterface Factory {\n          \n          \n            \n                @FunctionalInterface\n          \n          \n            \n            \tinterface Factory {", "url": "https://github.com/apache/flink/pull/13009#discussion_r462855642", "createdAt": "2020-07-30T09:02:16Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.Set;\n+\n+/**\n+ * Strategy which determines {@link ExecutionSlotSharingGroup} for each execution vertex.\n+ */\n+interface SlotSharingStrategy {\n+\n+\tExecutionSlotSharingGroup getExecutionSlotSharingGroup(\n+\t\tExecutionVertexID executionVertexId);\n+\n+\tSet<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups();\n+\n+\tinterface Factory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NzM2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic CoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {\n          \n          \n            \n            \tCoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {", "url": "https://github.com/apache/flink/pull/13009#discussion_r462857365", "createdAt": "2020-07-30T09:05:12Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/CoLocationConstraintDesc.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmanager.scheduler;\n+\n+import org.apache.flink.util.AbstractID;\n+\n+import java.util.Objects;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A read-only and light weight version of {@link CoLocationConstraint}.\n+ */\n+public class CoLocationConstraintDesc {\n+\n+\tprivate final AbstractID coLocationGroupId;\n+\n+\tprivate final int constraintIndex;\n+\n+\tpublic CoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1Nzk4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn vertices;\n          \n          \n            \n            \t\treturn Collections.unmodifiableList(vertices);", "url": "https://github.com/apache/flink/pull/13009#discussion_r462857984", "createdAt": "2020-07-30T09:06:19Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/CoLocationGroupDesc.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmanager.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.jobgraph.JobVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.util.AbstractID;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A read-only and light weight version of {@link CoLocationGroup}.\n+ */\n+public class CoLocationGroupDesc {\n+\n+\tprivate final AbstractID id;\n+\n+\tprivate final List<JobVertexID> vertices;\n+\n+\tprivate CoLocationGroupDesc(final AbstractID id, final List<JobVertexID> vertices) {\n+\t\tthis.id = checkNotNull(id);\n+\t\tthis.vertices = checkNotNull(vertices);\n+\t}\n+\n+\tpublic AbstractID getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic List<JobVertexID> getVertices() {\n+\t\treturn vertices;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MTYzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n          \n          \n            \n            \t\t\t// loop on job vertices so that an execution vertex will not be added into a group", "url": "https://github.com/apache/flink/pull/13009#discussion_r462961631", "createdAt": "2020-07-30T12:31:25Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjExMA==", "bodyText": "Is allVertices LinkedHashMap because we assume that topology gives the vertexes in the topological order to assign vertexes to their producers' groups ?", "url": "https://github.com/apache/flink/pull/13009#discussion_r462962110", "createdAt": "2020-07-30T12:32:21Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NjExNQ==", "bodyText": "Do you know whether we have some kind of check whether the co-location constraint does not contradict to the slot sharing group? like 2 executions must be co-located according to the co-location constraint but they are in different logical slot sharing groups (e.g. forced by user in API)?", "url": "https://github.com/apache/flink/pull/13009#discussion_r462976115", "createdAt": "2020-07-30T12:57:14Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Nzk2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);\n          \n          \n            \n            \t\t\treturn Objects.equals(slotSharingGroupId1, slotSharingGroupId2);", "url": "https://github.com/apache/flink/pull/13009#discussion_r462977966", "createdAt": "2020-07-30T13:00:28Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableProducerExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\n+\t\t\tfor (SchedulingResultPartition partition : executionVertex.getConsumedResults()) {\n+\t\t\t\tfinal ExecutionVertexID producerVertexId = partition.getProducer().getId();\n+\t\t\t\tif (!inSameLogicalSlotSharingGroup(producerVertexId, executionVertexId)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tfinal ExecutionSlotSharingGroup producerGroup = executionSlotSharingGroupMap.get(producerVertexId);\n+\n+\t\t\t\tcheckState(producerGroup != null);\n+\t\t\t\tif (isGroupAvailableForVertex(producerGroup, executionVertexId)) {\n+\t\t\t\t\treturn producerGroup;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate boolean inSameLogicalSlotSharingGroup(\n+\t\t\t\tfinal ExecutionVertexID executionVertexId1,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId2) {\n+\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId1 = slotSharingGroupMap.get(executionVertexId1.getJobVertexId());\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId2 = slotSharingGroupMap.get(executionVertexId2.getJobVertexId());\n+\n+\t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDE0Ng==", "bodyText": "Can this happen at this point?\nIf I understand correctly, if a vertex does not belong to any group then it belongs to the default group according to user docs. So then the question is whether the default group already has a slotSharingGroupId at this point:\n\nif yes, then this should not happen\nif no, then do we risk to create a new slotSharingGroupId for each executionVertex from the default group?", "url": "https://github.com/apache/flink/pull/13009#discussion_r462990146", "createdAt": "2020-07-30T13:20:08Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableProducerExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\n+\t\t\tfor (SchedulingResultPartition partition : executionVertex.getConsumedResults()) {\n+\t\t\t\tfinal ExecutionVertexID producerVertexId = partition.getProducer().getId();\n+\t\t\t\tif (!inSameLogicalSlotSharingGroup(producerVertexId, executionVertexId)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tfinal ExecutionSlotSharingGroup producerGroup = executionSlotSharingGroupMap.get(producerVertexId);\n+\n+\t\t\t\tcheckState(producerGroup != null);\n+\t\t\t\tif (isGroupAvailableForVertex(producerGroup, executionVertexId)) {\n+\t\t\t\t\treturn producerGroup;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate boolean inSameLogicalSlotSharingGroup(\n+\t\t\t\tfinal ExecutionVertexID executionVertexId1,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId2) {\n+\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId1 = slotSharingGroupMap.get(executionVertexId1.getJobVertexId());\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId2 = slotSharingGroupMap.get(executionVertexId2.getJobVertexId());\n+\n+\t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);\n+\t\t}\n+\n+\t\tprivate boolean isGroupAvailableForVertex(\n+\t\t\t\tfinal ExecutionSlotSharingGroup executionSlotSharingGroup,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId) {\n+\n+\t\t\tfinal Set<JobVertexID> assignedVertices = assignedJobVerticesForGroups.get(executionSlotSharingGroup);\n+\t\t\treturn assignedVertices == null || !assignedVertices.contains(executionVertexId.getJobVertexId());\n+\t\t}\n+\n+\t\tprivate void addVertexToExecutionSlotSharingGroup(\n+\t\t\t\tfinal SchedulingExecutionVertex vertex,\n+\t\t\t\tfinal ExecutionSlotSharingGroup group) {\n+\n+\t\t\tgroup.addVertex(vertex.getId());\n+\t\t\texecutionSlotSharingGroupMap.put(vertex.getId(), group);\n+\t\t\tassignedJobVerticesForGroups.computeIfAbsent(group, k -> new HashSet<>()).add(vertex.getId().getJobVertexId());\n+\t\t}\n+\n+\t\tprivate void findAvailableOrCreateNewExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\t// create a new slotSharingGroupId if the vertex is not in a slot sharing group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExODY4Ng==", "bodyText": "If we do not want to do the full complicated connected graph analysis (harder to maintain), we could a lighter optimisation now or later. After the suggested traversal, we could do one more traversal where we try to move producers closer to their consumers if the producers are not already bounded by other co-located consumers or possibly by a co-location constraint. Parent producers of the producers (if parent ones have less parallelism) should not bound them for the move if the second traversal is bottom->up.", "url": "https://github.com/apache/flink/pull/13009#discussion_r463118686", "createdAt": "2020-07-30T16:24:12Z", "author": {"login": "azagrebin"}, "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3NjQxMw=="}, "originalCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a"}, "originalPosition": 128}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "044578bc01da8b57e29a483ee2560a0e8f61148a", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/044578bc01da8b57e29a483ee2560a0e8f61148a", "committedDate": "2020-07-28T15:18:03Z", "message": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy"}, "afterCommit": {"oid": "d7133401edf323e5be894758398098e70cf70506", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/d7133401edf323e5be894758398098e70cf70506", "committedDate": "2020-08-03T17:09:20Z", "message": "fixup! [FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52f727e89f21c94f58b06647a70da769596872ca", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/52f727e89f21c94f58b06647a70da769596872ca", "committedDate": "2020-08-04T03:35:59Z", "message": "[FLINK-18690][runtime] Introduce ExecutionSlotSharingGroup and SlotSharingStrategy interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "557e982407c488191ade7cc66807662796b3a306", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/557e982407c488191ade7cc66807662796b3a306", "committedDate": "2020-08-04T03:37:04Z", "message": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7133401edf323e5be894758398098e70cf70506", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/d7133401edf323e5be894758398098e70cf70506", "committedDate": "2020-08-03T17:09:20Z", "message": "fixup! [FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy"}, "afterCommit": {"oid": "557e982407c488191ade7cc66807662796b3a306", "author": {"user": {"login": "zhuzhurk", "name": "Zhu Zhu"}}, "url": "https://github.com/apache/flink/commit/557e982407c488191ade7cc66807662796b3a306", "committedDate": "2020-08-04T03:37:04Z", "message": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTM0NjIz", "url": "https://github.com/apache/flink/pull/13009#pullrequestreview-460934623", "createdAt": "2020-08-04T15:38:24Z", "commit": {"oid": "557e982407c488191ade7cc66807662796b3a306"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3009, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}