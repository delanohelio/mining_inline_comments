{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MDYxMDIz", "number": 13299, "title": "[FLINK-19072][table-planner] Import Temporal Table join rule for Stream", "bodyText": "What is the purpose of the change\n\nThis pull request supports Temporal table join in planner.\n\nBrief change log\n\n\nea54f7198e : [FLINK-19072] import Temporal Table join rule\n(1) Import temporal table join rule to match all temporal join, lookup join also belong temporal join\n(2) Defferentiate lookup join and general temporal join in according the join pattern\n\n\n61ab18c : [FLINK-19073] Imporve streamExecTemporalJoinRule\n(1) Match temporal table join from temporal function in StreamExecLegacyTemporalJoinRule,  Match temporal table join in StreamTemporalJoinRule\n(2) Infer changelog mode trait for temporal table join node\n\n\n1b5a16f : [FLINK-19076] Import rule to deal Temporal Join condition\n(1) Obtains the unique key from versioned table/view\n(2) Prevent join condition(e.g. time attribute column, primary key) push down by adding temporal join condition in join node\n\n\nVerifying this change\nAdd plan tests  to cover existed lookup join, temporal function and temporal table join\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): (no)\nThe public API, i.e., is any changed class annotated with @Public(Evolving): (no)\nThe serializers: (no)\nThe runtime per-record code paths (performance sensitive): ( no)\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (no)\nThe S3 file system connector: (no)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)\nJavaDocs, will add docs in FLINK-19082", "createdAt": "2020-09-01T12:54:12Z", "url": "https://github.com/apache/flink/pull/13299", "merged": true, "mergeCommit": {"oid": "cd65bbb7cc2ec2099d70375cc009215cf57afe13"}, "closed": true, "closedAt": "2020-10-16T15:04:46Z", "author": {"login": "leonardBang"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEpNe5ABqjM3MTU1NjYzNjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSyHBsABqjM4ODE2OTkyMzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0f1e7d2e0945301759bd61af69c4428f71d64ce", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/f0f1e7d2e0945301759bd61af69c4428f71d64ce", "committedDate": "2020-09-01T12:19:36Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}, "afterCommit": {"oid": "2ed16425d7018bbb39be1edd6519fcb99cb45000", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/2ed16425d7018bbb39be1edd6519fcb99cb45000", "committedDate": "2020-09-01T15:33:24Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bbb019bf30fa08b0055755a4eba7c918683b5aab", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/bbb019bf30fa08b0055755a4eba7c918683b5aab", "committedDate": "2020-09-02T04:19:41Z", "message": "minor"}, "afterCommit": {"oid": "ade459ff295c6994b7d6d377674e02d668faee71", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/ade459ff295c6994b7d6d377674e02d668faee71", "committedDate": "2020-09-02T06:57:23Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ade459ff295c6994b7d6d377674e02d668faee71", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/ade459ff295c6994b7d6d377674e02d668faee71", "committedDate": "2020-09-02T06:57:23Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}, "afterCommit": {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/8928b195cdec50dee6df1e364df250c9283d0af7", "committedDate": "2020-09-23T13:38:20Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/8928b195cdec50dee6df1e364df250c9283d0af7", "committedDate": "2020-09-23T13:38:20Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition"}, "afterCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "committedDate": "2020-09-28T08:53:50Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjgzMTQ1", "url": "https://github.com/apache/flink/pull/13299#pullrequestreview-497283145", "createdAt": "2020-09-28T08:16:28Z", "commit": {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoxNjoyOFrOHYzD8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjo1NDo0NlrOHY8RwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDQ2Nw==", "bodyText": "nit: redundant period", "url": "https://github.com/apache/flink/pull/13299#discussion_r495764467", "createdAt": "2020-09-28T08:16:28Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecLookupJoin.scala", "diffHunk": "@@ -34,7 +34,7 @@ import java.util\n import scala.collection.JavaConversions._\n \n /**\n-  * Batch physical RelNode for temporal table join.\n+  * Batch physical RelNode for temporal table join that implements by lookup..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3OTgwMg==", "bodyText": "please add some comments about the limitation like: this rule can only be used in HepPlanner", "url": "https://github.com/apache/flink/pull/13299#discussion_r495779802", "createdAt": "2020-09-28T08:43:39Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -17,19 +17,30 @@\n  */\n package org.apache.flink.table.planner.plan.rules.logical\n \n-import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n-\n import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.hep.HepRelVertex\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelOptRuleOperand}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.logical.{LogicalCorrelate, LogicalFilter, LogicalSnapshot}\n-import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess, RexInputRef, RexNode, RexShuttle}\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical._\n+import org.apache.calcite.rex._\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.isRowtimeIndicatorType\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n   * The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into a Join\n   * to make join condition can be pushed-down. The join will be translated into\n-  * [[StreamExecLookupJoin]] in physical and might be translated into [[StreamExecTemporalJoin]]\n-  * in the future.\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDA5Nw==", "bodyText": "nit: redundant blank", "url": "https://github.com/apache/flink/pull/13299#discussion_r495780097", "createdAt": "2020-09-28T08:44:13Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjI1MQ==", "bodyText": "it's better to add some comments like \"do nothing\" at the end of this line", "url": "https://github.com/apache/flink/pull/13299#discussion_r495782251", "createdAt": "2020-09-28T08:47:31Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjQyMA==", "bodyText": "left table -> right table ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495782420", "createdAt": "2020-09-28T08:47:47Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NDA0Nw==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13299#discussion_r495784047", "createdAt": "2020-09-28T08:50:37Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NTM4OA==", "bodyText": "nit: move => into above line ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495785388", "createdAt": "2020-09-28T08:52:59Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a14e17dc399bc80687a4882b6e38aeddec2f3a"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTMyMw==", "bodyText": "remove if and call getTableScan(trimHep(project.getInput)) directly", "url": "https://github.com/apache/flink/pull/13299#discussion_r495789323", "createdAt": "2020-09-28T08:59:27Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDIwNg==", "bodyText": "we should also check whether the table in a LogicalTableScan is a TableSourceTable", "url": "https://github.com/apache/flink/pull/13299#discussion_r495790206", "createdAt": "2020-09-28T09:00:49Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]\n+        => Some(trimHep(project.getInput).asInstanceOf[TableScan])\n+      case _ => None\n+    }\n+  }\n+\n+  private def isTableSourceScan(relNode: RelNode): Boolean = {\n+    relNode match {\n+      case _: LogicalTableScan | _: FlinkLogicalLegacyTableSourceScan |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NTkyOA==", "bodyText": "nit: redundant blank", "url": "https://github.com/apache/flink/pull/13299#discussion_r495795928", "createdAt": "2020-09-28T09:10:37Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5ODEyNQ==", "bodyText": "timeAttributeFields  is never null", "url": "https://github.com/apache/flink/pull/13299#discussion_r495798125", "createdAt": "2020-09-28T09:14:18Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5OTQ4MA==", "bodyText": "move it to where it is used", "url": "https://github.com/apache/flink/pull/13299#discussion_r495799480", "createdAt": "2020-09-28T09:16:33Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMTEwOA==", "bodyText": "let leftFieldCnt be the parameter directly", "url": "https://github.com/apache/flink/pull/13299#discussion_r495801108", "createdAt": "2020-09-28T09:19:22Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwNTM2Mg==", "bodyText": "lookupTable => temporalTable", "url": "https://github.com/apache/flink/pull/13299#discussion_r495805362", "createdAt": "2020-09-28T09:26:33Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -103,18 +334,86 @@ class LogicalCorrelateToJoinFromTemporalTableRuleWithFilter\n }\n \n /**\n-  * Planner rule that matches temporal table join which join condition is true,\n-  * that means the right input of the Correlate is a Snapshot.\n-  * e.g. SELECT * FROM MyTable AS T JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D ON true\n+  * Planner rule that matches temporal table join which implemented by lookup join, the join\n+  * condition is true, that means the right input of the Correlate is a Snapshot.\n+  * e.g. SELECT * FROM MyTable AS T JOIN lookupTable FOR SYSTEM_TIME AS OF T.proctime AS D ON true\n   */\n+class LogicalCorrelateToJoinFromLookupTableRuleWithoutFilter\n+  extends LogicalCorrelateToJoinFromLookupTemporalTableRule(\n+    operand(classOf[LogicalCorrelate],\n+      operand(classOf[RelNode], any()),\n+      operand(classOf[LogicalSnapshot],\n+        operand(classOf[RelNode], any()))),\n+    \"LogicalCorrelateToJoinFromLookupTableRuleWithoutFilter\"\n+  ) {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val snapshot: LogicalSnapshot = call.rel(2)\n+    val snapshotInput: RelNode = trimHep(call.rel(3))\n+    isLookupJoin(snapshot, snapshotInput)\n+  }\n+\n+  override def getFilterCondition(call: RelOptRuleCall): RexNode = {\n+    call.builder().literal(true)\n+  }\n+\n+  override def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot = {\n+    call.rels(2).asInstanceOf[LogicalSnapshot]\n+  }\n+}\n+\n+/**\n+ * Planner rule that matches general temporal table join except lookup join, the join\n+ * condition is not true, that means the right input of the Correlate is a Filter.\n+ * e.g. SELECT * FROM MyTable AS T JOIN lookupTable FOR SYSTEM_TIME AS OF T.rowtime AS D", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDE4Ng==", "bodyText": "move this line out of map", "url": "https://github.com/apache/flink/pull/13299#discussion_r495820186", "createdAt": "2020-09-28T09:51:21Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDU4Mw==", "bodyText": "we can reuse rexBuilder", "url": "https://github.com/apache/flink/pull/13299#discussion_r495820583", "createdAt": "2020-09-28T09:52:01Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMjYzOQ==", "bodyText": "do we really check primary key constraint ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495822639", "createdAt": "2020-09-28T09:55:33Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMzAxNw==", "bodyText": "can be found", "url": "https://github.com/apache/flink/pull/13299#discussion_r495823017", "createdAt": "2020-09-28T09:56:09Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +\n+            s\" but no row time attribute found.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNTA2Mw==", "bodyText": "nit: redundant blank", "url": "https://github.com/apache/flink/pull/13299#discussion_r495825063", "createdAt": "2020-09-28T09:59:43Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +\n+            s\" but no row time attribute found.\")\n+      }\n+      // Deal primary key in TemporalJoinRewriteUniqueKeyRule\n+      TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+        rightTimeInputRef.get, leftJoinKey, rightJoinKey)\n+    } else {\n+      TemporalJoinUtil.makeProcTimeTemporalJoinConditionCall(\n+        rexBuilder, snapshotTimeInputRef, leftJoinKey, rightJoinKey)\n+    }\n+\n+    val builder = call.builder()\n+    val condition =  builder.and(joinCondition, temporalCondition)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNjAxOQ==", "bodyText": "revert this change", "url": "https://github.com/apache/flink/pull/13299#discussion_r495826019", "createdAt": "2020-09-28T10:01:23Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/common/CommonLookupJoinRule.scala", "diffHunk": "@@ -132,7 +127,7 @@ abstract class BaseSnapshotOnTableScanRule(description: String)\n     val join = call.rel[FlinkLogicalJoin](0)\n     val snapshot = call.rel[FlinkLogicalSnapshot](2)\n     val tableScan = call.rel[TableScan](3)\n-    matches(join, snapshot, tableScan)\n+     matches(join, snapshot, tableScan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyODgwNg==", "bodyText": "Similar comments like LogicalCorrelateToJoinFromTemporalTableRule\nand create a common package which both logical rules and physical rules can both use common utils", "url": "https://github.com/apache/flink/pull/13299#discussion_r495828806", "createdAt": "2020-09-28T10:06:13Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/common/CommonTemporalTableJoinRule.scala", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.flink.table.planner.plan.rules.physical.common\n+\n+import org.apache.calcite.plan.hep.HepRelVertex\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical.{LogicalProject, LogicalTableScan}\n+import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess}\n+\n+import org.apache.flink.table.planner.plan.nodes.logical._\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecLegacyTemporalJoin\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecLookupJoin\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+/**\n+  * Base implementation that matches temporal join node.\n+  *\n+  * <p> The temporal join node is a [[FlinkLogicalJoin]] whose left input is a [[FlinkLogicalRel]]\n+  * and right input is a [[FlinkLogicalSnapshot]].\n+  * It may be translated into [[StreamExecLookupJoin]] or [[StreamExecLegacyTemporalJoin]] in\n+  * physical phase.\n+  */\n+trait CommonTemporalTableJoinRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d19cb8dda823844673eebad1bdd6dea54f7198e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MTgxOQ==", "bodyText": "move these imports behind org.apache.flink.", "url": "https://github.com/apache/flink/pull/13299#discussion_r495861819", "createdAt": "2020-09-28T11:12:10Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecLegacyTemporalJoin.scala", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.nodes.physical.stream\n+\n+import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n+import org.apache.calcite.rex._", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MjMwNg==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13299#discussion_r495862306", "createdAt": "2020-09-28T11:13:13Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,19 +18,27 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import java.util\n+\n+import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n+import org.apache.calcite.rex._", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NDU1Ng==", "bodyText": "joinKeys is unique iff joinKeys is the super-set of uniqueKey", "url": "https://github.com/apache/flink/pull/13299#discussion_r495864556", "createdAt": "2020-09-28T11:17:56Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -59,21 +64,21 @@ class StreamExecTemporalJoin(\n   with StreamPhysicalRel\n   with StreamExecNode[RowData] {\n \n-  override def requireWatermark: Boolean = {\n-    val nonEquiJoinRex = getJoinInfo.getRemaining(cluster.getRexBuilder)\n-\n-    var rowtimeJoin: Boolean = false\n-    val visitor = new RexVisitorImpl[Unit](true) {\n-      override def visitCall(call: RexCall): Unit = {\n-        if (call.getOperator == TEMPORAL_JOIN_CONDITION) {\n-          rowtimeJoin = TemporalJoinUtil.isRowtimeCall(call)\n-        } else {\n-          call.getOperands.foreach(node => node.accept(this))\n-        }\n+  def rightInputUniqueKeyContainsJoinKey(): Boolean = {\n+    val right = getInput(1)\n+    val rightUniqueKeys = getCluster.getMetadataQuery.getUniqueKeys(right)\n+    if (rightUniqueKeys != null) {\n+      val joinKeys = keyPairs.map(_.target).toArray\n+      rightUniqueKeys.exists {\n+        uniqueKey => joinKeys.forall(uniqueKey.toArray.contains(_))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2ODE2Mg==", "bodyText": "use local variable to store each value of the Tuple2, which could improve code readability", "url": "https://github.com/apache/flink/pull/13299#discussion_r495868162", "createdAt": "2020-09-28T11:24:59Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2ODc2MQ==", "bodyText": "please throw the same exception for the validation", "url": "https://github.com/apache/flink/pull/13299#discussion_r495868761", "createdAt": "2020-09-28T11:26:13Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get,\n+          textualRepresentation),\n+          temporalJoinConditionExtractor.rightTimeAttribute.map(\n+            rightTimeAttribute =>\n+              extractInputRef(\n+                rightTimeAttribute,\n+                textualRepresentation\n+              ) - leftType.getFieldCount))\n+      } else {\n+        val leftTimeAttributes = leftInput.getRowType.getFieldList\n+          .filter(f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+        if (leftTimeAttributes.isEmpty) {\n+          throw new ValidationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2OTkzMQ==", "bodyText": "what if the left side has both row-time attribute and proc-time attribute ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495869931", "createdAt": "2020-09-28T11:28:38Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get,\n+          textualRepresentation),\n+          temporalJoinConditionExtractor.rightTimeAttribute.map(\n+            rightTimeAttribute =>\n+              extractInputRef(\n+                rightTimeAttribute,\n+                textualRepresentation\n+              ) - leftType.getFieldCount))\n+      } else {\n+        val leftTimeAttributes = leftInput.getRowType.getFieldList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NTY2Nw==", "bodyText": "please use RelOptUtil.InputFinder.bits(rexNode)", "url": "https://github.com/apache/flink/pull/13299#discussion_r495875667", "createdAt": "2020-09-28T11:40:46Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -327,6 +345,16 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     inputReferenceVisitor.getFields.head\n   }\n \n+  private def extractInputRefs(rexNode: RexNode, textualRepresentation: String): Array[Int] = {\n+    val inputReferenceVisitor = new InputRefVisitor\n+    rexNode.accept(inputReferenceVisitor)\n+    checkState(\n+      inputReferenceVisitor.getFields.length == 1,\n+      \"Failed to find input reference in [%s]\",\n+      textualRepresentation)\n+    inputReferenceVisitor.getFields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3ODAyOQ==", "bodyText": "use match", "url": "https://github.com/apache/flink/pull/13299#discussion_r495878029", "createdAt": "2020-09-28T11:45:42Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -339,75 +367,50 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n \n     var rightTimeAttribute: Option[RexNode] = None\n \n-    var rightPrimaryKeyExpression: Option[RexNode] = None\n+    var rightPrimaryKeyExpression: Option[Array[RexNode]] = None\n \n     override def visitCall(call: RexCall): RexNode = {\n       if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n         return super.visitCall(call)\n       }\n \n-      checkState(\n-        leftTimeAttribute.isEmpty\n-          && rightPrimaryKeyExpression.isEmpty\n-          && rightTimeAttribute.isEmpty,\n-        \"Multiple %s functions in [%s]\",\n-        TEMPORAL_JOIN_CONDITION,\n-        textualRepresentation)\n-\n-      if (TemporalJoinUtil.isRowtimeCall(call)) {\n+      if (TemporalJoinUtil.isRowTimeTemporalJoinConditionCall(call)) {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n         rightTimeAttribute = Some(call.getOperands.get(1))\n-\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(2)))\n-\n-        if (!isRowtimeIndicatorType(rightTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${rightTimeAttribute.get.getType}] \" +\n-              s\"used to create TemporalTableFunction\")\n-        }\n-        if (!isRowtimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else if (TemporalJoinUtil.isProctimeCall(call)) {\n+        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(4)))\n+      } else {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(1)))\n-\n-        if (!isProctimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non processing timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else {\n-        throw new IllegalStateException(\n-          s\"Unsupported invocation $call in [$textualRepresentation]\")\n       }\n       rexBuilder.makeLiteral(true)\n     }\n \n-    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): RexNode = {\n-      if (joinInfo.rightKeys.size() != 1) {\n+    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): Array[RexNode]  = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3OTQxOA==", "bodyText": "use (ref, index) instead of r in map", "url": "https://github.com/apache/flink/pull/13299#discussion_r495879418", "createdAt": "2020-09-28T11:48:36Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -339,75 +367,50 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n \n     var rightTimeAttribute: Option[RexNode] = None\n \n-    var rightPrimaryKeyExpression: Option[RexNode] = None\n+    var rightPrimaryKeyExpression: Option[Array[RexNode]] = None\n \n     override def visitCall(call: RexCall): RexNode = {\n       if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n         return super.visitCall(call)\n       }\n \n-      checkState(\n-        leftTimeAttribute.isEmpty\n-          && rightPrimaryKeyExpression.isEmpty\n-          && rightTimeAttribute.isEmpty,\n-        \"Multiple %s functions in [%s]\",\n-        TEMPORAL_JOIN_CONDITION,\n-        textualRepresentation)\n-\n-      if (TemporalJoinUtil.isRowtimeCall(call)) {\n+      if (TemporalJoinUtil.isRowTimeTemporalJoinConditionCall(call)) {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n         rightTimeAttribute = Some(call.getOperands.get(1))\n-\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(2)))\n-\n-        if (!isRowtimeIndicatorType(rightTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${rightTimeAttribute.get.getType}] \" +\n-              s\"used to create TemporalTableFunction\")\n-        }\n-        if (!isRowtimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else if (TemporalJoinUtil.isProctimeCall(call)) {\n+        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(4)))\n+      } else {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(1)))\n-\n-        if (!isProctimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non processing timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else {\n-        throw new IllegalStateException(\n-          s\"Unsupported invocation $call in [$textualRepresentation]\")\n       }\n       rexBuilder.makeLiteral(true)\n     }\n \n-    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): RexNode = {\n-      if (joinInfo.rightKeys.size() != 1) {\n+    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): Array[RexNode]  = {\n+      if (!rightPrimaryKey.isInstanceOf[RexCall] ||\n+        rightPrimaryKey.asInstanceOf[RexCall].getOperator != TEMPORAL_JOIN_CONDITION_PRIMARY_KEY) {\n         throw new ValidationException(\n-          s\"Only single column join key is supported. \" +\n-            s\"Found ${joinInfo.rightKeys} in [$textualRepresentation]\")\n-      }\n-      val rightJoinKeyInputReference = joinInfo.rightKeys.get(0) + rightKeysStartingOffset\n+          s\"No primary key [${rightPrimaryKey.asInstanceOf[RexCall]}] \" +\n+            s\"defined in versioned table of Event-time temporal table join\")\n+       }\n \n-      val rightPrimaryKeyInputReference = extractInputReference(\n+      val rightJoinKeyInputRefs = joinInfo.rightKeys\n+        .map(index => index + rightKeysStartingOffset)\n+        .toArray\n+\n+      val rightPrimaryKeyInputRefs = extractInputRefs(\n         rightPrimaryKey,\n         textualRepresentation)\n \n-      if (rightPrimaryKeyInputReference != rightJoinKeyInputReference) {\n+      val primaryKeyContainedInJoinKey = rightPrimaryKeyInputRefs.zipWithIndex\n+        .map(r => (r._1, rightJoinKeyInputRefs(r._2)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MTI2OA==", "bodyText": "BEFORE_AND_AFTER ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495881268", "createdAt": "2020-09-28T11:52:12Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -504,6 +512,39 @@ class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOpti\n             None\n         }\n \n+      case temporalJoin: StreamExecTemporalJoin =>\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+\n+        // the left input required trait depends on it's parent in temporal join\n+        // the left input will send message to parent\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.ONLY_UPDATE_AFTER", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzUwNg==", "bodyText": "reorder imports", "url": "https://github.com/apache/flink/pull/13299#discussion_r495887506", "createdAt": "2020-09-28T12:04:57Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/StreamExecTemporalJoinRule.scala", "diffHunk": "@@ -18,56 +18,53 @@\n \n package org.apache.flink.table.planner.plan.rules.physical.stream\n \n-import org.apache.flink.table.planner.plan.`trait`.FlinkRelDistribution\n-import org.apache.flink.table.planner.plan.nodes.FlinkConventions\n-import org.apache.flink.table.planner.plan.nodes.logical._\n-import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecTemporalJoin\n-import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil.containsTemporalJoinCondition\n-import org.apache.flink.table.planner.plan.utils.{FlinkRelOptUtil, IntervalJoinUtil}\n+import java.util\n \n import org.apache.calcite.plan.RelOptRule.{any, operand}\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelTraitSet}\n import org.apache.calcite.rel.RelNode\n import org.apache.calcite.rel.core.JoinRelType\n \n-import java.util\n+import org.apache.flink.table.planner.plan.`trait`.FlinkRelDistribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzAxMw==", "bodyText": "LegacyTemporalProcessTimeJoinOperator and TemporalProcessTimeJoinOperator is almost same, can we reuse them ?", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893013", "createdAt": "2020-09-28T12:15:31Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.functions.util.FunctionUtils;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+/**\n+ * The operator to temporal join a stream on processing time.\n+ */\n+public class LegacyTemporalProcessTimeJoinOperator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzExNQ==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893115", "createdAt": "2020-09-28T12:15:44Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * This operator works by keeping on the state collection of probe and build records to process\n+ * on next watermark. The idea is that between watermarks we are collecting those elements\n+ * and once we are sure that there will be no updates we emit the correct result and clean up the\n+ * state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * however we always keep at least one record - the latest one - even if it's past the last\n+ * watermark.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class LegacyTemporalRowTimeJoinOperator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61ab18c9e4012d0c65d64c2456af0900577b90db"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzQ0NA==", "bodyText": "reorder import", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893444", "createdAt": "2020-09-28T12:16:22Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -42,11 +41,11 @@ import org.apache.calcite.rex.{RexCall, RexInputRef, RexNode}\n import org.apache.calcite.sql.SqlKind\n import org.apache.calcite.sql.fun.SqlStdOperatorTable\n import org.apache.calcite.util.{Bug, BuiltInMethod, ImmutableBitSet, Util}\n-\n import com.google.common.collect.ImmutableSet\n-\n import java.util\n \n+import org.apache.calcite.plan.hep.HepRelVertex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NTQ0Nw==", "bodyText": "it's better we can put them into a separate commit", "url": "https://github.com/apache/flink/pull/13299#discussion_r495895447", "createdAt": "2020-09-28T12:20:09Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5Njk1Mw==", "bodyText": "!rel.outputRankNumber is unnecessary ? because even Rank output rank number, its value is always 1", "url": "https://github.com/apache/flink/pull/13299#discussion_r495896953", "createdAt": "2020-09-28T12:22:56Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {\n+      val rankRange = rel.rankRange\n+      val isRowNumberType = rel.rankType == RankType.ROW_NUMBER\n+      val isLimit1 = rankRange match {\n+        case rankRange: ConstantRankRange =>\n+          rankRange.getRankStart() == 1 && rankRange.getRankEnd() == 1\n+        case _ => false\n+      }\n+      !rel.outputRankNumber && isRowNumberType && isLimit1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NzYxNQ==", "bodyText": "please add related tests in FlinkRelMdUniqueKeysTest", "url": "https://github.com/apache/flink/pull/13299#discussion_r495897615", "createdAt": "2020-09-28T12:24:07Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {\n+      val rankRange = rel.rankRange\n+      val isRowNumberType = rel.rankType == RankType.ROW_NUMBER\n+      val isLimit1 = rankRange match {\n+        case rankRange: ConstantRankRange =>\n+          rankRange.getRankStart() == 1 && rankRange.getRankEnd() == 1\n+        case _ => false\n+      }\n+      !rel.outputRankNumber && isRowNumberType && isLimit1\n+    }\n+\n+    if (canConvertToDeduplicate) {\n+      val retSet = new JHashSet[ImmutableBitSet]\n+      retSet.add(rel.partitionKey)\n+      retSet\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5Nzc2MQ==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13299#discussion_r495897761", "createdAt": "2020-09-28T12:24:20Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -553,6 +570,20 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n     }\n   }\n \n+  def getUniqueKeys(\n+      subset: HepRelVertex,\n+      mq: RelMetadataQuery,\n+      ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n+    mq.getUniqueKeys(subset.getCurrentRel, ignoreNulls)\n+  }\n+\n+  def getUniqueKeys(\n+      subset: WatermarkAssigner,\n+      mq: RelMetadataQuery,\n+      ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n+    mq.getUniqueKeys(subset.getInput, ignoreNulls)\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMjcxOA==", "bodyText": "it's hard to read, it's better to add some comments and split them into a few steps", "url": "https://github.com/apache/flink/pull/13299#discussion_r495902718", "createdAt": "2020-09-28T12:33:10Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.JoinRelType\n+import org.apache.calcite.rex.{RexBuilder, RexCall, RexNode, RexShuttle}\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.planner.plan.metadata.FlinkRelMetadataQuery\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalJoin, FlinkLogicalRel, FlinkLogicalSnapshot}\n+import org.apache.flink.table.planner.plan.rules.physical.common.CommonTemporalTableJoinRule\n+import org.apache.flink.table.planner.plan.schema.TimeIndicatorRelDataType\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+  * Planner rule that rewrites temporal join with extracted primary key, Event-time temporal\n+  * table join requires primary key and row time attribute of versioned table. The versioned table\n+  * could be a table source or a view only if it contains the unique key and time attribute.\n+  *\n+  * <p> Flink support extract the primary key and row time attribute from the view if the view comes\n+  * from [[LogicalRank]] node which can convert to a [[Deduplicate]] node.\n+  */\n+class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n+  operand(classOf[FlinkLogicalJoin],\n+    operand(classOf[FlinkLogicalRel], any()),\n+    operand(classOf[FlinkLogicalSnapshot],\n+      operand(classOf[FlinkLogicalRel], any()))),\n+  \"TemporalJoinRewriteWithUniqueKeyRule\")\n+  with CommonTemporalTableJoinRule {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+    val snapshotInput = call.rel[FlinkLogicalRel](3)\n+\n+    val isTemporalJoin = matches(snapshot)\n+    val canConvertToLookup = canConvertToLookupJoin(snapshot, snapshotInput)\n+    val supportedJoinTypes = Seq(JoinRelType.INNER)\n+\n+    isTemporalJoin && !canConvertToLookup && supportedJoinTypes.contains(join.getJoinType)\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val leftInput = call.rel[FlinkLogicalRel](1)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+\n+    val joinCondition = join.getCondition\n+\n+    val newJoinCondition = joinCondition.accept(new RexShuttle {\n+      override def visitCall(call: RexCall): RexNode = {\n+        if (call.getOperator == TemporalJoinUtil.TEMPORAL_JOIN_CONDITION &&\n+        isRowTimeTemporalTableJoin(snapshot)) {\n+          val snapshotTimeInputRef = call.operands(0)\n+          val rightTimeInputRef = call.operands(1)\n+          val leftJoinKey = call.operands(2).asInstanceOf[RexCall].operands\n+          val rightJoinKey = call.operands(3).asInstanceOf[RexCall].operands\n+\n+          val rexBuilder = join.getCluster.getRexBuilder\n+          val primaryKeyInputRefs = extractPrimaryKeyInputRefs(leftInput, snapshot, rexBuilder)\n+          if (primaryKeyInputRefs.isEmpty) {\n+            throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+              s\" primary key and row time attribute in versioned table,\" +\n+              s\" but no primary key found.\")\n+          }\n+          TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+            rightTimeInputRef, leftJoinKey, rightJoinKey, primaryKeyInputRefs.get)\n+        }\n+        else {\n+          super.visitCall(call)\n+        }\n+      }\n+    })\n+    val rewriteJoin = FlinkLogicalJoin.create(\n+      leftInput, snapshot, newJoinCondition, join.getJoinType)\n+    call.transformTo(rewriteJoin)\n+  }\n+\n+  private def extractPrimaryKeyInputRefs(\n+      leftInput: RelNode,\n+      snapshot: FlinkLogicalSnapshot,\n+      rexBuilder: RexBuilder): Option[Seq[RexNode]] = {\n+    val rightFields = snapshot.getRowType.getFieldList\n+    val fmq = FlinkRelMetadataQuery.reuseOrCreate(snapshot.getCluster.getMetadataQuery)\n+\n+    val uniqueKeys = fmq.getUniqueKeys(snapshot.getInput())\n+    val fields = snapshot.getRowType.getFieldList\n+\n+    if (uniqueKeys != null && uniqueKeys.size() > 0) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      uniqueKeys\n+        .filter(_.nonEmpty)\n+        .map(_.toArray\n+          .map(fields)\n+          .map(f => rexBuilder.makeInputRef(\n+            f.getType,\n+            leftFieldCnt + rightFields.indexOf(f)))\n+          .toSeq)\n+        .toArray\n+        .sortBy(_.length)\n+        .headOption", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMzEwMA==", "bodyText": "nit: redundant blank", "url": "https://github.com/apache/flink/pull/13299#discussion_r495903100", "createdAt": "2020-09-28T12:33:50Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.JoinRelType\n+import org.apache.calcite.rex.{RexBuilder, RexCall, RexNode, RexShuttle}\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.planner.plan.metadata.FlinkRelMetadataQuery\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalJoin, FlinkLogicalRel, FlinkLogicalSnapshot}\n+import org.apache.flink.table.planner.plan.rules.physical.common.CommonTemporalTableJoinRule\n+import org.apache.flink.table.planner.plan.schema.TimeIndicatorRelDataType\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+  * Planner rule that rewrites temporal join with extracted primary key, Event-time temporal\n+  * table join requires primary key and row time attribute of versioned table. The versioned table\n+  * could be a table source or a view only if it contains the unique key and time attribute.\n+  *\n+  * <p> Flink support extract the primary key and row time attribute from the view if the view comes\n+  * from [[LogicalRank]] node which can convert to a [[Deduplicate]] node.\n+  */\n+class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n+  operand(classOf[FlinkLogicalJoin],\n+    operand(classOf[FlinkLogicalRel], any()),\n+    operand(classOf[FlinkLogicalSnapshot],\n+      operand(classOf[FlinkLogicalRel], any()))),\n+  \"TemporalJoinRewriteWithUniqueKeyRule\")\n+  with CommonTemporalTableJoinRule {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+    val snapshotInput = call.rel[FlinkLogicalRel](3)\n+\n+    val isTemporalJoin = matches(snapshot)\n+    val canConvertToLookup = canConvertToLookupJoin(snapshot, snapshotInput)\n+    val supportedJoinTypes = Seq(JoinRelType.INNER)\n+\n+    isTemporalJoin && !canConvertToLookup && supportedJoinTypes.contains(join.getJoinType)\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val leftInput = call.rel[FlinkLogicalRel](1)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+\n+    val joinCondition = join.getCondition\n+\n+    val newJoinCondition = joinCondition.accept(new RexShuttle {\n+      override def visitCall(call: RexCall): RexNode = {\n+        if (call.getOperator == TemporalJoinUtil.TEMPORAL_JOIN_CONDITION &&\n+        isRowTimeTemporalTableJoin(snapshot)) {\n+          val snapshotTimeInputRef = call.operands(0)\n+          val rightTimeInputRef = call.operands(1)\n+          val leftJoinKey = call.operands(2).asInstanceOf[RexCall].operands\n+          val rightJoinKey = call.operands(3).asInstanceOf[RexCall].operands\n+\n+          val rexBuilder = join.getCluster.getRexBuilder\n+          val primaryKeyInputRefs = extractPrimaryKeyInputRefs(leftInput, snapshot, rexBuilder)\n+          if (primaryKeyInputRefs.isEmpty) {\n+            throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+              s\" primary key and row time attribute in versioned table,\" +\n+              s\" but no primary key found.\")\n+          }\n+          TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+            rightTimeInputRef, leftJoinKey, rightJoinKey, primaryKeyInputRefs.get)\n+        }\n+        else {\n+          super.visitCall(call)\n+        }\n+      }\n+    })\n+    val rewriteJoin = FlinkLogicalJoin.create(\n+      leftInput, snapshot, newJoinCondition, join.getJoinType)\n+    call.transformTo(rewriteJoin)\n+  }\n+\n+  private def extractPrimaryKeyInputRefs(\n+      leftInput: RelNode,\n+      snapshot: FlinkLogicalSnapshot,\n+      rexBuilder: RexBuilder): Option[Seq[RexNode]] = {\n+    val rightFields = snapshot.getRowType.getFieldList\n+    val fmq = FlinkRelMetadataQuery.reuseOrCreate(snapshot.getCluster.getMetadataQuery)\n+\n+    val uniqueKeys = fmq.getUniqueKeys(snapshot.getInput())\n+    val fields = snapshot.getRowType.getFieldList\n+\n+    if (uniqueKeys != null && uniqueKeys.size() > 0) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      uniqueKeys\n+        .filter(_.nonEmpty)\n+        .map(_.toArray\n+          .map(fields)\n+          .map(f => rexBuilder.makeInputRef(\n+            f.getType,\n+            leftFieldCnt + rightFields.indexOf(f)))\n+          .toSeq)\n+        .toArray\n+        .sortBy(_.length)\n+        .headOption\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def isRowTimeTemporalTableJoin(snapshot: FlinkLogicalSnapshot): Boolean =\n+    snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if t.isEventTime => true\n+      case _ => false\n+    }\n+}\n+\n+object TemporalJoinRewriteWithUniqueKeyRule {\n+  val INSTANCE: TemporalJoinRewriteWithUniqueKeyRule = new TemporalJoinRewriteWithUniqueKeyRule\n+}\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNDY4MQ==", "bodyText": "indent", "url": "https://github.com/apache/flink/pull/13299#discussion_r495904681", "createdAt": "2020-09-28T12:36:45Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -17,75 +17,152 @@\n  */\n package org.apache.flink.table.planner.plan.utils\n \n-import org.apache.flink.util.Preconditions.checkArgument\n-\n+import org.apache.calcite.rel.core.JoinInfo\n import org.apache.calcite.rex._\n import org.apache.calcite.sql.`type`.{OperandTypes, ReturnTypes}\n import org.apache.calcite.sql.{SqlFunction, SqlFunctionCategory, SqlKind}\n \n+import scala.collection.JavaConversions._\n+\n /**\n-  * Utilities for temporal table join\n+  * Utilities for temporal table join.\n   */\n object TemporalJoinUtil {\n \n   // ----------------------------------------------------------------------------------------\n-  //                          Temporal TableFunction Join Utilities\n+  //                          Temporal Join Condition Utilities\n   // ----------------------------------------------------------------------------------------\n \n   /**\n-    * [[TEMPORAL_JOIN_CONDITION]] is a specific condition which correctly defines\n+    * [[TEMPORAL_JOIN_CONDITION]] is a specific join condition which correctly defines\n     * references to rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute.\n-    * The condition is used to mark this is a temporal tablefunction join.\n-    * Later rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n-    * extracted from the condition.\n+    * The condition is used to mark this is a temporal table join and ensure columns these\n+    * expressions depends on will not be pruned. The join key pair is necessary to ensure the\n+    * the condition will not push down.\n+    *\n+    * The rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n+    * extracted from the condition in physical phase.\n     */\n   val TEMPORAL_JOIN_CONDITION = new SqlFunction(\n     \"__TEMPORAL_JOIN_CONDITION\",\n     SqlKind.OTHER_FUNCTION,\n     ReturnTypes.BOOLEAN_NOT_NULL,\n     null,\n     OperandTypes.or(\n+      // right time attribute and primary key are required in event-time temporal table join,\n+      OperandTypes.sequence(\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)'\",\n+        OperandTypes.DATETIME,\n+        OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY),\n+      // the primary key may inferred later in event-time temporal table join,\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n         OperandTypes.ANY),\n+      // Only left time attribute is required for processing-time temporal table join,\n+      // primary key is optional\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n         OperandTypes.ANY)),\n     SqlFunctionCategory.SYSTEM)\n \n-  def isRowtimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 3\n-  }\n+  val TEMPORAL_JOIN_LEFT_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_LEFT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_RIGHT_KEY = new SqlFunction(\n+    \"TEMPORAL_JOIN_RIGHT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_CONDITION_PRIMARY_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_CONDITION_PRIMARY_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n \n-  def isProctimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 2\n-  }\n \n   def makeRowTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n     rightTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode],\n+    rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNTA2MQ==", "bodyText": "indent", "url": "https://github.com/apache/flink/pull/13299#discussion_r495905061", "createdAt": "2020-09-28T12:37:24Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -17,75 +17,152 @@\n  */\n package org.apache.flink.table.planner.plan.utils\n \n-import org.apache.flink.util.Preconditions.checkArgument\n-\n+import org.apache.calcite.rel.core.JoinInfo\n import org.apache.calcite.rex._\n import org.apache.calcite.sql.`type`.{OperandTypes, ReturnTypes}\n import org.apache.calcite.sql.{SqlFunction, SqlFunctionCategory, SqlKind}\n \n+import scala.collection.JavaConversions._\n+\n /**\n-  * Utilities for temporal table join\n+  * Utilities for temporal table join.\n   */\n object TemporalJoinUtil {\n \n   // ----------------------------------------------------------------------------------------\n-  //                          Temporal TableFunction Join Utilities\n+  //                          Temporal Join Condition Utilities\n   // ----------------------------------------------------------------------------------------\n \n   /**\n-    * [[TEMPORAL_JOIN_CONDITION]] is a specific condition which correctly defines\n+    * [[TEMPORAL_JOIN_CONDITION]] is a specific join condition which correctly defines\n     * references to rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute.\n-    * The condition is used to mark this is a temporal tablefunction join.\n-    * Later rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n-    * extracted from the condition.\n+    * The condition is used to mark this is a temporal table join and ensure columns these\n+    * expressions depends on will not be pruned. The join key pair is necessary to ensure the\n+    * the condition will not push down.\n+    *\n+    * The rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n+    * extracted from the condition in physical phase.\n     */\n   val TEMPORAL_JOIN_CONDITION = new SqlFunction(\n     \"__TEMPORAL_JOIN_CONDITION\",\n     SqlKind.OTHER_FUNCTION,\n     ReturnTypes.BOOLEAN_NOT_NULL,\n     null,\n     OperandTypes.or(\n+      // right time attribute and primary key are required in event-time temporal table join,\n+      OperandTypes.sequence(\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)'\",\n+        OperandTypes.DATETIME,\n+        OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY),\n+      // the primary key may inferred later in event-time temporal table join,\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n         OperandTypes.ANY),\n+      // Only left time attribute is required for processing-time temporal table join,\n+      // primary key is optional\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n         OperandTypes.ANY)),\n     SqlFunctionCategory.SYSTEM)\n \n-  def isRowtimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 3\n-  }\n+  val TEMPORAL_JOIN_LEFT_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_LEFT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_RIGHT_KEY = new SqlFunction(\n+    \"TEMPORAL_JOIN_RIGHT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_CONDITION_PRIMARY_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_CONDITION_PRIMARY_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n \n-  def isProctimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 2\n-  }\n \n   def makeRowTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n     rightTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode],\n+    rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {\n     rexBuilder.makeCall(\n       TEMPORAL_JOIN_CONDITION,\n       leftTimeAttribute,\n       rightTimeAttribute,\n+      makeLeftJoinKeyCall(rexBuilder, leftJoinKeyExpression),\n+      makeRightJoinKeyCall(rexBuilder, rightJoinKeyExpression),\n+      makePrimaryKeyCall(rexBuilder, rightPrimaryKeyExpression))\n+  }\n+\n+  def makeRowTimeTemporalJoinConditionCall(\n+      rexBuilder: RexBuilder,\n+      leftTimeAttribute: RexNode,\n+      rightTimeAttribute: RexNode,\n+      leftJoinKeyExpression: Seq[RexNode],\n+      rightJoinKeyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_CONDITION,\n+      leftTimeAttribute,\n+      rightTimeAttribute,\n+      makeLeftJoinKeyCall(rexBuilder, leftJoinKeyExpression),\n+      makeRightJoinKeyCall(rexBuilder, rightJoinKeyExpression))\n+  }\n+\n+  private def makePrimaryKeyCall(\n+      rexBuilder: RexBuilder,\n+      rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_CONDITION_PRIMARY_KEY,\n       rightPrimaryKeyExpression)\n   }\n \n+  private def makeLeftJoinKeyCall(\n+      rexBuilder: RexBuilder,\n+      keyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_LEFT_KEY,\n+      keyExpression)\n+  }\n+\n+  private def makeRightJoinKeyCall(\n+      rexBuilder: RexBuilder,\n+      keyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_RIGHT_KEY,\n+      keyExpression)\n+  }\n+\n   def makeProcTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode]): RexNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNjA2Mw==", "bodyText": "super.visitCall(call)", "url": "https://github.com/apache/flink/pull/13299#discussion_r495906063", "createdAt": "2020-09-28T12:39:12Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -103,4 +180,25 @@ object TemporalJoinUtil {\n     hasTemporalJoinCondition\n   }\n \n+  def isRowTimeJoin(rexBuilder: RexBuilder, joinInfo: JoinInfo): Boolean = {\n+    val nonEquiJoinRex = joinInfo.getRemaining(rexBuilder)\n+\n+    var rowtimeJoin: Boolean = false\n+    val visitor = new RexVisitorImpl[Unit](true) {\n+      override def visitCall(call: RexCall): Unit = {\n+        if (isRowTimeTemporalJoinConditionCall(call)) {\n+           rowtimeJoin = true\n+        } else {\n+          call.getOperands.foreach(node => node.accept(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwOTM1Mg==", "bodyText": "move them into before method", "url": "https://github.com/apache/flink/pull/13299#discussion_r495909352", "createdAt": "2020-09-28T12:44:55Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,95 +17,136 @@\n  */\n package org.apache.flink.table.planner.plan.batch.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.TableException\n import org.apache.flink.table.planner.utils.{BatchTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in batch mode.\n+ *\n+ * <p> Flink only supports lookup join in batch mode, the others Temporal join is not supported yet.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: BatchTableTestUtil = batchTestUtil()\n \n-  val orders = util.addDataStream[(Long, String, Timestamp)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n+\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT currency, rate, proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T\" +\n+      \"  WHERE rowNum = 1\")\n+\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxMTUzMA==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/13299#discussion_r495911530", "createdAt": "2020-09-28T12:48:25Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNDQ5OQ==", "bodyText": "another case: join keys does not match pk", "url": "https://github.com/apache/flink/pull/13299#discussion_r495914499", "createdAt": "2020-09-28T12:53:15Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val ratesHistory = util.addDataStream[(String, Int, Timestamp)](\n-    \"RatesHistory\", 'currency, 'rate, 'rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  util.addFunction(\n-    \"Rates\",\n-    ratesHistory.createTemporalTableFunction($\"rowtime\", $\"currency\"))\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val proctimeOrders = util.addDataStream[(Long, String)](\n-    \"ProctimeOrders\", 'o_amount, 'o_currency, 'o_proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n \n-  private val proctimeRatesHistory = util.addDataStream[(String, Int)](\n-    \"ProctimeRatesHistory\", 'currency, 'rate, 'proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT T.currency, T.rate, T.proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T \" +\n+      \"  WHERE T.rowNum = 1\")\n \n-  util.addFunction(\n-    \"ProctimeRates\",\n-    proctimeRatesHistory.createTemporalTableFunction($\"proctime\", $\"currency\"))\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")\n \n   @Test\n-  def testSimpleJoin(): Unit = {\n+  def testEventTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testSimpleProctimeJoin(): Unit = {\n+  def testEventTimeTemporalJoinWithView(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM ProctimeOrders AS o, \" +\n-      \"LATERAL TABLE (ProctimeRates(o.o_proctime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"DeduplicatedView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_rowtime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testJoinOnQueryLeft(): Unit = {\n-    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n-    util.tableEnv.createTemporaryView(\"Orders2\", orders)\n-\n+  def testProcTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders2 AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"latestView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n-  /**\n-    * Test versioned joins with more complicated query.\n-    * Important thing here is that we have complex OR join condition\n-    * and there are some columns that are not being used (are being pruned).\n-    */\n   @Test\n-  def testComplexJoin(): Unit = {\n-    val util = streamTestUtil()\n-    util.addDataStream[(String, Int)](\"Table3\", 't3_comment, 't3_secondary_key)\n-    util.addDataStream[(Timestamp, String, Long, String, Int)](\n-      \"Orders\", 'o_rowtime.rowtime, 'o_comment, 'o_amount, 'o_currency, 'o_secondary_key)\n-\n-    util.addDataStream[(Timestamp, String, String, Int, Int)](\n-      \"RatesHistory\", 'rowtime.rowtime, 'comment, 'currency, 'rate, 'secondary_key)\n-    val rates = util.tableEnv\n-      .sqlQuery(\"SELECT * FROM RatesHistory WHERE rate > 110\")\n-      .createTemporalTableFunction($\"rowtime\", $\"currency\")\n-    util.addTemporarySystemFunction(\"Rates\", rates)\n-\n-    val sqlQuery =\n-      \"SELECT * FROM \" +\n-        \"(SELECT \" +\n-        \"o_amount * rate as rate, \" +\n-        \"secondary_key as secondary_key \" +\n-        \"FROM Orders AS o, \" +\n-        \"LATERAL TABLE (Rates(o_rowtime)) AS r \" +\n-        \"WHERE currency = o_currency OR secondary_key = o_secondary_key), \" +\n-        \"Table3 \" +\n-        \"WHERE t3_secondary_key = secondary_key\"\n+  def testProcTimeTemporalJoinWithView(): Unit = {\n+    val sqlQuery = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"latest_rates \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testUncorrelatedJoin(): Unit = {\n-    expectedException.expect(classOf[TableException])\n-    expectedException.expectMessage(containsString(\"Cannot generate a valid execution plan\"))\n+  def testInvalidTemporalTablJoin(): Unit = {\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE leftTableWithoutTimeAttribute (\n+        | o_amount INT,\n+        | o_currency STRING,\n+        | o_time TIMESTAMP(3)\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery1 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM leftTableWithoutTimeAttribute AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_time as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery1,\n+      s\"Temporal table join currently only supports 'FOR SYSTEM_TIME AS OF'\" +\n+        s\" left table's time attribute field\",\n+      classOf[ValidationException])\n \n-    val sqlQuery = \"SELECT \" +\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutPk (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | WATERMARK FOR rowtime AS rowtime\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery2 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutPk FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery2,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no primary key found.\",\n+      classOf[ValidationException])\n+\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutTimeAttribute (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | PRIMARY KEY(currency) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery3 = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(TIMESTAMP '2016-06-27 10:10:42.123')) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutTimeAttribute FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery3,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no row time attribute found.\",\n+      classOf[ValidationException])\n \n-    util.verifyExplain(sqlQuery)\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutRowtime (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | proctime AS PROCTIME(),\n+        | PRIMARY KEY(currency) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery4 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutRowtime FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery4,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no row time attribute found.\",\n+      classOf[ValidationException])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNTQ1Ng==", "bodyText": "other cases: non-equal join condition,  equal join condition with other predicates, etc", "url": "https://github.com/apache/flink/pull/13299#discussion_r495915456", "createdAt": "2020-09-28T12:54:46Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val ratesHistory = util.addDataStream[(String, Int, Timestamp)](\n-    \"RatesHistory\", 'currency, 'rate, 'rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  util.addFunction(\n-    \"Rates\",\n-    ratesHistory.createTemporalTableFunction($\"rowtime\", $\"currency\"))\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val proctimeOrders = util.addDataStream[(Long, String)](\n-    \"ProctimeOrders\", 'o_amount, 'o_currency, 'o_proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n \n-  private val proctimeRatesHistory = util.addDataStream[(String, Int)](\n-    \"ProctimeRatesHistory\", 'currency, 'rate, 'proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT T.currency, T.rate, T.proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T \" +\n+      \"  WHERE T.rowNum = 1\")\n \n-  util.addFunction(\n-    \"ProctimeRates\",\n-    proctimeRatesHistory.createTemporalTableFunction($\"proctime\", $\"currency\"))\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")\n \n   @Test\n-  def testSimpleJoin(): Unit = {\n+  def testEventTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testSimpleProctimeJoin(): Unit = {\n+  def testEventTimeTemporalJoinWithView(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM ProctimeOrders AS o, \" +\n-      \"LATERAL TABLE (ProctimeRates(o.o_proctime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"DeduplicatedView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_rowtime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testJoinOnQueryLeft(): Unit = {\n-    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n-    util.tableEnv.createTemporaryView(\"Orders2\", orders)\n-\n+  def testProcTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders2 AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"latestView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n-  /**\n-    * Test versioned joins with more complicated query.\n-    * Important thing here is that we have complex OR join condition\n-    * and there are some columns that are not being used (are being pruned).\n-    */\n   @Test\n-  def testComplexJoin(): Unit = {\n-    val util = streamTestUtil()\n-    util.addDataStream[(String, Int)](\"Table3\", 't3_comment, 't3_secondary_key)\n-    util.addDataStream[(Timestamp, String, Long, String, Int)](\n-      \"Orders\", 'o_rowtime.rowtime, 'o_comment, 'o_amount, 'o_currency, 'o_secondary_key)\n-\n-    util.addDataStream[(Timestamp, String, String, Int, Int)](\n-      \"RatesHistory\", 'rowtime.rowtime, 'comment, 'currency, 'rate, 'secondary_key)\n-    val rates = util.tableEnv\n-      .sqlQuery(\"SELECT * FROM RatesHistory WHERE rate > 110\")\n-      .createTemporalTableFunction($\"rowtime\", $\"currency\")\n-    util.addTemporarySystemFunction(\"Rates\", rates)\n-\n-    val sqlQuery =\n-      \"SELECT * FROM \" +\n-        \"(SELECT \" +\n-        \"o_amount * rate as rate, \" +\n-        \"secondary_key as secondary_key \" +\n-        \"FROM Orders AS o, \" +\n-        \"LATERAL TABLE (Rates(o_rowtime)) AS r \" +\n-        \"WHERE currency = o_currency OR secondary_key = o_secondary_key), \" +\n-        \"Table3 \" +\n-        \"WHERE t3_secondary_key = secondary_key\"\n+  def testProcTimeTemporalJoinWithView(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694"}, "originalPosition": 187}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0719cf3cfc2219361b74540399126cc84a8e1cd", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/a0719cf3cfc2219361b74540399126cc84a8e1cd", "committedDate": "2020-10-13T14:50:29Z", "message": "add tests"}, "afterCommit": {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/b0e40b37f7993240764dce3280c9c59d5b0b6e75", "committedDate": "2020-10-14T10:37:15Z", "message": "add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MzA2Nzg5", "url": "https://github.com/apache/flink/pull/13299#pullrequestreview-508306789", "createdAt": "2020-10-14T12:47:30Z", "commit": {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMjo0NzozMVrOHhRPkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMzowNjo1MlrOHhSD-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY0NzU3MA==", "bodyText": "The join will be translated into [[StreamExecLookupJoin]] or [[StreamExecTemporalJoin]] in physical.", "url": "https://github.com/apache/flink/pull/13299#discussion_r504647570", "createdAt": "2020-10-14T12:47:31Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -17,19 +17,32 @@\n  */\n package org.apache.flink.table.planner.plan.rules.logical\n \n-import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n-\n import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.hep.{HepPlanner, HepRelVertex}\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelOptRuleOperand}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.logical.{LogicalCorrelate, LogicalFilter, LogicalSnapshot}\n-import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess, RexInputRef, RexNode, RexShuttle}\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical._\n+import org.apache.calcite.rex._\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.isRowtimeIndicatorType\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n   * The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into a Join\n   * to make join condition can be pushed-down. The join will be translated into\n-  * [[StreamExecLookupJoin]] in physical and might be translated into [[StreamExecTemporalJoin]]\n-  * in the future.\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY2MDk4NQ==", "bodyText": "move this close to testGetUniqueKeysOnStreamExecDeduplicate method", "url": "https://github.com/apache/flink/pull/13299#discussion_r504660985", "createdAt": "2020-10-14T13:06:52Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeysTest.scala", "diffHunk": "@@ -70,6 +70,16 @@ class FlinkRelMdUniqueKeysTest extends FlinkRelMdHandlerTestBase {\n     assertEquals(uniqueKeys(Array(0)), mq.getUniqueKeys(logicalFilter).toSet)\n   }\n \n+  @Test\n+  def testGetUniqueKeysOnWatermark(): Unit = {\n+    assertEquals(uniqueKeys(Array(0)), mq.getUniqueKeys(logicalWatermarkAssigner).toSet)\n+  }\n+\n+  @Test\n+  def testGetUniqueKeysOnRowtimeDeduplicate(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d142b0a736b24b1d1d714da9c26bf89279e643c8", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/d142b0a736b24b1d1d714da9c26bf89279e643c8", "committedDate": "2020-10-14T16:04:13Z", "message": "add more tests"}, "afterCommit": {"oid": "e7f001da22368aed31002c28199b4f97d2a2b63b", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/e7f001da22368aed31002c28199b4f97d2a2b63b", "committedDate": "2020-10-14T16:22:09Z", "message": "add more tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7f001da22368aed31002c28199b4f97d2a2b63b", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/e7f001da22368aed31002c28199b4f97d2a2b63b", "committedDate": "2020-10-14T16:22:09Z", "message": "add more tests"}, "afterCommit": {"oid": "9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "committedDate": "2020-10-15T02:08:45Z", "message": "add more tests(changelogmode tests)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "committedDate": "2020-10-15T02:08:45Z", "message": "add more tests(changelogmode tests)"}, "afterCommit": {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/55acd8f52fd5df5316efd04068754cdeca4d612f", "committedDate": "2020-10-15T02:46:23Z", "message": "add more tests(changelogmode tests)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4OTEwODky", "url": "https://github.com/apache/flink/pull/13299#pullrequestreview-508910892", "createdAt": "2020-10-15T03:25:31Z", "commit": {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzoyNTozMlrOHhvbhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNTo0NjoxNlrOHhxoRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjE1MQ==", "bodyText": "it's better we can do some refactor, many test cases do not involve aggregation", "url": "https://github.com/apache/flink/pull/13299#discussion_r505142151", "createdAt": "2020-10-15T03:25:32Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/physical/stream/ChangelogModeInferenceTest.scala", "diffHunk": "@@ -73,6 +122,28 @@ class ChangelogModeInferenceTest(aggMode: AggMode) extends TableTestBase {\n     util.verifyPlan(sql, ExplainDetail.CHANGELOG_MODE)\n   }\n \n+  @Test\n+  def testTemporalJoinWithDeduplicateView(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0NDQ1MA==", "bodyText": "both StreamExecTemporalJoinRule and TemporalJoinRewriteWithUniqueKeyRule will use this method indirectly, while StreamExecTemporalJoinRule is used in volcano planner.", "url": "https://github.com/apache/flink/pull/13299#discussion_r505144450", "createdAt": "2020-10-15T03:35:09Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/common/CommonTemporalTableJoinRule.scala", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.common\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalRel, FlinkLogicalSnapshot, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import org.apache.calcite.plan.hep.HepRelVertex\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical.{LogicalProject, LogicalTableScan}\n+import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess}\n+\n+/**\n+  * Base implementation that matches temporal join node.\n+  *\n+  * <p> The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into\n+  * a Join to make join condition can be pushed-down. The join will be translated into\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].\n+  */\n+trait CommonTemporalTableJoinRule {\n+\n+  protected def matches(snapshot: FlinkLogicalSnapshot): Boolean = {\n+\n+    // period specification check\n+    snapshot.getPeriod match {\n+      // it's left table's field, pass\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] =>\n+      case _ =>\n+        throw new TableException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field, doesn't support 'PROCTIME()'\")\n+    }\n+\n+    snapshot.getPeriod.getType match {\n+      // supports both event-time and processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new TableException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+    true\n+  }\n+\n+  protected def canConvertToLookupJoin(\n+      snapshot: FlinkLogicalSnapshot,\n+      snapshotInput: FlinkLogicalRel): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+      => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]\n+      => Some(trimHep(project.getInput).asInstanceOf[TableScan])\n+      case _ => None\n+    }\n+  }\n+\n+  private def isTableSourceScan(relNode: RelNode): Boolean = {\n+    relNode match {\n+      case r: LogicalTableScan =>\n+        val table = r.getTable\n+        table match {\n+          case _: LegacyTableSourceTable[Any] | _: TableSourceTable => true\n+          case _ => false\n+        }\n+      case _: FlinkLogicalLegacyTableSourceScan | _: FlinkLogicalTableSourceScan => true\n+      case _ => false\n+    }\n+  }\n+\n+  private def isLookupTableSource(relNode: RelNode): Boolean = relNode match {\n+    case scan: FlinkLogicalLegacyTableSourceScan =>\n+      scan.tableSource.isInstanceOf[LookupableTableSource[_]]\n+    case scan: FlinkLogicalTableSourceScan =>\n+      scan.tableSource.isInstanceOf[LookupTableSource]\n+    case scan: LogicalTableScan =>\n+      scan.getTable match {\n+        case table: LegacyTableSourceTable[_] =>\n+          table.tableSource.isInstanceOf[LookupableTableSource[_]]\n+        case table: TableSourceTable =>\n+          table.tableSource.isInstanceOf[LookupTableSource]\n+        case _ => false\n+      }\n+    case _ => false\n+  }\n+\n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3NDgwOA==", "bodyText": "add a test about right join and full join", "url": "https://github.com/apache/flink/pull/13299#discussion_r505174808", "createdAt": "2020-10-15T05:35:40Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRuleTest.scala", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule\n+import org.apache.calcite.plan.hep.HepMatchOrder\n+import org.apache.calcite.tools.RuleSets\n+\n+import org.apache.flink.api.scala._\n+import org.apache.flink.table.api._\n+import org.apache.flink.table.planner.plan.optimize.program.{FlinkChainedProgram, FlinkHepRuleSetProgramBuilder, HEP_RULES_EXECUTION_TYPE, StreamOptimizeContext}\n+import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase, TableTestUtil}\n+import org.junit.{Before, Test}\n+\n+/**\n+ * Test for [[LogicalCorrelateToJoinFromTemporalTableRule]].\n+ */\n+class LogicalCorrelateToJoinFromTemporalTableRuleTest extends TableTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69b257fae4b61dd7e2df59afccdf83da9c85a70a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3NjQzNg==", "bodyText": "also add a test about non-equal condition", "url": "https://github.com/apache/flink/pull/13299#discussion_r505176436", "createdAt": "2020-10-15T05:40:45Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRuleTest.scala", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule\n+import org.apache.calcite.plan.hep.HepMatchOrder\n+import org.apache.calcite.tools.RuleSets\n+\n+import org.apache.flink.api.scala._\n+import org.apache.flink.table.api._\n+import org.apache.flink.table.planner.plan.optimize.program.{FlinkChainedProgram, FlinkHepRuleSetProgramBuilder, HEP_RULES_EXECUTION_TYPE, StreamOptimizeContext}\n+import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase, TableTestUtil}\n+import org.junit.{Before, Test}\n+\n+/**\n+ * Test for [[LogicalCorrelateToJoinFromTemporalTableRule]].\n+ */\n+class LogicalCorrelateToJoinFromTemporalTableRuleTest extends TableTestBase {\n+\n+  protected val util: StreamTableTestUtil = streamTestUtil()\n+\n+  @Before\n+  def setup(): Unit = {\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE T1 (\n+        | id STRING,\n+        | mount INT,\n+        | proctime as PROCTIME(),\n+        | rowtime TIMESTAMP(3),\n+        | WATERMARK FOR rowtime AS rowtime\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+\n+    //lookup table, CollectionTableSource implements LookupableTableSource interface\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE T2 (\n+        | id STRING,\n+        | rate INT,\n+        | PRIMARY KEY(id) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+\n+    // non-lookup table\n+    util.addTableSource[(String, Int)](\"T3\", 'id, 'rate, 'rowtime.rowtime())\n+  }\n+\n+  @Test\n+  def testLookupJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.LOOKUP_JOIN_WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T2 FOR SYSTEM_TIME AS OF T1.proctime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testLeftLookupJoinOnTrue(): Unit = {\n+    // lookup join also does not support ON TRUE condition in runtime\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.LOOKUP_JOIN_WITHOUT_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 LEFT JOIN T2 FOR SYSTEM_TIME AS OF \" +\n+      \"T1.proctime AS dimTable ON TRUE\")\n+  }\n+\n+  @Test\n+  def testProcTimeTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T3 FOR SYSTEM_TIME AS OF T1.proctime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testRowTimeTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T3 FOR SYSTEM_TIME AS OF T1.rowtime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testRowTimeLeftTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 LEFT JOIN T3 FOR SYSTEM_TIME AS OF T1.rowtime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testLookupJoinOnTrue(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69b257fae4b61dd7e2df59afccdf83da9c85a70a"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3ODE4MA==", "bodyText": "Does runtime support left join? this change should be covered by at least one IT case", "url": "https://github.com/apache/flink/pull/13299#discussion_r505178180", "createdAt": "2020-10-15T05:46:16Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -241,7 +233,7 @@ class StreamExecTemporalJoinToCoProcessTranslator private (\n     val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n     val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n     joinType match {\n-      case JoinRelType.INNER =>\n+      case JoinRelType.INNER | JoinRelType.LEFT =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69b257fae4b61dd7e2df59afccdf83da9c85a70a"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb79e997201a60f34a935ee41905bbbb3969d6e8", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/bb79e997201a60f34a935ee41905bbbb3969d6e8", "committedDate": "2020-10-15T13:48:37Z", "message": "[FLINK-19072][table-planner] Import Temporal Table join rule for stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4175b42f65fec599c2821e33bce595b07cd8083", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/a4175b42f65fec599c2821e33bce595b07cd8083", "committedDate": "2020-10-15T13:49:08Z", "message": "[FLINK-19073][table-planner] Imporve streamExecTemporalJoinRule for stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "committedDate": "2020-10-15T13:50:07Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "11a74b700cc0c0d2ca59880c2398a812ec26512a", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/11a74b700cc0c0d2ca59880c2398a812ec26512a", "committedDate": "2020-10-15T13:17:31Z", "message": "address comments"}, "afterCommit": {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "author": {"user": {"login": "leonardBang", "name": "Leonard Xu"}}, "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "committedDate": "2020-10-15T13:50:07Z", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4337, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}