{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNDc3NjY1", "number": 12306, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOTo0MzoxNVrOD_U9gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDozODo1N1rOD_Z50A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzMwMzA1OnYy", "diffSide": "RIGHT", "path": "flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOTo0MzoxNVrOGZ7aSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwNzoyNDo0MVrOGaRu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg0MDk3MA==", "bodyText": "This does not remove the output from watermarkOutputs. Please add a test that verifies correct behaviour when removing outputs.\nWith the current design, it's actually not possible to remove the output from watermarkOutputs. One possible solution is to get rid of that list and always use the Map for iterating the outputs in onPeriodicEmit(). That would be a smidge slower but I think that's ok because periodic watermark emission does not happen super often.", "url": "https://github.com/apache/flink/pull/12306#discussion_r429840970", "createdAt": "2020-05-25T09:43:15Z", "author": {"login": "aljoscha"}, "path": "flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java", "diffHunk": "@@ -88,13 +85,17 @@ public WatermarkOutputMultiplexer(WatermarkOutput underlyingOutput) {\n \t * an output ID that can be used to get a deferred or immediate {@link WatermarkOutput} for that\n \t * output.\n \t */\n-\tpublic int registerNewOutput() {\n-\t\tint newOutputId = nextOutputId;\n-\t\tnextOutputId++;\n-\t\tOutputState outputState = new OutputState();\n-\t\twatermarkPerOutputId.put(newOutputId, outputState);\n+\tpublic void registerNewOutput(String id) {\n+\t\tfinal OutputState outputState = new OutputState();\n+\n+\t\tfinal OutputState previouslyRegistered = watermarkPerOutputId.putIfAbsent(id, outputState);\n+\t\tcheckState(previouslyRegistered == null, \"Already contains an output for ID %s\", id);\n+\n \t\twatermarkOutputs.add(outputState);\n-\t\treturn newOutputId;\n+\t}\n+\n+\tpublic boolean unregisterOutput(String id) {\n+\t\treturn watermarkPerOutputId.remove(id) != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4875f1635096a9d407bb4ddc71d0209e1ea024b4"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg0Njg3Mw==", "bodyText": "Why is it not possible to remove from watermarkOutputs? It is a linear operation (List.remove()), but then again, it doesn't happen very often.", "url": "https://github.com/apache/flink/pull/12306#discussion_r429846873", "createdAt": "2020-05-25T09:55:40Z", "author": {"login": "StephanEwen"}, "path": "flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java", "diffHunk": "@@ -88,13 +85,17 @@ public WatermarkOutputMultiplexer(WatermarkOutput underlyingOutput) {\n \t * an output ID that can be used to get a deferred or immediate {@link WatermarkOutput} for that\n \t * output.\n \t */\n-\tpublic int registerNewOutput() {\n-\t\tint newOutputId = nextOutputId;\n-\t\tnextOutputId++;\n-\t\tOutputState outputState = new OutputState();\n-\t\twatermarkPerOutputId.put(newOutputId, outputState);\n+\tpublic void registerNewOutput(String id) {\n+\t\tfinal OutputState outputState = new OutputState();\n+\n+\t\tfinal OutputState previouslyRegistered = watermarkPerOutputId.putIfAbsent(id, outputState);\n+\t\tcheckState(previouslyRegistered == null, \"Already contains an output for ID %s\", id);\n+\n \t\twatermarkOutputs.add(outputState);\n-\t\treturn newOutputId;\n+\t}\n+\n+\tpublic boolean unregisterOutput(String id) {\n+\t\treturn watermarkPerOutputId.remove(id) != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg0MDk3MA=="}, "originalCommit": {"oid": "4875f1635096a9d407bb4ddc71d0209e1ea024b4"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIwNjcwMA==", "bodyText": "Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...", "url": "https://github.com/apache/flink/pull/12306#discussion_r430206700", "createdAt": "2020-05-26T07:24:41Z", "author": {"login": "aljoscha"}, "path": "flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java", "diffHunk": "@@ -88,13 +85,17 @@ public WatermarkOutputMultiplexer(WatermarkOutput underlyingOutput) {\n \t * an output ID that can be used to get a deferred or immediate {@link WatermarkOutput} for that\n \t * output.\n \t */\n-\tpublic int registerNewOutput() {\n-\t\tint newOutputId = nextOutputId;\n-\t\tnextOutputId++;\n-\t\tOutputState outputState = new OutputState();\n-\t\twatermarkPerOutputId.put(newOutputId, outputState);\n+\tpublic void registerNewOutput(String id) {\n+\t\tfinal OutputState outputState = new OutputState();\n+\n+\t\tfinal OutputState previouslyRegistered = watermarkPerOutputId.putIfAbsent(id, outputState);\n+\t\tcheckState(previouslyRegistered == null, \"Already contains an output for ID %s\", id);\n+\n \t\twatermarkOutputs.add(outputState);\n-\t\treturn newOutputId;\n+\t}\n+\n+\tpublic boolean unregisterOutput(String id) {\n+\t\treturn watermarkPerOutputId.remove(id) != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg0MDk3MA=="}, "originalCommit": {"oid": "4875f1635096a9d407bb4ddc71d0209e1ea024b4"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzQ4NTIzOnYy", "diffSide": "RIGHT", "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMDo1MDowN1rOGZ9LCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1Mjo1NlrOGaaxGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2OTgzNQ==", "bodyText": "Is there a reason to override the method in the parent class here?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429869835", "createdAt": "2020-05-25T10:50:07Z", "author": {"login": "becketqin"}, "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ */\n+\n+package org.apache.flink.api.connector.source;\n+\n+import org.apache.flink.annotation.PublicEvolving;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+\n+/**\n+ * The interface provided by Flink task to the {@link SourceReader} to emit records\n+ * to downstream operators for message processing.\n+ */\n+@PublicEvolving\n+public interface ReaderOutput<T> extends SourceOutput<T> {\n+\n+\t/**\n+\t * Emit a record without a timestamp. Equivalent to {@link #collect(Object, long) collect(timestamp, null)};\n+\t *\n+\t * @param record the record to emit.\n+\t */\n+\t@Override\n+\tvoid collect(T record);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NDcxNQ==", "bodyText": "I often do that to spare the user navigating to parent classes to see methods and read JavaDocs. But it is purely cosmetic. I don't feel strongly about this.", "url": "https://github.com/apache/flink/pull/12306#discussion_r430354715", "createdAt": "2020-05-26T11:52:56Z", "author": {"login": "StephanEwen"}, "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ */\n+\n+package org.apache.flink.api.connector.source;\n+\n+import org.apache.flink.annotation.PublicEvolving;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+\n+/**\n+ * The interface provided by Flink task to the {@link SourceReader} to emit records\n+ * to downstream operators for message processing.\n+ */\n+@PublicEvolving\n+public interface ReaderOutput<T> extends SourceOutput<T> {\n+\n+\t/**\n+\t * Emit a record without a timestamp. Equivalent to {@link #collect(Object, long) collect(timestamp, null)};\n+\t *\n+\t * @param record the record to emit.\n+\t */\n+\t@Override\n+\tvoid collect(T record);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2OTgzNQ=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzQ5NjE2OnYy", "diffSide": "RIGHT", "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMDo1NDoyN1rOGZ9RpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1MzoyNFrOGaayGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTUyNA==", "bodyText": "Should we specify the behavior of this method to just return the existing SourceOutput if one is already created for the given split?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429871524", "createdAt": "2020-05-25T10:54:27Z", "author": {"login": "becketqin"}, "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ */\n+\n+package org.apache.flink.api.connector.source;\n+\n+import org.apache.flink.annotation.PublicEvolving;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+\n+/**\n+ * The interface provided by Flink task to the {@link SourceReader} to emit records\n+ * to downstream operators for message processing.\n+ */\n+@PublicEvolving\n+public interface ReaderOutput<T> extends SourceOutput<T> {\n+\n+\t/**\n+\t * Emit a record without a timestamp. Equivalent to {@link #collect(Object, long) collect(timestamp, null)};\n+\t *\n+\t * @param record the record to emit.\n+\t */\n+\t@Override\n+\tvoid collect(T record);\n+\n+\t/**\n+\t * Emit a record with timestamp.\n+\t *\n+\t * @param record the record to emit.\n+\t * @param timestamp the timestamp of the record.\n+\t */\n+\t@Override\n+\tvoid collect(T record, long timestamp);\n+\n+\t/**\n+\t * Emits the given watermark.\n+\t *\n+\t * <p>Emitting a watermark also implicitly marks the stream as <i>active</i>, ending\n+\t * previously marked idleness.\n+\t */\n+\t@Override\n+\tvoid emitWatermark(Watermark watermark);\n+\n+\t/**\n+\t * Marks this output as idle, meaning that downstream operations do not\n+\t * wait for watermarks from this output.\n+\t *\n+\t * <p>An output becomes active again as soon as the next watermark is emitted.\n+\t */\n+\t@Override\n+\tvoid markIdle();\n+\n+\t/**\n+\t * Creates a {@code SourceOutput} for a specific Source Split. Use these outputs if you want to\n+\t * run split-local logic, like watermark generation.\n+\t * Only one split-local output may be created per split.\n+\t *\n+\t * <p><b>IMPORTANT:</b> After the split has been finished, it is crucial to release the created\n+\t * output again. Otherwise it will continue to contribute to the watermark generation like a\n+\t * perpetually stalling source split, and may hold back the watermark indefinitely.\n+\t *\n+\t * @see #releaseOutputForSplit(String)\n+\t */\n+\tSourceOutput<T> createOutputForSplit(String splitId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NDk2OQ==", "bodyText": "Yes, that is better. Will change this.", "url": "https://github.com/apache/flink/pull/12306#discussion_r430354969", "createdAt": "2020-05-26T11:53:24Z", "author": {"login": "StephanEwen"}, "path": "flink-core/src/main/java/org/apache/flink/api/connector/source/ReaderOutput.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ */\n+\n+package org.apache.flink.api.connector.source;\n+\n+import org.apache.flink.annotation.PublicEvolving;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+\n+/**\n+ * The interface provided by Flink task to the {@link SourceReader} to emit records\n+ * to downstream operators for message processing.\n+ */\n+@PublicEvolving\n+public interface ReaderOutput<T> extends SourceOutput<T> {\n+\n+\t/**\n+\t * Emit a record without a timestamp. Equivalent to {@link #collect(Object, long) collect(timestamp, null)};\n+\t *\n+\t * @param record the record to emit.\n+\t */\n+\t@Override\n+\tvoid collect(T record);\n+\n+\t/**\n+\t * Emit a record with timestamp.\n+\t *\n+\t * @param record the record to emit.\n+\t * @param timestamp the timestamp of the record.\n+\t */\n+\t@Override\n+\tvoid collect(T record, long timestamp);\n+\n+\t/**\n+\t * Emits the given watermark.\n+\t *\n+\t * <p>Emitting a watermark also implicitly marks the stream as <i>active</i>, ending\n+\t * previously marked idleness.\n+\t */\n+\t@Override\n+\tvoid emitWatermark(Watermark watermark);\n+\n+\t/**\n+\t * Marks this output as idle, meaning that downstream operations do not\n+\t * wait for watermarks from this output.\n+\t *\n+\t * <p>An output becomes active again as soon as the next watermark is emitted.\n+\t */\n+\t@Override\n+\tvoid markIdle();\n+\n+\t/**\n+\t * Creates a {@code SourceOutput} for a specific Source Split. Use these outputs if you want to\n+\t * run split-local logic, like watermark generation.\n+\t * Only one split-local output may be created per split.\n+\t *\n+\t * <p><b>IMPORTANT:</b> After the split has been finished, it is crucial to release the created\n+\t * output again. Otherwise it will continue to contribute to the watermark generation like a\n+\t * perpetually stalling source split, and may hold back the watermark indefinitely.\n+\t *\n+\t * @see #releaseOutputForSplit(String)\n+\t */\n+\tSourceOutput<T> createOutputForSplit(String splitId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTUyNA=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzk0Nzg0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo0NDozOVrOGaBoEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1NzowOFrOGaa5mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0MjgwMQ==", "bodyText": "Might be better to put in the constructor of SourceOperator?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429942801", "createdAt": "2020-05-25T13:44:39Z", "author": {"login": "becketqin"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperatorFactory.java", "diffHunk": "@@ -61,9 +67,11 @@ public SourceOperatorFactory(Source<OUT, ?, ?> source, int numCoordinatorWorkerT\n \t\tfinal SourceOperator<OUT, ?> sourceOperator = instantiateSourceOperator(\n \t\t\t\tsource::createReader,\n \t\t\t\tgateway,\n-\t\t\t\tsource.getSplitSerializer());\n+\t\t\t\tsource.getSplitSerializer(),\n+\t\t\t\teventTimeConfig);\n \n \t\tsourceOperator.setup(parameters.getContainingTask(), parameters.getStreamConfig(), parameters.getOutput());\n+\t\tsourceOperator.processingTimeService = parameters.getProcessingTimeService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1Njg5MQ==", "bodyText": "Will do", "url": "https://github.com/apache/flink/pull/12306#discussion_r430356891", "createdAt": "2020-05-26T11:57:08Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperatorFactory.java", "diffHunk": "@@ -61,9 +67,11 @@ public SourceOperatorFactory(Source<OUT, ?, ?> source, int numCoordinatorWorkerT\n \t\tfinal SourceOperator<OUT, ?> sourceOperator = instantiateSourceOperator(\n \t\t\t\tsource::createReader,\n \t\t\t\tgateway,\n-\t\t\t\tsource.getSplitSerializer());\n+\t\t\t\tsource.getSplitSerializer(),\n+\t\t\t\teventTimeConfig);\n \n \t\tsourceOperator.setup(parameters.getContainingTask(), parameters.getStreamConfig(), parameters.getOutput());\n+\t\tsourceOperator.processingTimeService = parameters.getProcessingTimeService();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0MjgwMQ=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzk1NzI2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/EventTimeConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo0Nzo0MVrOGaBtxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0OTo1OFrOGbFpfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NDI2MQ==", "bodyText": "TimestampAndWatermarksFactory seems a more consistent class name.", "url": "https://github.com/apache/flink/pull/12306#discussion_r429944261", "createdAt": "2020-05-25T13:47:41Z", "author": {"login": "becketqin"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/EventTimeConfig.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.RecordTimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssignerSupplier;\n+import org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+\n+/**\n+ * A collection of all information relevant to setting up timestamp extraction and watermark\n+ * generation in a data source operator.\n+ */\n+public final class EventTimeConfig<T> implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NzQ3Mg==", "bodyText": "Maybe. I think this may actually serve a \"config-style\" purpose (at least if Configs may be more than key/value pairs).", "url": "https://github.com/apache/flink/pull/12306#discussion_r430357472", "createdAt": "2020-05-26T11:58:06Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/EventTimeConfig.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.RecordTimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssignerSupplier;\n+import org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+\n+/**\n+ * A collection of all information relevant to setting up timestamp extraction and watermark\n+ * generation in a data source operator.\n+ */\n+public final class EventTimeConfig<T> implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NDI2MQ=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NzI3OQ==", "bodyText": "The class got dropped in the latest rework anyways. So, no more need to find a good name ;-)", "url": "https://github.com/apache/flink/pull/12306#discussion_r431057279", "createdAt": "2020-05-27T11:49:58Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/EventTimeConfig.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.RecordTimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssignerSupplier;\n+import org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+\n+/**\n+ * A collection of all information relevant to setting up timestamp extraction and watermark\n+ * generation in a data source operator.\n+ */\n+public final class EventTimeConfig<T> implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NDI2MQ=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzk2OTA3OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo1MToyM1rOGaB0uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1NToxN1rOGaa1vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NjA0MA==", "bodyText": "Is this a symbolic special value of \"NO_TIMESTAMP\" or it might trigger retraction in the downstream operators?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429946040", "createdAt": "2020-05-25T13:51:23Z", "author": {"login": "becketqin"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+import org.apache.flink.api.common.eventtime.WatermarkGenerator;\n+import org.apache.flink.api.common.eventtime.WatermarkOutput;\n+import org.apache.flink.api.connector.source.SourceOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.tasks.ExceptionInChainedOperatorException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Implementation of the SourceOutput. The records emitted to this output are pushed into a given\n+ * {@link PushingAsyncDataInput.DataOutput}. The watermarks are pushed into the same output, or\n+ * into a separate {@link WatermarkOutput}, if one is provided.\n+ *\n+ * <h2>Perdiodic Watermarks</h2>\n+ *\n+ * <p>This output does not implement periodic watermarks\n+ * <h2>Note on Performance Considerations</h2>\n+ *\n+ * <p>The methods {@link SourceOutput#collect(Object)} and {@link SourceOutput#collect(Object, long)}\n+ * are highly performance-critical (part of the hot loop). To make the code as JIT friendly as possible,\n+ * we want to have only a single implementation of these two methods, across all classes.\n+ * That way, the JIT compiler can de-virtualize (and inline) them better.\n+ *\n+ * <p>Currently, we have one implementation of these methods in the batch case (see class\n+ * {@link BatchTimestampsAndWatermarks}) and one for the streaming case (this class). When the JVM\n+ * is dedicated to a single job (or type of job) only one of these classes will be loaded. In mixed\n+ * job setups, we still have a bimorphic method (rather than a poly/-/mega-morphic method).\n+ *\n+ * @param <T> The type of emitted records.\n+ */\n+public class SourceOutputWithWatermarks<T> implements SourceOutput<T> {\n+\n+\tprivate final PushingAsyncDataInput.DataOutput<T> recordsOutput;\n+\n+\tprivate final TimestampAssigner<T> timestampAssigner;\n+\n+\tprivate final WatermarkGenerator<T> watermarkGenerator;\n+\n+\tprivate final WatermarkOutput onEventWatermarkOutput;\n+\n+\tprivate final WatermarkOutput periodicWatermarkOutput;\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.\n+\t */\n+\tprotected SourceOutputWithWatermarks(\n+\t\t\tPushingAsyncDataInput.DataOutput<T> recordsOutput,\n+\t\t\tWatermarkOutput onEventWatermarkOutput,\n+\t\t\tWatermarkOutput periodicWatermarkOutput,\n+\t\t\tTimestampAssigner<T> timestampAssigner,\n+\t\t\tWatermarkGenerator<T> watermarkGenerator) {\n+\n+\t\tthis.recordsOutput = checkNotNull(recordsOutput);\n+\t\tthis.onEventWatermarkOutput = checkNotNull(onEventWatermarkOutput);\n+\t\tthis.periodicWatermarkOutput = checkNotNull(periodicWatermarkOutput);\n+\t\tthis.timestampAssigner = checkNotNull(timestampAssigner);\n+\t\tthis.watermarkGenerator = checkNotNull(watermarkGenerator);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// SourceOutput Methods\n+\t//\n+\t// Note that the two methods below are final, as a partial enforcement\n+\t// of the performance design goal mentioned in the class-level comment.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void collect(T record) {\n+\t\tcollect(record, Long.MIN_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NTkwMQ==", "bodyText": "Yes, it is, see comments in https://github.com/apache/flink/blob/master/flink-core/src/main/java/org/apache/flink/api/common/eventtime/TimestampAssigner.java\nWill replace this with a symbol to not have this \"magic value\" there.", "url": "https://github.com/apache/flink/pull/12306#discussion_r430355901", "createdAt": "2020-05-26T11:55:17Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+import org.apache.flink.api.common.eventtime.WatermarkGenerator;\n+import org.apache.flink.api.common.eventtime.WatermarkOutput;\n+import org.apache.flink.api.connector.source.SourceOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.tasks.ExceptionInChainedOperatorException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Implementation of the SourceOutput. The records emitted to this output are pushed into a given\n+ * {@link PushingAsyncDataInput.DataOutput}. The watermarks are pushed into the same output, or\n+ * into a separate {@link WatermarkOutput}, if one is provided.\n+ *\n+ * <h2>Perdiodic Watermarks</h2>\n+ *\n+ * <p>This output does not implement periodic watermarks\n+ * <h2>Note on Performance Considerations</h2>\n+ *\n+ * <p>The methods {@link SourceOutput#collect(Object)} and {@link SourceOutput#collect(Object, long)}\n+ * are highly performance-critical (part of the hot loop). To make the code as JIT friendly as possible,\n+ * we want to have only a single implementation of these two methods, across all classes.\n+ * That way, the JIT compiler can de-virtualize (and inline) them better.\n+ *\n+ * <p>Currently, we have one implementation of these methods in the batch case (see class\n+ * {@link BatchTimestampsAndWatermarks}) and one for the streaming case (this class). When the JVM\n+ * is dedicated to a single job (or type of job) only one of these classes will be loaded. In mixed\n+ * job setups, we still have a bimorphic method (rather than a poly/-/mega-morphic method).\n+ *\n+ * @param <T> The type of emitted records.\n+ */\n+public class SourceOutputWithWatermarks<T> implements SourceOutput<T> {\n+\n+\tprivate final PushingAsyncDataInput.DataOutput<T> recordsOutput;\n+\n+\tprivate final TimestampAssigner<T> timestampAssigner;\n+\n+\tprivate final WatermarkGenerator<T> watermarkGenerator;\n+\n+\tprivate final WatermarkOutput onEventWatermarkOutput;\n+\n+\tprivate final WatermarkOutput periodicWatermarkOutput;\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.\n+\t */\n+\tprotected SourceOutputWithWatermarks(\n+\t\t\tPushingAsyncDataInput.DataOutput<T> recordsOutput,\n+\t\t\tWatermarkOutput onEventWatermarkOutput,\n+\t\t\tWatermarkOutput periodicWatermarkOutput,\n+\t\t\tTimestampAssigner<T> timestampAssigner,\n+\t\t\tWatermarkGenerator<T> watermarkGenerator) {\n+\n+\t\tthis.recordsOutput = checkNotNull(recordsOutput);\n+\t\tthis.onEventWatermarkOutput = checkNotNull(onEventWatermarkOutput);\n+\t\tthis.periodicWatermarkOutput = checkNotNull(periodicWatermarkOutput);\n+\t\tthis.timestampAssigner = checkNotNull(timestampAssigner);\n+\t\tthis.watermarkGenerator = checkNotNull(watermarkGenerator);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// SourceOutput Methods\n+\t//\n+\t// Note that the two methods below are final, as a partial enforcement\n+\t// of the performance design goal mentioned in the class-level comment.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void collect(T record) {\n+\t\tcollect(record, Long.MIN_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NjA0MA=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzk5ODI2OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDowMTowNFrOGaCHEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1NjowN1rOGaa3XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk1MDczNw==", "bodyText": "Why is is a possibly different WatermarkOutput?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429950737", "createdAt": "2020-05-25T14:01:04Z", "author": {"login": "becketqin"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+import org.apache.flink.api.common.eventtime.WatermarkGenerator;\n+import org.apache.flink.api.common.eventtime.WatermarkOutput;\n+import org.apache.flink.api.connector.source.SourceOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.tasks.ExceptionInChainedOperatorException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Implementation of the SourceOutput. The records emitted to this output are pushed into a given\n+ * {@link PushingAsyncDataInput.DataOutput}. The watermarks are pushed into the same output, or\n+ * into a separate {@link WatermarkOutput}, if one is provided.\n+ *\n+ * <h2>Perdiodic Watermarks</h2>\n+ *\n+ * <p>This output does not implement periodic watermarks\n+ * <h2>Note on Performance Considerations</h2>\n+ *\n+ * <p>The methods {@link SourceOutput#collect(Object)} and {@link SourceOutput#collect(Object, long)}\n+ * are highly performance-critical (part of the hot loop). To make the code as JIT friendly as possible,\n+ * we want to have only a single implementation of these two methods, across all classes.\n+ * That way, the JIT compiler can de-virtualize (and inline) them better.\n+ *\n+ * <p>Currently, we have one implementation of these methods in the batch case (see class\n+ * {@link BatchTimestampsAndWatermarks}) and one for the streaming case (this class). When the JVM\n+ * is dedicated to a single job (or type of job) only one of these classes will be loaded. In mixed\n+ * job setups, we still have a bimorphic method (rather than a poly/-/mega-morphic method).\n+ *\n+ * @param <T> The type of emitted records.\n+ */\n+public class SourceOutputWithWatermarks<T> implements SourceOutput<T> {\n+\n+\tprivate final PushingAsyncDataInput.DataOutput<T> recordsOutput;\n+\n+\tprivate final TimestampAssigner<T> timestampAssigner;\n+\n+\tprivate final WatermarkGenerator<T> watermarkGenerator;\n+\n+\tprivate final WatermarkOutput onEventWatermarkOutput;\n+\n+\tprivate final WatermarkOutput periodicWatermarkOutput;\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.\n+\t */\n+\tprotected SourceOutputWithWatermarks(\n+\t\t\tPushingAsyncDataInput.DataOutput<T> recordsOutput,\n+\t\t\tWatermarkOutput onEventWatermarkOutput,\n+\t\t\tWatermarkOutput periodicWatermarkOutput,\n+\t\t\tTimestampAssigner<T> timestampAssigner,\n+\t\t\tWatermarkGenerator<T> watermarkGenerator) {\n+\n+\t\tthis.recordsOutput = checkNotNull(recordsOutput);\n+\t\tthis.onEventWatermarkOutput = checkNotNull(onEventWatermarkOutput);\n+\t\tthis.periodicWatermarkOutput = checkNotNull(periodicWatermarkOutput);\n+\t\tthis.timestampAssigner = checkNotNull(timestampAssigner);\n+\t\tthis.watermarkGenerator = checkNotNull(watermarkGenerator);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// SourceOutput Methods\n+\t//\n+\t// Note that the two methods below are final, as a partial enforcement\n+\t// of the performance design goal mentioned in the class-level comment.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void collect(T record) {\n+\t\tcollect(record, Long.MIN_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic final void collect(T record, long timestamp) {\n+\t\ttry {\n+\t\t\tfinal long assignedTimestamp = timestampAssigner.extractTimestamp(record, timestamp);\n+\n+\t\t\t// IMPORTANT: The event must be emitted before the watermark generator is called.\n+\t\t\trecordsOutput.emitRecord(new StreamRecord<>(record, assignedTimestamp));\n+\t\t\twatermarkGenerator.onEvent(record, assignedTimestamp, onEventWatermarkOutput);\n+\t\t} catch (ExceptionInChainedOperatorException e) {\n+\t\t\tthrow e;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new ExceptionInChainedOperatorException(e);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// WatermarkOutput Methods\n+\t//\n+\t// These two methods are final as well, to enforce the contract that the\n+\t// watermarks from emitWatermark(Watermark) go to the same output as the\n+\t// watermarks from the watermarkGenerator.onEvent(...) calls in the collect(...)\n+\t// methods.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void emitWatermark(Watermark watermark) {\n+\t\tonEventWatermarkOutput.emitWatermark(watermark);\n+\t}\n+\n+\t@Override\n+\tpublic final void markIdle() {\n+\t\tonEventWatermarkOutput.markIdle();\n+\t}\n+\n+\tpublic final void emitPeriodicWatermark() {\n+\t\twatermarkGenerator.onPeriodicEmit(periodicWatermarkOutput);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Factories\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NjMxNg==", "bodyText": "For the per-partition watermarking. The records flow directly downstream, but watermarks go to the WatermarkOutputMultiplexer which merges them.", "url": "https://github.com/apache/flink/pull/12306#discussion_r430356316", "createdAt": "2020-05-26T11:56:07Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/SourceOutputWithWatermarks.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+import org.apache.flink.api.common.eventtime.WatermarkGenerator;\n+import org.apache.flink.api.common.eventtime.WatermarkOutput;\n+import org.apache.flink.api.connector.source.SourceOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.tasks.ExceptionInChainedOperatorException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Implementation of the SourceOutput. The records emitted to this output are pushed into a given\n+ * {@link PushingAsyncDataInput.DataOutput}. The watermarks are pushed into the same output, or\n+ * into a separate {@link WatermarkOutput}, if one is provided.\n+ *\n+ * <h2>Perdiodic Watermarks</h2>\n+ *\n+ * <p>This output does not implement periodic watermarks\n+ * <h2>Note on Performance Considerations</h2>\n+ *\n+ * <p>The methods {@link SourceOutput#collect(Object)} and {@link SourceOutput#collect(Object, long)}\n+ * are highly performance-critical (part of the hot loop). To make the code as JIT friendly as possible,\n+ * we want to have only a single implementation of these two methods, across all classes.\n+ * That way, the JIT compiler can de-virtualize (and inline) them better.\n+ *\n+ * <p>Currently, we have one implementation of these methods in the batch case (see class\n+ * {@link BatchTimestampsAndWatermarks}) and one for the streaming case (this class). When the JVM\n+ * is dedicated to a single job (or type of job) only one of these classes will be loaded. In mixed\n+ * job setups, we still have a bimorphic method (rather than a poly/-/mega-morphic method).\n+ *\n+ * @param <T> The type of emitted records.\n+ */\n+public class SourceOutputWithWatermarks<T> implements SourceOutput<T> {\n+\n+\tprivate final PushingAsyncDataInput.DataOutput<T> recordsOutput;\n+\n+\tprivate final TimestampAssigner<T> timestampAssigner;\n+\n+\tprivate final WatermarkGenerator<T> watermarkGenerator;\n+\n+\tprivate final WatermarkOutput onEventWatermarkOutput;\n+\n+\tprivate final WatermarkOutput periodicWatermarkOutput;\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.\n+\t */\n+\tprotected SourceOutputWithWatermarks(\n+\t\t\tPushingAsyncDataInput.DataOutput<T> recordsOutput,\n+\t\t\tWatermarkOutput onEventWatermarkOutput,\n+\t\t\tWatermarkOutput periodicWatermarkOutput,\n+\t\t\tTimestampAssigner<T> timestampAssigner,\n+\t\t\tWatermarkGenerator<T> watermarkGenerator) {\n+\n+\t\tthis.recordsOutput = checkNotNull(recordsOutput);\n+\t\tthis.onEventWatermarkOutput = checkNotNull(onEventWatermarkOutput);\n+\t\tthis.periodicWatermarkOutput = checkNotNull(periodicWatermarkOutput);\n+\t\tthis.timestampAssigner = checkNotNull(timestampAssigner);\n+\t\tthis.watermarkGenerator = checkNotNull(watermarkGenerator);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// SourceOutput Methods\n+\t//\n+\t// Note that the two methods below are final, as a partial enforcement\n+\t// of the performance design goal mentioned in the class-level comment.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void collect(T record) {\n+\t\tcollect(record, Long.MIN_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic final void collect(T record, long timestamp) {\n+\t\ttry {\n+\t\t\tfinal long assignedTimestamp = timestampAssigner.extractTimestamp(record, timestamp);\n+\n+\t\t\t// IMPORTANT: The event must be emitted before the watermark generator is called.\n+\t\t\trecordsOutput.emitRecord(new StreamRecord<>(record, assignedTimestamp));\n+\t\t\twatermarkGenerator.onEvent(record, assignedTimestamp, onEventWatermarkOutput);\n+\t\t} catch (ExceptionInChainedOperatorException e) {\n+\t\t\tthrow e;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new ExceptionInChainedOperatorException(e);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// WatermarkOutput Methods\n+\t//\n+\t// These two methods are final as well, to enforce the contract that the\n+\t// watermarks from emitWatermark(Watermark) go to the same output as the\n+\t// watermarks from the watermarkGenerator.onEvent(...) calls in the collect(...)\n+\t// methods.\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic final void emitWatermark(Watermark watermark) {\n+\t\tonEventWatermarkOutput.emitWatermark(watermark);\n+\t}\n+\n+\t@Override\n+\tpublic final void markIdle() {\n+\t\tonEventWatermarkOutput.markIdle();\n+\t}\n+\n+\tpublic final void emitPeriodicWatermark() {\n+\t\twatermarkGenerator.onPeriodicEmit(periodicWatermarkOutput);\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Factories\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Creates a new SourceOutputWithWatermarks that emits records to the given DataOutput\n+\t * and watermarks to the (possibly different) WatermarkOutput.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk1MDczNw=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODExMjgwOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/TimestampsAndWatermarks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDozODo1N1rOGaDOTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTo1Njo0MlrOGaa4iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2ODk3NQ==", "bodyText": "Is this an \"Internal\" class? I am wondering when should the annotations be put?", "url": "https://github.com/apache/flink/pull/12306#discussion_r429968975", "createdAt": "2020-05-25T14:38:57Z", "author": {"login": "becketqin"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/TimestampsAndWatermarks.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.connector.source.ReaderOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+\n+/**\n+ * Basic interface for the timestamp extraction and watermark generation logic for the\n+ * {@link org.apache.flink.api.connector.source.SourceReader}.\n+ *\n+ * <p>Implementations of this class may or may not actually perform certain tasks, like watermark\n+ * generation. For example, the batch-oriented implementation typically skips all watermark generation\n+ * logic.\n+ *\n+ * @param <T> The type of the emitted records.\n+ */\n+public interface TimestampsAndWatermarks<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NjYxOQ==", "bodyText": "Good point, I will annotate all classes in that package with @Internal.", "url": "https://github.com/apache/flink/pull/12306#discussion_r430356619", "createdAt": "2020-05-26T11:56:42Z", "author": {"login": "StephanEwen"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/TimestampsAndWatermarks.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.source;\n+\n+import org.apache.flink.api.connector.source.ReaderOutput;\n+import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput;\n+\n+/**\n+ * Basic interface for the timestamp extraction and watermark generation logic for the\n+ * {@link org.apache.flink.api.connector.source.SourceReader}.\n+ *\n+ * <p>Implementations of this class may or may not actually perform certain tasks, like watermark\n+ * generation. For example, the batch-oriented implementation typically skips all watermark generation\n+ * logic.\n+ *\n+ * @param <T> The type of the emitted records.\n+ */\n+public interface TimestampsAndWatermarks<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2ODk3NQ=="}, "originalCommit": {"oid": "1cf9d57642f568baf3a92d22ed7d320cd5b146b6"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4560, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}