{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTczNjgz", "number": 11674, "title": "[FLINK-16887][table-planner-blink] Refactor retraction rules to support inferring ChangelogMode", "bodyText": "What is the purpose of the change\nCurrent retraction machanism to support more message kinds (insert/delete/update_before/update_after). And make the new machanism more extensible for future features and more readable.\nBrief change log\nDesign doc: Design documentation: https://docs.google.com/document/d/1n_iXIQsKT3uiBqENR8j8RdjRhZfzMhhB66QZvx2rFjE/edit?ts=5e8419c1#\n\n1st commit: introduce FlinkChangelogModeInferenceProgram with 2 traits and 2 satisfy visitor to infer changelog mode for every nodes.\n2nd commit: Remove interfaces and traits and rules of legacy retraction mechanism entirely\n3rd commit: Use new changelog trait description in plan tests and update all plan xml files\n4th commit: Fix remaining tests because of the validation change and plan change\n\nVerifying this change\nThis pull request is verified with existing tests.\nBut some tests are modified to have the new changelog trait description instead of the legacy AccMode trait.\nThe plan change in DagOptimizationTest is reasonable, because we can reuse more nodes after refactoring.\nDoes this pull request potentially affect one of the following parts:\n\nDependencies (does it add or upgrade a dependency): no\nThe public API, i.e., is any changed class annotated with @Public(Evolving): no\nThe serializers: no\nThe runtime per-record code paths (performance sensitive): no\nAnything that affects deployment or recovery: JobManager (and its components), Checkpointing, Kubernetes/Yarn/Mesos, ZooKeeper: no\nThe S3 file system connector: no\n\nDocumentation\n\nDoes this pull request introduce a new feature? no\nIf yes, how is the feature documented? not applicable", "createdAt": "2020-04-08T17:11:31Z", "url": "https://github.com/apache/flink/pull/11674", "merged": true, "mergeCommit": {"oid": "dcdbc792d2b67740fb879e6497abdb3f043dfb21"}, "closed": true, "closedAt": "2020-04-15T13:32:53Z", "author": {"login": "wuchong"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcW63lCgFqTM5MTgxNDI4OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX3_7qgFqTM5Mzc2NTcyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODE0Mjg5", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-391814289", "createdAt": "2020-04-12T01:56:52Z", "commit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "state": "COMMENTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwMTo1Njo1MlrOGERczA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzo1OTowOFrOGEVpvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzMzM4OA==", "bodyText": "It's better the pk info can also be printed for upsert sink.\njust for this case, the pk of upsert sink is empty(is illegal?), UA is needed ?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407133388", "createdAt": "2020-04-12T01:56:52Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/DagOptimizationTest.xml", "diffHunk": "@@ -959,15 +951,15 @@ LogicalSink(name=[`default_catalog`.`default_database`.`upsertSink`], fields=[b,\n     </Resource>\n     <Resource name=\"planAfter\">\n       <![CDATA[\n-Sink(name=[`default_catalog`.`default_database`.`upsertSink`], fields=[b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])\n-+- Union(all=[true], union=[b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])\n-   :- GroupAggregate(groupBy=[b, c], select=[b, c, SUM(a) AS a_sum], updateAsRetraction=[false], accMode=[Acc])\n-   :  +- Exchange(distribution=[hash[b, c]], updateAsRetraction=[true], accMode=[Acc])\n-   :     +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c], updateAsRetraction=[true], accMode=[Acc], reuse_id=[1])\n-   +- Calc(select=[CAST(1:BIGINT) AS b, c, a_sum], updateAsRetraction=[false], accMode=[Acc])\n-      +- GroupAggregate(groupBy=[c], select=[c, SUM(a) AS a_sum], updateAsRetraction=[false], accMode=[Acc])\n-         +- Exchange(distribution=[hash[c]], updateAsRetraction=[true], accMode=[Acc])\n-            +- Calc(select=[c, a], updateAsRetraction=[true], accMode=[Acc])\n+Sink(name=[`default_catalog`.`default_database`.`upsertSink`], fields=[b, c, a_sum], changelogMode=[NONE])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 792}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNDA0NA==", "bodyText": "remove assert, the parameter should be StreamPhysicalRel directly", "url": "https://github.com/apache/flink/pull/11674#discussion_r407134044", "createdAt": "2020-04-12T02:05:46Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/ChangelogPlanUtils.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.utils\n+\n+import org.apache.flink.table.connector.ChangelogMode\n+import org.apache.flink.table.planner.plan.`trait`.{ModifyKind, ModifyKindSetTraitDef, UpdateKind, UpdateKindTraitDef}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamPhysicalRel\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram\n+import org.apache.flink.types.RowKind\n+import org.apache.calcite.rel.RelNode\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+/**\n+ * Utilities for changelog plan.\n+ */\n+object ChangelogPlanUtils {\n+\n+  /**\n+   * Returns true if the plan produces insert-only changes.\n+   *\n+   *  <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def isInsertOnly(plan: RelNode): Boolean = {\n+    assert(plan.isInstanceOf[StreamPhysicalRel])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNDEwMQ==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/11674#discussion_r407134101", "createdAt": "2020-04-12T02:06:42Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/ChangelogPlanUtils.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.utils\n+\n+import org.apache.flink.table.connector.ChangelogMode\n+import org.apache.flink.table.planner.plan.`trait`.{ModifyKind, ModifyKindSetTraitDef, UpdateKind, UpdateKindTraitDef}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamPhysicalRel\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram\n+import org.apache.flink.types.RowKind\n+import org.apache.calcite.rel.RelNode\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+/**\n+ * Utilities for changelog plan.\n+ */\n+object ChangelogPlanUtils {\n+\n+  /**\n+   * Returns true if the plan produces insert-only changes.\n+   *\n+   *  <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def isInsertOnly(plan: RelNode): Boolean = {\n+    assert(plan.isInstanceOf[StreamPhysicalRel])\n+    val modifyKindSetTrait = plan.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+    modifyKindSetTrait.modifyKindSet.isInsertOnly\n+  }\n+\n+  /**\n+   * Returns true if the [[RelNode]] will generate UPDATE_BEFORE messages.\n+   * This method is used to determine whether the runtime operator should\n+   * produce UPDATE_BEFORE messages with UPDATE_AFTER message together.\n+   *\n+   * <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def generateUpdateBefore(node: RelNode): Boolean = {\n+    assert(node.isInstanceOf[StreamPhysicalRel])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNDExMw==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/11674#discussion_r407134113", "createdAt": "2020-04-12T02:06:48Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/ChangelogPlanUtils.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.utils\n+\n+import org.apache.flink.table.connector.ChangelogMode\n+import org.apache.flink.table.planner.plan.`trait`.{ModifyKind, ModifyKindSetTraitDef, UpdateKind, UpdateKindTraitDef}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamPhysicalRel\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram\n+import org.apache.flink.types.RowKind\n+import org.apache.calcite.rel.RelNode\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+/**\n+ * Utilities for changelog plan.\n+ */\n+object ChangelogPlanUtils {\n+\n+  /**\n+   * Returns true if the plan produces insert-only changes.\n+   *\n+   *  <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def isInsertOnly(plan: RelNode): Boolean = {\n+    assert(plan.isInstanceOf[StreamPhysicalRel])\n+    val modifyKindSetTrait = plan.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+    modifyKindSetTrait.modifyKindSet.isInsertOnly\n+  }\n+\n+  /**\n+   * Returns true if the [[RelNode]] will generate UPDATE_BEFORE messages.\n+   * This method is used to determine whether the runtime operator should\n+   * produce UPDATE_BEFORE messages with UPDATE_AFTER message together.\n+   *\n+   * <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def generateUpdateBefore(node: RelNode): Boolean = {\n+    assert(node.isInstanceOf[StreamPhysicalRel])\n+    val updateKindTrait = node.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+    updateKindTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+  }\n+\n+  /**\n+   * Gets an optional [[ChangelogMode]] of the given physical node.\n+   * The [[ChangelogMode]] is inferred from ModifyKindSetTrait and UpdateKindTrait.\n+   * The returned value is None if the given node is Sink node.\n+   *\n+   * <p>Note: this method must be called after [[FlinkChangelogModeInferenceProgram]] is applied.\n+   */\n+  def getChangelogMode(node: RelNode): Option[ChangelogMode] = {\n+    assert(node.isInstanceOf[StreamPhysicalRel])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNTUyNg==", "bodyText": "we should throw exception here which means ModifyKindSetTraitDef does not support volcano planner now", "url": "https://github.com/apache/flink/pull/11674#discussion_r407135526", "createdAt": "2020-04-12T02:25:46Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/ModifyKindSetTraitDef.scala", "diffHunk": "@@ -21,61 +21,30 @@ package org.apache.flink.table.planner.plan.`trait`\n import org.apache.calcite.plan.{RelOptPlanner, RelTraitDef}\n import org.apache.calcite.rel.RelNode\n \n-/**\n-  * Definition of the [[UpdateAsRetractionTrait]].\n-  */\n-class UpdateAsRetractionTraitDef extends RelTraitDef[UpdateAsRetractionTrait] {\n-  override def convert(\n-      planner: RelOptPlanner,\n-      rel: RelNode,\n-      toTrait: UpdateAsRetractionTrait,\n-      allowInfiniteCostConverters: Boolean): RelNode = {\n+class ModifyKindSetTraitDef extends RelTraitDef[ModifyKindSetTrait] {\n \n-    rel.copy(rel.getTraitSet.plus(toTrait), rel.getInputs)\n-  }\n-\n-  override def canConvert(\n-      planner: RelOptPlanner,\n-      fromTrait: UpdateAsRetractionTrait,\n-      toTrait: UpdateAsRetractionTrait): Boolean = true\n-\n-  override def getTraitClass: Class[UpdateAsRetractionTrait] = classOf[UpdateAsRetractionTrait]\n+  override def getTraitClass: Class[ModifyKindSetTrait] = classOf[ModifyKindSetTrait]\n \n   override def getSimpleName: String = this.getClass.getSimpleName\n \n-  override def getDefault: UpdateAsRetractionTrait = UpdateAsRetractionTrait.DEFAULT\n-}\n-\n-object UpdateAsRetractionTraitDef {\n-  val INSTANCE = new UpdateAsRetractionTraitDef\n-}\n-\n-/**\n-  * Definition of the [[AccModeTrait]].\n-  */\n-class AccModeTraitDef extends RelTraitDef[AccModeTrait] {\n-\n   override def convert(\n       planner: RelOptPlanner,\n       rel: RelNode,\n-      toTrait: AccModeTrait,\n+      toTrait: ModifyKindSetTrait,\n       allowInfiniteCostConverters: Boolean): RelNode = {\n-\n     rel.copy(rel.getTraitSet.plus(toTrait), rel.getInputs)\n   }\n \n   override def canConvert(\n       planner: RelOptPlanner,\n-      fromTrait: AccModeTrait,\n-      toTrait: AccModeTrait): Boolean = true\n+      fromTrait: ModifyKindSetTrait,\n+      toTrait: ModifyKindSetTrait): Boolean = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNTU2Mg==", "bodyText": "we should throw exception here which means UpdateKindTraitDef  does not support volcano planner now", "url": "https://github.com/apache/flink/pull/11674#discussion_r407135562", "createdAt": "2020-04-12T02:26:25Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/UpdateKindTraitDef.scala", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTraitDef}\n+import org.apache.calcite.rel.RelNode\n+\n+class UpdateKindTraitDef extends RelTraitDef[UpdateKindTrait] {\n+\n+  override def getTraitClass: Class[UpdateKindTrait] = classOf[UpdateKindTrait]\n+\n+  override def getSimpleName: String = this.getClass.getSimpleName\n+\n+  override def convert(\n+      planner: RelOptPlanner,\n+      rel: RelNode,\n+      toTrait: UpdateKindTrait,\n+      allowInfiniteCostConverters: Boolean): RelNode = {\n+    rel.copy(rel.getTraitSet.plus(toTrait), rel.getInputs)\n+  }\n+\n+  override def canConvert(\n+      planner: RelOptPlanner,\n+      fromTrait: UpdateKindTrait,\n+      toTrait: UpdateKindTrait): Boolean = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzNzEwMw==", "bodyText": "Now a complete change mode is represented by two Traits, NO_UPDATE is just a placeholder which also means ModifyKindSetTrait does not contain UPDATE.\nAnother idea is that we can treat ONLY_UPDATE_AFTER and BEFORE_AND_AFTER as a sub-attribute of ModifyKind.UPDATE (BEFORE_AND_AFTER is default), then we can use only one trait to represent changelog mode. The optimization we want to apply is whether BEFORE_AND_AFTER can be changed to ONLY_UPDATE_AFTER.\nIt's better we can also give some comments here.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407137103", "createdAt": "2020-04-12T02:46:16Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/UpdateKindTrait.scala", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTrait, RelTraitDef}\n+\n+/**\n+ * UpdateKindTrait is used to describe the kind of update operation.\n+ */\n+class UpdateKindTrait(val updateKind: UpdateKind) extends RelTrait {\n+\n+  override def satisfies(relTrait: RelTrait): Boolean = relTrait match {\n+    case other: UpdateKindTrait =>\n+      // should totally match\n+      other.updateKind == this.updateKind\n+    case _ => false\n+  }\n+\n+  override def getTraitDef: RelTraitDef[_ <: RelTrait] = UpdateKindTraitDef.INSTANCE\n+\n+  override def register(planner: RelOptPlanner): Unit = {}\n+\n+  override def hashCode(): Int = updateKind.hashCode()\n+\n+  override def equals(obj: Any): Boolean = obj match {\n+    case t: UpdateKindTrait => this.updateKind.equals(t.updateKind)\n+    case _ => false\n+  }\n+\n+  override def toString: String = s\"[${updateKind.toString}]\"\n+}\n+\n+object UpdateKindTrait {\n+  val NO_UPDATE = new UpdateKindTrait(UpdateKind.NO_UPDATE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzODIyMg==", "bodyText": "Retraction Traits -> Changelog Traits", "url": "https://github.com/apache/flink/pull/11674#discussion_r407138222", "createdAt": "2020-04-12T03:02:22Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/ExecNodePlanDumper.scala", "diffHunk": "@@ -48,7 +47,7 @@ object ExecNodePlanDumper {\n     * @param node               the ExecNode to convert\n     * @param detailLevel        detailLevel defines detail levels for EXPLAIN PLAN.\n     * @param withExecNodeId     whether including ID of ExecNode\n-    * @param withRetractTraits  whether including Retraction Traits of RelNode corresponding to\n+    * @param withChangelogTraits  whether including Retraction Traits of RelNode corresponding to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEzODI4OA==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/11674#discussion_r407138288", "createdAt": "2020-04-12T03:03:08Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/ExecNodePlanDumper.scala", "diffHunk": "@@ -75,7 +74,7 @@ object ExecNodePlanDumper {\n     * @param nodes              the ExecNodes to convert\n     * @param detailLevel        detailLevel defines detail levels for EXPLAIN PLAN.\n     * @param withExecNodeId     whether including ID of ExecNode\n-    * @param withRetractTraits  whether including Retraction Traits of RelNode corresponding to\n+    * @param withChangelogTraits  whether including Retraction Traits of RelNode corresponding to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTU1MA==", "bodyText": "rename this method to createNewNode", "url": "https://github.com/apache/flink/pull/11674#discussion_r407145550", "createdAt": "2020-04-12T04:48:11Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjE0MA==", "bodyText": "nit:  \"Rank\" -> \"Rank and SortLimit\"", "url": "https://github.com/apache/flink/pull/11674#discussion_r407146140", "createdAt": "2020-04-12T04:54:40Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzE5OQ==", "bodyText": "extract onlyAfterOrNoUpdate(childModifyKindSet) as a variable", "url": "https://github.com/apache/flink/pull/11674#discussion_r407147199", "createdAt": "2020-04-12T05:09:40Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MjQ4NQ==", "bodyText": "case sortLimit", "url": "https://github.com/apache/flink/pull/11674#discussion_r407152485", "createdAt": "2020-04-12T06:16:30Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1Mjc0Mg==", "bodyText": "move val newRankNodes = rankStrategies.map(rank.copy) into visitRankStrategies  method. which means we apply all RankStrategys to current node", "url": "https://github.com/apache/flink/pull/11674#discussion_r407152742", "createdAt": "2020-04-12T06:19:26Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MzI1MA==", "bodyText": "current implementation needs to visit all RankStrategies, actually we only need the first satisfied one. so we can use for to iterator all RankStrategies and return when meet first satisfied one.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407153250", "createdAt": "2020-04-12T06:25:04Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, ImmutableBitSet.of(), rank.getCollation)\n+        // creates new SortLimit nodes for every applied RankStrategy\n+        val newSortLimitNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newSortLimitNodes, requiredTrait)\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        replaceChildrenAndTrait(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = List(0, 1).map { childOrdinal =>\n+          val child = join.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+          val needUpdateBefore = !join.inputUniqueKeyContainsJoinKey(childOrdinal)\n+          val inputModifyKindSet = getModifyKindSet(child)\n+          val childRequiredTrait = if (needUpdateBefore || requiredUpdateBeforeByParent) {\n+            beforeAfterOrNoUpdate(inputModifyKindSet)\n+          } else {\n+            onlyAfterOrNoUpdate(inputModifyKindSet)\n+          }\n+          this.visit(child, childRequiredTrait)\n+        }\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          replaceChildrenAndTrait(join, Some(children.flatten), requiredTrait)\n+        }\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // forward required mode to left input\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+        val newLeftOption = this.visit(left, requiredTrait)\n+        // currently temporal join only support insert-only source as the right side\n+        val newRightOption = this.visit(right, UpdateKindTrait.NO_UPDATE)\n+        (newLeftOption, newRightOption) match {\n+          case (Some(newLeft), Some(newRight)) =>\n+            val leftTrait = newLeft.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(temporalJoin, Some(List(newLeft, newRight)), leftTrait)\n+          case _ =>\n+            None\n+        }\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        visitChildren(rel, requiredTrait) match {\n+          case None => None\n+          case Some(children) =>\n+            val childTrait = children.head.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(rel, Some(children), childTrait)\n+        }\n+\n+      case union: StreamExecUnion =>\n+        val children = union.getInputs.map { case child: StreamPhysicalRel =>\n+          val childModifyKindSet = getModifyKindSet(child)\n+          val requiredChildTrait = if (childModifyKindSet.isInsertOnly) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            requiredTrait\n+          }\n+          this.visit(child, requiredChildTrait)\n+        }.toList\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          val updateKinds = children.flatten\n+            .map(_.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE))\n+          // union can just forward changes, can't actively satisfy to another changelog mode\n+          val providedTrait = if (updateKinds.forall(k => UpdateKindTrait.NO_UPDATE == k)) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            updateKinds.head\n+          }\n+          replaceChildrenAndTrait(union, Some(children.flatten), providedTrait)\n+\n+        }\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        replaceChildrenAndTrait(rel, Some(List()), UpdateKindTrait.NO_UPDATE)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = if (scan.intermediateTable.isUpdateBeforeRequired) {\n+          // we can't drop UPDATE_BEFORE if it is required by other parent blocks\n+          UpdateKindTrait.BEFORE_AND_AFTER\n+        } else {\n+          requiredTrait\n+        }\n+        if (!providedTrait.satisfies(requiredTrait)) {\n+          // require ONLY_AFTER but can only provide BEFORE_AND_AFTER\n+          None\n+        } else {\n+          replaceChildrenAndTrait(rel, Some(List()), providedTrait)\n+        }\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: UpdateKindTrait): Option[List[StreamPhysicalRel]] = {\n+      val newChildren = for (child <- parent.getInputs) yield {\n+        this.visit(child.asInstanceOf[StreamPhysicalRel], requiredChildrenTrait) match {\n+          case None =>\n+            // return None if one of the children can't satisfy\n+            return None\n+          case Some(newChild) =>\n+            val providedTrait = newChild.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            val childDescription = newChild.getRelDetailedDescription\n+            if (!providedTrait.satisfies(requiredChildrenTrait)) {\n+              throw new TableException(s\"Provided trait $providedTrait can't satisfy \" +\n+                s\"required trait $requiredChildrenTrait. \" +\n+                s\"This is a bug in planner, please file an issue. \\n\" +\n+                s\"Current node is $childDescription\")\n+            }\n+            newChild\n+        }\n+      }\n+      Some(newChildren.toList)\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        childrenOption: Option[List[StreamPhysicalRel]],\n+        providedTrait: UpdateKindTrait): Option[StreamPhysicalRel] = childrenOption match {\n+      case None =>\n+        None\n+      case Some(children) =>\n+        val modifyKindSetTrait = node.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        val nodeDescription = node.getRelDetailedDescription\n+        if (!modifyKindSetTrait.satisfies(providedTrait)) {\n+          throw new TableException(s\"ModifyKindSetTrait $modifyKindSetTrait can't satisfy \" +\n+            s\"UpdateKindTrait $providedTrait. \" +\n+            s\"This is a bug in planner, please file an issue. \\n\" +\n+            s\"Current node is $nodeDescription.\")\n+        }\n+        val newTraitSet = node.getTraitSet.plus(providedTrait)\n+        Some(node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel])\n+    }\n+\n+    private def visitRankStrategies(\n+        rankStrategies: Seq[RankProcessStrategy],\n+        rankNodes: Seq[StreamPhysicalRel],\n+        requiredUpdateKindTrait: UpdateKindTrait): Option[StreamPhysicalRel] = {\n+      // go pass every RankProcessStrategy and Rank node, return the first satisfied converted node\n+      rankStrategies.zip(rankNodes).flatMap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 574}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MzYwMw==", "bodyText": "join.getInputs.zipWithIndex", "url": "https://github.com/apache/flink/pull/11674#discussion_r407153603", "createdAt": "2020-04-12T06:29:15Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, ImmutableBitSet.of(), rank.getCollation)\n+        // creates new SortLimit nodes for every applied RankStrategy\n+        val newSortLimitNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newSortLimitNodes, requiredTrait)\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        replaceChildrenAndTrait(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = List(0, 1).map { childOrdinal =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1NDA4MA==", "bodyText": "nit: single line for case child: StreamPhysicalRel =>", "url": "https://github.com/apache/flink/pull/11674#discussion_r407154080", "createdAt": "2020-04-12T06:34:26Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, ImmutableBitSet.of(), rank.getCollation)\n+        // creates new SortLimit nodes for every applied RankStrategy\n+        val newSortLimitNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newSortLimitNodes, requiredTrait)\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        replaceChildrenAndTrait(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = List(0, 1).map { childOrdinal =>\n+          val child = join.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+          val needUpdateBefore = !join.inputUniqueKeyContainsJoinKey(childOrdinal)\n+          val inputModifyKindSet = getModifyKindSet(child)\n+          val childRequiredTrait = if (needUpdateBefore || requiredUpdateBeforeByParent) {\n+            beforeAfterOrNoUpdate(inputModifyKindSet)\n+          } else {\n+            onlyAfterOrNoUpdate(inputModifyKindSet)\n+          }\n+          this.visit(child, childRequiredTrait)\n+        }\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          replaceChildrenAndTrait(join, Some(children.flatten), requiredTrait)\n+        }\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // forward required mode to left input\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+        val newLeftOption = this.visit(left, requiredTrait)\n+        // currently temporal join only support insert-only source as the right side\n+        val newRightOption = this.visit(right, UpdateKindTrait.NO_UPDATE)\n+        (newLeftOption, newRightOption) match {\n+          case (Some(newLeft), Some(newRight)) =>\n+            val leftTrait = newLeft.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(temporalJoin, Some(List(newLeft, newRight)), leftTrait)\n+          case _ =>\n+            None\n+        }\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        visitChildren(rel, requiredTrait) match {\n+          case None => None\n+          case Some(children) =>\n+            val childTrait = children.head.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(rel, Some(children), childTrait)\n+        }\n+\n+      case union: StreamExecUnion =>\n+        val children = union.getInputs.map { case child: StreamPhysicalRel =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 480}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1NDI2NA==", "bodyText": "union all updateKinds  ?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407154264", "createdAt": "2020-04-12T06:36:36Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, ImmutableBitSet.of(), rank.getCollation)\n+        // creates new SortLimit nodes for every applied RankStrategy\n+        val newSortLimitNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newSortLimitNodes, requiredTrait)\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        replaceChildrenAndTrait(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = List(0, 1).map { childOrdinal =>\n+          val child = join.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+          val needUpdateBefore = !join.inputUniqueKeyContainsJoinKey(childOrdinal)\n+          val inputModifyKindSet = getModifyKindSet(child)\n+          val childRequiredTrait = if (needUpdateBefore || requiredUpdateBeforeByParent) {\n+            beforeAfterOrNoUpdate(inputModifyKindSet)\n+          } else {\n+            onlyAfterOrNoUpdate(inputModifyKindSet)\n+          }\n+          this.visit(child, childRequiredTrait)\n+        }\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          replaceChildrenAndTrait(join, Some(children.flatten), requiredTrait)\n+        }\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // forward required mode to left input\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+        val newLeftOption = this.visit(left, requiredTrait)\n+        // currently temporal join only support insert-only source as the right side\n+        val newRightOption = this.visit(right, UpdateKindTrait.NO_UPDATE)\n+        (newLeftOption, newRightOption) match {\n+          case (Some(newLeft), Some(newRight)) =>\n+            val leftTrait = newLeft.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(temporalJoin, Some(List(newLeft, newRight)), leftTrait)\n+          case _ =>\n+            None\n+        }\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        visitChildren(rel, requiredTrait) match {\n+          case None => None\n+          case Some(children) =>\n+            val childTrait = children.head.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(rel, Some(children), childTrait)\n+        }\n+\n+      case union: StreamExecUnion =>\n+        val children = union.getInputs.map { case child: StreamPhysicalRel =>\n+          val childModifyKindSet = getModifyKindSet(child)\n+          val requiredChildTrait = if (childModifyKindSet.isInsertOnly) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            requiredTrait\n+          }\n+          this.visit(child, requiredChildTrait)\n+        }.toList\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          val updateKinds = children.flatten\n+            .map(_.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE))\n+          // union can just forward changes, can't actively satisfy to another changelog mode\n+          val providedTrait = if (updateKinds.forall(k => UpdateKindTrait.NO_UPDATE == k)) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            updateKinds.head", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1NDU1Mw==", "bodyText": "rename to createNewNode", "url": "https://github.com/apache/flink/pull/11674#discussion_r407154553", "createdAt": "2020-04-12T06:39:18Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfterOrNoUpdate(childModifyKindSet), beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NO_UPDATE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAfterOrNoUpdate(childModifyKindSet))\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(\n+                  onlyAfterOrNoUpdate(childModifyKindSet),\n+                  beforeAfterOrNoUpdate(childModifyKindSet))\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NO_UPDATE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NO_UPDATE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require no updates in input\n+        val children = visitChildren(rel, UpdateKindTrait.NO_UPDATE)\n+        replaceChildrenAndTrait(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, rank.partitionKey, rank.orderKey)\n+        // creates new Rank nodes for every applied RankStrategy\n+        val newRankNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newRankNodes, requiredTrait)\n+\n+      case rank: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank.getInput, ImmutableBitSet.of(), rank.getCollation)\n+        // creates new SortLimit nodes for every applied RankStrategy\n+        val newSortLimitNodes = rankStrategies.map(rank.copy)\n+        visitRankStrategies(rankStrategies, newSortLimitNodes, requiredTrait)\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNoUpdate(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        replaceChildrenAndTrait(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = List(0, 1).map { childOrdinal =>\n+          val child = join.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+          val needUpdateBefore = !join.inputUniqueKeyContainsJoinKey(childOrdinal)\n+          val inputModifyKindSet = getModifyKindSet(child)\n+          val childRequiredTrait = if (needUpdateBefore || requiredUpdateBeforeByParent) {\n+            beforeAfterOrNoUpdate(inputModifyKindSet)\n+          } else {\n+            onlyAfterOrNoUpdate(inputModifyKindSet)\n+          }\n+          this.visit(child, childRequiredTrait)\n+        }\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          replaceChildrenAndTrait(join, Some(children.flatten), requiredTrait)\n+        }\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // forward required mode to left input\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+        val newLeftOption = this.visit(left, requiredTrait)\n+        // currently temporal join only support insert-only source as the right side\n+        val newRightOption = this.visit(right, UpdateKindTrait.NO_UPDATE)\n+        (newLeftOption, newRightOption) match {\n+          case (Some(newLeft), Some(newRight)) =>\n+            val leftTrait = newLeft.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(temporalJoin, Some(List(newLeft, newRight)), leftTrait)\n+          case _ =>\n+            None\n+        }\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        visitChildren(rel, requiredTrait) match {\n+          case None => None\n+          case Some(children) =>\n+            val childTrait = children.head.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            replaceChildrenAndTrait(rel, Some(children), childTrait)\n+        }\n+\n+      case union: StreamExecUnion =>\n+        val children = union.getInputs.map { case child: StreamPhysicalRel =>\n+          val childModifyKindSet = getModifyKindSet(child)\n+          val requiredChildTrait = if (childModifyKindSet.isInsertOnly) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            requiredTrait\n+          }\n+          this.visit(child, requiredChildTrait)\n+        }.toList\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          val updateKinds = children.flatten\n+            .map(_.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE))\n+          // union can just forward changes, can't actively satisfy to another changelog mode\n+          val providedTrait = if (updateKinds.forall(k => UpdateKindTrait.NO_UPDATE == k)) {\n+            UpdateKindTrait.NO_UPDATE\n+          } else {\n+            updateKinds.head\n+          }\n+          replaceChildrenAndTrait(union, Some(children.flatten), providedTrait)\n+\n+        }\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        replaceChildrenAndTrait(rel, Some(List()), UpdateKindTrait.NO_UPDATE)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = if (scan.intermediateTable.isUpdateBeforeRequired) {\n+          // we can't drop UPDATE_BEFORE if it is required by other parent blocks\n+          UpdateKindTrait.BEFORE_AND_AFTER\n+        } else {\n+          requiredTrait\n+        }\n+        if (!providedTrait.satisfies(requiredTrait)) {\n+          // require ONLY_AFTER but can only provide BEFORE_AND_AFTER\n+          None\n+        } else {\n+          replaceChildrenAndTrait(rel, Some(List()), providedTrait)\n+        }\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: UpdateKindTrait): Option[List[StreamPhysicalRel]] = {\n+      val newChildren = for (child <- parent.getInputs) yield {\n+        this.visit(child.asInstanceOf[StreamPhysicalRel], requiredChildrenTrait) match {\n+          case None =>\n+            // return None if one of the children can't satisfy\n+            return None\n+          case Some(newChild) =>\n+            val providedTrait = newChild.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            val childDescription = newChild.getRelDetailedDescription\n+            if (!providedTrait.satisfies(requiredChildrenTrait)) {\n+              throw new TableException(s\"Provided trait $providedTrait can't satisfy \" +\n+                s\"required trait $requiredChildrenTrait. \" +\n+                s\"This is a bug in planner, please file an issue. \\n\" +\n+                s\"Current node is $childDescription\")\n+            }\n+            newChild\n+        }\n+      }\n+      Some(newChildren.toList)\n+    }\n+\n+    private def replaceChildrenAndTrait(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 550}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1NDY4Nw==", "bodyText": "revert this", "url": "https://github.com/apache/flink/pull/11674#discussion_r407154687", "createdAt": "2020-04-12T06:41:07Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdModifiedMonotonicity.scala", "diffHunk": "@@ -41,6 +40,7 @@ import org.apache.calcite.sql.validate.SqlMonotonicity\n import org.apache.calcite.sql.validate.SqlMonotonicity._\n import org.apache.calcite.sql.{SqlKind, SqlOperatorBinding}\n import org.apache.calcite.util.Util\n+import org.apache.flink.table.planner.plan.utils.ChangelogPlanUtils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1NTA1OA==", "bodyText": "remove this ?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407155058", "createdAt": "2020-04-12T06:45:29Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/RelNodeBlock.scala", "diffHunk": "@@ -146,14 +153,30 @@ class RelNodeBlock(val outputNode: RelNode) {\n \n   def getOptimizedPlan: RelNode = optimizedPlan.orNull\n \n-  def setUpdateAsRetraction(updateAsRetract: Boolean): Unit = {\n-    // set child block updateAsRetract, a child may have multi father.\n-    if (updateAsRetract) {\n-      this.updateAsRetract = true\n+  // TODO: not needed?\n+  def setRequiredModifyKindSet(modifyKindSet: ModifyKindSet, requester: String): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5NjQyNw==", "bodyText": "extract these code as a method, and put it in AggregateUtil, both StreamExecGroupAggregate and StreamExecGroupTableAggregate can use it", "url": "https://github.com/apache/flink/pull/11674#discussion_r407196427", "createdAt": "2020-04-12T13:11:51Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecGroupAggregate.scala", "diffHunk": "@@ -64,7 +63,14 @@ class StreamExecGroupAggregate(\n   with StreamExecNode[BaseRow] {\n \n   val aggInfoList: AggregateInfoList = {\n-    val needRetraction = StreamExecRetractionRules.isAccRetract(getInput)\n+    // need to call `retract()` if input contains update or delete\n+    val modifyKindSetTrait = inputRel.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+    val needRetraction = if (modifyKindSetTrait == null) {\n+      // FlinkChangelogModeInferenceProgram is not applied yet, false as default\n+      false\n+    } else {\n+      !modifyKindSetTrait.modifyKindSet.isInsertOnly\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5NjU0NA==", "bodyText": "remove useless import too", "url": "https://github.com/apache/flink/pull/11674#discussion_r407196544", "createdAt": "2020-04-12T13:12:56Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecIntermediateTableScan.scala", "diffHunk": "@@ -39,18 +39,6 @@ class StreamExecIntermediateTableScan(\n   extends CommonIntermediateTableScan(cluster, traitSet, table)\n   with StreamPhysicalRel {\n \n-  def isAccRetract: Boolean = intermediateTable.isAccRetract\n-\n-  override def producesUpdates: Boolean = {\n-    !UpdatingPlanChecker.isAppendOnly(intermediateTable.relNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5NzkxOQ==", "bodyText": "update the comment too", "url": "https://github.com/apache/flink/pull/11674#discussion_r407197919", "createdAt": "2020-04-12T13:24:50Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/TwoStageOptimizedAggregateRule.scala", "diffHunk": "@@ -131,7 +130,9 @@ class TwoStageOptimizedAggregateRule extends RelOptRule(\n       input.getCluster.getTypeFactory.asInstanceOf[FlinkTypeFactory])\n \n     // local agg shouldn't produce AccRetract Message", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTI2NQ==", "bodyText": "remove useless import too", "url": "https://github.com/apache/flink/pull/11674#discussion_r407199265", "createdAt": "2020-04-12T13:35:48Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/TraitUtil.scala", "diffHunk": "@@ -57,12 +57,4 @@ object TraitUtil {\n     }\n   }\n \n-  /**\n-    * Checks if a [[RelNode]] is in [[AccMode.AccRetract]] mode.\n-    */\n-  def isAccRetract(rel: RelNode): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTc3Mg==", "bodyText": "add a case to test append sink ?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407199772", "createdAt": "2020-04-12T13:39:56Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/SinkTest.xml", "diffHunk": "@@ -16,27 +16,6 @@ See the License for the specific language governing permissions and\n limitations under the License.\n -->\n <Root>\n-  <TestCase name=\"testAppendSink\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMTA2Mg==", "bodyText": "the changelog mode's value is incorrect.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407201062", "createdAt": "2020-04-12T13:49:59Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/stream/RetractionRulesWithTwoStageAggTest.xml", "diffHunk": "@@ -39,19 +39,19 @@ LogicalAggregate(group=[{0}], frequency=[COUNT($0)])\n     </Resource>\n     <Resource name=\"planAfter\">\n       <![CDATA[\n-GlobalGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(count$0) AS frequency], updateAsRetraction=[false], accMode=[Acc])\n-+- Exchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[Acc])\n-   +- LocalGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(cnt) AS count$0, COUNT_RETRACT(*) AS count1$1], updateAsRetraction=[true], accMode=[Acc])\n-      +- Union(all=[true], union=[cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-         :- Calc(select=[CAST(cnt) AS cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-         :  +- GlobalGroupAggregate(groupBy=[word], select=[word, COUNT(count$0) AS cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-         :     +- Exchange(distribution=[hash[word]], updateAsRetraction=[true], accMode=[Acc])\n-         :        +- LocalGroupAggregate(groupBy=[word], select=[word, COUNT(number) AS count$0], updateAsRetraction=[true], accMode=[Acc])\n-         :           +- MiniBatchAssigner(interval=[1000ms], mode=[ProcTime], updateAsRetraction=[true], accMode=[Acc])\n-         :              +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(word, number)]]], fields=[word, number], updateAsRetraction=[true], accMode=[Acc])\n-         +- Calc(select=[cnt], updateAsRetraction=[true], accMode=[Acc])\n-            +- MiniBatchAssigner(interval=[1000ms], mode=[ProcTime], updateAsRetraction=[true], accMode=[Acc])\n-               +- TableSourceScan(table=[[default_catalog, default_database, MyTable2, source: [TestTableSource(word, cnt)]]], fields=[word, cnt], updateAsRetraction=[true], accMode=[Acc])\n+GlobalGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(count$0) AS frequency], changelogMode=[I,UA,D])\n++- Exchange(distribution=[hash[cnt]], changelogMode=[I])\n+   +- LocalGroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(cnt) AS count$0, COUNT_RETRACT(*) AS count1$1], changelogMode=[I])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMTA3Ng==", "bodyText": "ditto", "url": "https://github.com/apache/flink/pull/11674#discussion_r407201076", "createdAt": "2020-04-12T13:50:08Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/stream/RetractionRulesWithTwoStageAggTest.xml", "diffHunk": "@@ -68,12 +68,12 @@ LogicalProject(EXPR$0=[$1])\n     </Resource>\n     <Resource name=\"planAfter\">\n       <![CDATA[\n-Calc(select=[EXPR$0], updateAsRetraction=[false], accMode=[Acc])\n-+- GlobalGroupAggregate(groupBy=[word], select=[word, COUNT(count$0) AS EXPR$0], updateAsRetraction=[false], accMode=[Acc])\n-   +- Exchange(distribution=[hash[word]], updateAsRetraction=[true], accMode=[Acc])\n-      +- LocalGroupAggregate(groupBy=[word], select=[word, COUNT(number) AS count$0], updateAsRetraction=[true], accMode=[Acc])\n-         +- MiniBatchAssigner(interval=[1000ms], mode=[ProcTime], updateAsRetraction=[true], accMode=[Acc])\n-            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(word, number)]]], fields=[word, number], updateAsRetraction=[true], accMode=[Acc])\n+Calc(select=[EXPR$0], changelogMode=[I,UA])\n++- GlobalGroupAggregate(groupBy=[word], select=[word, COUNT(count$0) AS EXPR$0], changelogMode=[I,UA])\n+   +- Exchange(distribution=[hash[word]], changelogMode=[I])\n+      +- LocalGroupAggregate(groupBy=[word], select=[word, COUNT(number) AS count$0], changelogMode=[I])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMTIyNA==", "bodyText": "the names of RetractionRulesTest and RetractionRulesWithTwoStageAggTest should also be updated", "url": "https://github.com/apache/flink/pull/11674#discussion_r407201224", "createdAt": "2020-04-12T13:51:33Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/stream/RetractionRulesTest.xml", "diffHunk": "@@ -39,15 +39,15 @@ LogicalAggregate(group=[{0}], frequency=[COUNT($0)])\n     </Resource>\n     <Resource name=\"planAfter\">\n       <![CDATA[\n-GroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(cnt) AS frequency], updateAsRetraction=[false], accMode=[Acc])\n-+- Exchange(distribution=[hash[cnt]], updateAsRetraction=[true], accMode=[AccRetract])\n-   +- Union(all=[true], union=[cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-      :- Calc(select=[CAST(cnt) AS cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-      :  +- GroupAggregate(groupBy=[word], select=[word, COUNT(number) AS cnt], updateAsRetraction=[true], accMode=[AccRetract])\n-      :     +- Exchange(distribution=[hash[word]], updateAsRetraction=[true], accMode=[Acc])\n-      :        +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(word, number)]]], fields=[word, number], updateAsRetraction=[true], accMode=[Acc])\n-      +- Calc(select=[cnt], updateAsRetraction=[true], accMode=[Acc])\n-         +- TableSourceScan(table=[[default_catalog, default_database, MyTable2, source: [TestTableSource(word, cnt)]]], fields=[word, cnt], updateAsRetraction=[true], accMode=[Acc])\n+GroupAggregate(groupBy=[cnt], select=[cnt, COUNT_RETRACT(cnt) AS frequency], changelogMode=[I,UA,D])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMjIzNw==", "bodyText": "DELETE is unnecessary ?  a1 and b1 are pks", "url": "https://github.com/apache/flink/pull/11674#discussion_r407202237", "createdAt": "2020-04-12T13:59:08Z", "author": {"login": "godfreyhe"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/JoinTest.xml", "diffHunk": "@@ -313,17 +313,17 @@ LogicalProject(a1=[$1], b1=[$3])\n     </Resource>\n     <Resource name=\"planAfter\">\n       <![CDATA[\n-Join(joinType=[InnerJoin], where=[=(a1, b1)], select=[a1, b1], leftInputSpec=[JoinKeyContainsUniqueKey], rightInputSpec=[JoinKeyContainsUniqueKey], updateAsRetraction=[false], accMode=[Acc])\n-:- Exchange(distribution=[hash[a1]], updateAsRetraction=[false], accMode=[Acc])\n-:  +- GroupAggregate(groupBy=[a1], select=[a1], updateAsRetraction=[false], accMode=[Acc])\n-:     +- Exchange(distribution=[hash[a1]], updateAsRetraction=[true], accMode=[Acc])\n-:        +- Calc(select=[a1, a2], updateAsRetraction=[true], accMode=[Acc])\n-:           +- TableSourceScan(table=[[default_catalog, default_database, A, source: [TestTableSource(a1, a2, a3)]]], fields=[a1, a2, a3], updateAsRetraction=[true], accMode=[Acc])\n-+- Exchange(distribution=[hash[b1]], updateAsRetraction=[false], accMode=[Acc])\n-   +- GroupAggregate(groupBy=[b1], select=[b1], updateAsRetraction=[false], accMode=[Acc])\n-      +- Exchange(distribution=[hash[b1]], updateAsRetraction=[true], accMode=[Acc])\n-         +- Calc(select=[b1, b2], updateAsRetraction=[true], accMode=[Acc])\n-            +- TableSourceScan(table=[[default_catalog, default_database, B, source: [TestTableSource(b1, b2, b3)]]], fields=[b1, b2, b3], updateAsRetraction=[true], accMode=[Acc])\n+Join(joinType=[InnerJoin], where=[=(a1, b1)], select=[a1, b1], leftInputSpec=[JoinKeyContainsUniqueKey], rightInputSpec=[JoinKeyContainsUniqueKey], changelogMode=[I,UA,D])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 245}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzczNTM2", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-391773536", "createdAt": "2020-04-11T15:02:58Z", "commit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTowMjo1OVrOGEN0fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNjowMjo0MVrOGEONEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3MzkxNg==", "bodyText": "nit: satisfies required traits by input nodes of current node.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407073916", "createdAt": "2020-04-11T15:02:59Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        replaceChildrenAndTrait(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        replaceChildrenAndTrait(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        replaceChildrenAndTrait(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        replaceChildrenAndTrait(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        replaceChildrenAndTrait(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        replaceChildrenAndTrait(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (leftKindSet.isInsertOnly &&\n+            rightKindSet.isInsertOnly && innerOrSemi) {\n+          // produce insert-only because results are deterministic\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        replaceChildrenAndTrait(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        replaceChildrenAndTrait(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        replaceChildrenAndTrait(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        replaceChildrenAndTrait(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        replaceChildrenAndTrait(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        replaceChildrenAndTrait(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def replaceChildrenAndTrait(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.diff(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfy required traits by inputs node of current node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3NzY1NQ==", "bodyText": "nit: happens -> happen", "url": "https://github.com/apache/flink/pull/11674#discussion_r407077655", "createdAt": "2020-04-11T15:37:36Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/trait/ModifyKind.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.trait;\n+\n+/**\n+ * Lists all kinds of modify operations that happens in a changelog.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3OTUxOQ==", "bodyText": "we can make this constructor private, since we already have a public newBuilder method for creating a Builder", "url": "https://github.com/apache/flink/pull/11674#discussion_r407079519", "createdAt": "2020-04-11T15:55:36Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/trait/ModifyKindSet.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.trait;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * The set of modify operations contained in a changelog.\n+ *\n+ * @see ModifyKind\n+ */\n+public class ModifyKindSet {\n+\n+\t/**\n+\t * Insert-only modify kind set.\n+\t */\n+\tpublic static final ModifyKindSet INSERT_ONLY = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.build();\n+\n+\t/**\n+\t * A modify kind set contains all change operations.\n+\t */\n+\tpublic static final ModifyKindSet ALL_CHANGES = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.addContainedKind(ModifyKind.UPDATE)\n+\t\t.addContainedKind(ModifyKind.DELETE)\n+\t\t.build();\n+\n+\tprivate final Set<ModifyKind> kinds;\n+\n+\tprivate ModifyKindSet(Set<ModifyKind> kinds) {\n+\t\tthis.kinds = Collections.unmodifiableSet(kinds);\n+\t}\n+\n+\tpublic Set<ModifyKind> getContainedKinds() {\n+\t\treturn kinds;\n+\t}\n+\n+\tpublic boolean contains(ModifyKind kind) {\n+\t\treturn kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean containsOnly(ModifyKind kind) {\n+\t\treturn kinds.size() == 1 && kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean isInsertOnly() {\n+\t\treturn containsOnly(ModifyKind.INSERT);\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn kinds.size();\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn kinds.isEmpty();\n+\t}\n+\n+\t/**\n+\t * Returns a new set of ModifyKind which is the difference between two sets.\n+\t * It is also equal to {@code this.kinds - that.kinds}. For example:\n+\t * [I,U,D] diff [I] = [U,D]\n+\t * [I,U] diff [U,D] = [I]\n+\t * [I,U,D] diff [I,U,D] = []\n+\t */\n+\tpublic ModifyKindSet diff(ModifyKindSet other) {\n+\t\tSet<ModifyKind> result = EnumSet.noneOf(ModifyKind.class);\n+\t\tresult.addAll(this.kinds);\n+\t\tresult.removeAll(other.kinds);\n+\t\treturn new ModifyKindSet(result);\n+\t}\n+\n+\t/**\n+\t * Returns a new ModifyKindSet with all kinds set in both this set and in another set.\n+\t */\n+\tpublic ModifyKindSet intersect(ModifyKindSet other) {\n+\t\tBuilder builder = new Builder();\n+\t\tfor (ModifyKind kind : other.getContainedKinds()) {\n+\t\t\tif (this.contains(kind)) {\n+\t\t\t\tbuilder.addContainedKind(kind);\n+\t\t\t}\n+\t\t}\n+\t\treturn builder.build();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tModifyKindSet that = (ModifyKindSet) o;\n+\t\treturn Objects.equals(kinds, that.kinds);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn Objects.hash(kinds);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tif (kinds.isEmpty()) {\n+\t\t\treturn \"NONE\";\n+\t\t}\n+\t\tList<String> modifyKinds = new ArrayList<>();\n+\t\tif (contains(ModifyKind.INSERT)) {\n+\t\t\tmodifyKinds.add(\"I\");\n+\t\t}\n+\t\tif (contains(ModifyKind.UPDATE)) {\n+\t\t\tmodifyKinds.add(\"U\");\n+\t\t}\n+\t\tif (contains(ModifyKind.DELETE)) {\n+\t\t\tmodifyKinds.add(\"D\");\n+\t\t}\n+\t\treturn String.join(\",\", modifyKinds);\n+\t}\n+\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Returns the union of a number of ModifyKindSets.\n+\t */\n+\tpublic static ModifyKindSet union(ModifyKindSet... modifyKindSets) {\n+\t\tBuilder builder = newBuilder();\n+\t\tfor (ModifyKindSet set : modifyKindSets) {\n+\t\t\tfor (ModifyKind kind : set.getContainedKinds()) {\n+\t\t\t\tbuilder.addContainedKind(kind);\n+\t\t\t}\n+\t\t}\n+\t\treturn builder.build();\n+\t}\n+\n+\t/**\n+\t * Builder for configuring and creating instances of {@link ModifyKindSet}.\n+\t */\n+\tpublic static Builder newBuilder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * Builder for configuring and creating instances of {@link ModifyKindSet}.\n+\t */\n+\tpublic static class Builder {\n+\n+\t\tprivate final Set<ModifyKind> kinds = EnumSet.noneOf(ModifyKind.class);\n+\n+\t\tpublic Builder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MDA2MA==", "bodyText": "we can use ModifyKindSet.INSERT_ONLY here.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407080060", "createdAt": "2020-04-11T16:01:14Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/ModifyKindSetTrait.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTrait, RelTraitDef}\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * ModifyKindSetTrait is used to describe what modify operation will be produced by this node.\n+ */\n+class ModifyKindSetTrait(val modifyKindSet: ModifyKindSet) extends RelTrait {\n+\n+  override def satisfies(relTrait: RelTrait): Boolean = relTrait match {\n+    case other: ModifyKindSetTrait =>\n+      // it\u2019s satisfied when modify kinds are included in the required set,\n+      // e.g. [I,U] satisfy [I,U,D]\n+      //      [I,U,D] not satisfy [I,D]\n+      this.modifyKindSet.getContainedKinds.forall(other.modifyKindSet.contains)\n+    case other: UpdateKindTrait =>\n+      // it's satisfied when UpdateKind matches ModifyKindSet\n+      other.updateKind match {\n+        case UpdateKind.NO_UPDATE =>\n+          modifyKindSet.containsOnly(ModifyKind.INSERT)\n+        case UpdateKind.BEFORE_AND_AFTER | UpdateKind.ONLY_UPDATE_AFTER =>\n+          modifyKindSet.contains(ModifyKind.UPDATE)\n+      }\n+    case _ => false\n+  }\n+\n+  override def getTraitDef: RelTraitDef[_ <: RelTrait] = ModifyKindSetTraitDef.INSTANCE\n+\n+  override def register(planner: RelOptPlanner): Unit = {}\n+\n+  override def hashCode(): Int = modifyKindSet.hashCode()\n+\n+  override def equals(obj: Any): Boolean = obj match {\n+    case t: ModifyKindSetTrait => this.modifyKindSet.equals(t.modifyKindSet)\n+    case _ => false\n+  }\n+\n+  override def toString: String = s\"[${modifyKindSet.toString}]\"\n+}\n+\n+object ModifyKindSetTrait {\n+  /**\n+   * An empty [[ModifyKindSetTrait]] which doesn't contain any [[ModifyKind]].\n+   */\n+  val EMPTY = new ModifyKindSetTrait(ModifyKindSet.newBuilder().build())\n+\n+  /**\n+   * Insert-only [[ModifyKindSetTrait]].\n+   */\n+  val INSERT_ONLY = new ModifyKindSetTrait(ModifyKindSet.newBuilder\n+    .addContainedKind(ModifyKind.INSERT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MDExMw==", "bodyText": "we can use ModifyKindSet.ALL_CHANGES here.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407080113", "createdAt": "2020-04-11T16:01:45Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/ModifyKindSetTrait.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTrait, RelTraitDef}\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * ModifyKindSetTrait is used to describe what modify operation will be produced by this node.\n+ */\n+class ModifyKindSetTrait(val modifyKindSet: ModifyKindSet) extends RelTrait {\n+\n+  override def satisfies(relTrait: RelTrait): Boolean = relTrait match {\n+    case other: ModifyKindSetTrait =>\n+      // it\u2019s satisfied when modify kinds are included in the required set,\n+      // e.g. [I,U] satisfy [I,U,D]\n+      //      [I,U,D] not satisfy [I,D]\n+      this.modifyKindSet.getContainedKinds.forall(other.modifyKindSet.contains)\n+    case other: UpdateKindTrait =>\n+      // it's satisfied when UpdateKind matches ModifyKindSet\n+      other.updateKind match {\n+        case UpdateKind.NO_UPDATE =>\n+          modifyKindSet.containsOnly(ModifyKind.INSERT)\n+        case UpdateKind.BEFORE_AND_AFTER | UpdateKind.ONLY_UPDATE_AFTER =>\n+          modifyKindSet.contains(ModifyKind.UPDATE)\n+      }\n+    case _ => false\n+  }\n+\n+  override def getTraitDef: RelTraitDef[_ <: RelTrait] = ModifyKindSetTraitDef.INSTANCE\n+\n+  override def register(planner: RelOptPlanner): Unit = {}\n+\n+  override def hashCode(): Int = modifyKindSet.hashCode()\n+\n+  override def equals(obj: Any): Boolean = obj match {\n+    case t: ModifyKindSetTrait => this.modifyKindSet.equals(t.modifyKindSet)\n+    case _ => false\n+  }\n+\n+  override def toString: String = s\"[${modifyKindSet.toString}]\"\n+}\n+\n+object ModifyKindSetTrait {\n+  /**\n+   * An empty [[ModifyKindSetTrait]] which doesn't contain any [[ModifyKind]].\n+   */\n+  val EMPTY = new ModifyKindSetTrait(ModifyKindSet.newBuilder().build())\n+\n+  /**\n+   * Insert-only [[ModifyKindSetTrait]].\n+   */\n+  val INSERT_ONLY = new ModifyKindSetTrait(ModifyKindSet.newBuilder\n+    .addContainedKind(ModifyKind.INSERT)\n+    .build)\n+\n+  /**\n+   * A modify [[ModifyKindSetTrait]] contains all change operations.\n+   */\n+  val ALL_CHANGES = new ModifyKindSetTrait(ModifyKindSet.newBuilder\n+    .addContainedKind(ModifyKind.INSERT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MDIxMQ==", "bodyText": "nit: A [[ModifyKindSetTrait]] which contains", "url": "https://github.com/apache/flink/pull/11674#discussion_r407080211", "createdAt": "2020-04-11T16:02:41Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/ModifyKindSetTrait.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTrait, RelTraitDef}\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * ModifyKindSetTrait is used to describe what modify operation will be produced by this node.\n+ */\n+class ModifyKindSetTrait(val modifyKindSet: ModifyKindSet) extends RelTrait {\n+\n+  override def satisfies(relTrait: RelTrait): Boolean = relTrait match {\n+    case other: ModifyKindSetTrait =>\n+      // it\u2019s satisfied when modify kinds are included in the required set,\n+      // e.g. [I,U] satisfy [I,U,D]\n+      //      [I,U,D] not satisfy [I,D]\n+      this.modifyKindSet.getContainedKinds.forall(other.modifyKindSet.contains)\n+    case other: UpdateKindTrait =>\n+      // it's satisfied when UpdateKind matches ModifyKindSet\n+      other.updateKind match {\n+        case UpdateKind.NO_UPDATE =>\n+          modifyKindSet.containsOnly(ModifyKind.INSERT)\n+        case UpdateKind.BEFORE_AND_AFTER | UpdateKind.ONLY_UPDATE_AFTER =>\n+          modifyKindSet.contains(ModifyKind.UPDATE)\n+      }\n+    case _ => false\n+  }\n+\n+  override def getTraitDef: RelTraitDef[_ <: RelTrait] = ModifyKindSetTraitDef.INSTANCE\n+\n+  override def register(planner: RelOptPlanner): Unit = {}\n+\n+  override def hashCode(): Int = modifyKindSet.hashCode()\n+\n+  override def equals(obj: Any): Boolean = obj match {\n+    case t: ModifyKindSetTrait => this.modifyKindSet.equals(t.modifyKindSet)\n+    case _ => false\n+  }\n+\n+  override def toString: String = s\"[${modifyKindSet.toString}]\"\n+}\n+\n+object ModifyKindSetTrait {\n+  /**\n+   * An empty [[ModifyKindSetTrait]] which doesn't contain any [[ModifyKind]].\n+   */\n+  val EMPTY = new ModifyKindSetTrait(ModifyKindSet.newBuilder().build())\n+\n+  /**\n+   * Insert-only [[ModifyKindSetTrait]].\n+   */\n+  val INSERT_ONLY = new ModifyKindSetTrait(ModifyKindSet.newBuilder\n+    .addContainedKind(ModifyKind.INSERT)\n+    .build)\n+\n+  /**\n+   * A modify [[ModifyKindSetTrait]] contains all change operations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxOTkwMzMw", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-391990330", "createdAt": "2020-04-13T07:01:38Z", "commit": {"oid": "6d34187c1dde98f1fc8573063e298bd481224688"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNzowMTozOFrOGEelJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNzoxMjo1MlrOGEeyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODUxOQ==", "bodyText": "use minus? diff sounds like another meaning", "url": "https://github.com/apache/flink/pull/11674#discussion_r407348519", "createdAt": "2020-04-13T07:01:38Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/trait/ModifyKindSet.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.trait;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * The set of modify operations contained in a changelog.\n+ *\n+ * @see ModifyKind\n+ */\n+public class ModifyKindSet {\n+\n+\t/**\n+\t * Insert-only modify kind set.\n+\t */\n+\tpublic static final ModifyKindSet INSERT_ONLY = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.build();\n+\n+\t/**\n+\t * A modify kind set contains all change operations.\n+\t */\n+\tpublic static final ModifyKindSet ALL_CHANGES = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.addContainedKind(ModifyKind.UPDATE)\n+\t\t.addContainedKind(ModifyKind.DELETE)\n+\t\t.build();\n+\n+\tprivate final Set<ModifyKind> kinds;\n+\n+\tprivate ModifyKindSet(Set<ModifyKind> kinds) {\n+\t\tthis.kinds = Collections.unmodifiableSet(kinds);\n+\t}\n+\n+\tpublic Set<ModifyKind> getContainedKinds() {\n+\t\treturn kinds;\n+\t}\n+\n+\tpublic boolean contains(ModifyKind kind) {\n+\t\treturn kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean containsOnly(ModifyKind kind) {\n+\t\treturn kinds.size() == 1 && kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean isInsertOnly() {\n+\t\treturn containsOnly(ModifyKind.INSERT);\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn kinds.size();\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn kinds.isEmpty();\n+\t}\n+\n+\t/**\n+\t * Returns a new set of ModifyKind which is the difference between two sets.\n+\t * It is also equal to {@code this.kinds - that.kinds}. For example:\n+\t * [I,U,D] diff [I] = [U,D]\n+\t * [I,U] diff [U,D] = [I]\n+\t * [I,U,D] diff [I,U,D] = []\n+\t */\n+\tpublic ModifyKindSet diff(ModifyKindSet other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d34187c1dde98f1fc8573063e298bd481224688"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODk1Nw==", "bodyText": "I think we should protect this class to let it be always non-empty.\nDoes an empty ModifyKindSet make any sense?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407348957", "createdAt": "2020-04-13T07:03:08Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/trait/ModifyKindSet.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.trait;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * The set of modify operations contained in a changelog.\n+ *\n+ * @see ModifyKind\n+ */\n+public class ModifyKindSet {\n+\n+\t/**\n+\t * Insert-only modify kind set.\n+\t */\n+\tpublic static final ModifyKindSet INSERT_ONLY = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.build();\n+\n+\t/**\n+\t * A modify kind set contains all change operations.\n+\t */\n+\tpublic static final ModifyKindSet ALL_CHANGES = ModifyKindSet.newBuilder()\n+\t\t.addContainedKind(ModifyKind.INSERT)\n+\t\t.addContainedKind(ModifyKind.UPDATE)\n+\t\t.addContainedKind(ModifyKind.DELETE)\n+\t\t.build();\n+\n+\tprivate final Set<ModifyKind> kinds;\n+\n+\tprivate ModifyKindSet(Set<ModifyKind> kinds) {\n+\t\tthis.kinds = Collections.unmodifiableSet(kinds);\n+\t}\n+\n+\tpublic Set<ModifyKind> getContainedKinds() {\n+\t\treturn kinds;\n+\t}\n+\n+\tpublic boolean contains(ModifyKind kind) {\n+\t\treturn kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean containsOnly(ModifyKind kind) {\n+\t\treturn kinds.size() == 1 && kinds.contains(kind);\n+\t}\n+\n+\tpublic boolean isInsertOnly() {\n+\t\treturn containsOnly(ModifyKind.INSERT);\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn kinds.size();\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn kinds.isEmpty();\n+\t}\n+\n+\t/**\n+\t * Returns a new set of ModifyKind which is the difference between two sets.\n+\t * It is also equal to {@code this.kinds - that.kinds}. For example:\n+\t * [I,U,D] diff [I] = [U,D]\n+\t * [I,U] diff [U,D] = [I]\n+\t * [I,U,D] diff [I,U,D] = []\n+\t */\n+\tpublic ModifyKindSet diff(ModifyKindSet other) {\n+\t\tSet<ModifyKind> result = EnumSet.noneOf(ModifyKind.class);\n+\t\tresult.addAll(this.kinds);\n+\t\tresult.removeAll(other.kinds);\n+\t\treturn new ModifyKindSet(result);\n+\t}\n+\n+\t/**\n+\t * Returns a new ModifyKindSet with all kinds set in both this set and in another set.\n+\t */\n+\tpublic ModifyKindSet intersect(ModifyKindSet other) {\n+\t\tBuilder builder = new Builder();\n+\t\tfor (ModifyKind kind : other.getContainedKinds()) {\n+\t\t\tif (this.contains(kind)) {\n+\t\t\t\tbuilder.addContainedKind(kind);\n+\t\t\t}\n+\t\t}\n+\t\treturn builder.build();\n+\t}\n+\n+\t/**\n+\t * Returns a new ModifyKindSet with the union of the other ModifyKindSet.\n+\t */\n+\tpublic ModifyKindSet union(ModifyKindSet other) {\n+\t\treturn union(this, other);\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tModifyKindSet that = (ModifyKindSet) o;\n+\t\treturn Objects.equals(kinds, that.kinds);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn Objects.hash(kinds);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tif (kinds.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d34187c1dde98f1fc8573063e298bd481224688"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0OTY3Mg==", "bodyText": "It's hard to imagine & understand why this class support merge, what should be the expected behavior?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407349672", "createdAt": "2020-04-13T07:05:57Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/trait/UpdateKind.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.trait;\n+\n+/**\n+ * Lists all kinds of {@link ModifyKind#UPDATE} operation.\n+ */\n+public enum UpdateKind {\n+\n+\t/**\n+\t * No update operation.\n+\t */\n+\tNO_UPDATE,\n+\n+\t/**\n+\t * This kind indicates that operators should emit update changes just as a row of\n+\t * {@code RowKind#UPDATE_AFTER}.\n+\t */\n+\tONLY_UPDATE_AFTER,\n+\n+\t/**\n+\t * This kind indicates that operators should emit update changes in the way that\n+\t * a row of {@code RowKind#UPDATE_BEFORE} and a row of {@code RowKind#UPDATE_AFTER} together.\n+\t */\n+\tBEFORE_AND_AFTER;\n+\n+\t/**\n+\t * Return a new UpdateKind which merges this UpdateKind and the other UpdateKind.\n+\t */\n+\tpublic UpdateKind merge(UpdateKind that) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d34187c1dde98f1fc8573063e298bd481224688"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM1MTg2NQ==", "bodyText": "why ModifyKindSetTrait will be compared with UpdateKindTrait", "url": "https://github.com/apache/flink/pull/11674#discussion_r407351865", "createdAt": "2020-04-13T07:12:52Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/trait/ModifyKindSetTrait.scala", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.`trait`\n+\n+import org.apache.calcite.plan.{RelOptPlanner, RelTrait, RelTraitDef}\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * ModifyKindSetTrait is used to describe what modify operation will be produced by this node.\n+ */\n+class ModifyKindSetTrait(val modifyKindSet: ModifyKindSet) extends RelTrait {\n+\n+  override def satisfies(relTrait: RelTrait): Boolean = relTrait match {\n+    case other: ModifyKindSetTrait =>\n+      // it\u2019s satisfied when modify kinds are included in the required set,\n+      // e.g. [I,U] satisfy [I,U,D]\n+      //      [I,U,D] not satisfy [I,D]\n+      this.modifyKindSet.getContainedKinds.forall(other.modifyKindSet.contains)\n+    case other: UpdateKindTrait =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d34187c1dde98f1fc8573063e298bd481224688"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODY3NDAw", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-391867400", "createdAt": "2020-04-12T15:15:39Z", "commit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxNToxNTozOVrOGEWQLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDowOToyOFrOGEnpSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjA3OA==", "bodyText": "nit: \"for every physical node.\" or \"for all physical nodes.\"", "url": "https://github.com/apache/flink/pull/11674#discussion_r407212078", "createdAt": "2020-04-12T15:15:39Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NzAzNQ==", "bodyText": "nit: current node's behavior", "url": "https://github.com/apache/flink/pull/11674#discussion_r407497035", "createdAt": "2020-04-13T14:09:28Z", "author": {"login": "libenchao"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,595 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNoUpdate, onlyAfterOrNoUpdate}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical nodes.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NO_UPDATE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node behavior", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27728b10f3e719b3f53fe199cf02e5b820ddfcd1"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzE3NzAz", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-392717703", "createdAt": "2020-04-14T08:38:22Z", "commit": {"oid": "8a496f496bbe955bd33460443eb53a696f612a68"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODozODoyMlrOGFEGmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODo0MzoxOFrOGFETCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MzI4OQ==", "bodyText": "IIRC we've decided to not let filter passing the update kind. To solve the bad case like a single 'x < 10' condition which won't satisfy the only_update_before case.", "url": "https://github.com/apache/flink/pull/11674#discussion_r407963289", "createdAt": "2020-04-14T08:38:22Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.optimize.program\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.plan.`trait`.UpdateKindTrait.{beforeAfterOrNone, onlyAfterOrNone}\n+import org.apache.flink.table.planner.plan.`trait`._\n+import org.apache.flink.table.planner.plan.nodes.physical.stream._\n+import org.apache.flink.table.planner.plan.utils._\n+import org.apache.flink.table.planner.sinks.DataStreamTableSink\n+import org.apache.flink.table.runtime.operators.join.FlinkJoinType\n+import org.apache.flink.table.sinks.{AppendStreamTableSink, RetractStreamTableSink, StreamTableSink, UpsertStreamTableSink}\n+\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.util.ImmutableBitSet\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+ * An optimize program to infer ChangelogMode for every physical node.\n+ */\n+class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOptimizeContext] {\n+\n+  private val SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR = new SatisfyModifyKindSetTraitVisitor\n+  private val SATISFY_UPDATE_KIND_TRAIT_VISITOR = new SatisfyUpdateKindTraitVisitor\n+\n+  override def optimize(\n+      root: RelNode,\n+      context: StreamOptimizeContext): RelNode = {\n+\n+    // step1: satisfy ModifyKindSet trait\n+    val physicalRoot = root.asInstanceOf[StreamPhysicalRel]\n+    val rootWithModifyKindSet = SATISFY_MODIFY_KIND_SET_TRAIT_VISITOR.visit(\n+      physicalRoot,\n+      // we do not propagate the ModifyKindSet requirement and requester among blocks\n+      // set default ModifyKindSet requirement and requester for root\n+      ModifyKindSetTrait.ALL_CHANGES,\n+      \"ROOT\")\n+\n+    // step2: satisfy UpdateKind trait\n+    val rootModifyKindSet = getModifyKindSet(rootWithModifyKindSet)\n+    // use the required UpdateKindTrait from parent blocks\n+    val requiredUpdateKindTrait = if (context.isUpdateBeforeRequired) {\n+      UpdateKindTrait.BEFORE_AND_AFTER\n+    } else if (rootModifyKindSet.isInsertOnly) {\n+      UpdateKindTrait.NONE\n+    } else {\n+      UpdateKindTrait.ONLY_UPDATE_AFTER\n+    }\n+    val finalRoot = SATISFY_UPDATE_KIND_TRAIT_VISITOR.visit(\n+      rootWithModifyKindSet,\n+      requiredUpdateKindTrait)\n+\n+    // step3: sanity check and return non-empty root\n+    if (finalRoot.isEmpty) {\n+      val plan = FlinkRelOptUtil.toString(root, withChangelogTraits = true)\n+      throw new TableException(\n+        \"Can't generate a valid execution plan for the given query:\\n\" + plan)\n+    } else {\n+      finalRoot.get\n+    }\n+  }\n+\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[ModifyKindSetTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[ModifyKindSetTrait]]\n+   * or an exception should be thrown if the planner doesn't support to satisfy the required\n+   * [[ModifyKindSetTrait]].\n+   */\n+  private class SatisfyModifyKindSetTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[ModifyKindSetTrait]] from root.\n+     *\n+     * <p>Each node should first require a [[ModifyKindSetTrait]] to its children.\n+     * If the trait provided by children does not satisfy the required one,\n+     * it should throw an exception and prompt the user that plan is not supported.\n+     * The required [[ModifyKindSetTrait]] may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>Each node should provide [[ModifyKindSetTrait]] according to current node's behavior\n+     * and the ModifyKindSetTrait provided by children.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required ModifyKindSetTrait\n+     * @param requester the requester who starts the requirement, used for better exception message\n+     * @return A converted node which satisfy required traits by inputs node of current node.\n+     *         Or throws exception if required trait can\u2019t be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val (sinkRequiredTrait, name) = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"UpsertStreamTableSink\")\n+          case _: RetractStreamTableSink[_] =>\n+            (ModifyKindSetTrait.ALL_CHANGES, \"RetractStreamTableSink\")\n+          case _: AppendStreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"AppendStreamTableSink\")\n+          case _: StreamTableSink[_] =>\n+            (ModifyKindSetTrait.INSERT_ONLY, \"StreamTableSink\")\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              (ModifyKindSetTrait.ALL_CHANGES, \"toRetractStream\")\n+            } else {\n+              (ModifyKindSetTrait.INSERT_ONLY, \"toAppendStream\")\n+            }\n+          case _ =>\n+            throw new UnsupportedOperationException(\n+              s\"Unsupported sink '${sink.sink.getClass.getSimpleName}'\")\n+        }\n+        val children = visitChildren(sink, sinkRequiredTrait, name)\n+        val sinkTrait = sink.getTraitSet.plus(ModifyKindSetTrait.EMPTY)\n+        // ignore required trait from context, because sink is the true root\n+        sink.copy(sinkTrait, children).asInstanceOf[StreamPhysicalRel]\n+\n+      case deduplicate: StreamExecDeduplicate =>\n+        // deduplicate only support insert only as input\n+        val children = visitChildren(deduplicate, ModifyKindSetTrait.INSERT_ONLY)\n+        val providedTrait = if (deduplicate.keepLastRow) {\n+          // produce updates if it keeps last row\n+          ModifyKindSetTrait.ALL_CHANGES\n+        } else {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        }\n+        createNewNode(deduplicate, children, providedTrait, requiredTrait, requester)\n+\n+      case agg: StreamExecGroupAggregate =>\n+        // agg support all changes in input\n+        val children = visitChildren(agg, ModifyKindSetTrait.ALL_CHANGES)\n+        val inputModifyKindSet = getModifyKindSet(children.head)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+          .addContainedKind(ModifyKind.UPDATE)\n+        if (inputModifyKindSet.contains(ModifyKind.UPDATE) ||\n+            inputModifyKindSet.contains(ModifyKind.DELETE)) {\n+          builder.addContainedKind(ModifyKind.DELETE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        createNewNode(agg, children, providedTrait, requiredTrait, requester)\n+\n+      case tagg: StreamExecGroupTableAggregate =>\n+        // table agg support all changes in input\n+        val children = visitChildren(tagg, ModifyKindSetTrait.ALL_CHANGES)\n+        // table aggregate will produce all changes, including deletions\n+        createNewNode(\n+          tagg, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case window: StreamExecGroupWindowAggregateBase =>\n+        // WindowAggregate and WindowTableAggregate support insert-only in input\n+        val children = visitChildren(window, ModifyKindSetTrait.INSERT_ONLY)\n+        val builder = ModifyKindSet.newBuilder()\n+          .addContainedKind(ModifyKind.INSERT)\n+        if (window.emitStrategy.produceUpdates) {\n+          builder.addContainedKind(ModifyKind.UPDATE)\n+        }\n+        val providedTrait = new ModifyKindSetTrait(builder.build())\n+        createNewNode(window, children, providedTrait, requiredTrait, requester)\n+\n+      case limit: StreamExecLimit =>\n+        // limit support all changes in input\n+        val children = visitChildren(limit, ModifyKindSetTrait.ALL_CHANGES)\n+        val providedTrait = if (getModifyKindSet(children.head).isInsertOnly) {\n+          ModifyKindSetTrait.INSERT_ONLY\n+        } else {\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        createNewNode(limit, children, providedTrait, requiredTrait, requester)\n+\n+      case _: StreamExecRank | _: StreamExecSortLimit =>\n+        // Rank and SortLimit supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        createNewNode(\n+          rel, children, ModifyKindSetTrait.ALL_CHANGES, requiredTrait, requester)\n+\n+      case sort: StreamExecSort =>\n+        // Sort supports consuming all changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        // Sort will buffer all inputs, and produce insert-only messages when input is finished\n+        createNewNode(\n+          sort, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case cep: StreamExecMatch =>\n+        // CEP only supports consuming insert-only and producing insert-only changes\n+        // give a better requester name for exception message\n+        val children = visitChildren(cep, ModifyKindSetTrait.INSERT_ONLY, \"Match Recognize\")\n+        createNewNode(\n+          cep, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case _: StreamExecTemporalSort | _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // TemporalSort, OverAggregate, WindowJoin only support consuming insert-only\n+        // and producing insert-only changes\n+        val children = visitChildren(rel, ModifyKindSetTrait.INSERT_ONLY)\n+        createNewNode(\n+          rel, children, ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case join: StreamExecJoin =>\n+        // join support all changes in input\n+        val children = visitChildren(rel, ModifyKindSetTrait.ALL_CHANGES)\n+        val leftKindSet = getModifyKindSet(children.head)\n+        val rightKindSet = getModifyKindSet(children.last)\n+        val innerOrSemi = join.flinkJoinType == FlinkJoinType.INNER ||\n+            join.flinkJoinType == FlinkJoinType.SEMI\n+        val providedTrait = if (innerOrSemi) {\n+          // forward left and right modify operations\n+          new ModifyKindSetTrait(leftKindSet.union(rightKindSet))\n+        } else {\n+          // otherwise, it may produce any kinds of changes\n+          ModifyKindSetTrait.ALL_CHANGES\n+        }\n+        createNewNode(join, children, providedTrait, requiredTrait, requester)\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // currently, temporal join only support insert-only input streams, including right side\n+        val children = visitChildren(temporalJoin, ModifyKindSetTrait.INSERT_ONLY)\n+        // forward left input changes\n+        val leftTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        createNewNode(temporalJoin, children, leftTrait, requiredTrait, requester)\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |\n+           _: StreamExecPythonCorrelate | _: StreamExecLookupJoin | _: StreamExecExchange |\n+           _: StreamExecExpand | _: StreamExecMiniBatchAssigner |\n+           _: StreamExecWatermarkAssigner =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        val childrenTrait = children.head.getTraitSet.getTrait(ModifyKindSetTraitDef.INSTANCE)\n+        // forward children mode\n+        createNewNode(rel, children, childrenTrait, requiredTrait, requester)\n+\n+      case union: StreamExecUnion =>\n+        // transparent forward requiredTrait to children\n+        val children = visitChildren(rel, requiredTrait, requester)\n+        // union provides all possible kinds of children have\n+        val providedKindSet = ModifyKindSet.union(children.map(getModifyKindSet): _*)\n+        createNewNode(\n+          union, children, new ModifyKindSetTrait(providedKindSet), requiredTrait, requester)\n+\n+      case _: StreamExecDataStreamScan | _: StreamExecTableSourceScan | _: StreamExecValues =>\n+        // DataStream, TableSource and Values only support producing insert-only messages\n+        createNewNode(\n+          rel, List(), ModifyKindSetTrait.INSERT_ONLY, requiredTrait, requester)\n+\n+      case scan: StreamExecIntermediateTableScan =>\n+        val providedTrait = new ModifyKindSetTrait(scan.intermediateTable.modifyKindSet)\n+        createNewNode(scan, List(), providedTrait, requiredTrait, requester)\n+\n+      case _ =>\n+        throw new UnsupportedOperationException(\n+          s\"Unsupported visit for ${rel.getClass.getSimpleName}\")\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait): List[StreamPhysicalRel] = {\n+      visitChildren(parent, requiredChildrenTrait, getNodeName(parent))\n+    }\n+\n+    private def visitChildren(\n+        parent: StreamPhysicalRel,\n+        requiredChildrenTrait: ModifyKindSetTrait,\n+        requester: String): List[StreamPhysicalRel] = {\n+      val newChildren = for (i <- 0 until parent.getInputs.size()) yield {\n+        visitChild(parent, i, requiredChildrenTrait, requester)\n+      }\n+      newChildren.toList\n+    }\n+\n+    private def visitChild(\n+        parent: StreamPhysicalRel,\n+        childOrdinal: Int,\n+        requiredChildTrait: ModifyKindSetTrait,\n+        requester: String): StreamPhysicalRel = {\n+      val child = parent.getInput(childOrdinal).asInstanceOf[StreamPhysicalRel]\n+      this.visit(child, requiredChildTrait, requester)\n+    }\n+\n+    private def getNodeName(rel: StreamPhysicalRel): String = {\n+      val prefix = \"StreamExec\"\n+      val typeName = rel.getRelTypeName\n+      if (typeName.startsWith(prefix)) {\n+        typeName.substring(prefix.length)\n+      } else {\n+        typeName\n+      }\n+    }\n+\n+    private def createNewNode(\n+        node: StreamPhysicalRel,\n+        children: List[StreamPhysicalRel],\n+        providedTrait: ModifyKindSetTrait,\n+        requiredTrait: ModifyKindSetTrait,\n+        requestedOwner: String): StreamPhysicalRel = {\n+      if (!providedTrait.satisfies(requiredTrait)) {\n+        val diff = providedTrait.modifyKindSet.minus(requiredTrait.modifyKindSet)\n+        val diffString = diff.getContainedKinds\n+          .toList.sorted // for deterministic error message\n+          .map(_.toString.toLowerCase)\n+          .mkString(\" and \")\n+        // creates a new node based on the new children, to have a more correct node description\n+        // e.g. description of GroupAggregate is based on the ModifyKindSetTrait of children\n+        val tempNode = node.copy(node.getTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+        val nodeString = tempNode.getRelDetailedDescription\n+        throw new TableException(\n+          s\"$requestedOwner doesn't support consuming $diffString changes \" +\n+          s\"which is produced by node $nodeString\")\n+      }\n+      val newTraitSet = node.getTraitSet.plus(providedTrait)\n+      node.copy(newTraitSet, children).asInstanceOf[StreamPhysicalRel]\n+    }\n+  }\n+\n+  /**\n+   * A visitor which will try to satisfy the required [[UpdateKindTrait]] from root.\n+   *\n+   * <p>After traversed by this visitor, every node should have a correct [[UpdateKindTrait]]\n+   * or returns None if the planner doesn't support to satisfy the required [[UpdateKindTrait]].\n+   */\n+  private class SatisfyUpdateKindTraitVisitor {\n+\n+    /**\n+     * Try to satisfy the required [[UpdateKindTrait]] from root.\n+     *\n+     * <p>Each node will first require a UpdateKindTrait to its children.\n+     * The required UpdateKindTrait may come from the node's parent,\n+     * or come from the node itself, depending on whether the node will destroy\n+     * the trait provided by children or pass the trait from children.\n+     *\n+     * <p>If the node will pass the children's UpdateKindTrait without destroying it,\n+     * then return a new node with new inputs and forwarded UpdateKindTrait.\n+     *\n+     * <p>If the node will destroy the children's UpdateKindTrait, then the node itself\n+     * needs to be converted, or a new node should be generated to satisfy the required trait,\n+     * such as marking itself not to generate UPDATE_BEFORE,\n+     * or generating a new node to filter UPDATE_BEFORE.\n+     *\n+     * @param rel the node who should satisfy the requiredTrait\n+     * @param requiredTrait the required UpdateKindTrait\n+     * @return A converted node which satisfies required traits by input nodes of current node.\n+     *         Or None if required traits cannot be satisfied.\n+     */\n+    def visit(\n+        rel: StreamPhysicalRel,\n+        requiredTrait: UpdateKindTrait): Option[StreamPhysicalRel] = rel match {\n+      case sink: StreamExecSink[_] =>\n+        val childModifyKindSet = getModifyKindSet(sink.getInput)\n+        val onlyAfter = onlyAfterOrNone(childModifyKindSet)\n+        val beforeAndAfter = beforeAfterOrNone(childModifyKindSet)\n+        val sinkRequiredTraits = sink.sink match {\n+          case _: UpsertStreamTableSink[_] =>\n+            // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+            Seq(onlyAfter, beforeAndAfter)\n+          case _: RetractStreamTableSink[_] =>\n+            Seq(beforeAndAfter)\n+          case _: AppendStreamTableSink[_] | _: StreamTableSink[_] =>\n+            Seq(UpdateKindTrait.NONE)\n+          case ds: DataStreamTableSink[_] =>\n+            if (ds.withChangeFlag) {\n+              if (ds.needUpdateBefore) {\n+                Seq(beforeAndAfter)\n+              } else {\n+                // support both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+                Seq(onlyAfter, beforeAndAfter)\n+              }\n+            } else {\n+              Seq(UpdateKindTrait.NONE)\n+            }\n+        }\n+        val children = sinkRequiredTraits.flatMap(t => visitChildren(sink, t))\n+        if (children.isEmpty) {\n+          None\n+        } else {\n+          val sinkTrait = sink.getTraitSet.plus(UpdateKindTrait.NONE)\n+          Some(sink.copy(sinkTrait, children.head).asInstanceOf[StreamPhysicalRel])\n+        }\n+\n+      case _: StreamExecGroupAggregate | _: StreamExecGroupTableAggregate |\n+           _: StreamExecLimit =>\n+        // Aggregate, TableAggregate and Limit requires update_before if there are updates\n+        val requiredChildTrait = beforeAfterOrNone(getModifyKindSet(rel.getInput(0)))\n+        val children = visitChildren(rel, requiredChildTrait)\n+        // use requiredTrait as providedTrait, because they should support all kinds of UpdateKind\n+        createNewNode(rel, children, requiredTrait)\n+\n+      case _: StreamExecGroupWindowAggregate | _: StreamExecGroupWindowTableAggregate |\n+           _: StreamExecDeduplicate | _: StreamExecTemporalSort | _: StreamExecMatch |\n+           _: StreamExecOverAggregate | _: StreamExecWindowJoin =>\n+        // WindowAggregate, WindowTableAggregate, Deduplicate, TemporalSort, CEP, OverAggregate\n+        // and WindowJoin require nothing about UpdateKind.\n+        val children = visitChildren(rel, UpdateKindTrait.NONE)\n+        createNewNode(rel, children, requiredTrait)\n+\n+      case rank: StreamExecRank =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          rank, rank.partitionKey, rank.orderKey)\n+        visitRankStrategies(rankStrategies, requiredTrait, rankStrategy => rank.copy(rankStrategy))\n+\n+      case sortLimit: StreamExecSortLimit =>\n+        val rankStrategies = RankProcessStrategy.analyzeRankProcessStrategies(\n+          sortLimit, ImmutableBitSet.of(), sortLimit.getCollation)\n+        visitRankStrategies(\n+          rankStrategies,\n+          requiredTrait,\n+          rankStrategy => sortLimit.copy(rankStrategy))\n+\n+      case sort: StreamExecSort =>\n+        val requiredChildTrait = beforeAfterOrNone(getModifyKindSet(sort.getInput))\n+        val children = visitChildren(sort, requiredChildTrait)\n+        createNewNode(sort, children, requiredTrait)\n+\n+      case join: StreamExecJoin =>\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.BEFORE_AND_AFTER\n+        val children = join.getInputs.zipWithIndex.map {\n+          case (child, childOrdinal) =>\n+            val physicalChild = child.asInstanceOf[StreamPhysicalRel]\n+            val needUpdateBefore = !join.inputUniqueKeyContainsJoinKey(childOrdinal)\n+            val inputModifyKindSet = getModifyKindSet(physicalChild)\n+            val childRequiredTrait = if (needUpdateBefore || requiredUpdateBeforeByParent) {\n+              beforeAfterOrNone(inputModifyKindSet)\n+            } else {\n+              onlyAfterOrNone(inputModifyKindSet)\n+            }\n+            this.visit(physicalChild, childRequiredTrait)\n+        }\n+        if (children.exists(_.isEmpty)) {\n+          None\n+        } else {\n+          createNewNode(join, Some(children.flatten.toList), requiredTrait)\n+        }\n+\n+      case temporalJoin: StreamExecTemporalJoin =>\n+        // forward required mode to left input\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+        val newLeftOption = this.visit(left, requiredTrait)\n+        // currently temporal join only support insert-only source as the right side\n+        // so it requires nothing about UpdateKind\n+        val newRightOption = this.visit(right, UpdateKindTrait.NONE)\n+        (newLeftOption, newRightOption) match {\n+          case (Some(newLeft), Some(newRight)) =>\n+            val leftTrait = newLeft.getTraitSet.getTrait(UpdateKindTraitDef.INSTANCE)\n+            createNewNode(temporalJoin, Some(List(newLeft, newRight)), leftTrait)\n+          case _ =>\n+            None\n+        }\n+\n+      case _: StreamExecCalc | _: StreamExecPythonCalc | _: StreamExecCorrelate |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a496f496bbe955bd33460443eb53a696f612a68"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2NjQ3Mw==", "bodyText": "why this operator is ignoring update before?", "url": "https://github.com/apache/flink/pull/11674#discussion_r407966473", "createdAt": "2020-04-14T08:43:18Z", "author": {"login": "KurtYoung"}, "path": "flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/api/stream/ExplainTest.xml", "diffHunk": "@@ -45,11 +45,11 @@ LogicalProject(EXPR$0=[$1])\n       +- LogicalTableScan(table=[[default_catalog, default_database, MyTable1]])\n \n == Optimized Logical Plan ==\n-Calc(select=[EXPR$0], updateAsRetraction=[false], accMode=[Acc]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}\n-+- GroupAggregate(groupBy=[a], select=[a, COUNT(*) AS EXPR$0], updateAsRetraction=[false], accMode=[Acc]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}\n-   +- Exchange(distribution=[hash[a]], updateAsRetraction=[true], accMode=[Acc]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}\n-      +- Calc(select=[a], updateAsRetraction=[true], accMode=[Acc]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}\n-         +- DataStreamScan(table=[[default_catalog, default_database, MyTable1]], fields=[a, b, c], updateAsRetraction=[true], accMode=[Acc]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}\n+Calc(select=[EXPR$0], changelogMode=[I,UA]): rowcount = , cumulative cost = {rows, cpu, io, network, memory}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a496f496bbe955bd33460443eb53a696f612a68"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNDk5ODA5", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-393499809", "createdAt": "2020-04-15T06:54:30Z", "commit": {"oid": "b33d8e0e64c7b8302d2f495340d8399b88c3b543"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce56fcd7c4168f70b239f3d62962e5b0146ad5d0", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/ce56fcd7c4168f70b239f3d62962e5b0146ad5d0", "committedDate": "2020-04-15T08:57:31Z", "message": "[FLINK-16887][table-planner-blink] Refactor retraction rules to support inferring ChangelogMode\n\nThis closes #11674"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b33d8e0e64c7b8302d2f495340d8399b88c3b543", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/b33d8e0e64c7b8302d2f495340d8399b88c3b543", "committedDate": "2020-04-14T15:15:49Z", "message": "do not satisfy only_update_before for filters"}, "afterCommit": {"oid": "ce56fcd7c4168f70b239f3d62962e5b0146ad5d0", "author": {"user": {"login": "wuchong", "name": "Jark Wu"}}, "url": "https://github.com/apache/flink/commit/ce56fcd7c4168f70b239f3d62962e5b0146ad5d0", "committedDate": "2020-04-15T08:57:31Z", "message": "[FLINK-16887][table-planner-blink] Refactor retraction rules to support inferring ChangelogMode\n\nThis closes #11674"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNzY1NzI0", "url": "https://github.com/apache/flink/pull/11674#pullrequestreview-393765724", "createdAt": "2020-04-15T13:20:57Z", "commit": {"oid": "ce56fcd7c4168f70b239f3d62962e5b0146ad5d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1988, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}