{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzQyNzM0", "number": 11177, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo0NjoxMVrODiPobQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1OTowMlrODjwbIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM0Mjg1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo0NjoxMVrOFtYuuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODo1NDoyOVrOFuivMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg==", "bodyText": "Why can not we move headOperator.getChainingStrategy() != ChainingStrategy.NEVER into the canBeChainedTo(headOperator) call/check?", "url": "https://github.com/apache/flink/pull/11177#discussion_r383135416", "createdAt": "2020-02-24T08:46:11Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDA0NQ==", "bodyText": "A different question imho. First, is upstream supporting chaining at all? Second, is this specific downstream chainable to the upstream.", "url": "https://github.com/apache/flink/pull/11177#discussion_r384320045", "createdAt": "2020-02-26T07:50:17Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0Nzk1NA==", "bodyText": "I would prefer to have one method to rule them all (to have one definite answer how to handle the chaining strategy), but as you prefer.", "url": "https://github.com/apache/flink/pull/11177#discussion_r384347954", "createdAt": "2020-02-26T08:54:29Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM1MzUxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo1MDozM1rOFtY1HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzo0OToxN1rOFuhAvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg==", "bodyText": "headOperator is a misnomer, as it's not always \"head\". It's just previous/up stream operator.  So at least headOperator -> upStreamOperator ?\nHowever, also maybe optional/subjective, I would expect the call be here head chained with next instead of next chained to head:\nheadOperator.getChainingStrategy().canBeChainedWith/canBeChainedTo(outOperator)\n\nas that's usually how lists/chains are being constructed/traversed - head to tail, so maybe:\ncanBeChainedWith(StreamOperatorFactory<?> downStreamOperator)\n\nafter all?", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137052", "createdAt": "2020-02-24T08:50:33Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTY3OQ==", "bodyText": "Renamed vars in a separate hotfix.\nFor the remainder naming, I think it's the other way around. If I construct head to tail, I'd ask can this node by chained to the head?", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319679", "createdAt": "2020-02-26T07:49:17Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg=="}, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM1OTc0OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo1Mjo0NFrOFtY4ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo1Mjo0NFrOFtY4ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzk3OA==", "bodyText": "Can we add a test coverage in StreamingJobGraphGeneratorTest?", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137978", "createdAt": "2020-02-24T08:52:44Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM3ODE5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo1ODo1N1rOFtZDcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzo0NzoxM1rOFug-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA==", "bodyText": "Do we need this enum? Can not we replace HEAD_AFTER_LEGACY_SOURCE with a check if that we are in a legacy source task and the downStreamOpeartor instanceof YieldingOperatorFactory?", "url": "https://github.com/apache/flink/pull/11177#discussion_r383140720", "createdAt": "2020-02-24T08:58:57Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAwMQ==", "bodyText": "Is yielding the root cause of not chainable to legacy sources? If so, then this is a valid way.\nI'm concerned though that we also disallow chaining of operators that just need access to the mailboxExecutor for submit.", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319001", "createdAt": "2020-02-26T07:47:13Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA=="}, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM4MDg5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOTowMDowM1rOFtZFIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzo0NjoxMlrOFug8sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg==", "bodyText": "Is it working properly? What if we have StreamSource -> OP2 -> OP3 -> AsyncWaitOperator?", "url": "https://github.com/apache/flink/pull/11177#discussion_r383141152", "createdAt": "2020-02-24T09:00:03Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODY0MQ==", "bodyText": "It was not. Good catch.", "url": "https://github.com/apache/flink/pull/11177#discussion_r384318641", "createdAt": "2020-02-26T07:46:12Z", "author": {"login": "AHeise"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg=="}, "originalCommit": {"oid": "7582e3e57ae14236024663a57a82cad7929be085"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjM4NzYxOnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOTowMjoyM1rOFtZI6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOTowMjoyM1rOFtZI6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MjEyMA==", "bodyText": "add a simple mapping function?\ninput = chainEnv.fromElements(1).map(....);", "url": "https://github.com/apache/flink/pull/11177#discussion_r383142120", "createdAt": "2020-02-24T09:02:23Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java", "diffHunk": "@@ -365,10 +365,10 @@ private void testProcessingTime(AsyncDataStream.OutputMode mode) throws Exceptio\n \t}\n \n \t/**\n-\t * Test for the temporary fix to FLINK-13063.\n+\t * Tests FLINK-16219.\n \t */\n \t@Test\n-\tpublic void testAsyncOperatorIsNeverChained() {\n+\tpublic void testAsyncOperatorIsNotChainedToSources() {\n \t\tStreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.getExecutionEnvironment();\n \n \t\tDataStream<Integer> input = chainEnv.fromElements(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d36bd3136fd8b56ee367ee29dc9c92beaf4542a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDE0NzY1OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODo1NjoxMFrOFuiyvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODo1NjoxMFrOFuiyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0ODg2MQ==", "bodyText": "nit: downstream -> downStream & upstream -> upStream. I quickly git grepped the code, and downstream is only used in text/docs. downStream is used in the code.", "url": "https://github.com/apache/flink/pull/11177#discussion_r384348861", "createdAt": "2020-02-26T08:56:10Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -542,14 +542,14 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tphysicalEdgesInOrder.add(edge);\n \n-\t\tInteger downStreamvertexID = edge.getTargetId();\n+\t\tInteger downstreamVertexID = edge.getTargetId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cab8f3199f86009056903418dc31e20313cae21"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODIwMTI5OnYy", "diffSide": "RIGHT", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1OTowMlrOFvvbyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1OTowMlrOFvvbyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNDU1NA==", "bodyText": "Can we unit test this method assuming that StreamNode and StreamGraph are easy to construct/mock?", "url": "https://github.com/apache/flink/pull/11177#discussion_r385604554", "createdAt": "2020-02-28T09:59:02Z", "author": {"login": "pnowojski"}, "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -587,30 +588,54 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamvertexID);\n+\t\t\t\t\theadOfChain, downStreamVertexID);\n \t\t}\n \t}\n \n \tpublic static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\tStreamNode upStreamVertex = streamGraph.getSourceVertex(edge);\n \t\tStreamNode downStreamVertex = streamGraph.getTargetVertex(edge);\n \n-\t\tStreamOperatorFactory<?> headOperator = upStreamVertex.getOperatorFactory();\n-\t\tStreamOperatorFactory<?> outOperator = downStreamVertex.getOperatorFactory();\n-\n \t\treturn downStreamVertex.getInEdges().size() == 1\n-\t\t\t\t&& outOperator != null\n-\t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& areOperatorsChainable(upStreamVertex, downStreamVertex, streamGraph)\n \t\t\t\t&& (edge.getPartitioner() instanceof ForwardPartitioner)\n \t\t\t\t&& edge.getShuffleMode() != ShuffleMode.BATCH\n \t\t\t\t&& upStreamVertex.getParallelism() == downStreamVertex.getParallelism()\n \t\t\t\t&& streamGraph.isChainingEnabled();\n \t}\n \n+\tprivate static boolean areOperatorsChainable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "810b12ab01637f7d70d091922ba9cbf9bc45680e"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 989, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}