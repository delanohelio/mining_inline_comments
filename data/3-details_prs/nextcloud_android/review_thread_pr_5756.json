{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDEyMTY0", "number": 5756, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMjoxMDowN1rODsWzkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowNzoxN1rODsiXnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODM3NTg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/owncloud/android/ui/fragment/contactsbackup/ContactListFragment.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMjoxMDowN1rOF9Ms5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo0OToyM1rOGCKMbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU1Nw==", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399715557", "createdAt": "2020-03-28T22:10:07Z", "author": {"login": "nextcloud-android-bot"}, "path": "src/main/java/com/owncloud/android/ui/fragment/contactsbackup/ContactListFragment.java", "diffHunk": "@@ -409,10 +399,10 @@ private void getAccountForImport() {\n                     String name = cursor.getString(cursor.getColumnIndex(ContactsContract.RawContacts.ACCOUNT_NAME));\n                     String type = cursor.getString(cursor.getColumnIndex(ContactsContract.RawContacts.ACCOUNT_TYPE));\n \n-                    ContactAccount account = new ContactAccount(name, name, type);\n+                    ContactsAccount account = new ContactsAccount(name, name, type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNzM1OA==", "bodyText": "Rename only. No logic chage intended at this tage so I propose we wontfix it.", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r404917358", "createdAt": "2020-04-07T15:49:23Z", "author": {"login": "ezaquarii"}, "path": "src/main/java/com/owncloud/android/ui/fragment/contactsbackup/ContactListFragment.java", "diffHunk": "@@ -409,10 +399,10 @@ private void getAccountForImport() {\n                     String name = cursor.getString(cursor.getColumnIndex(ContactsContract.RawContacts.ACCOUNT_NAME));\n                     String type = cursor.getString(cursor.getColumnIndex(ContactsContract.RawContacts.ACCOUNT_TYPE));\n \n-                    ContactAccount account = new ContactAccount(name, name, type);\n+                    ContactsAccount account = new ContactsAccount(name, name, type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU1Nw=="}, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODM3NTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMjoxMDowOFrOF9Ms5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo0ODoxMFrOGCKIng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU1OQ==", "bodyText": "Issue found: ComplexMethod - 12/10 - [doWork] at /src/src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt:59:18", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399715559", "createdAt": "2020-03-28T22:10:08Z", "author": {"login": "nextcloud-android-bot"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNjM4Mg==", "bodyText": "This is legacy code copied and converted to Kotlin. No changes to logic are intended at this stage to limit the risk.", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r404916382", "createdAt": "2020-04-07T15:48:10Z", "author": {"login": "ezaquarii"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU1OQ=="}, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODM3NTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMjoxMDowOVrOF9Ms6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo0ODoyNVrOGCKJSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU2MQ==", "bodyText": "Issue found: NestedBlockDepth - 4/4 - [doWork] at /src/src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt:59:18", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399715561", "createdAt": "2020-03-28T22:10:09Z", "author": {"login": "nextcloud-android-bot"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNjU1Mg==", "bodyText": "This is legacy code copied and converted to Kotlin. No changes to logic are intended at this stage to limit the risk.", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r404916552", "createdAt": "2020-04-07T15:48:25Z", "author": {"login": "ezaquarii"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU2MQ=="}, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODM3NTkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMjoxMDoxMFrOF9Ms7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo0ODozM1rOGCKJxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU2NQ==", "bodyText": "Issue found: TooGenericExceptionCaught - [e] at /src/src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt:103:18", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399715565", "createdAt": "2020-03-28T22:10:10Z", "author": {"login": "nextcloud-android-bot"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {\n+        val vCardFilePath = inputData.getString(VCARD_FILE_PATH) ?: \"\"\n+        val contactsAccountName = inputData.getString(ACCOUNT_NAME)\n+        val contactsAccountType = inputData.getString(ACCOUNT_TYPE)\n+        val selectedContactsIndices = inputData.getIntArray(SELECTED_CONTACTS_INDICES) ?: IntArray(0)\n+\n+        val file = File(vCardFilePath)\n+        val vCards = ArrayList<VCard>()\n+\n+        var cursor: Cursor? = null\n+        try {\n+            val operations = ContactOperations(applicationContext, contactsAccountName, contactsAccountType)\n+            vCards.addAll(Ezvcard.parse(file).all())\n+            Collections.sort(vCards, VCardComparator())\n+            cursor = contentResolver.query(\n+                ContactsContract.Contacts.CONTENT_URI,\n+                null,\n+                null,\n+                null,\n+                null\n+            )\n+            val ownContactMap = TreeMap<VCard, Long?>(VCardComparator())\n+            if (cursor != null && cursor.count > 0) {\n+                cursor.moveToFirst()\n+                for (i in 0 until cursor.count) {\n+                    val vCard = getContactFromCursor(cursor)\n+                    if (vCard != null) {\n+                        ownContactMap[vCard] = cursor.getLong(cursor.getColumnIndex(\"NAME_RAW_CONTACT_ID\"))\n+                    }\n+                    cursor.moveToNext()\n+                }\n+            }\n+            for (contactIndex in selectedContactsIndices) {\n+                val vCard = vCards[contactIndex]\n+                if (ContactListFragment.getDisplayName(vCard).isEmpty()) {\n+                    if (!ownContactMap.containsKey(vCard)) {\n+                        operations.insertContact(vCard)\n+                    } else {\n+                        operations.updateContact(vCard, ownContactMap[vCard])\n+                    }\n+                } else {\n+                    operations.insertContact(vCard) // Insert All the contacts without name\n+                }\n+            }\n+        } catch (e: Exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNjY3OA==", "bodyText": "This is legacy code copied and converted to Kotlin. No changes to logic are intended at this stage to limit the risk.", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r404916678", "createdAt": "2020-04-07T15:48:33Z", "author": {"login": "ezaquarii"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {\n+        val vCardFilePath = inputData.getString(VCARD_FILE_PATH) ?: \"\"\n+        val contactsAccountName = inputData.getString(ACCOUNT_NAME)\n+        val contactsAccountType = inputData.getString(ACCOUNT_TYPE)\n+        val selectedContactsIndices = inputData.getIntArray(SELECTED_CONTACTS_INDICES) ?: IntArray(0)\n+\n+        val file = File(vCardFilePath)\n+        val vCards = ArrayList<VCard>()\n+\n+        var cursor: Cursor? = null\n+        try {\n+            val operations = ContactOperations(applicationContext, contactsAccountName, contactsAccountType)\n+            vCards.addAll(Ezvcard.parse(file).all())\n+            Collections.sort(vCards, VCardComparator())\n+            cursor = contentResolver.query(\n+                ContactsContract.Contacts.CONTENT_URI,\n+                null,\n+                null,\n+                null,\n+                null\n+            )\n+            val ownContactMap = TreeMap<VCard, Long?>(VCardComparator())\n+            if (cursor != null && cursor.count > 0) {\n+                cursor.moveToFirst()\n+                for (i in 0 until cursor.count) {\n+                    val vCard = getContactFromCursor(cursor)\n+                    if (vCard != null) {\n+                        ownContactMap[vCard] = cursor.getLong(cursor.getColumnIndex(\"NAME_RAW_CONTACT_ID\"))\n+                    }\n+                    cursor.moveToNext()\n+                }\n+            }\n+            for (contactIndex in selectedContactsIndices) {\n+                val vCard = vCards[contactIndex]\n+                if (ContactListFragment.getDisplayName(vCard).isEmpty()) {\n+                    if (!ownContactMap.containsKey(vCard)) {\n+                        operations.insertContact(vCard)\n+                    } else {\n+                        operations.updateContact(vCard, ownContactMap[vCard])\n+                    }\n+                } else {\n+                    operations.insertContact(vCard) // Insert All the contacts without name\n+                }\n+            }\n+        } catch (e: Exception) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNTU2NQ=="}, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI2OTQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowNjo1OFrOF9cIuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowNjo1OFrOF9cIuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2ODQ0MQ==", "bodyText": "shouldn't we rather log the whole exception as in stack trace?", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399968441", "createdAt": "2020-03-30T07:06:58Z", "author": {"login": "AndyScherzinger"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {\n+        val vCardFilePath = inputData.getString(VCARD_FILE_PATH) ?: \"\"\n+        val contactsAccountName = inputData.getString(ACCOUNT_NAME)\n+        val contactsAccountType = inputData.getString(ACCOUNT_TYPE)\n+        val selectedContactsIndices = inputData.getIntArray(SELECTED_CONTACTS_INDICES) ?: IntArray(0)\n+\n+        val file = File(vCardFilePath)\n+        val vCards = ArrayList<VCard>()\n+\n+        var cursor: Cursor? = null\n+        try {\n+            val operations = ContactOperations(applicationContext, contactsAccountName, contactsAccountType)\n+            vCards.addAll(Ezvcard.parse(file).all())\n+            Collections.sort(vCards, VCardComparator())\n+            cursor = contentResolver.query(\n+                ContactsContract.Contacts.CONTENT_URI,\n+                null,\n+                null,\n+                null,\n+                null\n+            )\n+            val ownContactMap = TreeMap<VCard, Long?>(VCardComparator())\n+            if (cursor != null && cursor.count > 0) {\n+                cursor.moveToFirst()\n+                for (i in 0 until cursor.count) {\n+                    val vCard = getContactFromCursor(cursor)\n+                    if (vCard != null) {\n+                        ownContactMap[vCard] = cursor.getLong(cursor.getColumnIndex(\"NAME_RAW_CONTACT_ID\"))\n+                    }\n+                    cursor.moveToNext()\n+                }\n+            }\n+            for (contactIndex in selectedContactsIndices) {\n+                val vCard = vCards[contactIndex]\n+                if (ContactListFragment.getDisplayName(vCard).isEmpty()) {\n+                    if (!ownContactMap.containsKey(vCard)) {\n+                        operations.insertContact(vCard)\n+                    } else {\n+                        operations.updateContact(vCard, ownContactMap[vCard])\n+                    }\n+                } else {\n+                    operations.insertContact(vCard) // Insert All the contacts without name\n+                }\n+            }\n+        } catch (e: Exception) {\n+            logger.e(TAG, \"${e.message}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI3MDM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowNzoxN1rOF9cJUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzozNDowN1rOGCvfyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2ODU5NA==", "bodyText": "same here, no logging of the StackTrace", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r399968594", "createdAt": "2020-03-30T07:07:17Z", "author": {"login": "AndyScherzinger"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {\n+        val vCardFilePath = inputData.getString(VCARD_FILE_PATH) ?: \"\"\n+        val contactsAccountName = inputData.getString(ACCOUNT_NAME)\n+        val contactsAccountType = inputData.getString(ACCOUNT_TYPE)\n+        val selectedContactsIndices = inputData.getIntArray(SELECTED_CONTACTS_INDICES) ?: IntArray(0)\n+\n+        val file = File(vCardFilePath)\n+        val vCards = ArrayList<VCard>()\n+\n+        var cursor: Cursor? = null\n+        try {\n+            val operations = ContactOperations(applicationContext, contactsAccountName, contactsAccountType)\n+            vCards.addAll(Ezvcard.parse(file).all())\n+            Collections.sort(vCards, VCardComparator())\n+            cursor = contentResolver.query(\n+                ContactsContract.Contacts.CONTENT_URI,\n+                null,\n+                null,\n+                null,\n+                null\n+            )\n+            val ownContactMap = TreeMap<VCard, Long?>(VCardComparator())\n+            if (cursor != null && cursor.count > 0) {\n+                cursor.moveToFirst()\n+                for (i in 0 until cursor.count) {\n+                    val vCard = getContactFromCursor(cursor)\n+                    if (vCard != null) {\n+                        ownContactMap[vCard] = cursor.getLong(cursor.getColumnIndex(\"NAME_RAW_CONTACT_ID\"))\n+                    }\n+                    cursor.moveToNext()\n+                }\n+            }\n+            for (contactIndex in selectedContactsIndices) {\n+                val vCard = vCards[contactIndex]\n+                if (ContactListFragment.getDisplayName(vCard).isEmpty()) {\n+                    if (!ownContactMap.containsKey(vCard)) {\n+                        operations.insertContact(vCard)\n+                    } else {\n+                        operations.updateContact(vCard, ownContactMap[vCard])\n+                    }\n+                } else {\n+                    operations.insertContact(vCard) // Insert All the contacts without name\n+                }\n+            }\n+        } catch (e: Exception) {\n+            logger.e(TAG, \"${e.message}\")\n+        } finally {\n+            cursor?.close()\n+        }\n+\n+        return Result.success()\n+    }\n+\n+    private fun getContactFromCursor(cursor: Cursor): VCard? {\n+        val lookupKey = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY))\n+        val uri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_VCARD_URI, lookupKey)\n+        var vCard: VCard? = null\n+        try {\n+            contentResolver.openInputStream(uri).use { inputStream ->\n+                val vCardList = ArrayList<VCard>()\n+                vCardList.addAll(Ezvcard.parse(inputStream).all())\n+                if (vCardList.size > 0) {\n+                    vCard = vCardList[0]\n+                }\n+            }\n+        } catch (e: IOException) {\n+            logger.d(TAG, \"${e.message}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyODUyMg==", "bodyText": "#5835", "url": "https://github.com/nextcloud/android/pull/5756#discussion_r405528522", "createdAt": "2020-04-08T13:34:07Z", "author": {"login": "ezaquarii"}, "path": "src/main/java/com/nextcloud/client/jobs/ContactsImportWork.kt", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2017 Tobias Kaminsky\n+ * Copyright (C) 2017 Nextcloud GmbH.\n+ * Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.nextcloud.client.jobs\n+\n+import android.content.ContentResolver\n+import android.content.Context\n+import android.database.Cursor\n+import android.net.Uri\n+import android.provider.ContactsContract\n+import androidx.work.Worker\n+import androidx.work.WorkerParameters\n+import com.nextcloud.client.logger.Logger\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment\n+import com.owncloud.android.ui.fragment.contactsbackup.ContactListFragment.VCardComparator\n+import ezvcard.Ezvcard\n+import ezvcard.VCard\n+import third_parties.ezvcard_android.ContactOperations\n+import java.io.File\n+import java.io.IOException\n+import java.util.ArrayList\n+import java.util.Collections\n+import java.util.TreeMap\n+\n+class ContactsImportWork(\n+    appContext: Context,\n+    params: WorkerParameters,\n+    private val logger: Logger,\n+    private val contentResolver: ContentResolver\n+) : Worker(appContext, params) {\n+\n+    companion object {\n+        const val TAG = \"ContactsImportWork\"\n+        const val ACCOUNT_TYPE = \"account_type\"\n+        const val ACCOUNT_NAME = \"account_name\"\n+        const val VCARD_FILE_PATH = \"vcard_file_path\"\n+        const val SELECTED_CONTACTS_INDICES = \"selected_contacts_indices\"\n+    }\n+\n+    override fun doWork(): Result {\n+        val vCardFilePath = inputData.getString(VCARD_FILE_PATH) ?: \"\"\n+        val contactsAccountName = inputData.getString(ACCOUNT_NAME)\n+        val contactsAccountType = inputData.getString(ACCOUNT_TYPE)\n+        val selectedContactsIndices = inputData.getIntArray(SELECTED_CONTACTS_INDICES) ?: IntArray(0)\n+\n+        val file = File(vCardFilePath)\n+        val vCards = ArrayList<VCard>()\n+\n+        var cursor: Cursor? = null\n+        try {\n+            val operations = ContactOperations(applicationContext, contactsAccountName, contactsAccountType)\n+            vCards.addAll(Ezvcard.parse(file).all())\n+            Collections.sort(vCards, VCardComparator())\n+            cursor = contentResolver.query(\n+                ContactsContract.Contacts.CONTENT_URI,\n+                null,\n+                null,\n+                null,\n+                null\n+            )\n+            val ownContactMap = TreeMap<VCard, Long?>(VCardComparator())\n+            if (cursor != null && cursor.count > 0) {\n+                cursor.moveToFirst()\n+                for (i in 0 until cursor.count) {\n+                    val vCard = getContactFromCursor(cursor)\n+                    if (vCard != null) {\n+                        ownContactMap[vCard] = cursor.getLong(cursor.getColumnIndex(\"NAME_RAW_CONTACT_ID\"))\n+                    }\n+                    cursor.moveToNext()\n+                }\n+            }\n+            for (contactIndex in selectedContactsIndices) {\n+                val vCard = vCards[contactIndex]\n+                if (ContactListFragment.getDisplayName(vCard).isEmpty()) {\n+                    if (!ownContactMap.containsKey(vCard)) {\n+                        operations.insertContact(vCard)\n+                    } else {\n+                        operations.updateContact(vCard, ownContactMap[vCard])\n+                    }\n+                } else {\n+                    operations.insertContact(vCard) // Insert All the contacts without name\n+                }\n+            }\n+        } catch (e: Exception) {\n+            logger.e(TAG, \"${e.message}\")\n+        } finally {\n+            cursor?.close()\n+        }\n+\n+        return Result.success()\n+    }\n+\n+    private fun getContactFromCursor(cursor: Cursor): VCard? {\n+        val lookupKey = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY))\n+        val uri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_VCARD_URI, lookupKey)\n+        var vCard: VCard? = null\n+        try {\n+            contentResolver.openInputStream(uri).use { inputStream ->\n+                val vCardList = ArrayList<VCard>()\n+                vCardList.addAll(Ezvcard.parse(inputStream).all())\n+                if (vCardList.size > 0) {\n+                    vCard = vCardList[0]\n+                }\n+            }\n+        } catch (e: IOException) {\n+            logger.d(TAG, \"${e.message}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2ODU5NA=="}, "originalCommit": {"oid": "5204ba754105ad62c3cc0c7c9fcf9b4c2508b6fb"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3054, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}