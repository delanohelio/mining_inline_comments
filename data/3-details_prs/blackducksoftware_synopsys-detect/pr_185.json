{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDI5Mjgx", "number": 185, "title": "Sb bazel haskell cabal library rule", "bodyText": "Description\nAdded support for the bazel haskell_cabal_library repository rule. Involved some refactoring to make the bazel detector more generic (flexible enough for non-maven dependencies).", "createdAt": "2020-06-09T19:52:22Z", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185", "merged": true, "mergeCommit": {"oid": "0b532de5251f89dc3294c32af5957d39da7a66d9"}, "closed": true, "closedAt": "2020-06-12T20:17:16Z", "author": {"login": "stevebillings"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoT6C5gH2gAyNDMyMDI5MjgxOjlkZGY4ZGM2YzMwZTNlYzRmZjU0YjBlM2MyODc3YmYwODlhYmVhMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqocRVgFqTQzMDAwMzc4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9ddf8dc6c30e3ec4ff54b0e3c2877bf089abea38", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9ddf8dc6c30e3ec4ff54b0e3c2877bf089abea38", "committedDate": "2020-06-05T14:54:39Z", "message": "refactor: class renaming in preparation for making bazel pipelines more generic, in preparation for adding haskell rule support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d696bb3066847867a170bbb469d3a810eef0aa47", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/d696bb3066847867a170bbb469d3a810eef0aa47", "committedDate": "2020-06-05T14:55:35Z", "message": "feat(bazel): added Pipeline and associated classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faa81daaa4ab7e6f63619c69b4c6e079aec52e48", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/faa81daaa4ab7e6f63619c69b4c6e079aec52e48", "committedDate": "2020-06-05T19:26:24Z", "message": "refactor(bazel): migrating to Pipeline object..."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6ff6fe813fa286ca7e31d129e6ee1da7153cbc7", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/d6ff6fe813fa286ca7e31d129e6ee1da7153cbc7", "committedDate": "2020-06-05T19:51:36Z", "message": "test: adapting tests to new bazel class structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e3f4b7bbeaf71c3e1c0c0ad89aca4f9e1602bef", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/0e3f4b7bbeaf71c3e1c0c0ad89aca4f9e1602bef", "committedDate": "2020-06-05T20:09:37Z", "message": "feat(bazel): added (empty so far) FinalStepJsonProtoHaskellCabalLibrary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf11683fe3b225e821c9416c7cd83960f7e9ea91", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bf11683fe3b225e821c9416c7cd83960f7e9ea91", "committedDate": "2020-06-05T20:10:34Z", "message": "refactor: bazel test pkg rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d9c8a78653a871eb11f80015c27ef39b0083e02", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/6d9c8a78653a871eb11f80015c27ef39b0083e02", "committedDate": "2020-06-05T22:53:05Z", "message": "feat(bazel): Adding FinalStepJsonProtoHaskellCabalLibraries (in progress...)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a308d1f78f605e6067225e587923dc730d83935", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7a308d1f78f605e6067225e587923dc730d83935", "committedDate": "2020-06-07T18:08:02Z", "message": "feat: continued development"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5511fa1b21063019dfc35d235a2bbf7cf2cc4432", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/5511fa1b21063019dfc35d235a2bbf7cf2cc4432", "committedDate": "2020-06-08T13:36:03Z", "message": "feat(bazel): continued work on FinalStepJsonProtoHaskellCabalLibrary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f0109d30800bb6e353cfc9c580950c673419402", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4f0109d30800bb6e353cfc9c580950c673419402", "committedDate": "2020-06-08T16:07:20Z", "message": "feat(bazel): FinalStepJsonProtoHaskellCabalLibraries is passing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "709045abac451a400de3f21b03942209df1de7a2", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/709045abac451a400de3f21b03942209df1de7a2", "committedDate": "2020-06-08T19:11:05Z", "message": "refactor: refactoring bazel haskell"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17fc2d4619777fd3688067fbb55877fff8e614c5", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/17fc2d4619777fd3688067fbb55877fff8e614c5", "committedDate": "2020-06-08T20:16:51Z", "message": "feat(bazel): Added haskell cabal library pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e447fa3f5dfaf3d51c24b0e8beb9b063469505ce", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/e447fa3f5dfaf3d51c24b0e8beb9b063469505ce", "committedDate": "2020-06-08T21:03:11Z", "message": "Merge commit 'd19ad856095068ace4a71441876158ed9f86124c' into sb_bazelHaskellCabalLibraryRule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b167cf68cc19c88921432d495348e80b283cbd0d", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b167cf68cc19c88921432d495348e80b283cbd0d", "committedDate": "2020-06-08T21:17:34Z", "message": "refactor: bazel haskell: naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb535495f7ac01fc77e2597d79887ab1dcfae0d5", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bb535495f7ac01fc77e2597d79887ab1dcfae0d5", "committedDate": "2020-06-08T22:00:30Z", "message": "refactor: bazel haskell refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b5a62b08cdad7e6682cd18a25733c22247a8d00", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9b5a62b08cdad7e6682cd18a25733c22247a8d00", "committedDate": "2020-06-09T18:16:39Z", "message": "Merge branch 'master' into sb_bazelHaskellCabalLibraryRule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b8051b296b3c874aaaeba54d38521101cd32c9", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/93b8051b296b3c874aaaeba54d38521101cd32c9", "committedDate": "2020-06-09T20:40:14Z", "message": "style(help): Added doc for new bazel haskell_cabal_library functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2911792ac2f145c5343b4a0063b6e6a30d664674", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/2911792ac2f145c5343b4a0063b6e6a30d664674", "committedDate": "2020-06-09T20:46:07Z", "message": "style(help): bazel haskell_cabal_library release note"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5ebd5fa03548bf70f0069a26c1b567c52634b9e", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b5ebd5fa03548bf70f0069a26c1b567c52634b9e", "committedDate": "2020-06-09T20:55:49Z", "message": "refactor(bazel): cleaning up code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c78734fba7a71ecdab43545237fb20a41ad21770", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/c78734fba7a71ecdab43545237fb20a41ad21770", "committedDate": "2020-06-09T21:54:16Z", "message": "refactor(bazel): Cleaning up code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/3a198492e8270a5c64ea1428e3c3f66f4df07e91", "committedDate": "2020-06-09T22:29:39Z", "message": "refactor(bazel): code smell cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTA3MTQx", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#pullrequestreview-429107141", "createdAt": "2020-06-11T16:57:29Z", "commit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo1NzozMFrOGimYYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo1NzozMFrOGimYYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzYwMA==", "bodyText": "Did you consider creating gson/pojo model classes?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438933600", "createdAt": "2020-06-11T16:57:30Z", "author": {"login": "taikuukaits"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MDk3NzMx", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#pullrequestreview-429097731", "createdAt": "2020-06-11T16:45:12Z", "commit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0NToxMlrOGil8rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowMToyMFrOGimg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNjUxMQ==", "bodyText": "haskageCompNameVersionToDependency typo?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438926511", "createdAt": "2020-06-11T16:45:12Z", "author": {"login": "JakeMathews"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzE1MQ==", "bodyText": "Can this be smaller? Only include a few dependencies and maybe exclude data we don't parse? It looks like you are only checking the graph for colour.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438933151", "createdAt": "2020-06-11T16:56:42Z", "author": {"login": "JakeMathews"}, "path": "detectable/src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt", "diffHunk": "@@ -0,0 +1,908 @@\n+{\n+  \"results\": [{\n+    \"target\": {\n+      \"type\": \"RULE\",\n+      \"rule\": {\n+        \"name\": \"@stackage//:optparse-applicative\",\n+        \"ruleClass\": \"haskell_cabal_library\",\n+        \"location\": \"/root/.cache/bazel/_bazel_root/cc59a4f96db0d7083a7d7596a883ccd0/external/stackage/BUILD.bazel:528:1\",\n+        \"attribute\": [{\n+          \"name\": \"generator_location\",\n+          \"type\": \"STRING\",\n+          \"stringValue\": \"\",\n+          \"explicitlySpecified\": false,\n+          \"nodep\": false\n+        }, {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNDg2Mg==", "bodyText": "Why not use the GraphAssert class?\nAlso do we have to test that all the component pieces of ExternalId are set correctly? I think comparing the String result from ExternalId::createExternalId should be sufficient.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438934862", "createdAt": "2020-06-11T16:59:43Z", "author": {"login": "JakeMathews"}, "path": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/bazel/functional/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibrariesTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.synopsys.integration.detectable.detectables.bazel.functional.bazel.pipeline.step;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.gson.Gson;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.detectable.detectables.bazel.pipeline.step.FinalStepJsonProtoHaskellCabalLibraries;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public class FinalStepJsonProtoHaskellCabalLibrariesTest {\n+\n+    @Test\n+    public void testStep() throws IntegrationException, IOException {\n+        final File jsonProtoFile = new File(\"src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt\");\n+        final String jsonProtoHaskellCabalLibrary = FileUtils.readFileToString(jsonProtoFile, StandardCharsets.UTF_8);\n+        final FinalStepJsonProtoHaskellCabalLibraries step = new FinalStepJsonProtoHaskellCabalLibraries();\n+        final List<String> input = new ArrayList<>(1);\n+        input.add(jsonProtoHaskellCabalLibrary);\n+        final MutableDependencyGraph graph = step.finish(input);\n+        assertEquals(5, graph.getRootDependencies().size());\n+        boolean foundTargetComp = false;\n+        for (final Dependency dep : graph.getRootDependencies()) {\n+            if (\"colour\".equals(dep.getExternalId().getName())) {\n+                assertEquals(\"hackage\", dep.getExternalId().getForge().getName());\n+                assertEquals(\"/\", dep.getExternalId().getForge().getSeparator());\n+                assertEquals(\"colour\", dep.getExternalId().getName());\n+                assertEquals(\"2.3.5\", dep.getExternalId().getVersion());\n+                assertTrue(StringUtils.isBlank(dep.getExternalId().getGroup()));\n+                assertTrue(StringUtils.isBlank(dep.getExternalId().getArchitecture()));\n+                foundTargetComp = true;\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTgwNg==", "bodyText": "Can Gson not parse this Json?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438935806", "createdAt": "2020-06-11T17:01:20Z", "author": {"login": "JakeMathews"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();\n+        final JsonElement targetElement = resultsArrayMemberObject.get(\"target\");\n+        final JsonObject targetObject = targetElement.getAsJsonObject();\n+        logger.debug(String.format(\"targetType: %s\", targetObject.get(\"type\").toString()));\n+        final JsonElement targetTypeElement = targetObject.get(\"type\");\n+        final String targetTypeValue = targetTypeElement.getAsString();\n+        if (!\"RULE\".equals(targetTypeValue)) {\n+            logger.debug(String.format(\"This is not a rule; skipping it. (It's a %s)\", targetTypeValue));\n+            return Optional.empty();\n+        }\n+        final JsonElement ruleElement = targetObject.get(\"rule\");\n+        final JsonObject ruleObject = ruleElement.getAsJsonObject();\n+        logger.debug(String.format(\"ruleClass: %s\", ruleObject.get(\"ruleClass\").toString()));\n+        final JsonElement ruleClassElement = ruleObject.get(\"ruleClass\");\n+        final String ruleClassValue = ruleClassElement.getAsString();\n+        if (!\"haskell_cabal_library\".equals(ruleClassValue)) {\n+            logger.debug(String.format(\"This is not a haskell_cabal_library rule; skipping it. (It's a %s rule)\", ruleClassValue));\n+            return Optional.empty();\n+        }\n+        return Optional.of(ruleObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTE5MTE2", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#pullrequestreview-429119116", "createdAt": "2020-06-11T17:13:39Z", "commit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzoxMzozOVrOGim7mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzoxMzozOVrOGim7mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjYxOQ==", "bodyText": "I'd like to suggest more separation from parsing from transforming - you could have this Step use a Parser where the parser takes the string and returns say List of HaskellDependency and then the Step knows how to transform them into a dependency that is added to the graph, you are close as it is. I'd think extractHaskellCabalLibraryRule does all the json parsing and returns a well formed HaskellDependency and instead of returning a JsonObject that later work is done to, do all the json work up front and return a pojo. Then addDependencyToGraph doesn't take a JsonObject but takes in the HaskellDependency pojo. Then in your tests you can have a test that checks JsonObject -> HaskellDependency works and a test that List of HaskellDependency -> Graph. Would let you have smaller more isolated tests.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438942619", "createdAt": "2020-06-11T17:13:39Z", "author": {"login": "taikuukaits"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();\n+        final JsonElement targetElement = resultsArrayMemberObject.get(\"target\");\n+        final JsonObject targetObject = targetElement.getAsJsonObject();\n+        logger.debug(String.format(\"targetType: %s\", targetObject.get(\"type\").toString()));\n+        final JsonElement targetTypeElement = targetObject.get(\"type\");\n+        final String targetTypeValue = targetTypeElement.getAsString();\n+        if (!\"RULE\".equals(targetTypeValue)) {\n+            logger.debug(String.format(\"This is not a rule; skipping it. (It's a %s)\", targetTypeValue));\n+            return Optional.empty();\n+        }\n+        final JsonElement ruleElement = targetObject.get(\"rule\");\n+        final JsonObject ruleObject = ruleElement.getAsJsonObject();\n+        logger.debug(String.format(\"ruleClass: %s\", ruleObject.get(\"ruleClass\").toString()));\n+        final JsonElement ruleClassElement = ruleObject.get(\"ruleClass\");\n+        final String ruleClassValue = ruleClassElement.getAsString();\n+        if (!\"haskell_cabal_library\".equals(ruleClassValue)) {\n+            logger.debug(String.format(\"This is not a haskell_cabal_library rule; skipping it. (It's a %s rule)\", ruleClassValue));\n+            return Optional.empty();\n+        }\n+        return Optional.of(ruleObject);\n+    }\n+\n+    private void addDependencyToGraph(final MutableDependencyGraph dependencyGraph, final JsonObject ruleObject) throws IntegrationException {\n+        final JsonElement attributeElement = ruleObject.get(\"attribute\");\n+        final JsonArray attributeArray = attributeElement.getAsJsonArray();\n+\n+        final NameVersion dependencyNameVersion = extractDependencyDetails(attributeArray);\n+        final Dependency artifactDependency = haskageCompNameVersionToDependency(dependencyNameVersion.getName(), dependencyNameVersion.getVersion());\n+        try {\n+            logger.debug(String.format(\"Adding %s to graph\", artifactDependency.getExternalId().toString()));\n+            dependencyGraph.addChildToRoot(artifactDependency);\n+        } catch (final Exception e) {\n+            logger.error(String.format(\"Unable to create dependency from %s/%s\", dependencyNameVersion.getName(), dependencyNameVersion.getVersion()));\n+        }\n+    }\n+\n+    private NameVersion extractDependencyDetails(final JsonArray attributeArray) throws IntegrationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e20586c5e8cafe19170ac5a1c8dfd02d97a6c03", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7e20586c5e8cafe19170ac5a1c8dfd02d97a6c03", "committedDate": "2020-06-11T20:11:54Z", "message": "refactor: addressing code review feedback; first, a few simple changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df41fe04d0c14f80a87b03e5d956ef3813acf6f7", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/df41fe04d0c14f80a87b03e5d956ef3813acf6f7", "committedDate": "2020-06-11T20:43:13Z", "message": "refactor: split parser out from FinalStepJsonProtoHaskellCabalLibraries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8003b59c97da4058bcf4e280ffb223039472a0db", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8003b59c97da4058bcf4e280ffb223039472a0db", "committedDate": "2020-06-11T20:57:22Z", "message": "refactor(bazel): FinalStepJsonProtoHaskellCabalLibraries: inject ExternalIdFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efde127ae6bb9a488aeebcd878a5fe14bb3f39f6", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/efde127ae6bb9a488aeebcd878a5fe14bb3f39f6", "committedDate": "2020-06-11T20:57:43Z", "message": "test: added test for bazel haskell parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b63f863d40eb1a258342269a93f37d5ff58ea28c", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b63f863d40eb1a258342269a93f37d5ff58ea28c", "committedDate": "2020-06-11T21:17:33Z", "message": "refactor: cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc7cad88da4383c60239d44b794d66b506d38cda", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fc7cad88da4383c60239d44b794d66b506d38cda", "committedDate": "2020-06-12T15:35:52Z", "message": "Merge commit '3ce52f077047fe93e76ec3279ba849179a29e73f' into sb_bazelHaskellCabalLibraryRule\n\n# Conflicts:\n#\tdocs/templates/content/90-releasenotes.ftl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "436baebef3e7a7bb3cc3d3b435799867e00253f6", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/436baebef3e7a7bb3cc3d3b435799867e00253f6", "committedDate": "2020-06-12T18:12:22Z", "message": "refactor(bazel): haskell: first cut at pojo based parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1208ac16ebe1d67516f4391b3566fc8e4305eba8", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1208ac16ebe1d67516f4391b3566fc8e4305eba8", "committedDate": "2020-06-12T18:18:32Z", "message": "refactor(bazel): refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb74b2a93ab157cc503435547438fd70e9737d45", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/cb74b2a93ab157cc503435547438fd70e9737d45", "committedDate": "2020-06-12T19:13:50Z", "message": "refactor(bazel): cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba7a46d5cef2f4467787ac9060382685fa02a9a0", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/ba7a46d5cef2f4467787ac9060382685fa02a9a0", "committedDate": "2020-06-12T19:15:09Z", "message": "refactor(bazel): haskell: error checking for unexpected query output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a99560ac09e4a977e295fcadb133eed2b47b5b77", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a99560ac09e4a977e295fcadb133eed2b47b5b77", "committedDate": "2020-06-12T19:17:18Z", "message": "refactor(bazel): cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b802f8ef15ae0689b3ab51126fd6ad604f335185", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b802f8ef15ae0689b3ab51126fd6ad604f335185", "committedDate": "2020-06-12T19:28:07Z", "message": "refactor(bazel): addressing code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90bacda8be709331ae2757c630ffd09d5e867dbe", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/90bacda8be709331ae2757c630ffd09d5e867dbe", "committedDate": "2020-06-12T19:29:08Z", "message": "merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a90217a1b09cd99879c44b0c170ea048b656117", "author": {"user": null}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1a90217a1b09cd99879c44b0c170ea048b656117", "committedDate": "2020-06-12T19:36:23Z", "message": "refactor(bazel): code smell"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDAzNzgy", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#pullrequestreview-430003782", "createdAt": "2020-06-12T19:57:59Z", "commit": {"oid": "1a90217a1b09cd99879c44b0c170ea048b656117"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3328, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}