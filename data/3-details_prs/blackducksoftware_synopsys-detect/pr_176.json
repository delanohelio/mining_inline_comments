{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MDY5NDI0", "number": 176, "title": "DotNet 3", "bodyText": "Description\n\nAdded functionality to determine available dotnet runtimes and programmatically select the appropriate nuget inspector.\nAdded several abstractions for duplicate nuget functionality.", "createdAt": "2020-05-27T19:26:47Z", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176", "merged": true, "mergeCommit": {"oid": "fa3da79847e6af0c50a552ff42e54119070bac15"}, "closed": true, "closedAt": "2020-06-02T19:19:31Z", "author": {"login": "gkillough"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjzG6-gH2gAyNDI0MDY5NDI0OmE4ZDE3MTdhZmI2YjRlNDZkZDY0NzMwM2NhNTllOWNkYTIwMjkxYWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnZdN0AH2gAyNDI0MDY5NDI0OmY1MGMxNGUwYTNhMGU0NGQ2ODVlMDNhMzM4Y2MwYjBkYTBmZDI2NzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a8d1717afb6b4e46dd647303ca59e9cda20291ad", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a8d1717afb6b4e46dd647303ca59e9cda20291ad", "committedDate": "2020-05-22T14:26:09Z", "message": "feat(nuget): Begin implementing support for dotnet 3.1 runtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bf0ca56328aafa79be975ec7f8d59cad1260089", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8bf0ca56328aafa79be975ec7f8d59cad1260089", "committedDate": "2020-05-22T14:26:17Z", "message": "feat(nuget): Add semantic version parsing for dotnet runtimes and logic to determine which runtime to use"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71e80827f6f24ea1dd7ac7b90d8f6fda2f13affe", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/71e80827f6f24ea1dd7ac7b90d8f6fda2f13affe", "committedDate": "2020-05-22T15:11:34Z", "message": "feat(nuget): Make version parsing more generic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54d35c2519c3b0917c2afadd84202373d97cb7d0", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/54d35c2519c3b0917c2afadd84202373d97cb7d0", "committedDate": "2020-05-27T13:42:14Z", "message": "Add artifactory constants for dotnet3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "971dcc60ed218f8e7bf38bc8b745c03a50b89488", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/971dcc60ed218f8e7bf38bc8b745c03a50b89488", "committedDate": "2020-05-27T15:27:04Z", "message": "feat(nuget): Create additional abstraction for redundant nuget code and clean up TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7", "committedDate": "2020-05-27T15:27:25Z", "message": "Merge branch 'master' into gk_support_dotnet_3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTczMTM1", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-419573135", "createdAt": "2020-05-27T20:12:35Z", "commit": {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMjozNVrOGbbddQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMjozNVrOGbbddQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDY0NQ==", "bodyText": "I'd rather we separated the invocation of the command from the parsing and matching - it would make the unit tests simpler.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r431414645", "createdAt": "2020-05-27T20:12:35Z", "author": {"login": "taikuukaits"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/NugetRuntimeResolver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableOutput;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunner;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunnerException;\n+\n+public class NugetRuntimeResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b58ca7464daed344c2e3da25963f107ec859444", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4b58ca7464daed344c2e3da25963f107ec859444", "committedDate": "2020-05-27T20:14:38Z", "message": "fix: resolve sonar code smells"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTc0NjE1", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-419574615", "createdAt": "2020-05-27T20:14:51Z", "commit": {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fc0d76289939b1c4e425e66876a9249ad000d773", "committedDate": "2020-05-28T12:46:07Z", "message": "refactor(nuget): Split dotnet runtime finding and runtime verifying into separate classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzk1MTU2", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-420395156", "createdAt": "2020-05-28T18:49:39Z", "commit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0OTozOVrOGcCJ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0OTozOVrOGcCJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA==", "bodyText": "I think this is improved, but I think we could isolate more if you take in a List runtimes instead of taking the DotNetRuntimeFinder.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432048620", "createdAt": "2020-05-28T18:49:39Z", "author": {"login": "taikuukaits"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"\n+                                                                             + DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER\n+                                                                             + \"(\\\\.[0-9]+){0,2}(\\\\s){1}\\\\[.+\\\\]\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private DotNetRuntimeFinder dotNetRuntimeFinder;\n+\n+    public DotNetRuntimeAvailabilityVerifier(DotNetRuntimeFinder dotNetRuntimeFinder) {\n+        this.dotNetRuntimeFinder = dotNetRuntimeFinder;\n+    }\n+\n+    public boolean isRuntimeAvailable(String semanticVersion) throws DetectableException {\n+        String[] versionTokenStrings = StringUtils.split(semanticVersion, '.');\n+        List<Integer> numericVersionTokens = Arrays.stream(versionTokenStrings)\n+                                                 .filter(NumberUtils::isDigits)\n+                                                 .map(NumberUtils::toInt)\n+                                                 .collect(Collectors.toList());\n+\n+        if (numericVersionTokens.isEmpty()) {\n+            logger.warn(\"Invalid semantic version parameter for dotnet runtime query\");\n+            return false;\n+        }\n+\n+        Integer[] intArray = new Integer[numericVersionTokens.size()];\n+        return isRuntimeAvailable(numericVersionTokens.toArray(intArray));\n+    }\n+\n+    public boolean isRuntimeAvailable(Integer... versionTokens) throws DetectableException {\n+        List<String> runtimes = dotNetRuntimeFinder.listAvailableRuntimes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTEwOTk4", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-420510998", "createdAt": "2020-05-28T21:37:24Z", "commit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTozNzoyNFrOGcHpMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0OTozMlrOGcH9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA==", "bodyText": "Not in love with removing all the finals, but since we don't have an official rule on it, it's fine.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432138544", "createdAt": "2020-05-28T21:37:24Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzOTgzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n          \n          \n            \n                    if (nugetAirGapPath.isPresent()) {\n          \n          \n            \n                        return new File(nugetAirGapPath.get(), childName);\n          \n          \n            \n                    }\n          \n          \n            \n                    throw new DetectableException(\"Could not get the nuget air gap path\");\n          \n          \n            \n                    return airGapInspectorPaths.getNugetInspectorAirGapFile()\n          \n          \n            \n                        .map(nugetAirGapPath -> new File(nugetAirGapPath, childName))\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(\"Could not get the nuget air gap path\"));", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432139837", "createdAt": "2020-05-28T21:40:27Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/AirgapNugetInspectorLocator.java", "diffHunk": "@@ -26,23 +26,39 @@\n import java.util.Optional;\n \n import com.synopsys.integration.detect.workflow.airgap.AirGapInspectorPaths;\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n \n public class AirgapNugetInspectorLocator implements NugetInspectorLocator {\n+    public static final String INSPECTOR_DIR_DOTNET3 = \"nuget_dotnet3\";\n+    public static final String INSPECTOR_DIR_DOTNET = \"nuget_dotnet\";\n+    public static final String INSPECTOR_DIR_CLASSIC = \"nuget_classic\";\n+\n     private final AirGapInspectorPaths airGapInspectorPaths;\n \n-    public AirgapNugetInspectorLocator(final AirGapInspectorPaths airGapInspectorPaths) {\n+    public AirgapNugetInspectorLocator(AirGapInspectorPaths airGapInspectorPaths) {\n         this.airGapInspectorPaths = airGapInspectorPaths;\n     }\n \n     @Override\n-    public File locateExeInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_classic\"); // TODO: Why is there no ifPresent() check?\n+    public File locateDotnet3Inspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET3);\n+    }\n+\n+    @Override\n+    public File locateDotnetInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET);\n     }\n \n     @Override\n-    public File locateDotnetInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_dotnet\"); // TODO: Why is there no ifPresent() check?\n+    public File locateExeInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_CLASSIC);\n+    }\n+\n+    private File locateInspector(String childName) throws DetectableException {\n+        Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n+        if (nugetAirGapPath.isPresent()) {\n+            return new File(nugetAirGapPath.get(), childName);\n+        }\n+        throw new DetectableException(\"Could not get the nuget air gap path\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQ1NA==", "bodyText": "This seems like a very complicated Regex that will match small finite list of Strings. Perhaps a more simple lookup and replace is appropriate.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432140454", "createdAt": "2020-05-28T21:41:50Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjM5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final String overrideVersion;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private final String overrideVersion;\n          \n      \n    \n    \n  \n\nIf overrideVersion is nullable, can you add this annotation?\nIf it isn't actually nullable, why is it wrapped in Optional.ofNullable() below?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432142393", "createdAt": "2020-05-28T21:46:23Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/OnlineNugetInspectorLocator.java", "diffHunk": "@@ -27,36 +27,40 @@\n \n import com.synopsys.integration.detect.workflow.file.DirectoryManager;\n import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.function.ThrowingBiFunction;\n \n public class OnlineNugetInspectorLocator implements NugetInspectorLocator {\n     private final NugetInspectorInstaller nugetInspectorInstaller;\n     private final DirectoryManager directoryManager;\n     private final String overrideVersion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5Mw==", "bodyText": "You are using the wrong version of junit for some of your asserts.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143293", "createdAt": "2020-05-28T21:48:31Z", "author": {"login": "JakeMathews"}, "path": "src/test/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifierTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import org.junit.Assert;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzY5MQ==", "bodyText": "While your at it, could you replace this with a String.format()?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143691", "createdAt": "2020-05-28T21:49:32Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +101,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeVerifier.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n+        if (foundExecutable.isPresent() && foundExecutable.get().exists()) {\n+            String inspectorExecutable = foundExecutable.get().getAbsolutePath();\n+            logger.debug(\"Found nuget inspector: {}\", inspectorExecutable);\n+            return inspectorInitializer.apply(inspectorExecutable);\n         } else {\n-            throw new DetectableException(\"Unable to find nuget inspector named '\" + exeName + \"' in \" + toolsFolder.getAbsolutePath());\n+            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + inspectorName + \" in \" + toolsFolder.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9284befa605a6005182e049036207d27594213fd", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9284befa605a6005182e049036207d27594213fd", "committedDate": "2020-05-29T13:46:57Z", "message": "fix: Resolve several issues discovered in code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71449bce2b74b908cf65248499682ecf21d24600", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/71449bce2b74b908cf65248499682ecf21d24600", "committedDate": "2020-05-29T16:23:27Z", "message": "fix: Replace regex functionality with java code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bb964fc56089f27be817b8393d584b81dc32bdc", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4bb964fc56089f27be817b8393d584b81dc32bdc", "committedDate": "2020-06-01T13:34:01Z", "message": "refactor: Replace POC of dotnet runtime regex alternative with less verbose implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2c90baa54bff4e64cf9ed593db943d27a8b7ae1", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b2c90baa54bff4e64cf9ed593db943d27a8b7ae1", "committedDate": "2020-06-01T14:30:46Z", "message": "refactor: Clean up dotnet runtime parsing logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe6b9786dcd742f815418fa07991d38144373bd4", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fe6b9786dcd742f815418fa07991d38144373bd4", "committedDate": "2020-06-02T12:38:07Z", "message": "Merge branch 'gk_support_dotnet_3_no_regex' into gk_support_dotnet_3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63f520d6d7e3b77dd262431db547099903af669e", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/63f520d6d7e3b77dd262431db547099903af669e", "committedDate": "2020-06-02T12:38:36Z", "message": "Merge branch 'master' into gk_support_dotnet_3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcd5c3fd90a5c7ae624fce221939e5abb9803646", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fcd5c3fd90a5c7ae624fce221939e5abb9803646", "committedDate": "2020-06-02T12:46:40Z", "message": "refactor: Make method name plural"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/5cde737c321f89502e64f6f57ba39629eebd72cd", "committedDate": "2020-06-02T15:35:22Z", "message": "chore: Add copyright header to new files"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODEzNDU0", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-422813454", "createdAt": "2020-06-02T15:42:32Z", "commit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0MjozMlrOGd3u6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0Njo1NVrOGd3_rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NTAxOQ==", "bodyText": "If you could add them back for now that would be great.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433975019", "createdAt": "2020-06-02T15:42:32Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n          \n          \n            \n                    File foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().\n          \n          \n            \n                        .filter(File::exists)\n          \n          \n            \n                        .findFirst()\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(String.format(\"Unable to find nuget inspector, looking for %s in %s\", inspectorName, toolsFolder.toString())));", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433978350", "createdAt": "2020-06-02T15:45:52Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +102,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeManager.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3OTMxMQ==", "bodyText": "I think we don't need the if/else if we do the filtering in the Stream.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433979311", "createdAt": "2020-06-02T15:46:55Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +102,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeManager.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA=="}, "originalCommit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODI1MjM4", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#pullrequestreview-422825238", "createdAt": "2020-06-02T15:55:32Z", "commit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bf080bbf63bfb6d7610665cbd1955d08765384c", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/3bf080bbf63bfb6d7610665cbd1955d08765384c", "committedDate": "2020-06-02T16:15:49Z", "message": "fix: Add finals to local variables based on project preference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f50c14e0a3a0e44d685e03a338cc0b0da0fd2675", "author": {"user": {"login": "gkillough", "name": "Gavin Killough"}}, "url": "https://github.com/blackducksoftware/synopsys-detect/commit/f50c14e0a3a0e44d685e03a338cc0b0da0fd2675", "committedDate": "2020-06-02T18:48:40Z", "message": "Merge branch 'master' into gk_support_dotnet_3"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3320, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}