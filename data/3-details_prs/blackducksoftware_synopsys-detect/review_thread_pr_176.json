{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MDY5NDI0", "number": 176, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMjozNVrOEAQlGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0NTo1MlrOEBzf4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzA3MDk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/NugetRuntimeResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMjozNVrOGbbddQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMjozNVrOGbbddQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDY0NQ==", "bodyText": "I'd rather we separated the invocation of the command from the parsing and matching - it would make the unit tests simpler.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r431414645", "createdAt": "2020-05-27T20:12:35Z", "author": {"login": "taikuukaits"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/NugetRuntimeResolver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableOutput;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunner;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunnerException;\n+\n+public class NugetRuntimeResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDk3NDQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0OTozOVrOGcCJ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTowMjo1OVrOGcLl-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA==", "bodyText": "I think this is improved, but I think we could isolate more if you take in a List runtimes instead of taking the DotNetRuntimeFinder.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432048620", "createdAt": "2020-05-28T18:49:39Z", "author": {"login": "taikuukaits"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"\n+                                                                             + DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER\n+                                                                             + \"(\\\\.[0-9]+){0,2}(\\\\s){1}\\\\[.+\\\\]\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private DotNetRuntimeFinder dotNetRuntimeFinder;\n+\n+    public DotNetRuntimeAvailabilityVerifier(DotNetRuntimeFinder dotNetRuntimeFinder) {\n+        this.dotNetRuntimeFinder = dotNetRuntimeFinder;\n+    }\n+\n+    public boolean isRuntimeAvailable(String semanticVersion) throws DetectableException {\n+        String[] versionTokenStrings = StringUtils.split(semanticVersion, '.');\n+        List<Integer> numericVersionTokens = Arrays.stream(versionTokenStrings)\n+                                                 .filter(NumberUtils::isDigits)\n+                                                 .map(NumberUtils::toInt)\n+                                                 .collect(Collectors.toList());\n+\n+        if (numericVersionTokens.isEmpty()) {\n+            logger.warn(\"Invalid semantic version parameter for dotnet runtime query\");\n+            return false;\n+        }\n+\n+        Integer[] intArray = new Integer[numericVersionTokens.size()];\n+        return isRuntimeAvailable(numericVersionTokens.toArray(intArray));\n+    }\n+\n+    public boolean isRuntimeAvailable(Integer... versionTokens) throws DetectableException {\n+        List<String> runtimes = dotNetRuntimeFinder.listAvailableRuntimes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1OTM3MQ==", "bodyText": "The reason I was hesitant about doing something like that is that it would allow you to pass in an arbitrary list of Strings. Even if we wrapped those Strings in a new type of object (e.g. DotNetRuntimeModel or something), I think these are concerns that are already correctly coupled. Decoupling further would essentially make this a semVer regex util that just so happens to have a constant pattern related to dotnet runtimes. If we want to go that route, that's fine (obviously we would move the runtime pattern constant somewhere else), but I think that is what we're really talking about if we decouple this further.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432059371", "createdAt": "2020-05-28T19:09:05Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"\n+                                                                             + DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER\n+                                                                             + \"(\\\\.[0-9]+){0,2}(\\\\s){1}\\\\[.+\\\\]\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private DotNetRuntimeFinder dotNetRuntimeFinder;\n+\n+    public DotNetRuntimeAvailabilityVerifier(DotNetRuntimeFinder dotNetRuntimeFinder) {\n+        this.dotNetRuntimeFinder = dotNetRuntimeFinder;\n+    }\n+\n+    public boolean isRuntimeAvailable(String semanticVersion) throws DetectableException {\n+        String[] versionTokenStrings = StringUtils.split(semanticVersion, '.');\n+        List<Integer> numericVersionTokens = Arrays.stream(versionTokenStrings)\n+                                                 .filter(NumberUtils::isDigits)\n+                                                 .map(NumberUtils::toInt)\n+                                                 .collect(Collectors.toList());\n+\n+        if (numericVersionTokens.isEmpty()) {\n+            logger.warn(\"Invalid semantic version parameter for dotnet runtime query\");\n+            return false;\n+        }\n+\n+        Integer[] intArray = new Integer[numericVersionTokens.size()];\n+        return isRuntimeAvailable(numericVersionTokens.toArray(intArray));\n+    }\n+\n+    public boolean isRuntimeAvailable(Integer... versionTokens) throws DetectableException {\n+        List<String> runtimes = dotNetRuntimeFinder.listAvailableRuntimes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzI1Ng==", "bodyText": "Gotcha, I can say it is very typical for parsers to take in a list of strings, such as NpmParser. And it is convention we know you can't just pass an arbitrary list of strings. That said I would not be opposed to a small data class like DotNetRuntimeResult(List runtimes).\nPersonally not having to create a mock runtime executable and eliminating the explicit dependency outweigh protecting someone from passing wrong strings. But I would also be fine with what you have. Depends on the type of change that comes in next.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432203256", "createdAt": "2020-05-29T01:02:59Z", "author": {"login": "taikuukaits"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"\n+                                                                             + DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER\n+                                                                             + \"(\\\\.[0-9]+){0,2}(\\\\s){1}\\\\[.+\\\\]\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private DotNetRuntimeFinder dotNetRuntimeFinder;\n+\n+    public DotNetRuntimeAvailabilityVerifier(DotNetRuntimeFinder dotNetRuntimeFinder) {\n+        this.dotNetRuntimeFinder = dotNetRuntimeFinder;\n+    }\n+\n+    public boolean isRuntimeAvailable(String semanticVersion) throws DetectableException {\n+        String[] versionTokenStrings = StringUtils.split(semanticVersion, '.');\n+        List<Integer> numericVersionTokens = Arrays.stream(versionTokenStrings)\n+                                                 .filter(NumberUtils::isDigits)\n+                                                 .map(NumberUtils::toInt)\n+                                                 .collect(Collectors.toList());\n+\n+        if (numericVersionTokens.isEmpty()) {\n+            logger.warn(\"Invalid semantic version parameter for dotnet runtime query\");\n+            return false;\n+        }\n+\n+        Integer[] intArray = new Integer[numericVersionTokens.size()];\n+        return isRuntimeAvailable(numericVersionTokens.toArray(intArray));\n+    }\n+\n+    public boolean isRuntimeAvailable(Integer... versionTokens) throws DetectableException {\n+        List<String> runtimes = dotNetRuntimeFinder.listAvailableRuntimes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTUzMTQ2OnYy", "diffSide": "LEFT", "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTozNzoyNFrOGcHpMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0MjozMlrOGd3u6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA==", "bodyText": "Not in love with removing all the finals, but since we don't have an official rule on it, it's fine.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432138544", "createdAt": "2020-05-28T21:37:24Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzMzA1Mg==", "bodyText": "My save actions are configured based on the Engineer Onboarding on Confluence, but if you guys have a different preference in Detect, I can update the settings for the project accordingly. I assumed the finals were just left over from when we still had that convention mandated.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432433052", "createdAt": "2020-05-29T11:53:05Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NTAxOQ==", "bodyText": "If you could add them back for now that would be great.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433975019", "createdAt": "2020-06-02T15:42:32Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTUzOTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/AirgapNugetInspectorLocator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MDoyN1rOGcHuPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MDoyN1rOGcHuPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzOTgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n          \n          \n            \n                    if (nugetAirGapPath.isPresent()) {\n          \n          \n            \n                        return new File(nugetAirGapPath.get(), childName);\n          \n          \n            \n                    }\n          \n          \n            \n                    throw new DetectableException(\"Could not get the nuget air gap path\");\n          \n          \n            \n                    return airGapInspectorPaths.getNugetInspectorAirGapFile()\n          \n          \n            \n                        .map(nugetAirGapPath -> new File(nugetAirGapPath, childName))\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(\"Could not get the nuget air gap path\"));", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432139837", "createdAt": "2020-05-28T21:40:27Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/AirgapNugetInspectorLocator.java", "diffHunk": "@@ -26,23 +26,39 @@\n import java.util.Optional;\n \n import com.synopsys.integration.detect.workflow.airgap.AirGapInspectorPaths;\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n \n public class AirgapNugetInspectorLocator implements NugetInspectorLocator {\n+    public static final String INSPECTOR_DIR_DOTNET3 = \"nuget_dotnet3\";\n+    public static final String INSPECTOR_DIR_DOTNET = \"nuget_dotnet\";\n+    public static final String INSPECTOR_DIR_CLASSIC = \"nuget_classic\";\n+\n     private final AirGapInspectorPaths airGapInspectorPaths;\n \n-    public AirgapNugetInspectorLocator(final AirGapInspectorPaths airGapInspectorPaths) {\n+    public AirgapNugetInspectorLocator(AirGapInspectorPaths airGapInspectorPaths) {\n         this.airGapInspectorPaths = airGapInspectorPaths;\n     }\n \n     @Override\n-    public File locateExeInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_classic\"); // TODO: Why is there no ifPresent() check?\n+    public File locateDotnet3Inspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET3);\n+    }\n+\n+    @Override\n+    public File locateDotnetInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET);\n     }\n \n     @Override\n-    public File locateDotnetInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_dotnet\"); // TODO: Why is there no ifPresent() check?\n+    public File locateExeInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_CLASSIC);\n+    }\n+\n+    private File locateInspector(String childName) throws DetectableException {\n+        Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n+        if (nugetAirGapPath.isPresent()) {\n+            return new File(nugetAirGapPath.get(), childName);\n+        }\n+        throw new DetectableException(\"Could not get the nuget air gap path\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU0MzU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MTo1MFrOGcHwpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMTo1NzoyMlrOGcZujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQ1NA==", "bodyText": "This seems like a very complicated Regex that will match small finite list of Strings. Perhaps a more simple lookup and replace is appropriate.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432140454", "createdAt": "2020-05-28T21:41:50Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzNDgzMA==", "bodyText": "Yeah, I talked to @ekerwin about regex usage usage yesterday. I will be updating the logic here to be more universally maintainable.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432434830", "createdAt": "2020-05-29T11:57:22Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQ1NA=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU1NTczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/OnlineNugetInspectorLocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0NjoyM1rOGcH4OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjo1MzoyMVrOGcbZJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjM5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final String overrideVersion;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private final String overrideVersion;\n          \n      \n    \n    \n  \n\nIf overrideVersion is nullable, can you add this annotation?\nIf it isn't actually nullable, why is it wrapped in Optional.ofNullable() below?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432142393", "createdAt": "2020-05-28T21:46:23Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/OnlineNugetInspectorLocator.java", "diffHunk": "@@ -27,36 +27,40 @@\n \n import com.synopsys.integration.detect.workflow.file.DirectoryManager;\n import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.function.ThrowingBiFunction;\n \n public class OnlineNugetInspectorLocator implements NugetInspectorLocator {\n     private final NugetInspectorInstaller nugetInspectorInstaller;\n     private final DirectoryManager directoryManager;\n     private final String overrideVersion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MjExOQ==", "bodyText": "This was the state I found the source in and was trying to minimize my impact (I believe it's passed through in a couple places). That said, this is definitely a good change and I'll go ahead and make it.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432462119", "createdAt": "2020-05-29T12:53:21Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/OnlineNugetInspectorLocator.java", "diffHunk": "@@ -27,36 +27,40 @@\n \n import com.synopsys.integration.detect.workflow.file.DirectoryManager;\n import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.function.ThrowingBiFunction;\n \n public class OnlineNugetInspectorLocator implements NugetInspectorLocator {\n     private final NugetInspectorInstaller nugetInspectorInstaller;\n     private final DirectoryManager directoryManager;\n     private final String overrideVersion;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjM5Mw=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU2MTUwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifierTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0ODozMVrOGcH7vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjo1OToyNVrOGcblww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5Mw==", "bodyText": "You are using the wrong version of junit for some of your asserts.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143293", "createdAt": "2020-05-28T21:48:31Z", "author": {"login": "JakeMathews"}, "path": "src/test/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifierTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import org.junit.Assert;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2NTM0Nw==", "bodyText": "Good catch.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432465347", "createdAt": "2020-05-29T12:59:25Z", "author": {"login": "gkillough"}, "path": "src/test/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifierTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import org.junit.Assert;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5Mw=="}, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU2Mzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0OTozMlrOGcH9Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0OTozMlrOGcH9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzY5MQ==", "bodyText": "While your at it, could you replace this with a String.format()?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143691", "createdAt": "2020-05-28T21:49:32Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +101,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeVerifier.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n+        if (foundExecutable.isPresent() && foundExecutable.get().exists()) {\n+            String inspectorExecutable = foundExecutable.get().getAbsolutePath();\n+            logger.debug(\"Found nuget inspector: {}\", inspectorExecutable);\n+            return inspectorInitializer.apply(inspectorExecutable);\n         } else {\n-            throw new DetectableException(\"Unable to find nuget inspector named '\" + exeName + \"' in \" + toolsFolder.getAbsolutePath());\n+            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + inspectorName + \" in \" + toolsFolder.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzI3Nzc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0NTo1MlrOGd377g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0Njo1NVrOGd3_rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n          \n          \n            \n                    File foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().\n          \n          \n            \n                        .filter(File::exists)\n          \n          \n            \n                        .findFirst()\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(String.format(\"Unable to find nuget inspector, looking for %s in %s\", inspectorName, toolsFolder.toString())));", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433978350", "createdAt": "2020-06-02T15:45:52Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +102,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeManager.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3OTMxMQ==", "bodyText": "I think we don't need the if/else if we do the filtering in the Stream.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433979311", "createdAt": "2020-06-02T15:46:55Z", "author": {"login": "JakeMathews"}, "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +102,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeManager.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA=="}, "originalCommit": {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1611, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}