{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjYxMzgz", "number": 198, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMzoyNFrOELxXwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzoyMDo1OVrOELxuqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzc4Njg4OnYy", "diffSide": "RIGHT", "path": "detectable/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMzoyNFrOGtf2aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDo0NzoyOVrOGw5Qbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2MDkzNw==", "bodyText": "I'd really prefer we didn't add configuration as a dependency to detectable - could we create an interface and hide FilterableEnumValue behind it? I'd rather detectables were immune to changes to detect configuration.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r450360937", "createdAt": "2020-07-06T17:03:24Z", "author": {"login": "taikuukaits"}, "path": "detectable/build.gradle", "diffHunk": "@@ -1,4 +1,6 @@\n dependencies {\n+    implementation project(':configuration')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyMjkyNw==", "bodyText": "Removed the new dependency by moving the FilterableEnumValue complexity to DetectableOptionFactory.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r453922927", "createdAt": "2020-07-13T20:47:29Z", "author": {"login": "stevebillings"}, "path": "detectable/build.gradle", "diffHunk": "@@ -1,4 +1,6 @@\n dependencies {\n+    implementation project(':configuration')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2MDkzNw=="}, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzgyODI3OnYy", "diffSide": "RIGHT", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/BazelDetectableOptions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzoxNTo1NFrOGtgP8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDo0ODoxMVrOGw5SBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2NzQ3NA==", "bodyText": "I think this work should move to the configuration factory - imo options shouldn't have logic, they are POJO and should be constructed in a valid state. This would let detectable not need to know about FilterableEnumValue - the configuration just converts that to the appropriate Set and creates a valid option object.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r450367474", "createdAt": "2020-07-06T17:15:54Z", "author": {"login": "taikuukaits"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/BazelDetectableOptions.java", "diffHunk": "@@ -22,30 +22,62 @@\n  */\n package com.synopsys.integration.detectable.detectables.bazel;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n+import java.util.Set;\n+\n+import com.synopsys.integration.configuration.property.types.enumfilterable.FilterableEnumUtils;\n+import com.synopsys.integration.configuration.property.types.enumfilterable.FilterableEnumValue;\n \n public class BazelDetectableOptions {\n     private final String targetName;\n-    private final WorkspaceRule bazelDependencyRule;\n+    private final List<FilterableEnumValue<WorkspaceRule>> bazelDependencyRulesPropertyValues;\n     private final List<String> bazelCqueryAdditionalOptions;\n \n-    public BazelDetectableOptions(final String targetName, final WorkspaceRule bazelDependencyRule,\n-        final List<String> bazelCqueryAdditionalOptions) {\n+    public BazelDetectableOptions(String targetName, List<FilterableEnumValue<WorkspaceRule>> bazelDependencyRulesPropertyValues,\n+        List<String> bazelCqueryAdditionalOptions) {\n         this.targetName = targetName;\n-        this.bazelDependencyRule = bazelDependencyRule;\n+        this.bazelDependencyRulesPropertyValues = bazelDependencyRulesPropertyValues;\n         this.bazelCqueryAdditionalOptions = bazelCqueryAdditionalOptions;\n     }\n \n     public Optional<String> getTargetName() {\n         return Optional.ofNullable(targetName);\n     }\n \n-    public WorkspaceRule getBazelDependencyRule() {\n-        return bazelDependencyRule;\n-    }\n-\n     public List<String> getBazelCqueryAdditionalOptions() {\n         return bazelCqueryAdditionalOptions;\n     }\n+\n+    public Set<WorkspaceRule> getBazelDependencyRules() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyMzMzNA==", "bodyText": "I moved it to DetectableOptionFactory... is that what you meant?", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r453923334", "createdAt": "2020-07-13T20:48:11Z", "author": {"login": "stevebillings"}, "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/BazelDetectableOptions.java", "diffHunk": "@@ -22,30 +22,62 @@\n  */\n package com.synopsys.integration.detectable.detectables.bazel;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n+import java.util.Set;\n+\n+import com.synopsys.integration.configuration.property.types.enumfilterable.FilterableEnumUtils;\n+import com.synopsys.integration.configuration.property.types.enumfilterable.FilterableEnumValue;\n \n public class BazelDetectableOptions {\n     private final String targetName;\n-    private final WorkspaceRule bazelDependencyRule;\n+    private final List<FilterableEnumValue<WorkspaceRule>> bazelDependencyRulesPropertyValues;\n     private final List<String> bazelCqueryAdditionalOptions;\n \n-    public BazelDetectableOptions(final String targetName, final WorkspaceRule bazelDependencyRule,\n-        final List<String> bazelCqueryAdditionalOptions) {\n+    public BazelDetectableOptions(String targetName, List<FilterableEnumValue<WorkspaceRule>> bazelDependencyRulesPropertyValues,\n+        List<String> bazelCqueryAdditionalOptions) {\n         this.targetName = targetName;\n-        this.bazelDependencyRule = bazelDependencyRule;\n+        this.bazelDependencyRulesPropertyValues = bazelDependencyRulesPropertyValues;\n         this.bazelCqueryAdditionalOptions = bazelCqueryAdditionalOptions;\n     }\n \n     public Optional<String> getTargetName() {\n         return Optional.ofNullable(targetName);\n     }\n \n-    public WorkspaceRule getBazelDependencyRule() {\n-        return bazelDependencyRule;\n-    }\n-\n     public List<String> getBazelCqueryAdditionalOptions() {\n         return bazelCqueryAdditionalOptions;\n     }\n+\n+    public Set<WorkspaceRule> getBazelDependencyRules() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2NzQ3NA=="}, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzg0NTU1OnYy", "diffSide": "RIGHT", "path": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/bazel/functional/bazel/BazelExtractorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzoyMDo1OVrOGtgaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDo0ODoyOFrOGw5SpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MDE1MA==", "bodyText": "I think extractors should be tested in a battery test - the size of this test and the amount of mocking needed makes this test difficult to follow and it seems like a good candidate for a battery test. I wouldn't mind discussing this kind of test at large but this to me is what the battery is for.", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r450370150", "createdAt": "2020-07-06T17:20:59Z", "author": {"login": "taikuukaits"}, "path": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/bazel/functional/bazel/BazelExtractorTest.java", "diffHunk": "@@ -191,4 +193,70 @@ public void testMavenInstall() throws ExecutableRunnerException, IntegrationExce\n         assertTrue(foundFailureAccess);\n         assertTrue(foundErrorProneAnnotations);\n     }\n+\n+    @Test\n+    public void testMultipleRuleTypes() throws ExecutableRunnerException, IntegrationException, IOException {\n+        Assumptions.assumeFalse(SystemUtils.IS_OS_WINDOWS);\n+\n+        BazelCommandExecutor bazelCommandExecutor = Mockito.mock(BazelCommandExecutor.class);\n+        BazelVariableSubstitutor bazelVariableSubstitutor = Mockito.mock(BazelVariableSubstitutor.class);\n+        ExternalIdFactory externalIdFactory = new ExternalIdFactory();\n+        File workspaceDir = new File(\".\");\n+        ExecutableRunner executableRunner = Mockito.mock(ExecutableRunner.class);\n+        BazelWorkspace bazelWorkspace = Mockito.mock(BazelWorkspace.class);\n+        Mockito.when(bazelWorkspace.getDependencyRuleTypes()).thenReturn(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL,\n+            WorkspaceRule.HASKELL_CABAL_LIBRARY));\n+        WorkspaceRuleChooser workspaceRuleChooser = Mockito.mock(WorkspaceRuleChooser.class);\n+        Mockito.when(workspaceRuleChooser.choose(\n+            Mockito.eq(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL, WorkspaceRule.HASKELL_CABAL_LIBRARY)),\n+            Mockito.isNull())).thenReturn(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL, WorkspaceRule.HASKELL_CABAL_LIBRARY));\n+        BazelExtractor bazelExtractor = new BazelExtractor(executableRunner, externalIdFactory, workspaceRuleChooser);\n+        File bazelExe = new File(\"/usr/bin/bazel\");\n+\n+        // bazel cquery --noimplicit_deps \"kind(j.*import, deps(//:ProjectRunner))\" --output build\n+        List<String> bazelArgsGetDependenciesMavenInstall = new ArrayList<>();\n+        bazelArgsGetDependenciesMavenInstall.add(\"cquery\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"--noimplicit_deps\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"kind(j.*import, deps(//:ProjectRunner))\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"--output\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"build\");\n+        ExecutableOutput bazelCmdExecutableOutputGetDependenciesMavenInstall = Mockito.mock(ExecutableOutput.class);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesMavenInstall.getReturnCode()).thenReturn(0);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesMavenInstall.getStandardOutput()).thenReturn(\n+            \"jvm_import(\\n  name = \\\"com_google_guava_failureaccess\\\",\\n\" +\n+                \"  tags = [\\\"maven_coordinates=com.google.guava:failureaccess:1.0\\\"],\\n\" +\n+                \"  tags = [\\\"maven_coordinates=com.google.errorprone:error_prone_annotations:2.2.0\\\"],\");\n+        Mockito.when(executableRunner.execute(workspaceDir, bazelExe, bazelArgsGetDependenciesMavenInstall)).thenReturn(bazelCmdExecutableOutputGetDependenciesMavenInstall);\n+\n+        // bazel cquery --noimplicit_deps \"kind(haskell_cabal_library, deps(//:ProjectRunner))\" --output jsonproto\n+        List<String> bazelArgsGetDependenciesHaskellCabalLibrary = new ArrayList<>();\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"cquery\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"--noimplicit_deps\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"kind(haskell_cabal_library, deps(//:ProjectRunner))\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"--output\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"jsonproto\");\n+        ExecutableOutput bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary = Mockito.mock(ExecutableOutput.class);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary.getReturnCode()).thenReturn(0);\n+        File jsonProtoFile = new File(\"src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt\");\n+        String jsonProtoHaskellCabalLibrary = FileUtils.readFileToString(jsonProtoFile, StandardCharsets.UTF_8);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary.getStandardOutput()).thenReturn(jsonProtoHaskellCabalLibrary);\n+        Mockito.when(executableRunner.execute(workspaceDir, bazelExe, bazelArgsGetDependenciesHaskellCabalLibrary)).thenReturn(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary);\n+\n+        Extraction result = bazelExtractor.extract(bazelExe, workspaceDir, bazelWorkspace, \"//:ProjectRunner\", new BazelProjectNameGenerator(), null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyMzQ5Mw==", "bodyText": "Moved to a new battery test", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/198#discussion_r453923493", "createdAt": "2020-07-13T20:48:28Z", "author": {"login": "stevebillings"}, "path": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/bazel/functional/bazel/BazelExtractorTest.java", "diffHunk": "@@ -191,4 +193,70 @@ public void testMavenInstall() throws ExecutableRunnerException, IntegrationExce\n         assertTrue(foundFailureAccess);\n         assertTrue(foundErrorProneAnnotations);\n     }\n+\n+    @Test\n+    public void testMultipleRuleTypes() throws ExecutableRunnerException, IntegrationException, IOException {\n+        Assumptions.assumeFalse(SystemUtils.IS_OS_WINDOWS);\n+\n+        BazelCommandExecutor bazelCommandExecutor = Mockito.mock(BazelCommandExecutor.class);\n+        BazelVariableSubstitutor bazelVariableSubstitutor = Mockito.mock(BazelVariableSubstitutor.class);\n+        ExternalIdFactory externalIdFactory = new ExternalIdFactory();\n+        File workspaceDir = new File(\".\");\n+        ExecutableRunner executableRunner = Mockito.mock(ExecutableRunner.class);\n+        BazelWorkspace bazelWorkspace = Mockito.mock(BazelWorkspace.class);\n+        Mockito.when(bazelWorkspace.getDependencyRuleTypes()).thenReturn(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL,\n+            WorkspaceRule.HASKELL_CABAL_LIBRARY));\n+        WorkspaceRuleChooser workspaceRuleChooser = Mockito.mock(WorkspaceRuleChooser.class);\n+        Mockito.when(workspaceRuleChooser.choose(\n+            Mockito.eq(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL, WorkspaceRule.HASKELL_CABAL_LIBRARY)),\n+            Mockito.isNull())).thenReturn(Sets.newHashSet(WorkspaceRule.MAVEN_INSTALL, WorkspaceRule.HASKELL_CABAL_LIBRARY));\n+        BazelExtractor bazelExtractor = new BazelExtractor(executableRunner, externalIdFactory, workspaceRuleChooser);\n+        File bazelExe = new File(\"/usr/bin/bazel\");\n+\n+        // bazel cquery --noimplicit_deps \"kind(j.*import, deps(//:ProjectRunner))\" --output build\n+        List<String> bazelArgsGetDependenciesMavenInstall = new ArrayList<>();\n+        bazelArgsGetDependenciesMavenInstall.add(\"cquery\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"--noimplicit_deps\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"kind(j.*import, deps(//:ProjectRunner))\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"--output\");\n+        bazelArgsGetDependenciesMavenInstall.add(\"build\");\n+        ExecutableOutput bazelCmdExecutableOutputGetDependenciesMavenInstall = Mockito.mock(ExecutableOutput.class);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesMavenInstall.getReturnCode()).thenReturn(0);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesMavenInstall.getStandardOutput()).thenReturn(\n+            \"jvm_import(\\n  name = \\\"com_google_guava_failureaccess\\\",\\n\" +\n+                \"  tags = [\\\"maven_coordinates=com.google.guava:failureaccess:1.0\\\"],\\n\" +\n+                \"  tags = [\\\"maven_coordinates=com.google.errorprone:error_prone_annotations:2.2.0\\\"],\");\n+        Mockito.when(executableRunner.execute(workspaceDir, bazelExe, bazelArgsGetDependenciesMavenInstall)).thenReturn(bazelCmdExecutableOutputGetDependenciesMavenInstall);\n+\n+        // bazel cquery --noimplicit_deps \"kind(haskell_cabal_library, deps(//:ProjectRunner))\" --output jsonproto\n+        List<String> bazelArgsGetDependenciesHaskellCabalLibrary = new ArrayList<>();\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"cquery\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"--noimplicit_deps\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"kind(haskell_cabal_library, deps(//:ProjectRunner))\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"--output\");\n+        bazelArgsGetDependenciesHaskellCabalLibrary.add(\"jsonproto\");\n+        ExecutableOutput bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary = Mockito.mock(ExecutableOutput.class);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary.getReturnCode()).thenReturn(0);\n+        File jsonProtoFile = new File(\"src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt\");\n+        String jsonProtoHaskellCabalLibrary = FileUtils.readFileToString(jsonProtoFile, StandardCharsets.UTF_8);\n+        Mockito.when(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary.getStandardOutput()).thenReturn(jsonProtoHaskellCabalLibrary);\n+        Mockito.when(executableRunner.execute(workspaceDir, bazelExe, bazelArgsGetDependenciesHaskellCabalLibrary)).thenReturn(bazelCmdExecutableOutputGetDependenciesHaskellCabalLibrary);\n+\n+        Extraction result = bazelExtractor.extract(bazelExe, workspaceDir, bazelWorkspace, \"//:ProjectRunner\", new BazelProjectNameGenerator(), null, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MDE1MA=="}, "originalCommit": {"oid": "0a2dc2a319d36459d8d3527c392e6f9f42b01849"}, "originalPosition": 239}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1631, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}