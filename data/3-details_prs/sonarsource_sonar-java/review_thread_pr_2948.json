{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MjM1MDc0", "number": 2948, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODoyODowOVrOD6JScw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODozMzozMlrOD6JaOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjk2MTc5OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODoyODowOVrOGRz6iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODoyODowOVrOGRz6iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTU0NQ==", "bodyText": "\ud83d\ude31 the previous implementation of the rule was complex and not using the MethodMatchers API.\nwe should use a matcher like:\n  private static final MethodMatchers PRINT_STACK_TRACE_MATCHER = MethodMatchers.create()\n    .ofSubTypes(\"java.lang.Throwable\").names(\"printStackTrace\").addWithoutParametersMatcher().build();\n\nthem checkMethodInvocation will become far more easier to read:\n  private void checkMethodInvocation(MethodInvocationTree tree) {\n    if (PRINT_STACK_TRACE_MATCHER.matches(tree)) {\n      reportIssue(ExpressionUtils.methodName(tree), MESSAGE);\n    }\n  }", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421329545", "createdAt": "2020-05-07T08:28:09Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -19,32 +19,74 @@\n  */\n package org.sonar.java.checks.security;\n \n-import java.util.Collections;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Objects;\n import javax.annotation.CheckForNull;\n import org.sonar.check.Rule;\n import org.sonar.java.checks.helpers.ExpressionsHelper;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n import org.sonar.plugins.java.api.tree.AnnotationTree;\n import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S4507\")\n public class DebugFeatureEnabledCheck extends IssuableSubscriptionVisitor {\n \n   private static final String MESSAGE = \"Make sure this debug feature is deactivated before delivering the code in production.\";\n \n+  private final Deque<Symbol.TypeSymbol> enclosingClass = new LinkedList<>();\n+\n   @Override\n   public List<Tree.Kind> nodesToVisit() {\n-    return Collections.singletonList(Tree.Kind.ANNOTATION);\n+    return Arrays.asList(Tree.Kind.ANNOTATION, Tree.Kind.CLASS, Tree.Kind.METHOD_INVOCATION);\n   }\n \n   @Override\n   public void visitNode(Tree tree) {\n-    AnnotationTree annotation = (AnnotationTree) tree;\n+    switch (tree.kind()) {\n+      case ANNOTATION:\n+        checkAnnotation((AnnotationTree) tree);\n+        break;\n+      case METHOD_INVOCATION:\n+        checkMethodInvocation((MethodInvocationTree) tree);\n+        break;\n+      default:\n+        ClassTree classTree = (ClassTree) tree;\n+        enclosingClass.push(classTree.symbol());\n+        break;\n+    }\n+  }\n+\n+  @Override\n+  public void leaveNode(Tree tree) {\n+    if (tree instanceof ClassTree) {\n+      enclosingClass.pop();\n+    }\n+  }\n+\n+  private void checkMethodInvocation(MethodInvocationTree tree) {\n+    if (tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) tree.methodSelect();\n+      IdentifierTree identifierTree = memberSelectExpressionTree.identifier();\n+      if (!enclosingClassExtendsThrowable()\n+        && \"printStackTrace\".equals(identifierTree.name())\n+        && calledOnTypeInheritedFromThrowable(memberSelectExpressionTree.expression())\n+        && tree.arguments().isEmpty()) {\n+        reportIssue(identifierTree, MESSAGE);\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "837b76177ce7d09f217cd07e3bdb6307cfaed247"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjk4MTcwOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODozMzozMlrOGR0HhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMToxMzoyNlrOGR5xYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ==", "bodyText": "With a MethodMatcher:\n\nthe above two methods can be removed\nenclosingClass field can be removed\nnodesToVisit() on  Tree.Kind.CLASS can be removed\nleaveNode() can be removed\n\n\ud83d\ude0e", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421332869", "createdAt": "2020-05-07T08:33:32Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -67,4 +109,12 @@ private static AssignmentExpressionTree getDebugArgument(ExpressionTree expressi\n     return null;\n   }\n \n+  private boolean enclosingClassExtendsThrowable() {\n+    return enclosingClass.peek() != null && enclosingClass.peek().type().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean calledOnTypeInheritedFromThrowable(ExpressionTree tree) {\n+    return tree.symbolType().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "837b76177ce7d09f217cd07e3bdb6307cfaed247"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5ODY2Mw==", "bodyText": "The enclosingClassExtendsThrowable method (along witht the enclosingClass field) is there to prevent issues from being reported when calling printWithStackTrace inside classes extending Throwable.\nAs far as I can tell there's no way to say \"Don't match when inside a class inheriting from X\" with MethodMatchers, so that part of the code seems to still be necessary.", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421398663", "createdAt": "2020-05-07T10:21:17Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -67,4 +109,12 @@ private static AssignmentExpressionTree getDebugArgument(ExpressionTree expressi\n     return null;\n   }\n \n+  private boolean enclosingClassExtendsThrowable() {\n+    return enclosingClass.peek() != null && enclosingClass.peek().type().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean calledOnTypeInheritedFromThrowable(ExpressionTree tree) {\n+    return tree.symbolType().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ=="}, "originalCommit": {"oid": "837b76177ce7d09f217cd07e3bdb6307cfaed247"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyNTUwNw==", "bodyText": "You are right, we need to keep enclosingClass, I didn't understand it correctly previously.", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421425507", "createdAt": "2020-05-07T11:13:26Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -67,4 +109,12 @@ private static AssignmentExpressionTree getDebugArgument(ExpressionTree expressi\n     return null;\n   }\n \n+  private boolean enclosingClassExtendsThrowable() {\n+    return enclosingClass.peek() != null && enclosingClass.peek().type().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean calledOnTypeInheritedFromThrowable(ExpressionTree tree) {\n+    return tree.symbolType().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ=="}, "originalCommit": {"oid": "837b76177ce7d09f217cd07e3bdb6307cfaed247"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3992, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}