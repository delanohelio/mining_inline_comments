{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NTgzNTYy", "number": 3291, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDoxOToyNVrOE7j4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDo1MTo0NlrOE7kuXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODg5MjcxOnYy", "diffSide": "RIGHT", "path": "java-checks-test-sources/src/main/java/checks/ReplaceLambdaByMethodRefCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDoxOToyNVrOH3Rmpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDoxOToyNVrOH3Rmpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcyMjE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return i -> (R) i; // Compliant, 'R.class::cast' wont compile.\n          \n          \n            \n                return i -> (R) i; // Compliant, 'R.class::cast' won't compile.", "url": "https://github.com/SonarSource/sonar-java/pull/3291#discussion_r527722150", "createdAt": "2020-11-20T14:19:25Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks-test-sources/src/main/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -143,6 +165,10 @@ void test2(Object param) {\n     });\n   }\n \n+  private static <I, R> Function<I, R> castingIdentity() {\n+    return i -> (R) i; // Compliant, 'R.class::cast' wont compile.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d407f508fb86c8170c79718885ac2cf5da131a0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTAzMTM1OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDo1MTo0NlrOH3S6ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNToyMTo0M1rOH3UHAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MzU4OQ==", "bodyText": "There is no such thing as an IdentifierTree not being an IdentifierTreeImpl, so the first test is useless.\nNow, I'm afraid I don't understand what you try to achieve here.\nTesting if we are in the presence of a raw type of a generic type? For instance (List) obj ?\nWhatever it is, we have a way to express this through our own API rather than relying on the toString() of the eclipse binding.", "url": "https://github.com/SonarSource/sonar-java/pull/3291#discussion_r527743589", "createdAt": "2020-11-20T14:51:46Z", "author": {"login": "m-g-sonar"}, "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -130,12 +135,32 @@ private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Sy\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), symbol)) {\n-        return Optional.of(typeCastTree.type().symbolType().name());\n+        return getTypeName(typeCastTree.type());\n       }\n     }\n     return Optional.empty();\n   }\n+  \n+  private static Optional<String> getTypeName(TypeTree type) {\n+    if (type.is(Tree.Kind.PARAMETERIZED_TYPE)) {\n+      type = ((ParameterizedTypeTree) type).type();\n+    }\n+    if (type.is(Tree.Kind.IDENTIFIER) && !isGeneric((IdentifierTree) type)) {\n+      return Optional.of(((IdentifierTree) type).name());\n+    }\n+    if (type.is(Tree.Kind.ARRAY_TYPE)) {\n+      return getTypeName(((ArrayTypeTree) type).type()).map(x -> x + \"[]\");\n+    }\n+    if (type.is(Tree.Kind.PRIMITIVE_TYPE)) {\n+      return Optional.of(((PrimitiveTypeTree) type).keyword().text());\n+    }\n+    return Optional.empty();\n+  }\n \n+  private static boolean isGeneric(IdentifierTree identifierTree) {\n+    return (identifierTree instanceof IdentifierTreeImpl) && ((IdentifierTreeImpl) identifierTree).binding.toString().matches(\"<[A-Z]>\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "395d42ce77e3243e8481cdd06702c9051121ebc2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0NjYwMA==", "bodyText": "That's a case when we're inside a parametrized method\n  private static <I, R> Function<I, R> castingIdentity() {\n    return i -> (R) i; // Compliant, 'R.class::cast' wont compile.\n  }\n\n'R.class' doesn't compile, but it's still catched as identifier.", "url": "https://github.com/SonarSource/sonar-java/pull/3291#discussion_r527746600", "createdAt": "2020-11-20T14:56:18Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -130,12 +135,32 @@ private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Sy\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), symbol)) {\n-        return Optional.of(typeCastTree.type().symbolType().name());\n+        return getTypeName(typeCastTree.type());\n       }\n     }\n     return Optional.empty();\n   }\n+  \n+  private static Optional<String> getTypeName(TypeTree type) {\n+    if (type.is(Tree.Kind.PARAMETERIZED_TYPE)) {\n+      type = ((ParameterizedTypeTree) type).type();\n+    }\n+    if (type.is(Tree.Kind.IDENTIFIER) && !isGeneric((IdentifierTree) type)) {\n+      return Optional.of(((IdentifierTree) type).name());\n+    }\n+    if (type.is(Tree.Kind.ARRAY_TYPE)) {\n+      return getTypeName(((ArrayTypeTree) type).type()).map(x -> x + \"[]\");\n+    }\n+    if (type.is(Tree.Kind.PRIMITIVE_TYPE)) {\n+      return Optional.of(((PrimitiveTypeTree) type).keyword().text());\n+    }\n+    return Optional.empty();\n+  }\n \n+  private static boolean isGeneric(IdentifierTree identifierTree) {\n+    return (identifierTree instanceof IdentifierTreeImpl) && ((IdentifierTreeImpl) identifierTree).binding.toString().matches(\"<[A-Z]>\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MzU4OQ=="}, "originalCommit": {"oid": "395d42ce77e3243e8481cdd06702c9051121ebc2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc1MTk2Ng==", "bodyText": "So I think this method should help:\nhttps://github.com/SonarSource/sonar-java/blob/master/java-frontend/src/main/java/org/sonar/java/model/JUtils.java#L94\nWhich would make:\nreturn JUtils.isTypeVar(identiferTree.symbolType());", "url": "https://github.com/SonarSource/sonar-java/pull/3291#discussion_r527751966", "createdAt": "2020-11-20T15:04:22Z", "author": {"login": "m-g-sonar"}, "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -130,12 +135,32 @@ private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Sy\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), symbol)) {\n-        return Optional.of(typeCastTree.type().symbolType().name());\n+        return getTypeName(typeCastTree.type());\n       }\n     }\n     return Optional.empty();\n   }\n+  \n+  private static Optional<String> getTypeName(TypeTree type) {\n+    if (type.is(Tree.Kind.PARAMETERIZED_TYPE)) {\n+      type = ((ParameterizedTypeTree) type).type();\n+    }\n+    if (type.is(Tree.Kind.IDENTIFIER) && !isGeneric((IdentifierTree) type)) {\n+      return Optional.of(((IdentifierTree) type).name());\n+    }\n+    if (type.is(Tree.Kind.ARRAY_TYPE)) {\n+      return getTypeName(((ArrayTypeTree) type).type()).map(x -> x + \"[]\");\n+    }\n+    if (type.is(Tree.Kind.PRIMITIVE_TYPE)) {\n+      return Optional.of(((PrimitiveTypeTree) type).keyword().text());\n+    }\n+    return Optional.empty();\n+  }\n \n+  private static boolean isGeneric(IdentifierTree identifierTree) {\n+    return (identifierTree instanceof IdentifierTreeImpl) && ((IdentifierTreeImpl) identifierTree).binding.toString().matches(\"<[A-Z]>\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MzU4OQ=="}, "originalCommit": {"oid": "395d42ce77e3243e8481cdd06702c9051121ebc2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc2MzIwMg==", "bodyText": "Thanks, That helped :)", "url": "https://github.com/SonarSource/sonar-java/pull/3291#discussion_r527763202", "createdAt": "2020-11-20T15:21:43Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -130,12 +135,32 @@ private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Sy\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), symbol)) {\n-        return Optional.of(typeCastTree.type().symbolType().name());\n+        return getTypeName(typeCastTree.type());\n       }\n     }\n     return Optional.empty();\n   }\n+  \n+  private static Optional<String> getTypeName(TypeTree type) {\n+    if (type.is(Tree.Kind.PARAMETERIZED_TYPE)) {\n+      type = ((ParameterizedTypeTree) type).type();\n+    }\n+    if (type.is(Tree.Kind.IDENTIFIER) && !isGeneric((IdentifierTree) type)) {\n+      return Optional.of(((IdentifierTree) type).name());\n+    }\n+    if (type.is(Tree.Kind.ARRAY_TYPE)) {\n+      return getTypeName(((ArrayTypeTree) type).type()).map(x -> x + \"[]\");\n+    }\n+    if (type.is(Tree.Kind.PRIMITIVE_TYPE)) {\n+      return Optional.of(((PrimitiveTypeTree) type).keyword().text());\n+    }\n+    return Optional.empty();\n+  }\n \n+  private static boolean isGeneric(IdentifierTree identifierTree) {\n+    return (identifierTree instanceof IdentifierTreeImpl) && ((IdentifierTreeImpl) identifierTree).binding.toString().matches(\"<[A-Z]>\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MzU4OQ=="}, "originalCommit": {"oid": "395d42ce77e3243e8481cdd06702c9051121ebc2"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3839, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}