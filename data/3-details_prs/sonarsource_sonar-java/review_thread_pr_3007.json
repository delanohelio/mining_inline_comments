{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNDg4MTcw", "number": 3007, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMjozNDozM1rOEFCtGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo0NTo1N1rOEFEG0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzIyNjQ4OnYy", "diffSide": "RIGHT", "path": "java-checks-test-sources/src/main/java/checks/AssertJConsecutiveAssertionCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMjozNDozM1rOGjCS6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1OToyNFrOGjnLWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM5MDk1Mg==", "bodyText": "You should add a second consecutive assertThat, to be sure to test that there is no issue.", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439390952", "createdAt": "2020-06-12T12:34:33Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks-test-sources/src/main/java/checks/AssertJConsecutiveAssertionCheck.java", "diffHunk": "@@ -193,6 +193,11 @@ void assert_on_member_select_7() {\n     assertThat(fof.field.list.length).isNotEqualTo(1);\n   }\n \n+  @Test\n+  void assert_on_constructor() {\n+    assertThat(new java.util.Random()).isNotEqualTo(new java.util.Random()); // Compliant", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NTIyNw==", "bodyText": "\ud83d\ude16 I just repeat 10 times in my head MAKE YOUR TEST FAIL FIRST!", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439995227", "createdAt": "2020-06-15T07:59:24Z", "author": {"login": "alban-auzeill"}, "path": "java-checks-test-sources/src/main/java/checks/AssertJConsecutiveAssertionCheck.java", "diffHunk": "@@ -193,6 +193,11 @@ void assert_on_member_select_7() {\n     assertThat(fof.field.list.length).isNotEqualTo(1);\n   }\n \n+  @Test\n+  void assert_on_constructor() {\n+    assertThat(new java.util.Random()).isNotEqualTo(new java.util.Random()); // Compliant", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM5MDk1Mg=="}, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzI2MjgzOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMjo0NTo1MVrOGjCotg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMjo0NTo1MVrOGjCotg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM5NjUzNA==", "bodyText": "You are never testing secondary locations in any tests.", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439396534", "createdAt": "2020-06-12T12:45:51Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(2), mit.arguments().get(1));\n+    } else if (JUNIT4_ASSERTIONS_WITHOUT_MESSAGE.matches(mit) || JUNIT5_ASSERTIONS.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(1), mit.arguments().get(0));\n+    } else {\n+      // AssertJ or FestAssert\n+      ExpressionTree actualExpression = mit.arguments().get(0);\n+      consecutiveMethodIgnoringMessageDescription(mit)\n+        .filter(ASSERTJ_AND_FEST_ASSERT_PREDICATES::matches)\n+        .ifPresent(predicate -> checkActualAndExpectedExpression(methodName(predicate).name(), actualExpression, predicate.arguments().get(0)));\n+    }\n+  }\n+\n+  private void checkActualAndExpectedExpression(String predicateMethodName, ExpressionTree actualExpression, ExpressionTree expectedExpression) {\n+    if (ExpressionsHelper.alwaysReturnSameValue(actualExpression) &&\n+      SyntacticEquivalence.areEquivalent(actualExpression, expectedExpression) &&\n+      !isLegitimateSelfComparison(predicateMethodName, actualExpression)) {\n+      List<Location> secondaryLocations = Collections.singletonList(new Location(\"actual\", actualExpression));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzI5ODE4OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMjo1NzoxN1rOGjC-RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowNzowNlrOGjnbwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwMjA1Mw==", "bodyText": "I don't think this is a wise use of AbstractMethodDetection, you end up calling many matchers twice. I would prefer to directly go for an IssuableSubscriptionVisitor.", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439402053", "createdAt": "2020-06-12T12:57:17Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5OTQyNg==", "bodyText": "Good advice, I don't need to visit NEW_CLASS and METHOD_REFERENCE, and it's easier.", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439999426", "createdAt": "2020-06-15T08:07:06Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwMjA1Mw=="}, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzMzMTYzOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzowODowNVrOGjDTTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzowODowNVrOGjDTTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNzQzNg==", "bodyText": "We should use @VisibleForTesting here.\nSame for classSymbolOfTheUnitTest.", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439407436", "createdAt": "2020-06-12T13:08:05Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(2), mit.arguments().get(1));\n+    } else if (JUNIT4_ASSERTIONS_WITHOUT_MESSAGE.matches(mit) || JUNIT5_ASSERTIONS.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(1), mit.arguments().get(0));\n+    } else {\n+      // AssertJ or FestAssert\n+      ExpressionTree actualExpression = mit.arguments().get(0);\n+      consecutiveMethodIgnoringMessageDescription(mit)\n+        .filter(ASSERTJ_AND_FEST_ASSERT_PREDICATES::matches)\n+        .ifPresent(predicate -> checkActualAndExpectedExpression(methodName(predicate).name(), actualExpression, predicate.arguments().get(0)));\n+    }\n+  }\n+\n+  private void checkActualAndExpectedExpression(String predicateMethodName, ExpressionTree actualExpression, ExpressionTree expectedExpression) {\n+    if (ExpressionsHelper.alwaysReturnSameValue(actualExpression) &&\n+      SyntacticEquivalence.areEquivalent(actualExpression, expectedExpression) &&\n+      !isLegitimateSelfComparison(predicateMethodName, actualExpression)) {\n+      List<Location> secondaryLocations = Collections.singletonList(new Location(\"actual\", actualExpression));\n+      reportIssue(expectedExpression, MESSAGE, secondaryLocations, null);\n+    }\n+  }\n+\n+  private static boolean isLegitimateSelfComparison(String comparisonMethodName, ExpressionTree actualExpression) {\n+    // In a unit test validating \"equals\" and \"hashCode\" methods, it's legitimate to compare an object to itself.\n+    // In other kinds of tests, it's a bug. But it's complicated to know if a unit test is about validating the\n+    // \"equals\" method or not. The following trade-off allows the self-comparison of an object if the unit test\n+    // package is related to the tested object package.\n+    Type actualExpressionType = actualExpression.symbolType();\n+    return EQUALS_HASH_CODE_METHODS.contains(comparisonMethodName) &&\n+      !isPrimitiveOrNull(actualExpressionType) &&\n+      arePackageRelated(\n+        packageOf(actualExpressionType.symbol()),\n+        packageOf(classSymbolOfTheUnitTest(actualExpression)));\n+  }\n+\n+  private static boolean isPrimitiveOrNull(Type actualExpressionType) {\n+    return actualExpressionType.isPrimitive() || \"null\".equals(actualExpressionType.symbol().name());\n+  }\n+\n+  static boolean arePackageRelated(String actualTypePackage, String unitTestPackage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzM5ODMyOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzoyODo0MVrOGjD9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo1MTozNlrOGjrJ3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxODE4Mw==", "bodyText": "Can't we use JUtils.enclosingClass here?", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439418183", "createdAt": "2020-06-12T13:28:41Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(2), mit.arguments().get(1));\n+    } else if (JUNIT4_ASSERTIONS_WITHOUT_MESSAGE.matches(mit) || JUNIT5_ASSERTIONS.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(1), mit.arguments().get(0));\n+    } else {\n+      // AssertJ or FestAssert\n+      ExpressionTree actualExpression = mit.arguments().get(0);\n+      consecutiveMethodIgnoringMessageDescription(mit)\n+        .filter(ASSERTJ_AND_FEST_ASSERT_PREDICATES::matches)\n+        .ifPresent(predicate -> checkActualAndExpectedExpression(methodName(predicate).name(), actualExpression, predicate.arguments().get(0)));\n+    }\n+  }\n+\n+  private void checkActualAndExpectedExpression(String predicateMethodName, ExpressionTree actualExpression, ExpressionTree expectedExpression) {\n+    if (ExpressionsHelper.alwaysReturnSameValue(actualExpression) &&\n+      SyntacticEquivalence.areEquivalent(actualExpression, expectedExpression) &&\n+      !isLegitimateSelfComparison(predicateMethodName, actualExpression)) {\n+      List<Location> secondaryLocations = Collections.singletonList(new Location(\"actual\", actualExpression));\n+      reportIssue(expectedExpression, MESSAGE, secondaryLocations, null);\n+    }\n+  }\n+\n+  private static boolean isLegitimateSelfComparison(String comparisonMethodName, ExpressionTree actualExpression) {\n+    // In a unit test validating \"equals\" and \"hashCode\" methods, it's legitimate to compare an object to itself.\n+    // In other kinds of tests, it's a bug. But it's complicated to know if a unit test is about validating the\n+    // \"equals\" method or not. The following trade-off allows the self-comparison of an object if the unit test\n+    // package is related to the tested object package.\n+    Type actualExpressionType = actualExpression.symbolType();\n+    return EQUALS_HASH_CODE_METHODS.contains(comparisonMethodName) &&\n+      !isPrimitiveOrNull(actualExpressionType) &&\n+      arePackageRelated(\n+        packageOf(actualExpressionType.symbol()),\n+        packageOf(classSymbolOfTheUnitTest(actualExpression)));\n+  }\n+\n+  private static boolean isPrimitiveOrNull(Type actualExpressionType) {\n+    return actualExpressionType.isPrimitive() || \"null\".equals(actualExpressionType.symbol().name());\n+  }\n+\n+  static boolean arePackageRelated(String actualTypePackage, String unitTestPackage) {\n+    return unitTestPackage.startsWith(actualTypePackage) || actualTypePackage.startsWith(unitTestPackage);\n+  }\n+\n+  @CheckForNull\n+  static Symbol classSymbolOfTheUnitTest(@Nullable ExpressionTree actualExpression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MDM4MQ==", "bodyText": "\ud83e\udd18", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r440060381", "createdAt": "2020-06-15T09:51:36Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AssertionCompareToSelfCheck.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.MethodTreeUtils;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.JavaFileScannerContext.Location;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.Tree.Kind;\n+\n+import static org.sonar.java.model.ExpressionUtils.methodName;\n+\n+@Rule(key = \"S5863\")\n+public class AssertionCompareToSelfCheck extends AbstractMethodDetection {\n+\n+  private static final String ASSERT_ARRAY_EQUALS = \"assertArrayEquals\";\n+  private static final String ASSERT_EQUALS = \"assertEquals\";\n+  private static final String IS_EQUAL_TO = \"isEqualTo\";\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"org.assertj.core.api.Assertions\",\n+        \"org.assertj.core.api.AssertionsForInterfaceTypes\",\n+        \"org.assertj.core.api.AssertionsForClassTypes\")\n+      .names(\"assertThat\", \"assertThatObject\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"org.fest.assertions.Assertions\")\n+      .names(\"assertThat\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()\n+    .ofTypes(\"org.junit.jupiter.api.Assertions\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, \"assertIterableEquals\", \"assertLinesMatch\")\n+    .addParametersMatcher(parameters -> parameters.size() >= 2)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()\n+    .ofTypes(\"org.junit.Assert\")\n+    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)\n+    .addParametersMatcher(\"java.lang.String\", MethodMatchers.ANY, MethodMatchers.ANY)\n+    .build();\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"as\", \"describedAs\", \"withFailMessage\", \"overridingErrorMessage\").withAnyParameters().build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"as\", \"describedAs\", \"overridingErrorMessage\").withAnyParameters().build());\n+\n+  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.assertj.core.api.AbstractAssert\")\n+      .names(\"contains\", \"containsAll\", \"containsAllEntriesOf\", \"containsAnyElementOf\", \"containsAnyOf\",\n+        \"containsExactly\", \"containsExactlyElementsOf\", \"containsExactlyEntriesOf\", \"containsExactlyInAnyOrder\",\n+        \"containsExactlyInAnyOrderEntriesOf\", \"containsIgnoringCase\", \"containsOnly\", \"containsOnlyElementsOf\",\n+        \"containsSequence\", \"containsSubsequence\", \"doesNotContain\", \"endsWith\",\n+        \"hasSameClassAs\", \"hasSameElementsAs\", \"hasSameHashCodeAs\", \"hasSameSizeAs\", IS_EQUAL_TO,\n+        \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build(),\n+    MethodMatchers.create()\n+      .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+      .names(\"contains\", \"containsExactly\", \"containsIgnoringCase\", \"containsOnly\", \"doesNotContain\", \"endsWith\",\n+        IS_EQUAL_TO, \"isEqualToIgnoringCase\", \"isSameAs\", \"startsWith\")\n+      .addParametersMatcher(MethodMatchers.ANY)\n+      .build());\n+\n+  private static final List<String> EQUALS_HASH_CODE_METHODS = Arrays.asList(ASSERT_EQUALS, IS_EQUAL_TO, \"hasSameHashCodeAs\");\n+\n+  public static final String MESSAGE = \"Replace this assertion to not have the same actual and expected expression.\";\n+\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS,\n+      JUNIT5_ASSERTIONS,\n+      JUNIT4_ASSERTIONS_WITH_MESSAGE,\n+      JUNIT4_ASSERTIONS_WITHOUT_MESSAGE);\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(2), mit.arguments().get(1));\n+    } else if (JUNIT4_ASSERTIONS_WITHOUT_MESSAGE.matches(mit) || JUNIT5_ASSERTIONS.matches(mit)) {\n+      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(1), mit.arguments().get(0));\n+    } else {\n+      // AssertJ or FestAssert\n+      ExpressionTree actualExpression = mit.arguments().get(0);\n+      consecutiveMethodIgnoringMessageDescription(mit)\n+        .filter(ASSERTJ_AND_FEST_ASSERT_PREDICATES::matches)\n+        .ifPresent(predicate -> checkActualAndExpectedExpression(methodName(predicate).name(), actualExpression, predicate.arguments().get(0)));\n+    }\n+  }\n+\n+  private void checkActualAndExpectedExpression(String predicateMethodName, ExpressionTree actualExpression, ExpressionTree expectedExpression) {\n+    if (ExpressionsHelper.alwaysReturnSameValue(actualExpression) &&\n+      SyntacticEquivalence.areEquivalent(actualExpression, expectedExpression) &&\n+      !isLegitimateSelfComparison(predicateMethodName, actualExpression)) {\n+      List<Location> secondaryLocations = Collections.singletonList(new Location(\"actual\", actualExpression));\n+      reportIssue(expectedExpression, MESSAGE, secondaryLocations, null);\n+    }\n+  }\n+\n+  private static boolean isLegitimateSelfComparison(String comparisonMethodName, ExpressionTree actualExpression) {\n+    // In a unit test validating \"equals\" and \"hashCode\" methods, it's legitimate to compare an object to itself.\n+    // In other kinds of tests, it's a bug. But it's complicated to know if a unit test is about validating the\n+    // \"equals\" method or not. The following trade-off allows the self-comparison of an object if the unit test\n+    // package is related to the tested object package.\n+    Type actualExpressionType = actualExpression.symbolType();\n+    return EQUALS_HASH_CODE_METHODS.contains(comparisonMethodName) &&\n+      !isPrimitiveOrNull(actualExpressionType) &&\n+      arePackageRelated(\n+        packageOf(actualExpressionType.symbol()),\n+        packageOf(classSymbolOfTheUnitTest(actualExpression)));\n+  }\n+\n+  private static boolean isPrimitiveOrNull(Type actualExpressionType) {\n+    return actualExpressionType.isPrimitive() || \"null\".equals(actualExpressionType.symbol().name());\n+  }\n+\n+  static boolean arePackageRelated(String actualTypePackage, String unitTestPackage) {\n+    return unitTestPackage.startsWith(actualTypePackage) || actualTypePackage.startsWith(unitTestPackage);\n+  }\n+\n+  @CheckForNull\n+  static Symbol classSymbolOfTheUnitTest(@Nullable ExpressionTree actualExpression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxODE4Mw=="}, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzQ1NjE5OnYy", "diffSide": "RIGHT", "path": "its/ruling/src/test/resources/sonar-server/java-S5863.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo0NTo1N1rOGjEiBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo1Njo0MVrOGjrVQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNzU4OQ==", "bodyText": "I'm still worried about the noise we will generate when reporting similar FPs.\nThe fact that we will consider this obvious FP as a \"major bug\" doesn't help...\nMaybe we should ask for a third mind?", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r439427589", "createdAt": "2020-06-12T13:45:57Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "its/ruling/src/test/resources/sonar-server/java-S5863.json", "diffHunk": "@@ -0,0 +1,8 @@\n+{\n+'org.sonarsource.sonarqube:sonar-server:src/test/java/org/sonar/server/computation/task/projectanalysis/api/measurecomputer/MeasureComputerDefinitionImplTest.java':[\n+156,\n+],\n+'org.sonarsource.sonarqube:sonar-server:src/test/java/org/sonar/server/user/DefaultUserTest.java':[\n+33,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MzI5OQ==", "bodyText": "After discussions, we decided to change the strategy. Instead of having an exception using packages name, we will try to base the exception on unit test method name containing some keywords (e.g. \"equals\", \"hash_code\")", "url": "https://github.com/SonarSource/sonar-java/pull/3007#discussion_r440063299", "createdAt": "2020-06-15T09:56:41Z", "author": {"login": "alban-auzeill"}, "path": "its/ruling/src/test/resources/sonar-server/java-S5863.json", "diffHunk": "@@ -0,0 +1,8 @@\n+{\n+'org.sonarsource.sonarqube:sonar-server:src/test/java/org/sonar/server/computation/task/projectanalysis/api/measurecomputer/MeasureComputerDefinitionImplTest.java':[\n+156,\n+],\n+'org.sonarsource.sonarqube:sonar-server:src/test/java/org/sonar/server/user/DefaultUserTest.java':[\n+33,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNzU4OQ=="}, "originalCommit": {"oid": "cceb1e432244172d66fa8d67eddbfd492fbd4479"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4037, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}