{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MTk1NzA4", "number": 3297, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTowMTo1NlrOE8lcxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowODo1M1rOE-16mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTYzNTg4OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTowMTo1NlrOH4ymPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwODoyMjoyOVrOH5nzIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMxMTI5NA==", "bodyText": "It probably makes sense to initialize activeFlags in the constructor rather than parse and to get rid of initialFlags altogether (this would also entail getting rid of RegexParseResult.initialFlags, which should be fine because we can just use parseResult.getResult().activeFlags() instead).", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r529311294", "createdAt": "2020-11-24T09:01:56Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java", "diffHunk": "@@ -81,6 +83,7 @@ public RegexParser(RegexSource source, FlagSet initialFlags) {\n   }\n \n   public RegexParseResult parse() {\n+    this.activeFlags = initialFlags;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4Mjk0Ng==", "bodyText": "I removed the field initialFlags but keept the getter getInitialFlags().", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r530182946", "createdAt": "2020-11-25T08:22:29Z", "author": {"login": "alban-auzeill"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java", "diffHunk": "@@ -81,6 +83,7 @@ public RegexParser(RegexSource source, FlagSet initialFlags) {\n   }\n \n   public RegexParseResult parse() {\n+    this.activeFlags = initialFlags;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMxMTI5NA=="}, "originalCommit": {"oid": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTc1ODYxOnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToxODoyN1rOH4z18A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwODoyMDo1M1rOH5nvvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMTY5Ng==", "bodyText": "If we decide to remove RegexParseResult.initialFlags, RegexTrees should never use FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r529331696", "createdAt": "2020-11-24T09:18:27Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java", "diffHunk": "@@ -30,7 +30,7 @@\n   private final List<JavaCharacter> orOperators;\n \n   public DisjunctionTree(RegexSource source, IndexRange range, List<RegexTree> alternatives, List<JavaCharacter> orOperators) {\n-    super(source, range);\n+    super(source, range, FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4MjA3Nw==", "bodyText": "I have set correct activeFlags on all AutomatonState and removed FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r530182077", "createdAt": "2020-11-25T08:20:53Z", "author": {"login": "alban-auzeill"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java", "diffHunk": "@@ -30,7 +30,7 @@\n   private final List<JavaCharacter> orOperators;\n \n   public DisjunctionTree(RegexSource source, IndexRange range, List<RegexTree> alternatives, List<JavaCharacter> orOperators) {\n-    super(source, range);\n+    super(source, range, FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMTY5Ng=="}, "originalCommit": {"oid": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTQxNDgxOnYy", "diffSide": "RIGHT", "path": "java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzo1MDo1MFrOH778qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo1NzoxOVrOH8w0dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxMDIxNg==", "bodyText": "This doesn't really test what I wanted to test. The intent was to have a regex where the reluctantly quantified bit is subject to a flag, but the part after the reluctant quantifier is not. Previously the flag wouldn't have been taken into account in that case because it called flagActive for both arguments after both have been parsed. With the new system, both arguments should have accurate flags.\nSo to test this with the features we currently support, (?U:\\\\s*?)\\u202F would be an example of a current FN that should be fixed by the change in how flags are tracked.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532610216", "createdAt": "2020-11-30T13:50:50Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java", "diffHunk": "@@ -21,7 +21,8 @@ void noncompliant(String str) {\n     str.matches(\".*?\\\\P{L}\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"\\\\p{L}*+\".}}\n     str.matches(\"\\\\[.*?\\\\]\"); // Noncompliant [[sc=21;ec=24]] {{Replace this use of a reluctant quantifier with \"[^\\\\]]*+\".}}\n     str.matches(\".+?[abc]\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"[^abc]++\".}}\n-    \n+    str.matches(\"(?i:.*?[a-z])\"); // Noncompliant [[sc=22;ec=25]] {{Replace this use of a reluctant quantifier with \"[^a-z]*+\".}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NjQ3MA==", "bodyText": "Unfortunately ReluctantQuantifierCheck only supports DOT and ESCAPED_CHARACTER_CLASS before the *?, and only PLAIN_CHARACTER, ESCAPED_CHARACTER_CLASS, CHARACTER_CLASS after.\nSo it was not possible to have different active flags before and after *?. For this, I had to change the rule implementation \ud83d\ude1e to support NON_CAPTURING_GROUP.\nSee this commit: SONARJAVA-3564 ReluctantQuantifierCheck support mixed active flags", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r533476470", "createdAt": "2020-12-01T14:57:19Z", "author": {"login": "alban-auzeill"}, "path": "java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java", "diffHunk": "@@ -21,7 +21,8 @@ void noncompliant(String str) {\n     str.matches(\".*?\\\\P{L}\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"\\\\p{L}*+\".}}\n     str.matches(\"\\\\[.*?\\\\]\"); // Noncompliant [[sc=21;ec=24]] {{Replace this use of a reluctant quantifier with \"[^\\\\]]*+\".}}\n     str.matches(\".+?[abc]\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"[^abc]++\".}}\n-    \n+    str.matches(\"(?i:.*?[a-z])\"); // Noncompliant [[sc=22;ec=25]] {{Replace this use of a reluctant quantifier with \"[^a-z]*+\".}}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxMDIxNg=="}, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjI5ODA3OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjo1NToxM1rOH8EWGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjo1NToxM1rOH8EWGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NzgwMg==", "bodyText": "Should be Character.MAX_CODE_POINT without the - 1 unless I'm missing something.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532747802", "createdAt": "2020-11-30T16:55:13Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -45,38 +50,69 @@\n    * non-null and the tree returned by {@code getValue} will be the element of the character class which matches that\n    * code point.\n    */\n-  private TreeMap<Integer, CharacterClassElementTree> contents = new TreeMap<>();\n+  private TreeMap<Integer, RegexSyntaxElement> contents = new TreeMap<>();\n \n   private boolean containsUnknownCharacters = false;\n \n   public SimplifiedRegexCharacterClass() {\n   }\n \n-  public SimplifiedRegexCharacterClass(CharacterClassElementTree tree, FlagSet flags) {\n-    add(tree, flags);\n+  public SimplifiedRegexCharacterClass(CharacterClassElementTree tree) {\n+    add(tree);\n+  }\n+\n+  public SimplifiedRegexCharacterClass(DotTree tree) {\n+    char[] orderedExcludedCharacters;\n+    if (tree.activeFlags().contains(Pattern.DOTALL)) {\n+      orderedExcludedCharacters = new char[] {};\n+    } else if (tree.activeFlags().contains(Pattern.UNIX_LINES)) {\n+      orderedExcludedCharacters = new char[] {'\\n'};\n+    } else {\n+      orderedExcludedCharacters = new char[] {'\\n', '\\r', '\\u0085', '\\u2028', '\\u2029'};\n+    }\n+    int from = 0;\n+    for (char excludedCharacter : orderedExcludedCharacters) {\n+      int to = excludedCharacter - 1;\n+      if (to > from) {\n+        addRange(from, to, tree);\n+      }\n+      from = excludedCharacter + 1;\n+    }\n+    addRange(from, Character.MAX_CODE_POINT - 1, tree);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQ2NDU0OnYy", "diffSide": "RIGHT", "path": "java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzozMjoyMFrOH8F8Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo0Njo0OFrOH9OIbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MzkzMQ==", "bodyText": "Create ticket", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532773931", "createdAt": "2020-11-30T17:32:20Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java", "diffHunk": "@@ -52,4 +69,226 @@ void testIntersectionWithTrueAsDefaultAnswer() {\n     assertFalse(empty.intersects(aToZ, true));\n     assertFalse(empty.intersects(unknown, true));\n   }\n+\n+  @Test\n+  void intersects_dot() {\n+    assertIntersects(\".\", \"a\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \".\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\0\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\uFFFF\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"a\", \".\", true, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"[a-z]\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"[a-z]\", \".\", false, NO_FLAGS).isTrue();\n+\n+    // by default [\\r\\n\\u0085\\u2028\\u2029] excluded from DotTree\n+    assertIntersects(\".\", \"[\\r\\n\\u0085\\u2028\\u2029]\", false, NO_FLAGS).isFalse();\n+    assertIntersects(\".\", \"\\b\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \" \", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, NO_FLAGS).isTrue();\n+  }\n+   \n+  @Test\n+  void intersects_dot_unix_lines() {\n+    // only \\n excluded when UNIX_LINES is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES).isFalse();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.UNIX_LINES).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_dot_all() {\n+    // no exclusion and UNIX_LINES is ignored when DOTALL is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES | Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.DOTALL).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_with_utf16() {\n+    String maxCodePoint = new String(Character.toChars(Character.MAX_CODE_POINT));\n+    // two characters\n+    assertThat(maxCodePoint).hasSize(2);\n+    // but a single code point\n+    assertThat(maxCodePoint.codePoints().count()).isEqualTo(1);\n+    // and java Pattern support it\n+    assertThat(maxCodePoint).matches(\".\");\n+\n+    RegexTree result = parseRegex(maxCodePoint, new FlagSet()).getResult();\n+    // FIXME result should be a single PlainCharacterTree and not a SequenceTree of two PlainCharacterTree s\n+    // In oder to assert: assertIntersects(\".\", maxCodePoint, false, NO_FLAGS).isTrue();\n+    // Instead of:\n+    assertThat(result).isInstanceOf(SequenceTree.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjcxOQ==", "bodyText": "Created https://jira.sonarsource.com/browse/SONARJAVA-3624", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r533956719", "createdAt": "2020-12-02T07:46:48Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java", "diffHunk": "@@ -52,4 +69,226 @@ void testIntersectionWithTrueAsDefaultAnswer() {\n     assertFalse(empty.intersects(aToZ, true));\n     assertFalse(empty.intersects(unknown, true));\n   }\n+\n+  @Test\n+  void intersects_dot() {\n+    assertIntersects(\".\", \"a\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \".\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\0\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\uFFFF\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"a\", \".\", true, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"[a-z]\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"[a-z]\", \".\", false, NO_FLAGS).isTrue();\n+\n+    // by default [\\r\\n\\u0085\\u2028\\u2029] excluded from DotTree\n+    assertIntersects(\".\", \"[\\r\\n\\u0085\\u2028\\u2029]\", false, NO_FLAGS).isFalse();\n+    assertIntersects(\".\", \"\\b\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \" \", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, NO_FLAGS).isTrue();\n+  }\n+   \n+  @Test\n+  void intersects_dot_unix_lines() {\n+    // only \\n excluded when UNIX_LINES is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES).isFalse();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.UNIX_LINES).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_dot_all() {\n+    // no exclusion and UNIX_LINES is ignored when DOTALL is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES | Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.DOTALL).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_with_utf16() {\n+    String maxCodePoint = new String(Character.toChars(Character.MAX_CODE_POINT));\n+    // two characters\n+    assertThat(maxCodePoint).hasSize(2);\n+    // but a single code point\n+    assertThat(maxCodePoint.codePoints().count()).isEqualTo(1);\n+    // and java Pattern support it\n+    assertThat(maxCodePoint).matches(\".\");\n+\n+    RegexTree result = parseRegex(maxCodePoint, new FlagSet()).getResult();\n+    // FIXME result should be a single PlainCharacterTree and not a SequenceTree of two PlainCharacterTree s\n+    // In oder to assert: assertIntersects(\".\", maxCodePoint, false, NO_FLAGS).isTrue();\n+    // Instead of:\n+    assertThat(result).isInstanceOf(SequenceTree.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MzkzMQ=="}, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjY4OTc2OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyMFrOH8IEzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyMFrOH8IEzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODkxMQ==", "bodyText": "If that only contains unknown characters and this is empty, the result should still be true false even if the default answer is true. So return !isEmpty() || !that.containsUnknownCharacters;.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532808911", "createdAt": "2020-11-30T18:27:20Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -87,9 +123,36 @@ public boolean intersects(SimplifiedRegexCharacterClass that, boolean defaultAns\n     return false;\n   }\n \n-  public void addRange(int from, int to, CharacterClassElementTree tree) {\n+  public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n+    if (that.containsUnknownCharacters && !defaultAnswer) {\n+      return false;\n+    }\n+    Iterator<Map.Entry<Integer, RegexSyntaxElement>> thatIter = that.contents.entrySet().iterator();\n+    if (!thatIter.hasNext()) {\n+      // that.contents is empty, any set is a superset of it\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzIyMjU1OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMDo0NDozOVrOH8NIhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMDo0NDozOVrOH8NIhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5MTc4Mw==", "bodyText": "There's a bug here if that ends with a range that goes up to MAX_CODE_POINT (inclusive), in which case the last entry of that.contents won't be a null entry. I've fixed the same bug for intersects in my PR.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532891783", "createdAt": "2020-11-30T20:44:39Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -87,9 +123,36 @@ public boolean intersects(SimplifiedRegexCharacterClass that, boolean defaultAns\n     return false;\n   }\n \n-  public void addRange(int from, int to, CharacterClassElementTree tree) {\n+  public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n+    if (that.containsUnknownCharacters && !defaultAnswer) {\n+      return false;\n+    }\n+    Iterator<Map.Entry<Integer, RegexSyntaxElement>> thatIter = that.contents.entrySet().iterator();\n+    if (!thatIter.hasNext()) {\n+      // that.contents is empty, any set is a superset of it\n+      return true;\n+    }\n+    Map.Entry<Integer, RegexSyntaxElement> thatEntry = thatIter.next();\n+    while (thatIter.hasNext()) {\n+      Map.Entry<Integer, RegexSyntaxElement> thatNextEntry = thatIter.next();\n+      if (thatEntry.getValue() != null) {\n+        Map.Entry<Integer, RegexSyntaxElement> thisBefore = contents.floorEntry(thatEntry.getKey());\n+        if (thisBefore == null || thisBefore.getValue() == null) {\n+          return false;\n+        }\n+        NavigableMap<Integer, RegexSyntaxElement> thisSubMap = contents.subMap(thatEntry.getKey(), false, thatNextEntry.getKey(), false);\n+        if (thisSubMap.values().stream().anyMatch(Objects::isNull)) {\n+          return false;\n+        }\n+      }\n+      thatEntry = thatNextEntry;\n+    }\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzMwNTIzOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowODo1M1rOH8N6dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowODo1M1rOH8N6dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwNDU2NA==", "bodyText": "I believe we should still report the issue if the continuation is not a RegexSyntaxElement. If the non-regex-syntax continuation has a single successor (i.e. it's not a branch), we can just report on that successor instead (or, if it's still not a regex syntax element, keep following single edges until we find one or a branch). And if it's a branch (as might be the case for something like (xx++)+x) we should probably still report by only reporting on the repetition itself with the message adjusted accordingly.", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532904564", "createdAt": "2020-11-30T21:08:53Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.Collections;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.RegexTreeHelper;\n+import org.sonar.java.checks.helpers.SubAutomaton;\n+import org.sonar.java.regex.RegexCheck;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.FinalState;\n+import org.sonar.java.regex.ast.Quantifier;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.java.regex.ast.RegexSyntaxElement;\n+import org.sonar.java.regex.ast.RepetitionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5994\")\n+public class PossessiveQuantifierContinuationCheck extends AbstractRegexCheck {\n+\n+  private static final String MESSAGE = \"Change this impossible to match sub-pattern that conflicts with the previous possessive quantifier.\";\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    new Visitor(regexForLiterals.getFinalState()).visit(regexForLiterals);\n+  }\n+\n+  private class Visitor extends RegexBaseVisitor {\n+\n+    private final FinalState finalState;\n+\n+    public Visitor(FinalState finalState) {\n+      this.finalState = finalState;\n+    }\n+\n+    @Override\n+    public void visitRepetition(RepetitionTree repetitionTree) {\n+      AutomatonState continuation = repetitionTree.continuation();\n+      if (doesRepetitionContinuationAlwaysFail(repetitionTree) && continuation instanceof RegexSyntaxElement) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5afbfeeef0963237e9835bd551e07921414592fa"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3852, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}