{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNTI2ODY1", "number": 3270, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNjo0MVrOE7I-UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjo0MzowMFrOE7JKMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ4NDY0OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNjo0MVrOH2nV0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNjo0MVrOH2nV0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTcxMw==", "bodyText": "we should take the erasure of ownerType or we gonna face inconcistencies.", "url": "https://github.com/SonarSource/sonar-java/pull/3270#discussion_r527029713", "createdAt": "2020-11-19T16:36:41Z", "author": {"login": "m-g-sonar"}, "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "diffHunk": "@@ -116,14 +116,24 @@ public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {\n     @Override\n     public void visitIdentifier(IdentifierTree tree) {\n       Type type = tree.symbolType();\n-      if (!sameErasure(type) && type.isSubtypeOf(classType.erasure())) {\n+      if (!sameErasure(type) && type.isSubtypeOf(classTypeErasure) && !isNestedIntoParent(type)) {\n         reportIssue(tree, String.format(\"Remove this reference to \\\"%s\\\".\", type.symbol().name()));\n       }\n     }\n \n     private boolean sameErasure(Type type) {\n-      return classType.erasure().equals(type.erasure());\n+      return classTypeErasure.equals(type.erasure());\n     }\n+\n+    private boolean isNestedIntoParent(Type type) {\n+      Symbol ownerSymbol = type.symbol().owner();\n+      if (ownerSymbol != null) {\n+        Type ownerType = ownerSymbol.type();\n+        return ownerType != null && ownerType.isSubtypeOf(classTypeErasure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064d38f4819563515d5befd27c03768630514e15"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ5NTYxOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozODo1OVrOH2nclQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozODo1OVrOH2nclQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzMTQ0NQ==", "bodyText": "isNestedSubtype()", "url": "https://github.com/SonarSource/sonar-java/pull/3270#discussion_r527031445", "createdAt": "2020-11-19T16:38:59Z", "author": {"login": "m-g-sonar"}, "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "diffHunk": "@@ -116,14 +116,24 @@ public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {\n     @Override\n     public void visitIdentifier(IdentifierTree tree) {\n       Type type = tree.symbolType();\n-      if (!sameErasure(type) && type.isSubtypeOf(classType.erasure())) {\n+      if (!sameErasure(type) && type.isSubtypeOf(classTypeErasure) && !isNestedIntoParent(type)) {\n         reportIssue(tree, String.format(\"Remove this reference to \\\"%s\\\".\", type.symbol().name()));\n       }\n     }\n \n     private boolean sameErasure(Type type) {\n-      return classType.erasure().equals(type.erasure());\n+      return classTypeErasure.equals(type.erasure());\n     }\n+\n+    private boolean isNestedIntoParent(Type type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064d38f4819563515d5befd27c03768630514e15"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDUxNTA2OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjo0MzowMFrOH2nopA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjo0MzowMFrOH2nopA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNDUzMg==", "bodyText": "Type ownerType = Objects.requiresNonNull(type.symbol().owner()).type();", "url": "https://github.com/SonarSource/sonar-java/pull/3270#discussion_r527034532", "createdAt": "2020-11-19T16:43:00Z", "author": {"login": "m-g-sonar"}, "path": "java-checks/src/main/java/org/sonar/java/checks/SubClassStaticReferenceCheck.java", "diffHunk": "@@ -116,14 +116,24 @@ public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {\n     @Override\n     public void visitIdentifier(IdentifierTree tree) {\n       Type type = tree.symbolType();\n-      if (!sameErasure(type) && type.isSubtypeOf(classType.erasure())) {\n+      if (!sameErasure(type) && type.isSubtypeOf(classTypeErasure) && !isNestedIntoParent(type)) {\n         reportIssue(tree, String.format(\"Remove this reference to \\\"%s\\\".\", type.symbol().name()));\n       }\n     }\n \n     private boolean sameErasure(Type type) {\n-      return classType.erasure().equals(type.erasure());\n+      return classTypeErasure.equals(type.erasure());\n     }\n+\n+    private boolean isNestedIntoParent(Type type) {\n+      Symbol ownerSymbol = type.symbol().owner();\n+      if (ownerSymbol != null) {\n+        Type ownerType = ownerSymbol.type();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064d38f4819563515d5befd27c03768630514e15"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3805, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}