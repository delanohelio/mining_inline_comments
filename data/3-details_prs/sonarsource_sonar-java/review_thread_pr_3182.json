{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NzgwMjY0", "number": 3182, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwOTo0MzoyNFrOEkdFVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTo1Mjo1OFrOEkmyGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NjYwNjk1OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/resources/org/sonar/l10n/java/rules/java/S5976_java.html", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwOTo0MzoyNFrOHTaFcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwOTo0MzoyNFrOHTaFcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMjM2OQ==", "bodyText": "@CsvSource seems to be a good argument provider when there are multiple parameters to pass to the test methods, but if we only show this example in compliant code, developers will also use @CsvSource when there's a single parameter instead of @ValueSource that is IMO simpler. So I would add before this testSum test a simpler one like:\n@ParameterizedTest\n@ValueSource(ints = {1, 2, 3})\nvoid test_not_null(int arg) {\n  assertNotNull(getTax(arg));\n}", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490112369", "createdAt": "2020-09-17T09:43:24Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/resources/org/sonar/l10n/java/rules/java/S5976_java.html", "diffHunk": "@@ -0,0 +1,57 @@\n+<p>When multiple tests differ only by a few hardcoded values they should be refactored as a single \"parameterized\" test. This reduces the chances of\n+adding a bug and makes them more readable. Parameterized tests exist in most test frameworks (JUnit, TestNG, etc...).</p>\n+<h2>Noncompliant Code Example</h2>\n+<p>with JUnit 5</p>\n+<pre>\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class AppTest\n+{\n+    @Test\n+    void testSum11() {  // Noncompliant. These tests differ only by a few hardcoded numbers.\n+        assertEquals(Integer.sum(1, 1), 2);\n+    }\n+\n+    @Test\n+    void testSum12() {  // Similar test\n+        assertEquals(Integer.sum(1, 2), 3);\n+    }\n+\n+    @Test\n+    void testSum22() {  // Similar test\n+        assertEquals(Integer.sum(2, 2), 4);\n+    }\n+}\n+</pre>\n+<h2>Compliant Solution</h2>\n+<pre>\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+public class AppTest\n+{\n+    @ParameterizedTest\n+    @CsvSource({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzM2NzA0OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowNzoxNFrOHThLUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMjozOVrOHTlQZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyODU2Mg==", "bodyText": "I disagree, the logic should be careful with the semantic kind of the literals, let's take this example:\nclass FooTest {\n  @Test\n  void test1() { // FP \"compute(1)\" and \"compute(2.0f)\" is not related to the same method\n    int a = compute(1);\n    assertEquals(a, 0);\n  }\n\n  @Test\n  void test2() {\n    int a = compute(2.0f);\n    assertEquals(a, 0);\n  }\n\n  @Test\n  void test3() {\n    int a = compute(3);\n    assertEquals(a, 0);\n  }\n\n  int compute(int a) { return 0;  }\n  int compute(float a) { return 0; }\n}\n\nSo, when the left and right literals do not have the same types, we should check if a parameter could have a compatible type that will really keep the same test semantic.", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490228562", "createdAt": "2020-09-17T13:07:14Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.JavaTree;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.BlockTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.StatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import static java.util.Arrays.asList;\n+\n+@Rule(key = \"S5976\")\n+public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String MESSAGE = \"Replace these %d tests with a single Parameterized one.\";\n+\n+  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(\n+    \"org.junit.Test\",\n+    \"org.junit.jupiter.api.Test\",\n+    \"org.testng.annotations.Test\"));\n+\n+  private static final int MIN_SIMILAR_METHODS = 3;\n+  private static final int MIN_NUMBER_STATEMENTS = 2;\n+  private static final int MAX_NUMBER_PARAMETER = 3;\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(ParameterizedTestCheck::isParametrizedCandidate)\n+      .collect(Collectors.toList());\n+    if (methods.size() < MIN_SIMILAR_METHODS) {\n+      return;\n+    }\n+\n+    Set<MethodTree> handled = new HashSet<>();\n+    for (int i = 0; i < methods.size(); i++) {\n+      MethodTree method = methods.get(i);\n+      List<StatementTree> methodBody = method.block().body();\n+      // In addition to filtering literals, we want to count the number of differences since they will represent the number of parameter\n+      // that would be required to transform the tests to a single parametrized one.\n+      CollectAndFilter collectAndFilter = new CollectAndFilter();\n+\n+      List<MethodTree> equivalentMethods = methods.stream()\n+        .skip(i + 1L)\n+        // avoid reporting multiple times\n+        .filter(otherMethod -> !handled.contains(otherMethod))\n+        // only consider method syntactically equivalent, ignoring literals\n+        .filter(otherMethod -> {\n+          boolean areEquivalent = SyntacticEquivalence.areEquivalent(methodBody, otherMethod.block().body(), collectAndFilter);\n+          if (areEquivalent) {\n+            // If methods where not equivalent, we don't want to pollute the set of node to parameterize.\n+            collectAndFilter.validateCollection();\n+          }\n+          return areEquivalent;\n+        })\n+        .collect(Collectors.toList());\n+\n+      if (equivalentMethods.size() + 1 >= MIN_SIMILAR_METHODS) {\n+        handled.add(method);\n+        handled.addAll(equivalentMethods);\n+\n+        if (collectAndFilter.nodeToParametrize.size() > MAX_NUMBER_PARAMETER) {\n+          // We don't report an issue if the change would result in too many parameters.\n+          // We still add it to \"handled\" to not report a subset of candidate methods.\n+          continue;\n+        }\n+\n+        List<JavaFileScannerContext.Location> secondaries = collectAndFilter.nodeToParametrize.stream().map(param ->\n+          new JavaFileScannerContext.Location(\"Value to parameterize\", param)).collect(Collectors.toCollection(ArrayList::new));\n+\n+        equivalentMethods.stream().map(equivalentMethod ->\n+          new JavaFileScannerContext.Location(\"Related test\", equivalentMethod.simpleName()))\n+          .forEach(secondaries::add);\n+\n+        reportIssue(method.simpleName(), String.format(MESSAGE, equivalentMethods.size() + 1) , secondaries, null);\n+      }\n+    }\n+  }\n+\n+  private static boolean isParametrizedCandidate(MethodTree methodTree) {\n+    BlockTree block = methodTree.block();\n+    SymbolMetadata symbolMetadata = methodTree.symbol().metadata();\n+    return block != null &&\n+      block.body().size() >= MIN_NUMBER_STATEMENTS &&\n+      TEST_ANNOTATIONS.stream().anyMatch(symbolMetadata::isAnnotatedWith);\n+  }\n+\n+  static class CollectAndFilter implements BiPredicate<JavaTree, JavaTree> {\n+\n+    Set<JavaTree> nodeToParametrize = new HashSet<>();\n+    private final Set<JavaTree> currentNodeToParameterize = new HashSet<>();\n+\n+    @Override\n+    public boolean test(JavaTree leftNode, JavaTree rightNode) {\n+      if (isLiteral(leftNode) && isLiteral(rightNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NTM5Nw==", "bodyText": "Make sense, and in fact, even when the issue is correct (relate to the same method taking Object for example), using parameterized tests would not result in something super clear, so let's consider only literals of the same type.", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490295397", "createdAt": "2020-09-17T14:32:39Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.JavaTree;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.BlockTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.StatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import static java.util.Arrays.asList;\n+\n+@Rule(key = \"S5976\")\n+public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String MESSAGE = \"Replace these %d tests with a single Parameterized one.\";\n+\n+  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(\n+    \"org.junit.Test\",\n+    \"org.junit.jupiter.api.Test\",\n+    \"org.testng.annotations.Test\"));\n+\n+  private static final int MIN_SIMILAR_METHODS = 3;\n+  private static final int MIN_NUMBER_STATEMENTS = 2;\n+  private static final int MAX_NUMBER_PARAMETER = 3;\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(ParameterizedTestCheck::isParametrizedCandidate)\n+      .collect(Collectors.toList());\n+    if (methods.size() < MIN_SIMILAR_METHODS) {\n+      return;\n+    }\n+\n+    Set<MethodTree> handled = new HashSet<>();\n+    for (int i = 0; i < methods.size(); i++) {\n+      MethodTree method = methods.get(i);\n+      List<StatementTree> methodBody = method.block().body();\n+      // In addition to filtering literals, we want to count the number of differences since they will represent the number of parameter\n+      // that would be required to transform the tests to a single parametrized one.\n+      CollectAndFilter collectAndFilter = new CollectAndFilter();\n+\n+      List<MethodTree> equivalentMethods = methods.stream()\n+        .skip(i + 1L)\n+        // avoid reporting multiple times\n+        .filter(otherMethod -> !handled.contains(otherMethod))\n+        // only consider method syntactically equivalent, ignoring literals\n+        .filter(otherMethod -> {\n+          boolean areEquivalent = SyntacticEquivalence.areEquivalent(methodBody, otherMethod.block().body(), collectAndFilter);\n+          if (areEquivalent) {\n+            // If methods where not equivalent, we don't want to pollute the set of node to parameterize.\n+            collectAndFilter.validateCollection();\n+          }\n+          return areEquivalent;\n+        })\n+        .collect(Collectors.toList());\n+\n+      if (equivalentMethods.size() + 1 >= MIN_SIMILAR_METHODS) {\n+        handled.add(method);\n+        handled.addAll(equivalentMethods);\n+\n+        if (collectAndFilter.nodeToParametrize.size() > MAX_NUMBER_PARAMETER) {\n+          // We don't report an issue if the change would result in too many parameters.\n+          // We still add it to \"handled\" to not report a subset of candidate methods.\n+          continue;\n+        }\n+\n+        List<JavaFileScannerContext.Location> secondaries = collectAndFilter.nodeToParametrize.stream().map(param ->\n+          new JavaFileScannerContext.Location(\"Value to parameterize\", param)).collect(Collectors.toCollection(ArrayList::new));\n+\n+        equivalentMethods.stream().map(equivalentMethod ->\n+          new JavaFileScannerContext.Location(\"Related test\", equivalentMethod.simpleName()))\n+          .forEach(secondaries::add);\n+\n+        reportIssue(method.simpleName(), String.format(MESSAGE, equivalentMethods.size() + 1) , secondaries, null);\n+      }\n+    }\n+  }\n+\n+  private static boolean isParametrizedCandidate(MethodTree methodTree) {\n+    BlockTree block = methodTree.block();\n+    SymbolMetadata symbolMetadata = methodTree.symbol().metadata();\n+    return block != null &&\n+      block.body().size() >= MIN_NUMBER_STATEMENTS &&\n+      TEST_ANNOTATIONS.stream().anyMatch(symbolMetadata::isAnnotatedWith);\n+  }\n+\n+  static class CollectAndFilter implements BiPredicate<JavaTree, JavaTree> {\n+\n+    Set<JavaTree> nodeToParametrize = new HashSet<>();\n+    private final Set<JavaTree> currentNodeToParameterize = new HashSet<>();\n+\n+    @Override\n+    public boolean test(JavaTree leftNode, JavaTree rightNode) {\n+      if (isLiteral(leftNode) && isLiteral(rightNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyODU2Mg=="}, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzM5NDUyOnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoxMzoyOFrOHThb2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoxMzoyOFrOHThb2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMjc5NA==", "bodyText": "I would add:\n      if (handled.contains(method)) {\n        continue;\n      }", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490232794", "createdAt": "2020-09-17T13:13:28Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.JavaTree;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.BlockTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.StatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import static java.util.Arrays.asList;\n+\n+@Rule(key = \"S5976\")\n+public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String MESSAGE = \"Replace these %d tests with a single Parameterized one.\";\n+\n+  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(\n+    \"org.junit.Test\",\n+    \"org.junit.jupiter.api.Test\",\n+    \"org.testng.annotations.Test\"));\n+\n+  private static final int MIN_SIMILAR_METHODS = 3;\n+  private static final int MIN_NUMBER_STATEMENTS = 2;\n+  private static final int MAX_NUMBER_PARAMETER = 3;\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(ParameterizedTestCheck::isParametrizedCandidate)\n+      .collect(Collectors.toList());\n+    if (methods.size() < MIN_SIMILAR_METHODS) {\n+      return;\n+    }\n+\n+    Set<MethodTree> handled = new HashSet<>();\n+    for (int i = 0; i < methods.size(); i++) {\n+      MethodTree method = methods.get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzQ3MzM4OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoyODo1MVrOHTiMVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoyODo1MVrOHTiMVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI0NTIwNg==", "bodyText": "I don't understand how this code can accidentally work.\n\nIf a method is equivalent, we copy currentNodeToParameterize into nodeToParametrize, without cleaning currentNodeToParameterize, it's not optimum\nIf a method is not equivalent, we do nothing! we keep currentNodeToParameterize dirty and it's content will be copied into nodeToParametrize by the following equivalent method \ud83d\ude16", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490245206", "createdAt": "2020-09-17T13:28:51Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.JavaTree;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.BlockTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.StatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import static java.util.Arrays.asList;\n+\n+@Rule(key = \"S5976\")\n+public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String MESSAGE = \"Replace these %d tests with a single Parameterized one.\";\n+\n+  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(\n+    \"org.junit.Test\",\n+    \"org.junit.jupiter.api.Test\",\n+    \"org.testng.annotations.Test\"));\n+\n+  private static final int MIN_SIMILAR_METHODS = 3;\n+  private static final int MIN_NUMBER_STATEMENTS = 2;\n+  private static final int MAX_NUMBER_PARAMETER = 3;\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(ParameterizedTestCheck::isParametrizedCandidate)\n+      .collect(Collectors.toList());\n+    if (methods.size() < MIN_SIMILAR_METHODS) {\n+      return;\n+    }\n+\n+    Set<MethodTree> handled = new HashSet<>();\n+    for (int i = 0; i < methods.size(); i++) {\n+      MethodTree method = methods.get(i);\n+      List<StatementTree> methodBody = method.block().body();\n+      // In addition to filtering literals, we want to count the number of differences since they will represent the number of parameter\n+      // that would be required to transform the tests to a single parametrized one.\n+      CollectAndFilter collectAndFilter = new CollectAndFilter();\n+\n+      List<MethodTree> equivalentMethods = methods.stream()\n+        .skip(i + 1L)\n+        // avoid reporting multiple times\n+        .filter(otherMethod -> !handled.contains(otherMethod))\n+        // only consider method syntactically equivalent, ignoring literals\n+        .filter(otherMethod -> {\n+          boolean areEquivalent = SyntacticEquivalence.areEquivalent(methodBody, otherMethod.block().body(), collectAndFilter);\n+          if (areEquivalent) {\n+            // If methods where not equivalent, we don't want to pollute the set of node to parameterize.\n+            collectAndFilter.validateCollection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzYzNTg3OnYy", "diffSide": "RIGHT", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDowMjoxNVrOHTjx_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDowMjoxNVrOHTjx_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI3MTIzMQ==", "bodyText": "We probably don't need to add method itself to handled because the two loops will only look after method in the methods list.", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490271231", "createdAt": "2020-09-17T14:02:15Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/tests/ParameterizedTestCheck.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.JavaTree;\n+import org.sonar.java.model.SyntacticEquivalence;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.BlockTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.StatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import static java.util.Arrays.asList;\n+\n+@Rule(key = \"S5976\")\n+public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String MESSAGE = \"Replace these %d tests with a single Parameterized one.\";\n+\n+  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(\n+    \"org.junit.Test\",\n+    \"org.junit.jupiter.api.Test\",\n+    \"org.testng.annotations.Test\"));\n+\n+  private static final int MIN_SIMILAR_METHODS = 3;\n+  private static final int MIN_NUMBER_STATEMENTS = 2;\n+  private static final int MAX_NUMBER_PARAMETER = 3;\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(ParameterizedTestCheck::isParametrizedCandidate)\n+      .collect(Collectors.toList());\n+    if (methods.size() < MIN_SIMILAR_METHODS) {\n+      return;\n+    }\n+\n+    Set<MethodTree> handled = new HashSet<>();\n+    for (int i = 0; i < methods.size(); i++) {\n+      MethodTree method = methods.get(i);\n+      List<StatementTree> methodBody = method.block().body();\n+      // In addition to filtering literals, we want to count the number of differences since they will represent the number of parameter\n+      // that would be required to transform the tests to a single parametrized one.\n+      CollectAndFilter collectAndFilter = new CollectAndFilter();\n+\n+      List<MethodTree> equivalentMethods = methods.stream()\n+        .skip(i + 1L)\n+        // avoid reporting multiple times\n+        .filter(otherMethod -> !handled.contains(otherMethod))\n+        // only consider method syntactically equivalent, ignoring literals\n+        .filter(otherMethod -> {\n+          boolean areEquivalent = SyntacticEquivalence.areEquivalent(methodBody, otherMethod.block().body(), collectAndFilter);\n+          if (areEquivalent) {\n+            // If methods where not equivalent, we don't want to pollute the set of node to parameterize.\n+            collectAndFilter.validateCollection();\n+          }\n+          return areEquivalent;\n+        })\n+        .collect(Collectors.toList());\n+\n+      if (equivalentMethods.size() + 1 >= MIN_SIMILAR_METHODS) {\n+        handled.add(method);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzc4MzQ3OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/model/SyntacticEquivalence.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMTozM1rOHTlM-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozMTozM1rOHTlM-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NDUyMA==", "bodyText": "I don't like the bellow variable name equivalenceFilter, I expect a filter to reduce the result and not to extends it. Here we pass (t1, t2) -> false to a filter, it's confusing, the result should be empty if it was a filter.\nWhy not calling it: tolerantEquivalence or permissiveEquivalence?", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490294520", "createdAt": "2020-09-17T14:31:33Z", "author": {"login": "alban-auzeill"}, "path": "java-frontend/src/main/java/org/sonar/java/model/SyntacticEquivalence.java", "diffHunk": "@@ -37,33 +37,53 @@ private SyntacticEquivalence() {\n    * @return true, if nodes are syntactically equivalent\n    */\n   public static boolean areEquivalent(List<? extends Tree> leftList, List<? extends Tree> rightList) {\n+    return areEquivalent(leftList, rightList, (t1, t2) -> false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c3a99a7603513e6d2ca14c1f3032b92fdfd246"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODE5NjA4OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/model/SyntacticEquivalence.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTo1Mjo1OFrOHTpQNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNTo1Mjo1OFrOHTpQNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM2MDg4Ng==", "bodyText": "duplicated line", "url": "https://github.com/SonarSource/sonar-java/pull/3182#discussion_r490360886", "createdAt": "2020-09-17T15:52:58Z", "author": {"login": "alban-auzeill"}, "path": "java-frontend/src/main/java/org/sonar/java/model/SyntacticEquivalence.java", "diffHunk": "@@ -37,33 +37,54 @@ private SyntacticEquivalence() {\n    * @return true, if nodes are syntactically equivalent\n    */\n   public static boolean areEquivalent(List<? extends Tree> leftList, List<? extends Tree> rightList) {\n+    return areEquivalent(leftList, rightList, (t1, t2) -> false);\n+  }\n+\n+  /**\n+   * @return true, if nodes are syntactically equivalent\n+   * Use permissiveEquivalence to force the equivalence of two nodes\n+   * Use permissiveEquivalence to force the equivalence of two nodes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f3ee4cb16adc7d4d864b81875700164c09e6011"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3897, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}