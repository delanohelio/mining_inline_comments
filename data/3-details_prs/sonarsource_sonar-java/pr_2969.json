{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MzIwNjcz", "number": 2969, "title": "Adding new Regex Parser (SONARJAVA-3425)", "bodyText": "", "createdAt": "2020-05-28T08:08:20Z", "url": "https://github.com/SonarSource/sonar-java/pull/2969", "merged": true, "mergeCommit": {"oid": "0722f0eb6686ab38602ea1df4103104163a91fd8"}, "closed": true, "closedAt": "2020-05-29T13:54:41Z", "author": {"login": "m-g-sonar"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclJeoagH2gAyNDI0MzIwNjczOmE4ZGQzY2JhOTE0YjFlZmI0NzFlMjQxN2E4YTFhZTI4MTlkMzEyNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmCNYlAH2gAyNDI0MzIwNjczOmUyYmExYWY5ZmI0YmRkNGNhZTczYmU2NmMxYWIwYTJlMDhhNDIwZDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a8dd3cba914b1efb471e2417a8a1ae2819d31270", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/a8dd3cba914b1efb471e2417a8a1ae2819d31270", "committedDate": "2020-05-26T19:03:53Z", "message": "Create AST for Regex parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39383d8572955dbc55fe30ac272478367cf4c557", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/39383d8572955dbc55fe30ac272478367cf4c557", "committedDate": "2020-05-27T11:17:28Z", "message": "Implement getting locations from RegexSource\n\nAlso implement getting the full string from a RegexSource and simplify\nthe code to get substrings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "909eb41c3ee6c30860a0b5ca0e3a432c64145a76", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/909eb41c3ee6c30860a0b5ca0e3a432c64145a76", "committedDate": "2020-05-27T13:57:40Z", "message": "Add missing license headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/adbc5a39173132e86cbba0b22a94eac38dea3cb2", "committedDate": "2020-05-27T17:27:24Z", "message": "Implement parsing for basic regex syntax"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMDQwODIy", "url": "https://github.com/SonarSource/sonar-java/pull/2969#pullrequestreview-420040822", "createdAt": "2020-05-28T12:06:27Z", "commit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjowNjoyOFrOGbyFQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoyMTo1MlrOGbylLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA==", "bodyText": "I wonder about this List. since we are passing the reference, it might be possible to modify it after. We probably better provide a Collections.unmodifiableList(...).", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431785280", "createdAt": "2020-05-28T12:06:28Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODIxMw==", "bodyText": "instead of throwing an exception here, I believe we could simply check at the very beginning of constructing the RegexSource if all the literals are STRING_LITERALs, and throw if it's not the case.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431788213", "createdAt": "2020-05-28T12:12:10Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4OTE4NA==", "bodyText": "can be written directly:\nreturn literal.asConstant(String.class)\n  .orElseThrow(() -> new IllegalArgumentException(\"Only string literals allowed\"));", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431789184", "createdAt": "2020-05-28T12:13:58Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MDc3MA==", "bodyText": "even if used only for temporary objects when computing locations, these 2 fields can be final", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431790770", "createdAt": "2020-05-28T12:16:51Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");\n+    }\n+  }\n+\n+  private static class Position {\n+    int indexOfLiteral;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MzQ1NQ==", "bodyText": "What about a Position constructor which exactly this instead of a dedicated method? Of course then the class can not be static anymore, but I think it makes sense.\nPosition startPosition = new Position(beginningOffset);\nPosition endPosition = new Position(endingOffset);\n\n...\nprivate class Position {\n  Position(int sourceIndex) {\n    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n    this.indexOfLiteral = entry.getKey();\n    this.indexInsideLiteral = entry.getValue();\n  }\n\n...", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431793455", "createdAt": "2020-05-28T12:21:52Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4beb022b72ab3d0276bcb4b088a9ae5dc8cd0609", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/4beb022b72ab3d0276bcb4b088a9ae5dc8cd0609", "committedDate": "2020-05-28T14:01:34Z", "message": "Fixes from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef46538260bb2d5250c20d08981c9bd331bc8e8b", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/ef46538260bb2d5250c20d08981c9bd331bc8e8b", "committedDate": "2020-05-28T14:05:55Z", "message": "Fix errors in the parser discovered while testing\n\nMost notably this fixes the precedence of sequences vs. the repetition\noperator (meaning PlainTextTree is now PlainCharacterTree because it\ncan't contain more than one character); inverts the result of\n`isPlainTextCharacter` to actually be correct; amends the list of\nnon-plain-text-characters and properly handles the index going out of\nbounds."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88bbcca56739540e73b5e2772a6711a032f20a58", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/88bbcca56739540e73b5e2772a6711a032f20a58", "committedDate": "2020-05-28T15:16:01Z", "message": "Fix error in index-range-to-location translation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35a2678e04b6223daf6d8296109b4b8429a95f6", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/b35a2678e04b6223daf6d8296109b4b8429a95f6", "committedDate": "2020-05-28T15:16:39Z", "message": "Implement equality for index ranges for easier testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "committedDate": "2020-05-28T15:19:24Z", "message": "Add parser tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "517e5b7a339b27f3b008bbd7fd20249a5736a01c", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/517e5b7a339b27f3b008bbd7fd20249a5736a01c", "committedDate": "2020-05-28T15:17:04Z", "message": "Add parser tests"}, "afterCommit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "committedDate": "2020-05-28T15:19:24Z", "message": "Add parser tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjY0NDE2", "url": "https://github.com/SonarSource/sonar-java/pull/2969#pullrequestreview-420264416", "createdAt": "2020-05-28T16:02:30Z", "commit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjowMjozMFrOGb8KMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjowMjozMFrOGb8KMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDM4NA==", "bodyText": "This merging can only work if the IndexRange given as argument is AFTER this IndexRange. Could it be done the other way or by construction we will always call it correctly?", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431950384", "createdAt": "2020-05-28T16:02:30Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/IndexRange.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.Objects;\n+\n+public class IndexRange {\n+\n+  private final int beginningOffset;\n+  private final int endingOffset;\n+\n+  public IndexRange(int beginningOffset, int endingOffset) {\n+    this.beginningOffset = beginningOffset;\n+    this.endingOffset = endingOffset;\n+  }\n+\n+  public int getBeginningOffset() {\n+    return beginningOffset;\n+  }\n+\n+  public int getEndingOffset() {\n+    return endingOffset;\n+  }\n+\n+  public IndexRange merge(IndexRange other) {\n+    return new IndexRange(beginningOffset, other.endingOffset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787fb066596e1038b2866ba58203ebb5ea8467c1", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/787fb066596e1038b2866ba58203ebb5ea8467c1", "committedDate": "2020-05-29T11:55:23Z", "message": "Separate regex parser tests into multiple classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f07df79d0c18acbec7f236198efca2fa8c6f5a2", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/9f07df79d0c18acbec7f236198efca2fa8c6f5a2", "committedDate": "2020-05-29T12:40:02Z", "message": "Make SyntaxErrors contain a RegexToken object\n\nOtherwise we'd have nothing to pass to `reportIssue`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2ba1af9fb4bdd4cae73be66c1ab0a2e08a420d3", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/e2ba1af9fb4bdd4cae73be66c1ab0a2e08a420d3", "committedDate": "2020-05-29T13:09:38Z", "message": "Add more tests for syntax errors and improve error messages\n\nAlso fix possible exception when trying to report an error at the end\nof the regular expression"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1692, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}