{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMzEzODYw", "number": 3353, "title": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection", "bodyText": "", "createdAt": "2020-12-15T14:59:06Z", "url": "https://github.com/SonarSource/sonar-java/pull/3353", "merged": true, "mergeCommit": {"oid": "dca00e260ac02e1cc962ae5846c906438a22bb9a"}, "closed": true, "closedAt": "2020-12-16T16:17:49Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmbuSQgBqjQxMTUwNTQ1MzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmxXkdgFqTU1Mzg1MjQ4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffa7a99cb8c0cfa166a9550150bfd0ef02548209", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/ffa7a99cb8c0cfa166a9550150bfd0ef02548209", "committedDate": "2020-12-15T14:56:04Z", "message": "WIP"}, "afterCommit": {"oid": "af30b8f864f046ed68d6d1c4d52281c25148e531", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/af30b8f864f046ed68d6d1c4d52281c25148e531", "committedDate": "2020-12-15T15:04:09Z", "message": "WIP"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af30b8f864f046ed68d6d1c4d52281c25148e531", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/af30b8f864f046ed68d6d1c4d52281c25148e531", "committedDate": "2020-12-15T15:04:09Z", "message": "WIP"}, "afterCommit": {"oid": "9eb9b81a65992db634a2a2ffb0620d72c79e8120", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/9eb9b81a65992db634a2a2ffb0620d72c79e8120", "committedDate": "2020-12-15T15:24:06Z", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNTc4MTcy", "url": "https://github.com/SonarSource/sonar-java/pull/3353#pullrequestreview-552578172", "createdAt": "2020-12-15T15:28:09Z", "commit": {"oid": "9eb9b81a65992db634a2a2ffb0620d72c79e8120"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyODoxMFrOIGRO8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyODoxMFrOIGRO8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NDcyMg==", "bodyText": "Without semantic this annotation won't be found. So this line protects of FPs in case of incomplete semantic., the same check is done in line 179", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r543444722", "createdAt": "2020-12-15T15:28:10Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> \n+          !(constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+            setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .flatMap(methodTree -> methodTree.parameters().stream())\n+      .map(variableTree -> variableTree.simpleName().name())\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static boolean isAnnotatedWithInject(MethodTree methodTree) {\n+    return methodTree.symbol().metadata().isAnnotatedWith(JAVAX_INJECT)\n+      || methodTree.symbol().metadata().annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eb9b81a65992db634a2a2ffb0620d72c79e8120"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "committedDate": "2020-12-15T15:30:14Z", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9eb9b81a65992db634a2a2ffb0620d72c79e8120", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/9eb9b81a65992db634a2a2ffb0620d72c79e8120", "committedDate": "2020-12-15T15:24:06Z", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection"}, "afterCommit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "committedDate": "2020-12-15T15:30:14Z", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDkyNDA3", "url": "https://github.com/SonarSource/sonar-java/pull/3353#pullrequestreview-553492407", "createdAt": "2020-12-16T09:19:37Z", "commit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOToxOTozN1rOIG7c8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTo0ODoyOVrOIG8tRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNjQzNQ==", "bodyText": "We are doing a first filtering here, and then a second in checkVariableMember thanks to isExcluded. We could move the second filtering here.\nIt will avoid having the differents kind of injections being filtered at two different places.", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544136435", "createdAt": "2020-12-16T09:19:37Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NTk5Mg==", "bodyText": "isAnnotatedWith will go through all annotations, so with this code, you end up going through the list 4 times when the field is not annotated by any of the annotations (which I expect to be the most frequent case). We could do everything in one shot, without using isAnnotatedWith.\nThe same happens in isAnnotatedWithInject.", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544145992", "createdAt": "2020-12-16T09:33:10Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -135,10 +173,14 @@ private static boolean isTransientSerializableOrInjected(VariableTree member) {\n       return true;\n     }\n     SymbolMetadata metadata = member.symbol().metadata();\n-    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\n+    return metadata.isAnnotatedWith(JAVAX_INJECT)\n       || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\n       || metadata.isAnnotatedWith(\"org.apache.wicket.spring.injection.annot.SpringBean\")\n-      || metadata.annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());\n+      || hasAnnotationsWithIncompleteSemantic(metadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng==", "bodyText": "I'm wondering if we can really rely on the naming of parameters here. As an example, we will not support the example described in the ticket.\nWhat is your opinion on it?", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544156996", "createdAt": "2020-12-16T09:48:29Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> \n+          !(constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+            setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .flatMap(methodTree -> methodTree.parameters().stream())\n+      .map(variableTree -> variableTree.simpleName().name())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzEwNTAx", "url": "https://github.com/SonarSource/sonar-java/pull/3353#pullrequestreview-553710501", "createdAt": "2020-12-16T13:59:21Z", "commit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMzo1OToyMVrOIHGnSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDozMjozNlrOIHILYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxOTMwNg==", "bodyText": "What do you think about this solution instead?\n  private static boolean isAnnotatedWith(SymbolMetadata metadata, String... fullyQualifiedNames) {\n    Set<String> fullyQualifiedNamesSet = new HashSet<>(Arrays.asList(fullyQualifiedNames));\n    return metadata.annotations().stream()\n      .map(a -> a.symbol().type())\n      .anyMatch(t -> t.isUnknown() || fullyQualifiedNamesSet.contains(t.fullyQualifiedName()));\n  }\nTo sum up, I'm using a stream instead of the loop, and a HashSet instead of isOneOf.", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544319306", "createdAt": "2020-12-16T13:59:21Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -135,10 +179,23 @@ private static boolean isTransientSerializableOrInjected(VariableTree member) {\n       return true;\n     }\n     SymbolMetadata metadata = member.symbol().metadata();\n-    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\n-      || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\n-      || metadata.isAnnotatedWith(\"org.apache.wicket.spring.injection.annot.SpringBean\")\n-      || metadata.annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());\n+    return isAnnotatedWith(metadata, JAVAX_INJECT, \"javax.ejb.EJB\", \"org.apache.wicket.spring.injection.annot.SpringBean\");\n+  }\n+\n+  private static boolean isAnnotatedWith(SymbolMetadata metadata, String... fullyQualifiedNames) {\n+    for (SymbolMetadata.AnnotationInstance annotation : metadata.annotations()) {\n+      Type type = annotation.symbol().type();\n+      if (type.isUnknown() || isOneOf(type, fullyQualifiedNames)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isOneOf(Type type, String[] fullyQualifiedNames) {\n+    return Arrays.stream(fullyQualifiedNames)\n+      .map(type::is)\n+      .reduce(false, Boolean::logicalOr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyNjUyMQ==", "bodyText": "You compute this two times (the first one in getConstructorInjectedFields), what about storing it in an intermediate variable instead?", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544326521", "createdAt": "2020-12-16T14:09:00Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,32 +65,65 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+\n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+\n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODkzMA==", "bodyText": "Nice one, this solution looks better to me! What about using it for the setter as well? Doing both in this method?", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544328930", "createdAt": "2020-12-16T14:12:13Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> \n+          !(constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+            setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .flatMap(methodTree -> methodTree.parameters().stream())\n+      .map(variableTree -> variableTree.simpleName().name())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng=="}, "originalCommit": {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzEyMA==", "bodyText": "This should work fine, I would just add a test when you have multiple constructors reaching the forEach, to make sure we are not losing anything across different visits.", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544333120", "createdAt": "2020-12-16T14:17:36Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,32 +65,65 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+\n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+\n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> !(isExcluded(variableTree) ||\n+          constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+          setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(methodTree -> isAnnotatedWith(methodTree.symbol().metadata(), JAVAX_INJECT))\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    Set<String> fields = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.VARIABLE))\n+      .map(VariableTree.class::cast)\n+      .map(variableTree -> variableTree.simpleName().name())\n+      .collect(Collectors.toSet());\n+\n+    AssignmentsVisitor assignmentsVisitor = new AssignmentsVisitor(fields);\n+    \n+    classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(methodTree -> isAnnotatedWith(methodTree.symbol().metadata(), JAVAX_INJECT))\n+      .forEach(methodTree -> methodTree.accept(assignmentsVisitor));\n+    \n+    return assignmentsVisitor.getUsedFields();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0NDkyOA==", "bodyText": "Do we really need this check? If we collect any variable assigned, it should work fine, the set returned will just contain unrelated names.", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544344928", "createdAt": "2020-12-16T14:32:36Z", "author": {"login": "quentin-jaquier-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -168,4 +225,30 @@ private static boolean implementsSerializable(@Nullable Type type) {\n     return false;\n   }\n \n+  private static final class AssignmentsVisitor extends BaseTreeVisitor {\n+    private final Set<String> fields;\n+    private final Set<String> usedFields = new HashSet<>();\n+\n+    public AssignmentsVisitor(Set<String> fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override\n+    public void visitAssignmentExpression(AssignmentExpressionTree tree) {\n+      if (ExpressionUtils.isSelectOnThisOrSuper(tree)) {\n+        MemberSelectExpressionTree select = ((MemberSelectExpressionTree) tree.variable());\n+        usedFields.add(select.identifier().name());\n+      } else if (tree.variable().is(Tree.Kind.IDENTIFIER)) {\n+        IdentifierTree identifier = ((IdentifierTree) tree.variable());\n+        if (fields.contains(identifier.name())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "committedDate": "2020-12-16T15:38:48Z", "message": "SONARJAVA-3467 Adjust review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0786f30246e6d3567e6435352b0937a37e9c9ecd", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/0786f30246e6d3567e6435352b0937a37e9c9ecd", "committedDate": "2020-12-16T12:38:10Z", "message": "SONARJAVA-3467 Adjust review comments"}, "afterCommit": {"oid": "120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "author": {"user": {"login": "margarita-nedzelska-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "committedDate": "2020-12-16T15:38:48Z", "message": "SONARJAVA-3467 Adjust review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzODUyNDg5", "url": "https://github.com/SonarSource/sonar-java/pull/3353#pullrequestreview-553852489", "createdAt": "2020-12-16T16:17:27Z", "commit": {"oid": "120d464fc62f118b1dcaeaaf70ce96eb832cd9d3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1871, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}