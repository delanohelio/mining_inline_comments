{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNTg4MDU4", "number": 3283, "title": "SONARJAVA-3557 Rule S6001: Back references in regular expressions should only refer to capturing groups that are matched before the reference", "bodyText": "", "createdAt": "2020-11-17T17:43:21Z", "url": "https://github.com/SonarSource/sonar-java/pull/3283", "merged": true, "mergeCommit": {"oid": "b53d136b3542ca88dcc208a9f9a6b09dd7e7a744"}, "closed": true, "closedAt": "2020-11-26T11:07:59Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdddduMgBqjQwMDY4MDk3MjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfU9RjgBqjQwMjc1ODU3NzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1b5c5b5a6b15b50b6e4aeafb485f2b8dba8d145", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/b1b5c5b5a6b15b50b6e4aeafb485f2b8dba8d145", "committedDate": "2020-11-17T17:41:54Z", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference"}, "afterCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/8076639e28ea0e7122712115e76528fb8196012c", "committedDate": "2020-11-17T18:00:32Z", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NTU2Mzg5", "url": "https://github.com/SonarSource/sonar-java/pull/3283#pullrequestreview-534556389", "createdAt": "2020-11-19T15:21:44Z", "commit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNToyMTo0NFrOH2jxlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoxNTo0M1rOH2mY7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3MTI4Ng==", "bodyText": "findIn go through the automaton state successors to find CapturingGroupTrees\nIf we stop before the FinalState it's dangerous, we will not call markBackReferences for all groups.\nFor example:\nA valid regex \"(.)\\\\1(.)\\\\2\" that can match \"aabb\" raises a false-positive.\nBecause findIn visits successors before filling the groupNames, so the back reference \\\\1 is an impossiblePath and we stop the visit.", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526971286", "createdAt": "2020-11-19T15:21:44Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);\n+  }\n+\n+  private static class CapturingGroupCollector extends RegexBaseVisitor {\n+    private final Map<String, CapturingGroupTree> capturingGroups = new HashMap<>();\n+    @Override\n+    public void visitCapturingGroup(CapturingGroupTree group) {\n+      capturingGroups.put(\"\" + group.getGroupNumber(), group);\n+      group.getName().ifPresent(name -> capturingGroups.put(name, group));\n+      super.visitCapturingGroup(group);\n+    }\n+  }\n+\n+  private static class ValidBackReferenceFinder {\n+    private final Set<BackReferenceTree> legalBackReferences = new HashSet<>();\n+    private final Set<String> groupNames = new HashSet<>();\n+    private final Set<AutomatonState> visited = new HashSet<>();\n+\n+    public void findIn(AutomatonState state) {\n+      if (visited.contains(state) || impossiblePath(state)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk4MzY2NA==", "bodyText": "the parameter visited has the same name as the field, so it could be confused by the reader.", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526983664", "createdAt": "2020-11-19T15:37:09Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);\n+  }\n+\n+  private static class CapturingGroupCollector extends RegexBaseVisitor {\n+    private final Map<String, CapturingGroupTree> capturingGroups = new HashMap<>();\n+    @Override\n+    public void visitCapturingGroup(CapturingGroupTree group) {\n+      capturingGroups.put(\"\" + group.getGroupNumber(), group);\n+      group.getName().ifPresent(name -> capturingGroups.put(name, group));\n+      super.visitCapturingGroup(group);\n+    }\n+  }\n+\n+  private static class ValidBackReferenceFinder {\n+    private final Set<BackReferenceTree> legalBackReferences = new HashSet<>();\n+    private final Set<String> groupNames = new HashSet<>();\n+    private final Set<AutomatonState> visited = new HashSet<>();\n+\n+    public void findIn(AutomatonState state) {\n+      if (visited.contains(state) || impossiblePath(state)) {\n+        return;\n+      }\n+      visited.add(state);\n+      for (AutomatonState succ : state.successors()) {\n+        findIn(succ);\n+      }\n+      if (state instanceof CapturingGroupTree) {\n+        CapturingGroupTree group = (CapturingGroupTree) state;\n+        markBackReferences(group, group.continuation(), new HashSet<>());\n+        groupNames.add(\"\" + group.getGroupNumber());\n+        group.getName().ifPresent(groupNames::add);\n+      }\n+    }\n+\n+    private boolean impossiblePath(AutomatonState state) {\n+      return state instanceof BackReferenceTree && !groupNames.contains(((BackReferenceTree) state).groupName());\n+    }\n+\n+    private void markBackReferences(CapturingGroupTree group, AutomatonState state, Set<AutomatonState> visited) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5NDczNQ==", "bodyText": "IMO, the check will find a lot of CapturingGroupTree and a few BackReferenceTree.\nAnd the current algorithm browses the tree to find the groups and from each group browses the tree to mark valid references. From a performance perspective, it's not good to do all those lookups for nothing.\nI would prefer to first use a RegexBaseVisitor to collect all the BackReferenceTree, and to continue only if the list is not empty. Then the collected list can be used at the end instead of ImpossibleBackReferenceFinder visitor.", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526994735", "createdAt": "2020-11-19T15:51:02Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxNDEyNg==", "bodyText": "the \\ should not be &amp;bsol;, only HTML dev would understand \ud83d\ude09", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r527014126", "createdAt": "2020-11-19T16:15:43Z", "author": {"login": "alban-auzeill"}, "path": "java-checks/src/main/resources/org/sonar/l10n/java/rules/java/S6001_java.html", "diffHunk": "@@ -0,0 +1,18 @@\n+<p>When a back reference in a regex refers to a capturing group that hasn't been defined yet (or at all), it can never be matched. Named back\n+references throw a <code>PatternSyntaxException</code> in that case; numeric back references fail silently when they can't match, simply making the\n+match fail.</p>\n+<p>When the group is defined before the back reference but on a different control path (like in <code>(.)|&amp;bsol;&amp;bsol;1</code> for example),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67dff30f4b345a5b1c15c3c91da1b1c27c11d97e", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/67dff30f4b345a5b1c15c3c91da1b1c27c11d97e", "committedDate": "2020-11-20T18:59:26Z", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8076639e28ea0e7122712115e76528fb8196012c", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/8076639e28ea0e7122712115e76528fb8196012c", "committedDate": "2020-11-17T18:00:32Z", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference"}, "afterCommit": {"oid": "9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "committedDate": "2020-11-20T18:59:26Z", "message": "Rework algorithm to get rid of FPs without FNs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99a6bb60aa11b6560e4335c638fbba55264d4335", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/99a6bb60aa11b6560e4335c638fbba55264d4335", "committedDate": "2020-11-23T13:13:42Z", "message": "Rework algorithm to get rid of FPs without FNs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "committedDate": "2020-11-20T18:59:26Z", "message": "Rework algorithm to get rid of FPs without FNs"}, "afterCommit": {"oid": "99a6bb60aa11b6560e4335c638fbba55264d4335", "author": {"user": {"login": "sebastian-hungerecker-sonarsource", "name": "Sebastian Hungerecker"}}, "url": "https://github.com/SonarSource/sonar-java/commit/99a6bb60aa11b6560e4335c638fbba55264d4335", "committedDate": "2020-11-23T13:13:42Z", "message": "Rework algorithm to get rid of FPs without FNs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1940, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}