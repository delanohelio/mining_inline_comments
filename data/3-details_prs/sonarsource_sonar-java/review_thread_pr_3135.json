{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NzUxNDUx", "number": 3135, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozMjo1NVrOEYa-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozODoxOFrOEYbENQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDQzMjI5OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozMjo1NVrOHAv3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozMjo1NVrOHAv3Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU0NjI1MQ==", "bodyText": "Is this always true or just in the case of boolean constraints? If not, under which conditions would SymbolicValue.setConstraint return a list of multiple items? And if so, why doesn't it return an option instead of a list?", "url": "https://github.com/SonarSource/sonar-java/pull/3135#discussion_r470546251", "createdAt": "2020-08-14T10:32:55Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "diffHunk": "@@ -502,6 +512,59 @@ private static ExpressionTree cleanupCondition(ExpressionTree condition) {\n     return cleanedUpCondition;\n   }\n \n+  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n+    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n+    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n+    ProgramState state = poppedSwitchValue.state;\n+\n+    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n+    for (CaseGroupTree caseGroup : caseGroups) {\n+      int numberOfCaseValues = caseGroup.labels()\n+        .stream()\n+        .map(CaseLabelTree::expressions)\n+        .mapToInt(List::size)\n+        .sum();\n+      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n+      state = poppedCaseValues.state;\n+      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n+    }\n+\n+    ProgramState elseState = state;\n+    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n+    // default block exists, the block after the switch statement.\n+    CFG.Block elseBlock = null;\n+    for (CFG.Block successor : programPosition.successors()) {\n+      CaseGroupTree caseGroup = successor.caseGroup();\n+      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+        continue;\n+      }\n+\n+      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n+        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n+        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n+        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n+        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n+      }\n+      if (successor.isDefaultBlock()) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+      }\n+    }\n+    assert(elseBlock != null);\n+    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n+  }\n+\n+  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {\n+    List<ProgramState> states = condition.setConstraint(state, constraint);\n+    if (states.isEmpty()) {\n+      return state;\n+    }\n+    assert(states.size() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c5706bfc9b357a4f4171c8590b30c28e4f49d5"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDQ0NzI1OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozODoxOFrOHAv_8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMDozODoxOFrOHAv_8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU0ODQ2Ng==", "bodyText": "I'm a bit unsure about this method because I'm generally a bit unsure about what SymbolicValue.setConstraint does (compared to ProgramState.addConstraint). From the code it looks like it adds the constraint unless it's already there, but that doesn't explain why it failed to properly add the constraints when I used ProgramState.addConstraint instead of this method.", "url": "https://github.com/SonarSource/sonar-java/pull/3135#discussion_r470548466", "createdAt": "2020-08-14T10:38:18Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "diffHunk": "@@ -502,6 +512,59 @@ private static ExpressionTree cleanupCondition(ExpressionTree condition) {\n     return cleanedUpCondition;\n   }\n \n+  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n+    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n+    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n+    ProgramState state = poppedSwitchValue.state;\n+\n+    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n+    for (CaseGroupTree caseGroup : caseGroups) {\n+      int numberOfCaseValues = caseGroup.labels()\n+        .stream()\n+        .map(CaseLabelTree::expressions)\n+        .mapToInt(List::size)\n+        .sum();\n+      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n+      state = poppedCaseValues.state;\n+      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n+    }\n+\n+    ProgramState elseState = state;\n+    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n+    // default block exists, the block after the switch statement.\n+    CFG.Block elseBlock = null;\n+    for (CFG.Block successor : programPosition.successors()) {\n+      CaseGroupTree caseGroup = successor.caseGroup();\n+      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+        continue;\n+      }\n+\n+      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n+        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n+        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n+        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n+        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n+      }\n+      if (successor.isDefaultBlock()) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+      }\n+    }\n+    assert(elseBlock != null);\n+    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n+  }\n+\n+  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c5706bfc9b357a4f4171c8590b30c28e4f49d5"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3982, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}