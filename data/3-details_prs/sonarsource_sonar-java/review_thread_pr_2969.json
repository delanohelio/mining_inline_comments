{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MzIwNjcz", "number": 2969, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjowNjoyOFrOEAeohw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjowMjozMFrOEAkyYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTM3MzUxOnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjowNjoyOFrOGbyFQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxODoxNlrOGb0pbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA==", "bodyText": "I wonder about this List. since we are passing the reference, it might be possible to modify it after. We probably better provide a Collections.unmodifiableList(...).", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431785280", "createdAt": "2020-05-28T12:06:28Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMjg3MA==", "bodyText": "@m-g-sonar Are you worried that RegexSource might modify the list? Or that someone else (with access to the original list) might modify the list after the RegexSource is created? Because unmodifiableList won't prevent the latter - we'd need to make an actual copy to protect against that. And as for the former, I don't think it's necessary to use unmodifiableList to prevent modifications from within the same class.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431822870", "createdAt": "2020-05-28T13:11:44Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNjY1OQ==", "bodyText": "Actually you're right, we should be making it unmodifiable because the literals are accessible through a public getter. I forgot about that. Thanks.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431826659", "createdAt": "2020-05-28T13:17:12Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNzMxMQ==", "bodyText": "Though on third thought, it might make more sense to just remove the getter because I don't think we actually need it.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431827311", "createdAt": "2020-05-28T13:18:16Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTM5MTg1OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoxMjoxMFrOGbyQtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyMzoxMlrOGb01-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODIxMw==", "bodyText": "instead of throwing an exception here, I believe we could simply check at the very beginning of constructing the RegexSource if all the literals are STRING_LITERALs, and throw if it's not the case.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431788213", "createdAt": "2020-05-28T12:12:10Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDUyMA==", "bodyText": "We are doing this at the beginning of the constructor (that's when getString is called).", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431830520", "createdAt": "2020-05-28T13:23:12Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODIxMw=="}, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTM5ODEzOnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoxMzo1OFrOGbyUgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoxMzo1OFrOGbyUgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4OTE4NA==", "bodyText": "can be written directly:\nreturn literal.asConstant(String.class)\n  .orElseThrow(() -> new IllegalArgumentException(\"Only string literals allowed\"));", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431789184", "createdAt": "2020-05-28T12:13:58Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTQwNzY3OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoxNjo1MVrOGbyasg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoxNjo1MVrOGbyasg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MDc3MA==", "bodyText": "even if used only for temporary objects when computing locations, these 2 fields can be final", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431790770", "createdAt": "2020-05-28T12:16:51Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");\n+    }\n+  }\n+\n+  private static class Position {\n+    int indexOfLiteral;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTQyNDAwOnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjoyMTo1MlrOGbylLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxMzoyM1rOGb0cYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MzQ1NQ==", "bodyText": "What about a Position constructor which exactly this instead of a dedicated method? Of course then the class can not be static anymore, but I think it makes sense.\nPosition startPosition = new Position(beginningOffset);\nPosition endPosition = new Position(endingOffset);\n\n...\nprivate class Position {\n  Position(int sourceIndex) {\n    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n    this.indexOfLiteral = entry.getKey();\n    this.indexInsideLiteral = entry.getValue();\n  }\n\n...", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431793455", "createdAt": "2020-05-28T12:21:52Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMzk3MA==", "bodyText": "That makes sense, I'll do that. Thank you.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431823970", "createdAt": "2020-05-28T13:13:23Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MzQ1NQ=="}, "originalCommit": {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDM4MTc3OnYy", "diffSide": "RIGHT", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/IndexRange.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjowMjozMFrOGb8KMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjoxMDoyM1rOGb8dkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDM4NA==", "bodyText": "This merging can only work if the IndexRange given as argument is AFTER this IndexRange. Could it be done the other way or by construction we will always call it correctly?", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431950384", "createdAt": "2020-05-28T16:02:30Z", "author": {"login": "m-g-sonar"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/IndexRange.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.Objects;\n+\n+public class IndexRange {\n+\n+  private final int beginningOffset;\n+  private final int endingOffset;\n+\n+  public IndexRange(int beginningOffset, int endingOffset) {\n+    this.beginningOffset = beginningOffset;\n+    this.endingOffset = endingOffset;\n+  }\n+\n+  public int getBeginningOffset() {\n+    return beginningOffset;\n+  }\n+\n+  public int getEndingOffset() {\n+    return endingOffset;\n+  }\n+\n+  public IndexRange merge(IndexRange other) {\n+    return new IndexRange(beginningOffset, other.endingOffset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NTM0Ng==", "bodyText": "Barring bugs in the parser, it should only ever be called with the earlier index range first. It might be a good idea to verify this and throw an InvalidArgumentException otherwise though.", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431955346", "createdAt": "2020-05-28T16:10:23Z", "author": {"login": "sebastian-hungerecker-sonarsource"}, "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/IndexRange.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.Objects;\n+\n+public class IndexRange {\n+\n+  private final int beginningOffset;\n+  private final int endingOffset;\n+\n+  public IndexRange(int beginningOffset, int endingOffset) {\n+    this.beginningOffset = beginningOffset;\n+    this.endingOffset = endingOffset;\n+  }\n+\n+  public int getBeginningOffset() {\n+    return beginningOffset;\n+  }\n+\n+  public int getEndingOffset() {\n+    return endingOffset;\n+  }\n+\n+  public IndexRange merge(IndexRange other) {\n+    return new IndexRange(beginningOffset, other.endingOffset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDM4NA=="}, "originalCommit": {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4003, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}