{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MTYwMjUx", "number": 3218, "title": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes", "bodyText": "", "createdAt": "2020-09-28T13:54:49Z", "url": "https://github.com/SonarSource/sonar-java/pull/3218", "merged": true, "mergeCommit": {"oid": "d9bb379b1446c29c001b96cb4d7838820bc2383e"}, "closed": true, "closedAt": "2020-09-29T14:48:00Z", "author": {"login": "quentin-jaquier-sonarsource"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNTCw8AH2gAyNDk0MTYwMjUxOmNlZWJmMzVjYzQ4ZGM1YTE2OTEwYmU4YTU4M2Q5M2FjNDIxYjZjNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNncadgH2gAyNDk0MTYwMjUxOjcyYmE0YWM4ZmIyYjU5YjRkNDE1MjJiZDNlN2Y1OWRhOGQyMjQxM2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ceebf35cc48dc5a16910be8a583d93ac421b6c77", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/ceebf35cc48dc5a16910be8a583d93ac421b6c77", "committedDate": "2020-09-28T12:49:28Z", "message": "Move S2333 tests files to compiled module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "committedDate": "2020-09-28T15:04:40Z", "message": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "847e4ca4e3063304147801bc806b86f1e91c0397", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/847e4ca4e3063304147801bc806b86f1e91c0397", "committedDate": "2020-09-28T13:53:09Z", "message": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes"}, "afterCommit": {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "committedDate": "2020-09-28T15:04:40Z", "message": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTYwMjU4", "url": "https://github.com/SonarSource/sonar-java/pull/3218#pullrequestreview-498160258", "createdAt": "2020-09-29T07:17:50Z", "commit": {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoxNzo1MFrOHZeIEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODoxNTowN1rOHZgshA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3MDAzMg==", "bodyText": "Maybe it would be nice to have a method 'checkRedundantmodifiers' with vararg argument of Modifiers, so you can call it once with a couple of modifiers", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496470032", "createdAt": "2020-09-29T07:17:50Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -64,6 +64,13 @@ public void visitNode(Tree tree) {\n         checkRedundantModifier(modifiers, Modifier.FINAL);\n       } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n         checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      } else if (member.is(Kind.CLASS, Kind.INTERFACE) && isInterfaceOrAnnotation(tree)) {\n+        ClassTree nested = (ClassTree) member;\n+        ModifiersTree modifiers = nested.modifiers();\n+        checkRedundantModifier(modifiers, Modifier.PUBLIC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjUxMjEzMg==", "bodyText": "In general I'll suggest to refactor it switch {} to have sth like this:\nswitch (member.kind()) {\n        case METHOD:\n          checkMethod(classTree, (MethodTree) member);\n          break;\n        case VARIABLE:\n          checkVariable(classTree, (VariableTree) member);\n          break;\n        case CONSTRUCTOR: ...\n        case CLASS: ...\n        case INTERFACE: ...\n\n      }\n\nTo my mind it will be more readable, too many else if is quite difficult to understand", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496512132", "createdAt": "2020-09-29T08:15:07Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -64,6 +64,13 @@ public void visitNode(Tree tree) {\n         checkRedundantModifier(modifiers, Modifier.FINAL);\n       } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n         checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      } else if (member.is(Kind.CLASS, Kind.INTERFACE) && isInterfaceOrAnnotation(tree)) {\n+        ClassTree nested = (ClassTree) member;\n+        ModifiersTree modifiers = nested.modifiers();\n+        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n+        checkRedundantModifier(modifiers, Modifier.STATIC);\n+      } else if (member.is(Kind.INTERFACE) && tree.is(Kind.CLASS, Kind.ENUM)) {\n+        checkRedundantModifier(((ClassTree) member).modifiers(), Modifier.STATIC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f57a30d86c32603ca1d1125321068b342b269adb", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/f57a30d86c32603ca1d1125321068b342b269adb", "committedDate": "2020-09-29T09:49:04Z", "message": "Refactor code for readability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MzI5MjIz", "url": "https://github.com/SonarSource/sonar-java/pull/3218#pullrequestreview-498329223", "createdAt": "2020-09-29T10:29:58Z", "commit": {"oid": "f57a30d86c32603ca1d1125321068b342b269adb"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMDoyOTo1OFrOHZmujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMDozNToxNlrOHZm6VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMDk1OA==", "bodyText": "Maybe it would be nice to rename it to sth more general like checkNestedType. Cause this method is used on both classes and interfaces, so a little bit confusing.", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496610958", "createdAt": "2020-09-29T10:29:58Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f57a30d86c32603ca1d1125321068b342b269adb"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMTc4Mw==", "bodyText": "Maybe 'Modifiers'?", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496611783", "createdAt": "2020-09-29T10:31:24Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = nested.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC);\n+    }\n+  }\n+\n+  private void checkNestedInterface(ClassTree nested, ClassTree classTree) {\n+    if (classTree.is(Kind.CLASS, Kind.ENUM)) {\n+      checkRedundantModifier(nested.modifiers(), Modifier.STATIC);\n+    }\n+  }\n+\n   private static boolean isInterfaceOrAnnotation(Tree tree) {\n     return tree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);\n   }\n \n-  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier modifier) {\n-    ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n-    if (foundModifier != null) {\n-      reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");\n+  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier... modifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f57a30d86c32603ca1d1125321068b342b269adb"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMzk3Mw==", "bodyText": "I'll suggest also to have a String representation of each modifier somewhere in utils or helpers. Cause it's not optimal to have modifier.toString().toLowerCase(Locale.US)  each time we need it.\nAlso, that's up to you, personally I prefer String.format() over String concat.", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496613973", "createdAt": "2020-09-29T10:35:16Z", "author": {"login": "margarita-nedzelska-sonarsource"}, "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = nested.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC);\n+    }\n+  }\n+\n+  private void checkNestedInterface(ClassTree nested, ClassTree classTree) {\n+    if (classTree.is(Kind.CLASS, Kind.ENUM)) {\n+      checkRedundantModifier(nested.modifiers(), Modifier.STATIC);\n+    }\n+  }\n+\n   private static boolean isInterfaceOrAnnotation(Tree tree) {\n     return tree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);\n   }\n \n-  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier modifier) {\n-    ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n-    if (foundModifier != null) {\n-      reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");\n+  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier... modifiers) {\n+    for (Modifier modifier : modifiers) {\n+      ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n+      if (foundModifier != null) {\n+        reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f57a30d86c32603ca1d1125321068b342b269adb"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72ba4ac8fb2b59b4d41522bd3e7f59da8d22413e", "author": {"user": {"login": "quentin-jaquier-sonarsource", "name": null}}, "url": "https://github.com/SonarSource/sonar-java/commit/72ba4ac8fb2b59b4d41522bd3e7f59da8d22413e", "committedDate": "2020-09-29T12:35:35Z", "message": "Fix from review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1897, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}