{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDc1ODA0", "number": 4431, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDo1ODoxM1rOFGv8fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNzoyMjoyN1rOFG0Wag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNjIxMzA5OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/InstallationCleaner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDo1ODoxM1rOIH5lzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNjoyNlrOIH842Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1NDUwOA==", "bodyText": "Should it be java.exe for Windows?", "url": "https://github.com/wildfly/wildfly-core/pull/4431#discussion_r545154508", "createdAt": "2020-12-17T14:58:13Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/InstallationCleaner.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ *\n+ * Copyright 2020 Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Allows for cleanup of a bootable JAR installation. The {@link #run()} method blocks until the\n+ * {@linkplain BootableEnvironment#getPidFile() PID file} is deleted or a\n+ * {@linkplain BootableEnvironment#getTimeout() timeout} is reached. Then there is an attempt to delete the install\n+ * directory.\n+ * <p>\n+ * If the {@code org.wildfly.core.jar.cleanup.newProcess} system property is set to {@code true}, the default for Windows,\n+ * a new process will be launched to delete the install directory.\n+ * </p>\n+ *\n+ * @author <a href=\"mailto:jperkins@redhat.com\">James R. Perkins</a>\n+ */\n+class InstallationCleaner implements Runnable {\n+    private final BootableEnvironment environment;\n+    private final Path cleanupMarker;\n+    private final BootableJarLogger logger;\n+    private final boolean newProcess;\n+    private final int retries;\n+\n+    InstallationCleaner(final BootableEnvironment environment, final BootableJarLogger logger) {\n+        this.environment = environment;\n+        cleanupMarker = environment.getJBossHome().resolve(\"wildfly-cleanup-marker\");\n+        this.logger = logger;\n+        newProcess = getProperty(\"org.wildfly.core.jar.cleanup.newProcess\", environment.isWindows());\n+        retries = getProperty(\"org.wildfly.core.jar.cleanup.retries\", 3);\n+    }\n+\n+    @Override\n+    public void run() {\n+        // Clean up is not already in progress\n+        if (Files.notExists(cleanupMarker)) {\n+            try {\n+                Files.createFile(cleanupMarker);\n+                long timeout = environment.getTimeout() * 1000;\n+                final Path pidFile = environment.getPidFile();\n+                final long wait = 500L;\n+                while (Files.exists(pidFile)) {\n+                    try {\n+                        TimeUnit.MILLISECONDS.sleep(wait);\n+                    } catch (InterruptedException ignore) {\n+                        break;\n+                    }\n+                    timeout -= wait;\n+                    if (timeout <= 0) {\n+                        logger.cleanupTimeout(environment.getTimeout(), pidFile);\n+                        break;\n+                    }\n+                }\n+                cleanup();\n+            } catch (IOException e) {\n+                logger.failedToStartCleanupProcess(e, environment.getJBossHome());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Either starts a new process to delete the install directory or deletes the install directory in the current\n+     * process.\n+     * <p>\n+     * By default Windows will launch a new cleanup process. This can be controlled by setting the\n+     * {@code org.wildfly.core.jar.cleanup.newProcess} to {@code true} to launch or a new process or {@code false} to\n+     * delete the install directory in the current process.\n+     * </p>\n+     *\n+     * @throws IOException if an error occurs deleting the directory\n+     */\n+    void cleanup() throws IOException {\n+        if (newProcess) {\n+            try {\n+                newProcess();\n+            } catch (IOException e) {\n+                deleteDirectory();\n+                throw e;\n+            }\n+        } else {\n+            deleteDirectory();\n+        }\n+    }\n+\n+    private void deleteDirectory() throws IOException {\n+        final Path installDir = environment.getJBossHome();\n+        Files.walkFileTree(installDir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) {\n+                try {\n+                    // Don't delete the cleanup marker until we're ready to delete the directory\n+                    if (!file.equals(cleanupMarker)) {\n+                        Files.delete(file);\n+                    }\n+                } catch (IOException e) {\n+                    logger.cantDelete(file.toString(), e);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) {\n+                try {\n+                    if (dir.equals(installDir)) {\n+                        // We have to delete the marker before we can delete the directory\n+                        Files.deleteIfExists(cleanupMarker);\n+                    }\n+                    Files.delete(dir);\n+                } catch (IOException e) {\n+                    logger.cantDelete(dir.toString(), e);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private void newProcess() throws IOException {\n+        // Start a new process which will clean up the install directory. This is done in a new process in cases where\n+        // this process may hold locks on to resources that need to be cleaned up.\n+        final String[] cmd = {\n+                getJavaCommand(),\n+                \"-cp\",\n+                // Use the current class path as it should just have the bootable JAR on it and this is where the\n+                // CleanupProcess is located.\n+                System.getProperty(\"java.class.path\"),\n+                \"org.wildfly.core.jar.boot.CleanupProcessor\",\n+                environment.getJBossHome().toString(),\n+                Integer.toString(retries)\n+        };\n+        final ProcessBuilder builder = new ProcessBuilder(cmd)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                .directory(new File(System.getProperty(\"user.dir\")));\n+        builder.start();\n+    }\n+\n+    private String getJavaCommand() {\n+        final Path javaHome = Paths.get(System.getProperty(\"java.home\"));\n+        final Path java;\n+        if (environment.isWindows()) {\n+            java = javaHome.resolve(\"bin\").resolve(\"java.exe\");\n+        } else {\n+            java = javaHome.resolve(\"bin\").resolve(\"java\");\n+        }\n+        if (Files.exists(java)) {\n+            return java.toString();\n+        }\n+        return \"java\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5880c1e9e66436af22ea0a041801a3dd34a13c"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwODUzNw==", "bodyText": "I thought about that, but I know on Windows from CMD java works. That said java.home should never be a missing property and this is a fallback that should never happen.", "url": "https://github.com/wildfly/wildfly-core/pull/4431#discussion_r545208537", "createdAt": "2020-12-17T16:06:26Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/InstallationCleaner.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ *\n+ * Copyright 2020 Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Allows for cleanup of a bootable JAR installation. The {@link #run()} method blocks until the\n+ * {@linkplain BootableEnvironment#getPidFile() PID file} is deleted or a\n+ * {@linkplain BootableEnvironment#getTimeout() timeout} is reached. Then there is an attempt to delete the install\n+ * directory.\n+ * <p>\n+ * If the {@code org.wildfly.core.jar.cleanup.newProcess} system property is set to {@code true}, the default for Windows,\n+ * a new process will be launched to delete the install directory.\n+ * </p>\n+ *\n+ * @author <a href=\"mailto:jperkins@redhat.com\">James R. Perkins</a>\n+ */\n+class InstallationCleaner implements Runnable {\n+    private final BootableEnvironment environment;\n+    private final Path cleanupMarker;\n+    private final BootableJarLogger logger;\n+    private final boolean newProcess;\n+    private final int retries;\n+\n+    InstallationCleaner(final BootableEnvironment environment, final BootableJarLogger logger) {\n+        this.environment = environment;\n+        cleanupMarker = environment.getJBossHome().resolve(\"wildfly-cleanup-marker\");\n+        this.logger = logger;\n+        newProcess = getProperty(\"org.wildfly.core.jar.cleanup.newProcess\", environment.isWindows());\n+        retries = getProperty(\"org.wildfly.core.jar.cleanup.retries\", 3);\n+    }\n+\n+    @Override\n+    public void run() {\n+        // Clean up is not already in progress\n+        if (Files.notExists(cleanupMarker)) {\n+            try {\n+                Files.createFile(cleanupMarker);\n+                long timeout = environment.getTimeout() * 1000;\n+                final Path pidFile = environment.getPidFile();\n+                final long wait = 500L;\n+                while (Files.exists(pidFile)) {\n+                    try {\n+                        TimeUnit.MILLISECONDS.sleep(wait);\n+                    } catch (InterruptedException ignore) {\n+                        break;\n+                    }\n+                    timeout -= wait;\n+                    if (timeout <= 0) {\n+                        logger.cleanupTimeout(environment.getTimeout(), pidFile);\n+                        break;\n+                    }\n+                }\n+                cleanup();\n+            } catch (IOException e) {\n+                logger.failedToStartCleanupProcess(e, environment.getJBossHome());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Either starts a new process to delete the install directory or deletes the install directory in the current\n+     * process.\n+     * <p>\n+     * By default Windows will launch a new cleanup process. This can be controlled by setting the\n+     * {@code org.wildfly.core.jar.cleanup.newProcess} to {@code true} to launch or a new process or {@code false} to\n+     * delete the install directory in the current process.\n+     * </p>\n+     *\n+     * @throws IOException if an error occurs deleting the directory\n+     */\n+    void cleanup() throws IOException {\n+        if (newProcess) {\n+            try {\n+                newProcess();\n+            } catch (IOException e) {\n+                deleteDirectory();\n+                throw e;\n+            }\n+        } else {\n+            deleteDirectory();\n+        }\n+    }\n+\n+    private void deleteDirectory() throws IOException {\n+        final Path installDir = environment.getJBossHome();\n+        Files.walkFileTree(installDir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) {\n+                try {\n+                    // Don't delete the cleanup marker until we're ready to delete the directory\n+                    if (!file.equals(cleanupMarker)) {\n+                        Files.delete(file);\n+                    }\n+                } catch (IOException e) {\n+                    logger.cantDelete(file.toString(), e);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) {\n+                try {\n+                    if (dir.equals(installDir)) {\n+                        // We have to delete the marker before we can delete the directory\n+                        Files.deleteIfExists(cleanupMarker);\n+                    }\n+                    Files.delete(dir);\n+                } catch (IOException e) {\n+                    logger.cantDelete(dir.toString(), e);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private void newProcess() throws IOException {\n+        // Start a new process which will clean up the install directory. This is done in a new process in cases where\n+        // this process may hold locks on to resources that need to be cleaned up.\n+        final String[] cmd = {\n+                getJavaCommand(),\n+                \"-cp\",\n+                // Use the current class path as it should just have the bootable JAR on it and this is where the\n+                // CleanupProcess is located.\n+                System.getProperty(\"java.class.path\"),\n+                \"org.wildfly.core.jar.boot.CleanupProcessor\",\n+                environment.getJBossHome().toString(),\n+                Integer.toString(retries)\n+        };\n+        final ProcessBuilder builder = new ProcessBuilder(cmd)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                .directory(new File(System.getProperty(\"user.dir\")));\n+        builder.start();\n+    }\n+\n+    private String getJavaCommand() {\n+        final Path javaHome = Paths.get(System.getProperty(\"java.home\"));\n+        final Path java;\n+        if (environment.isWindows()) {\n+            java = javaHome.resolve(\"bin\").resolve(\"java.exe\");\n+        } else {\n+            java = javaHome.resolve(\"bin\").resolve(\"java\");\n+        }\n+        if (Files.exists(java)) {\n+            return java.toString();\n+        }\n+        return \"java\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1NDUwOA=="}, "originalCommit": {"oid": "6d5880c1e9e66436af22ea0a041801a3dd34a13c"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNjkzNDgyOnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNzoyMjoyN1rOIIAS7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODo0NTo1MVrOIIDswg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDM2NQ==", "bodyText": "Maybe instead of just logging this should throw an exception. What do you think @jfdenise?", "url": "https://github.com/wildfly/wildfly-core/pull/4431#discussion_r545264365", "createdAt": "2020-12-17T17:22:27Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -233,21 +230,15 @@ private LogContext configureLogContext() throws IOException {\n     }\n \n     public void run() throws Exception {\n-        try {\n-            server = buildServer(startServerArgs);\n-        } catch (RuntimeException ex) {\n-            cleanup();\n-            throw ex;\n-        }\n-\n         Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n-        server.start();\n-    }\n-\n-    private void cleanup() {\n-        log.deletingHome(environment.getJBossHome());\n-        deleteDir(environment.getJBossHome());\n+        server = buildServer(startServerArgs);\n \n+        if (Files.notExists(pidFile)) {\n+            Files.write(pidFile, Collections.singleton(Long.toString(org.wildfly.common.os.Process.getProcessId())), StandardCharsets.UTF_8, StandardOpenOption.CREATE_NEW);\n+        } else {\n+            log.pidFileAlreadyExists(pidFile, environment.getJBossHome());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5880c1e9e66436af22ea0a041801a3dd34a13c"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMyMDEzMA==", "bodyText": "I agree, that seems an invalid state. We should start from an empty directory.", "url": "https://github.com/wildfly/wildfly-core/pull/4431#discussion_r545320130", "createdAt": "2020-12-17T18:45:51Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -233,21 +230,15 @@ private LogContext configureLogContext() throws IOException {\n     }\n \n     public void run() throws Exception {\n-        try {\n-            server = buildServer(startServerArgs);\n-        } catch (RuntimeException ex) {\n-            cleanup();\n-            throw ex;\n-        }\n-\n         Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n-        server.start();\n-    }\n-\n-    private void cleanup() {\n-        log.deletingHome(environment.getJBossHome());\n-        deleteDir(environment.getJBossHome());\n+        server = buildServer(startServerArgs);\n \n+        if (Files.notExists(pidFile)) {\n+            Files.write(pidFile, Collections.singleton(Long.toString(org.wildfly.common.os.Process.getProcessId())), StandardCharsets.UTF_8, StandardOpenOption.CREATE_NEW);\n+        } else {\n+            log.pidFileAlreadyExists(pidFile, environment.getJBossHome());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDM2NQ=="}, "originalCommit": {"oid": "6d5880c1e9e66436af22ea0a041801a3dd34a13c"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3753, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}