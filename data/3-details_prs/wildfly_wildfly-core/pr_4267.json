{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5Mzc0Mzcw", "number": 4267, "title": "[WFCORE-5032] Elytron subsystem should not depend upon PicketBox", "bodyText": "Performing some testing provisioning a server without legacy security was causing JACC to fail, this PR is the WildFly Core side of changes to revisit the relationship between Elytron and Legacy Security for JACC handling.  To get clean CI runs this will require the WildFly PR to be merged first:\nwildfly/wildfly#13407\nhttps://issues.redhat.com/browse/WFCORE-5032 - Elytron should not have a dependency on PicketBox.\nhttps://issues.redhat.com/browse/WFCORE-5020 - Ensure the PolicyConfigurationFactory registration happens using service start up and uses the specified module for class loading.\nhttps://issues.redhat.com/browse/WFCORE-5049 - Ensure any Policy is installed before instantiating the PolicyConfigurationFactory.\nStarting off with the hold label in place as some additional testing is also being performed but unless issues are found these PRs are ready for review.", "createdAt": "2020-07-15T09:54:19Z", "url": "https://github.com/wildfly/wildfly-core/pull/4267", "merged": true, "mergeCommit": {"oid": "34370813cc48a17d94e9ea2f35a3eb1042960bc6"}, "closed": true, "closedAt": "2020-08-06T14:45:28Z", "author": {"login": "darranl"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy6rSKAH2gAyNDQ5Mzc0MzcwOmQ0ZDYxMWEzZjI4NjgwYTBhMzA1OWM0NmFmOGRlYjhlZGM2Zjc4N2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7jjwmgH2gAyNDQ5Mzc0MzcwOmE0NWQwOTlmZGMzN2M2M2NjOWU0MGE1MTAxYTM4NDVlZDNiOTRhZDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d4d611a3f28680a0a3059c46af8deb8edc6f787e", "author": {"user": {"login": "ehsavoie", "name": "Emmanuel Hugonnet"}}, "url": "https://github.com/wildfly/wildfly-core/commit/d4d611a3f28680a0a3059c46af8deb8edc6f787e", "committedDate": "2020-07-08T13:44:04Z", "message": "[WFCORE-4873]: Upgrade JGit to 5.8.0.202006091008-r\n\n * Adding a new layer to be able to 'remove' git support.\n * Adding bouncycastle dependencies and splitting the modules.\n * Removing jcraft jsch and jzlib dependencies.\n * Upgrading jgit and its dependency JavaEWAH to 1.1.7.\n * Disabling commit signing.\n\nJira: https://issues.redhat.com/browse/WFCORE-4873"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a0235aeb9898aeb2a370ce8a14540ef5f6dbc1", "author": {"user": {"login": "fjuma", "name": "Farah Juma"}}, "url": "https://github.com/wildfly/wildfly-core/commit/54a0235aeb9898aeb2a370ce8a14540ef5f6dbc1", "committedDate": "2020-07-10T19:25:02Z", "message": "[WFCORE-5042] Upgrade WildFly Elytron to 1.13.0.CR2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d23772731876ce9f95f800296d7d0665a81c774d", "author": {"user": {"login": "ashley-abdelsayed98", "name": "Ashley Abdel-Sayed"}}, "url": "https://github.com/wildfly/wildfly-core/commit/d23772731876ce9f95f800296d7d0665a81c774d", "committedDate": "2020-07-10T19:26:03Z", "message": "[WFCORE-5044] Add org.apache.sshd:sshd-common dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5585e2c0c5da48ad9d9ad733ef87f9355e56000f", "author": {"user": {"login": "darranl", "name": "Darran Lofthouse"}}, "url": "https://github.com/wildfly/wildfly-core/commit/5585e2c0c5da48ad9d9ad733ef87f9355e56000f", "committedDate": "2020-07-15T08:56:43Z", "message": "[WFCORE-5042] Upgrade WildFly Elytron to 1.13.0.CR2\n\nAddress merge conflict with [WFCORE-4873]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbcaff70c6ed34b52c728365e774078cfe30dd70", "author": {"user": {"login": "darranl", "name": "Darran Lofthouse"}}, "url": "https://github.com/wildfly/wildfly-core/commit/bbcaff70c6ed34b52c728365e774078cfe30dd70", "committedDate": "2020-07-15T09:12:19Z", "message": "[WFCORE-5032] Remove direct dependency on PicketBox and instead dynamically discover PolicyContextHandlers from the security subsystem if available."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53af992d24ceea74b3693b8121bdc5d1451c699b", "author": {"user": {"login": "darranl", "name": "Darran Lofthouse"}}, "url": "https://github.com/wildfly/wildfly-core/commit/53af992d24ceea74b3693b8121bdc5d1451c699b", "committedDate": "2020-07-15T09:12:19Z", "message": "[WFCORE-5020] Ensure and defined PolicyConfigurationFactory is instantiated at the time the service starts.\n\nAlso use the defined module and verify the correct instance was loaded."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c", "author": {"user": {"login": "darranl", "name": "Darran Lofthouse"}}, "url": "https://github.com/wildfly/wildfly-core/commit/8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c", "committedDate": "2020-07-15T09:12:19Z", "message": "[WFCORE-5049] Ensure the Policy is registered before the PolicyConfigurationFactory is instantiated."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5ODA2NjU4", "url": "https://github.com/wildfly/wildfly-core/pull/4267#pullrequestreview-459806658", "createdAt": "2020-08-03T07:32:47Z", "commit": {"oid": "8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNzozMjo0N1rOG6vBhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNzozMjo0N1rOG6vBhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MTAyOQ==", "bodyText": "should this sys prop remain? or should it be discarded at some point?", "url": "https://github.com/wildfly/wildfly-core/pull/4267#discussion_r464241029", "createdAt": "2020-08-03T07:32:47Z", "author": {"login": "jmesnil"}, "path": "elytron/src/main/java/org/wildfly/extension/elytron/PolicyDefinitions.java", "diffHunk": "@@ -287,292 +276,131 @@ protected void recordCapabilitiesAndRequirements(OperationContext context, Attri\n \n     }\n \n-    private static Supplier<Policy> getPolicyProvider(OperationContext context, ModelNode model, ServiceBuilder<Policy> serviceBuilder) throws OperationFailedException {\n-        Supplier<Policy> result = configureJaccPolicy(context, model, serviceBuilder);\n+    private static Consumer<Consumer<Policy>> getPolicyProvider(OperationContext context, ModelNode model) throws OperationFailedException {\n+        Consumer<Consumer<Policy>> result = configureJaccPolicy(context, model);\n         if (result == null) {\n             result = configureCustomPolicy(context, model);\n         }\n         return result;\n     }\n \n-    private static Supplier<Policy> configureCustomPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n+    private static Consumer<Consumer<Policy>> configureCustomPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n         ModelNode policyModel = model.get(CUSTOM_POLICY);\n \n         if (policyModel.isDefined()) {\n             String className = CustomPolicyDefinition.CLASS_NAME.resolveModelAttribute(context, policyModel).asString();\n             String module = CustomPolicyDefinition.MODULE.resolveModelAttribute(context, policyModel).asStringOrNull();\n \n-            return () -> newPolicy(className, module);\n+            return (t) -> {\n+                try {\n+                    t.accept(newPolicy(className, ClassLoadingAttributeDefinitions.resolveClassLoader(module)));\n+                } catch (ModuleLoadException e) {\n+                    throw ElytronSubsystemMessages.ROOT_LOGGER.unableToLoadModuleRuntime(module, e);\n+                }\n+            };\n         }\n \n         return null;\n     }\n \n-    private static Supplier<Policy> configureJaccPolicy(OperationContext context, ModelNode model, ServiceBuilder<Policy> serviceBuilder) throws OperationFailedException {\n+    private static Consumer<Consumer<Policy>> configureJaccPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n         ModelNode policyModel = model.get(JACC_POLICY);\n \n         if (policyModel.isDefined()) {\n-            String policyProvider = JaccPolicyDefinition.POLICY_PROVIDER.resolveModelAttribute(context, policyModel).asString();\n-            String configurationFactory = JaccPolicyDefinition.CONFIGURATION_FACTORY.resolveModelAttribute(context, policyModel).asString();\n+            final String policyProvider = JaccPolicyDefinition.POLICY_PROVIDER.resolveModelAttribute(context, policyModel).asString();\n+            final String configurationFactory = JaccPolicyDefinition.CONFIGURATION_FACTORY.resolveModelAttribute(context, policyModel).asString();\n+            final boolean defaultConfigurationFactory = configurationFactory.equals(JaccPolicyDefinition.CONFIGURATION_FACTORY.getDefaultValue().asString());\n             String module = JaccPolicyDefinition.MODULE.resolveModelAttribute(context, policyModel).asStringOrNull();\n \n-            serviceBuilder.addAliases(JACC_POLICY_RUNTIME_CAPABILITY.getCapabilityServiceName());\n+            return new Consumer<Consumer<Policy>>() {\n \n-            return new Supplier<Policy>() {\n                 @Override\n-                public Policy get() {\n-                    if (configurationFactory != null) {\n-                        if (WildFlySecurityManager.isChecking()) {\n-                            AccessController.doPrivileged(setConfigurationProviderSystemProperty());\n-                        } else {\n-                            setConfigurationProviderSystemProperty().run();\n-                        }\n-                    }\n-\n-                    Policy policy = newPolicy(policyProvider, module);\n+                public void accept(Consumer<Policy> policyConsumer) {\n \n                     try {\n-                        PolicyContext.registerHandler(SecurityConstants.SUBJECT_CONTEXT_KEY, createSubjectPolicyContextHandler(), true);\n-                        PolicyContext.registerHandler(SecurityConstants.CALLBACK_HANDLER_KEY, createCallbackHandlerContextHandler(), true);\n-                        PolicyContext.registerHandler(SecurityIdentity.class.getName(), createSecurityIdentityContextHandler(), true);\n-                    } catch (PolicyContextException cause) {\n-                        throw ElytronSubsystemMessages.ROOT_LOGGER.failedToRegisterPolicyHandlers(cause);\n-                    }\n-\n-                    return policy;\n-                }\n-\n-                private PrivilegedAction<Void> setConfigurationProviderSystemProperty() {\n-                    return () -> {\n-                        if (WildFlySecurityManager.isChecking()) {\n-                            WildFlySecurityManager.setPropertyPrivileged(\"javax.security.jacc.PolicyConfigurationFactory.provider\", configurationFactory);\n-                        } else {\n-                            System.setProperty(\"javax.security.jacc.PolicyConfigurationFactory.provider\", configurationFactory);\n-                        }\n-                        return null;\n-                    };\n-                }\n+                        ClassLoader configuredClassLoader = ClassLoadingAttributeDefinitions.resolveClassLoader(module);\n \n-                private PolicyContextHandler createSecurityIdentityContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        final String KEY = SecurityIdentity.class.getName();\n+                        Policy policy = newPolicy(policyProvider, configuredClassLoader);\n+                        policyConsumer.accept(policy);\n \n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            if (supports(key)) {\n-                                SecurityDomain securityDomain = doPrivileged((PrivilegedAction<SecurityDomain>) SecurityDomain::getCurrent);\n+                        doPrivileged((PrivilegedExceptionAction<PolicyConfigurationFactory>) () -> newPolicyConfigurationFactory(\n+                                configurationFactory,\n+                                defaultConfigurationFactory ? PolicyDefinitions.class.getClassLoader() : configuredClassLoader));\n \n-                                if (securityDomain == null) {\n-                                    return null;\n-                                }\n+                        Map<String, PolicyContextHandler> discoveredHandlers = discoverPolicyContextHandlers();\n \n-                                SecurityIdentity securityIdentity = securityDomain.getCurrentSecurityIdentity();\n-\n-                                if (securityIdentity != null) {\n-                                    return securityIdentity;\n-                                }\n-                            }\n-\n-                            return null;\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return new String[]{KEY};\n+                        registerHandler(discoveredHandlers, new SubjectPolicyContextHandler());\n+                        registerHandler(discoveredHandlers, new SecurityIdentityHandler());\n+                        for (Entry<String, PolicyContextHandler> entry : discoveredHandlers.entrySet()) {\n+                            PolicyContext.registerHandler(entry.getKey(), entry.getValue(), true);\n                         }\n \n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return getKeys()[0].equalsIgnoreCase(key);\n-                        }\n-                    };\n+                    } catch (Exception cause) {\n+                        throw ElytronSubsystemMessages.ROOT_LOGGER.failedToRegisterPolicyHandlers(cause);\n+                    }\n                 }\n \n-                private PolicyContextHandler createCallbackHandlerContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        // in case applications are using legacy (PicketBox) security infrastructure\n-                        CallbackHandlerPolicyContextHandler legacy = new CallbackHandlerPolicyContextHandler();\n-\n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            return legacy.getContext(key, data);\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return legacy.getKeys();\n-                        }\n-\n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return legacy.supports(key);\n+                private void registerHandler(Map<String, PolicyContextHandler> discoveredHandlers, PolicyContextHandler handler) throws PolicyContextException {\n+                    for (String key : handler.getKeys()) {\n+                        PolicyContextHandler discovered = discoveredHandlers.remove(key);\n+                        if (discovered != null) {\n+                            ElytronSubsystemMessages.ROOT_LOGGER.tracef(\"Registering DelegatingPolicyContextHandler for key '%s'.\", key);\n+                            PolicyContext.registerHandler(key, discovered != null ? new DelegatingPolicyContextHandler(key, handler, discovered) : handler, true);\n+                        } else {\n+                            PolicyContext.registerHandler(key, handler, true);\n                         }\n-                    };\n+                    }\n                 }\n \n-                private PolicyContextHandler createSubjectPolicyContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        // in case applications are using legacy (PicketBox) security infrastructure\n-                        SubjectPolicyContextHandler legacy = new SubjectPolicyContextHandler();\n-\n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            if (supports(key)) {\n-                                SecurityIdentity securityIdentity = (SecurityIdentity) PolicyContext.getContext(SecurityIdentity.class.getName());\n-\n-                                if (securityIdentity == null) {\n-                                    return legacy.getContext(key, data);\n-                                }\n-\n-                                return SubjectUtil.fromSecurityIdentity(securityIdentity);\n+                private Map<String, PolicyContextHandler> discoverPolicyContextHandlers() throws PolicyContextException {\n+                    Map<String, PolicyContextHandler> handlerMap = new HashMap<>();\n+                    ServiceLoader<PolicyContextHandler> serviceLoader = ServiceLoader.load(PolicyContextHandler.class, PolicyDefinitions.class.getClassLoader());\n+                    for (PolicyContextHandler handler : serviceLoader) {\n+                        for (String key : handler.getKeys()) {\n+                            if (handlerMap.put(key, handler) != null) {\n+                                throw ElytronSubsystemMessages.ROOT_LOGGER.duplicatePolicyContextHandler(key);\n+                            }\n+                            if (ElytronSubsystemMessages.ROOT_LOGGER.isTraceEnabled()) {\n+                                ElytronSubsystemMessages.ROOT_LOGGER.tracef(\"Discovered PolicyContextHandler '%s' for key '%s'.\", handler.getClass().getName(), key);\n                             }\n-\n-                            return null;\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return legacy.getKeys();\n                         }\n+                    }\n \n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return legacy.supports(key);\n-                        }\n-                    };\n+                    return handlerMap;\n                 }\n+\n             };\n         }\n \n         return null;\n     }\n \n-    private static Policy newPolicy(String className, String module) {\n+    private static Policy newPolicy(String className, ClassLoader classLoader) {\n         try {\n-            ClassLoader classLoader = ClassLoadingAttributeDefinitions.resolveClassLoader(module);\n             Object policy = classLoader.loadClass(className).newInstance();\n             return Policy.class.cast(policy);\n         } catch (Exception e) {\n             throw ElytronSubsystemMessages.ROOT_LOGGER.failedToCreatePolicy(className, e);\n         }\n     }\n \n-    /**\n-     * Utilities for dealing with {@link Subject}.\n-     *\n-     * @author <a href=\"mailto:sguilhen@redhat.com\">Stefan Guilhen</a>\n-     */\n-    static final class SubjectUtil {\n-\n-        /**\n-         * Converts the supplied {@link SecurityIdentity} into a {@link Subject}.\n-         *\n-         * @param securityIdentity the {@link SecurityIdentity} to be converted.\n-         * @return the constructed {@link Subject} instance.\n-         */\n-        static Subject fromSecurityIdentity(final SecurityIdentity securityIdentity) {\n-            Assert.checkNotNullParam(\"securityIdentity\", securityIdentity);\n-            Subject subject = new Subject();\n-            subject.getPrincipals().add(securityIdentity.getPrincipal());\n-\n-            // add the 'Roles' group to the subject containing the identity's mapped roles.\n-            Group rolesGroup = new SimpleGroup(\"Roles\");\n-            for (String role : securityIdentity.getRoles()) {\n-                rolesGroup.addMember(new NamePrincipal(role));\n-            }\n-            subject.getPrincipals().add(rolesGroup);\n-\n-            // add a 'CallerPrincipal' group containing the identity's principal.\n-            Group callerPrincipalGroup = new SimpleGroup(\"CallerPrincipal\");\n-            callerPrincipalGroup.addMember(securityIdentity.getPrincipal());\n-            subject.getPrincipals().add(callerPrincipalGroup);\n-\n-            // process the identity's public and private credentials.\n-            for (Credential credential : securityIdentity.getPublicCredentials()) {\n-                if (credential instanceof PublicKeyCredential) {\n-                    subject.getPublicCredentials().add(credential.castAs(PublicKeyCredential.class).getPublicKey());\n-                }\n-                else if (credential instanceof X509CertificateChainPublicCredential) {\n-                    subject.getPublicCredentials().add(credential.castAs(X509CertificateChainPublicCredential.class).getCertificateChain());\n-                }\n-                else {\n-                    subject.getPublicCredentials().add(credential);\n-                }\n-            }\n+    private static PolicyConfigurationFactory newPolicyConfigurationFactory(String className, ClassLoader classLoader) throws PolicyContextException, ClassNotFoundException {\n+        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n \n-            for (Credential credential : doPrivileged((PrivilegedAction<IdentityCredentials>) securityIdentity::getPrivateCredentials)) {\n-                if (credential instanceof PasswordCredential) {\n-                    addPrivateCredential(subject, credential.castAs(PasswordCredential.class).getPassword());\n-                }\n-                else if (credential instanceof SecretKeyCredential) {\n-                    addPrivateCredential(subject, credential.castAs(SecretKeyCredential.class).getSecretKey());\n-                }\n-                else if (credential instanceof KeyPairCredential) {\n-                    addPrivateCredential(subject, credential.castAs(KeyPairCredential.class).getKeyPair());\n-                }\n-                else if (credential instanceof X509CertificateChainPrivateCredential) {\n-                    addPrivateCredential(subject, credential.castAs(X509CertificateChainPrivateCredential.class).getCertificateChain());\n-                }\n-                else {\n-                    addPrivateCredential(subject, credential);\n-                }\n+        try {\n+            Thread.currentThread().setContextClassLoader(classLoader);\n+            System.setProperty(PolicyConfigurationFactory.class.getName() + \".provider\", className);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c"}, "originalPosition": 428}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45d099fdc37c63cc9e40a5101a3845ed3b94ad8", "author": {"user": {"login": "darranl", "name": "Darran Lofthouse"}}, "url": "https://github.com/wildfly/wildfly-core/commit/a45d099fdc37c63cc9e40a5101a3845ed3b94ad8", "committedDate": "2020-08-04T09:53:21Z", "message": "[WFCORE-5020] Ensure the Elytron AuthConfigFactory is used so we don't fall back to the PicketBox implementation."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3438, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}