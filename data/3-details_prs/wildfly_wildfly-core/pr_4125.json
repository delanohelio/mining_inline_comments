{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTAyMDUz", "number": 4125, "title": "WFCORE-4895, Bootable jar runtime", "bodyText": "Issue: https://issues.redhat.com/browse/WFCORE-4895\n\nAdded new bootable-jar parent module with boot and runtime sub modules.\nAdded new artifacts to galleon-feature-pack and legacy feature-pack\nAdded API to launch bootable jar in Launcher API\nEvolved test-runner to support bootable jar\nNew bootable test profile, -Dts.bootable, rely on wildfly-jar-maven-plugin 2.0.0.Alpha1\nExperimental run of the bootable profile (green): https://ci.wildfly.org/buildConfiguration/WildFlyCore_Experiments/196010\nUpgraded vaut-test-feature-pack build to not need local resolution (useless with latest Galleon and not supported by bootable jar). Removed associated resolve-locals elements in pom.xml.", "createdAt": "2020-04-01T16:28:12Z", "url": "https://github.com/wildfly/wildfly-core/pull/4125", "merged": true, "mergeCommit": {"oid": "f9561d5dcf52066e574b6507cb20e1f4892546cd"}, "closed": true, "closedAt": "2020-05-12T07:12:09Z", "author": {"login": "jfdenise"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTbvbWgBqjMxODkwOTI5MTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccFNVTgBqjMyODA3NDU4MDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4f6a4285bbf06247117c06e61287869b286aa43", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/f4f6a4285bbf06247117c06e61287869b286aa43", "committedDate": "2020-04-01T15:57:56Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/e81116b1a1db9e63c2df18f54c82d833ea6a3825", "committedDate": "2020-04-01T18:09:28Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTcyMDE0", "url": "https://github.com/wildfly/wildfly-core/pull/4125#pullrequestreview-389172014", "createdAt": "2020-04-07T14:27:23Z", "commit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyNzoyM1rOGCGPXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo0ODoyNFrOGCHPdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjU3Mg==", "bodyText": "This is just a minor note. It might be useful to add a comment here that logging needs to be configured before other components have a chance to initialize a logger.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404852572", "createdAt": "2020-04-07T14:27:23Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA==", "bodyText": "If we do this we mandate that users must use the JBoss Log Manager. Maybe this is okay, but maybe it's something we should look at.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404855884", "createdAt": "2020-04-07T14:31:37Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTMzNQ==", "bodyText": "Is there a reason we're swallowing the errors here?", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859335", "createdAt": "2020-04-07T14:36:22Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTQyNA==", "bodyText": "Is there a reason we're swallowing the errors here?", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859424", "createdAt": "2020-04-07T14:36:29Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTkyMA==", "bodyText": "This seems odd as we swallow the error below at line 291.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859920", "createdAt": "2020-04-07T14:37:08Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MjU4OA==", "bodyText": "Is there a reason we're doing this privileged? I ask because if we're running this under a security manager the other places where we set system properties are gonna be an issue as well.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404862588", "createdAt": "2020-04-07T14:40:30Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);\n+                        if (ret.hasDefined(RESULT)) {\n+                            String val = ret.get(RESULT).asString();\n+                            if (STOPPED.equals(val)) {\n+                                log.serverStopped();\n+                                break;\n+                            } else {\n+                                log.serverNotStopped();\n+                            }\n+                        }\n+                        Thread.sleep(1000);\n+                    } else {\n+                        log.nullController();\n+                        break;\n+                    }\n+                } catch (Exception ex) {\n+                    log.unexpectedExceptionWhileShuttingDown(ex);\n+                }\n+            }\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    /**\n+     * Modular entry point.\n+     *\n+     * @param jbossHome Server home directory.\n+     * @param args User provided arguments.\n+     * @param moduleLoader JBoss modules loader.\n+     * @param moduleClassLoader Bootable jar module classloader\n+     * @param unzipTime Time spent to unzip the server.\n+     * @throws Exception\n+     */\n+    public static void run(Path jbossHome, List<String> args, ModuleLoader moduleLoader, ModuleClassLoader moduleClassLoader, Long unzipTime) throws Exception {\n+        setTccl(moduleClassLoader);\n+        Arguments arguments;\n+        try {\n+            arguments = Arguments.parseArguments(args);\n+        } catch (Throwable ex) {\n+            System.err.println(ex);\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        if (arguments.isHelp()) {\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        BootableJar bootableJar = new BootableJar(jbossHome, arguments, moduleLoader, unzipTime);\n+        bootableJar.run();\n+    }\n+\n+    static void setTccl(final ClassLoader cl) {\n+        if (System.getSecurityManager() == null) {\n+            Thread.currentThread().setContextClassLoader(cl);\n+        } else {\n+            AccessController.doPrivileged(new PrivilegedAction<Object>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2ODk4Mg==", "bodyText": "We need to add these to the license core-feature-pack-licenses.xml with the appropriate license.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404868982", "createdAt": "2020-04-07T14:48:24Z", "author": {"login": "jamezp"}, "path": "core-feature-pack/pom.xml", "diffHunk": "@@ -786,6 +786,16 @@\n             <groupId>org.wildfly.core</groupId>\n             <artifactId>wildfly-launcher</artifactId>\n         </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-runtime</artifactId>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-boot</artifactId>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/e81116b1a1db9e63c2df18f54c82d833ea6a3825", "committedDate": "2020-04-01T18:09:28Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "committedDate": "2020-04-07T15:47:55Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "committedDate": "2020-04-07T15:47:55Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/1bf07c30be271f067238c64e6ed62745bbf47f94", "committedDate": "2020-04-07T16:09:34Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5Mjg0ODEz", "url": "https://github.com/wildfly/wildfly-core/pull/4125#pullrequestreview-389284813", "createdAt": "2020-04-07T16:24:35Z", "commit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTY1ODEz", "url": "https://github.com/wildfly/wildfly-core/pull/4125#pullrequestreview-389965813", "createdAt": "2020-04-08T13:19:53Z", "commit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxOTo1M1rOGCu4Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NTo0OFrOGCzI5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg==", "bodyText": "You could expose the currentProcessState from the Server and avoid polling with a management Operation.\nThe benefits are you will get all the possible process states, in case of needing a different one instead of STOPPED, and it avoid any overhead executing the management operation. I used this on this issue: https://github.com/wildfly/wildfly-core/pull/4119/files#diff-ba94eab7c9f427c4ba24827d0908d9edR374", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405518426", "createdAt": "2020-04-08T13:19:53Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU5NA==", "bodyText": "Why do we need java.desktop? I cannot find the reason why this dependency is required", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405561594", "createdAt": "2020-04-08T14:19:29Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ==", "bodyText": "The boolean argument should be yes instead of false. Doing so the internal variable that stores the currentProcessState gets updated upon an nitification.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405586281", "createdAt": "2020-04-08T14:53:20Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4ODE5Ng==", "bodyText": "Why do we need org.wildfly.common? I cannot find the reason why this dependency is required", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405588196", "createdAt": "2020-04-08T14:55:48Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>\n+        <module name=\"org.wildfly.common\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/1bf07c30be271f067238c64e6ed62745bbf47f94", "committedDate": "2020-04-07T16:09:34Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "committedDate": "2020-04-09T07:25:58Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "committedDate": "2020-04-09T07:25:58Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "2191a9d7ea118efa9236ee25ad64d5f282818611", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/2191a9d7ea118efa9236ee25ad64d5f282818611", "committedDate": "2020-04-09T08:22:35Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2191a9d7ea118efa9236ee25ad64d5f282818611", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/2191a9d7ea118efa9236ee25ad64d5f282818611", "committedDate": "2020-04-09T08:22:35Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "a7cc61775b4387c6b485ba70eb3dbf746041e346", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/a7cc61775b4387c6b485ba70eb3dbf746041e346", "committedDate": "2020-04-09T08:41:38Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7cc61775b4387c6b485ba70eb3dbf746041e346", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/a7cc61775b4387c6b485ba70eb3dbf746041e346", "committedDate": "2020-04-09T08:41:38Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "057a82543e5a013d41129eb506dcf09cfe5da318", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/057a82543e5a013d41129eb506dcf09cfe5da318", "committedDate": "2020-04-10T13:52:53Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "057a82543e5a013d41129eb506dcf09cfe5da318", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/057a82543e5a013d41129eb506dcf09cfe5da318", "committedDate": "2020-04-10T13:52:53Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "committedDate": "2020-04-14T14:35:39Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTY0Nzg4", "url": "https://github.com/wildfly/wildfly-core/pull/4125#pullrequestreview-399164788", "createdAt": "2020-04-23T14:38:06Z", "commit": {"oid": "e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDozODowNlrOGKrjkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1Nzo1MVrOGKsoWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1MjU2MA==", "bodyText": "ok, thanks!", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413852560", "createdAt": "2020-04-23T14:38:06Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU5NA=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2ODYxMA==", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413868610", "createdAt": "2020-04-23T14:56:07Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MDE2OQ==", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413870169", "createdAt": "2020-04-23T14:57:51Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 303}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f4bb783e6d2069deb71346e215bec880ae0fa83", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/1f4bb783e6d2069deb71346e215bec880ae0fa83", "committedDate": "2020-04-28T12:48:41Z", "message": "Fix for WFCORE-4895, Bootable runtime module"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "committedDate": "2020-04-14T14:35:39Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "42f72678a67def585b4f0678e98e68bb9a2c7b85", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/42f72678a67def585b4f0678e98e68bb9a2c7b85", "committedDate": "2020-04-28T13:58:33Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c03341fe70c06a59f724e204d5e5adf3fc14a631", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/c03341fe70c06a59f724e204d5e5adf3fc14a631", "committedDate": "2020-04-28T14:59:25Z", "message": "Fix for WFCORE-4895, Bootable runtime module, ts.bootable profile, launcher and test-runner support for bootable jar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "committedDate": "2020-04-28T14:59:35Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42f72678a67def585b4f0678e98e68bb9a2c7b85", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/42f72678a67def585b4f0678e98e68bb9a2c7b85", "committedDate": "2020-04-28T13:58:33Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}, "afterCommit": {"oid": "0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "author": {"user": {"login": "jfdenise", "name": "Jean-Fran\u00e7ois Denise "}}, "url": "https://github.com/wildfly/wildfly-core/commit/0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "committedDate": "2020-04-28T14:59:35Z", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3464, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}