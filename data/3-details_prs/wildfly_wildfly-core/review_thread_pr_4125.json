{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTAyMDUz", "number": 4125, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyNzoyM1rODvll9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NTo0OFrODwB-uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI1NTkxOnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyNzoyM1rOGCGPXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo0ODo1MFrOGCKKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjU3Mg==", "bodyText": "This is just a minor note. It might be useful to add a comment here that logging needs to be configured before other components have a chance to initialize a logger.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404852572", "createdAt": "2020-04-07T14:27:23Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNjkwNg==", "bodyText": "Ok, added a comment.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404916906", "createdAt": "2020-04-07T15:48:50Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjU3Mg=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI3NjAyOnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozMTozN1rOGCGcTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjoyMTo0OVrOGCLpjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA==", "bodyText": "If we do this we mandate that users must use the JBoss Log Manager. Maybe this is okay, but maybe it's something we should look at.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404855884", "createdAt": "2020-04-07T14:31:37Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMDA1NA==", "bodyText": "@jamezp , I was under the assumption that the jboss logmanager was the only usable implementation with the Logging subsystem. You are suggesting that user could set the system property and not rely on the logging subsystem? I could check if the system property exists and do nothing if that is the case.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404920054", "createdAt": "2020-04-07T15:53:03Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTE5OQ==", "bodyText": "I'm redacting this concern. The logging subsystem does require the JBoss Log Manager, my thought was if the subsystem was removed maybe the user would want to use a different log manager. However the servers main entry point does do some log manager initialization as well so removing a requirement like that is out of scope for this. Sorry about the confusion there.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404941199", "createdAt": "2020-04-07T16:21:49Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI5NzE2OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozNjoyMlrOGCGpxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo1NDoyOVrOGCKbKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTMzNQ==", "bodyText": "Is there a reason we're swallowing the errors here?", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859335", "createdAt": "2020-04-07T14:36:22Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMTEzMA==", "bodyText": "We want to clean as much as we can even if a failure occurs (eg: Windows and opened jar deletion). I should add a log.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404921130", "createdAt": "2020-04-07T15:54:29Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTMzNQ=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI5NzYwOnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozNjoyOVrOGCGqIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo1Njo0OFrOGCKh-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTQyNA==", "bodyText": "Is there a reason we're swallowing the errors here?", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859424", "createdAt": "2020-04-07T14:36:29Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMjg3NA==", "bodyText": "Same, continue to delete although we have errors. I will add a log.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404922874", "createdAt": "2020-04-07T15:56:48Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTQyNA=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjMwMDQ5OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozNzowOFrOGCGsEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo1NzowMFrOGCKilw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTkyMA==", "bodyText": "This seems odd as we swallow the error below at line 291.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859920", "createdAt": "2020-04-07T14:37:08Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMzAzMQ==", "bodyText": "Yep, need to remove it.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404923031", "createdAt": "2020-04-07T15:57:00Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTkyMA=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjMxNzQ5OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo0MDozMFrOGCG2fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo1MDoyOVrOGCKPoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MjU4OA==", "bodyText": "Is there a reason we're doing this privileged? I ask because if we're running this under a security manager the other places where we set system properties are gonna be an issue as well.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404862588", "createdAt": "2020-04-07T14:40:30Z", "author": {"login": "jamezp"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);\n+                        if (ret.hasDefined(RESULT)) {\n+                            String val = ret.get(RESULT).asString();\n+                            if (STOPPED.equals(val)) {\n+                                log.serverStopped();\n+                                break;\n+                            } else {\n+                                log.serverNotStopped();\n+                            }\n+                        }\n+                        Thread.sleep(1000);\n+                    } else {\n+                        log.nullController();\n+                        break;\n+                    }\n+                } catch (Exception ex) {\n+                    log.unexpectedExceptionWhileShuttingDown(ex);\n+                }\n+            }\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    /**\n+     * Modular entry point.\n+     *\n+     * @param jbossHome Server home directory.\n+     * @param args User provided arguments.\n+     * @param moduleLoader JBoss modules loader.\n+     * @param moduleClassLoader Bootable jar module classloader\n+     * @param unzipTime Time spent to unzip the server.\n+     * @throws Exception\n+     */\n+    public static void run(Path jbossHome, List<String> args, ModuleLoader moduleLoader, ModuleClassLoader moduleClassLoader, Long unzipTime) throws Exception {\n+        setTccl(moduleClassLoader);\n+        Arguments arguments;\n+        try {\n+            arguments = Arguments.parseArguments(args);\n+        } catch (Throwable ex) {\n+            System.err.println(ex);\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        if (arguments.isHelp()) {\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        BootableJar bootableJar = new BootableJar(jbossHome, arguments, moduleLoader, unzipTime);\n+        bootableJar.run();\n+    }\n+\n+    static void setTccl(final ClassLoader cl) {\n+        if (System.getSecurityManager() == null) {\n+            Thread.currentThread().setContextClassLoader(cl);\n+        } else {\n+            AccessController.doPrivileged(new PrivilegedAction<Object>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODE3Nw==", "bodyText": "That is un-needed, I removed the block.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404918177", "createdAt": "2020-04-07T15:50:29Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);\n+                        if (ret.hasDefined(RESULT)) {\n+                            String val = ret.get(RESULT).asString();\n+                            if (STOPPED.equals(val)) {\n+                                log.serverStopped();\n+                                break;\n+                            } else {\n+                                log.serverNotStopped();\n+                            }\n+                        }\n+                        Thread.sleep(1000);\n+                    } else {\n+                        log.nullController();\n+                        break;\n+                    }\n+                } catch (Exception ex) {\n+                    log.unexpectedExceptionWhileShuttingDown(ex);\n+                }\n+            }\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    /**\n+     * Modular entry point.\n+     *\n+     * @param jbossHome Server home directory.\n+     * @param args User provided arguments.\n+     * @param moduleLoader JBoss modules loader.\n+     * @param moduleClassLoader Bootable jar module classloader\n+     * @param unzipTime Time spent to unzip the server.\n+     * @throws Exception\n+     */\n+    public static void run(Path jbossHome, List<String> args, ModuleLoader moduleLoader, ModuleClassLoader moduleClassLoader, Long unzipTime) throws Exception {\n+        setTccl(moduleClassLoader);\n+        Arguments arguments;\n+        try {\n+            arguments = Arguments.parseArguments(args);\n+        } catch (Throwable ex) {\n+            System.err.println(ex);\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        if (arguments.isHelp()) {\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        BootableJar bootableJar = new BootableJar(jbossHome, arguments, moduleLoader, unzipTime);\n+        bootableJar.run();\n+    }\n+\n+    static void setTccl(final ClassLoader cl) {\n+        if (System.getSecurityManager() == null) {\n+            Thread.currentThread().setContextClassLoader(cl);\n+        } else {\n+            AccessController.doPrivileged(new PrivilegedAction<Object>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MjU4OA=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjM1NjY3OnYy", "diffSide": "RIGHT", "path": "core-feature-pack/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo0ODoyNFrOGCHPdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTo1MDo0NFrOGCKQSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2ODk4Mg==", "bodyText": "We need to add these to the license core-feature-pack-licenses.xml with the appropriate license.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404868982", "createdAt": "2020-04-07T14:48:24Z", "author": {"login": "jamezp"}, "path": "core-feature-pack/pom.xml", "diffHunk": "@@ -786,6 +786,16 @@\n             <groupId>org.wildfly.core</groupId>\n             <artifactId>wildfly-launcher</artifactId>\n         </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-runtime</artifactId>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-boot</artifactId>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODM0Ng==", "bodyText": "Thank-you, added.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404918346", "createdAt": "2020-04-07T15:50:44Z", "author": {"login": "jfdenise"}, "path": "core-feature-pack/pom.xml", "diffHunk": "@@ -786,6 +786,16 @@\n             <groupId>org.wildfly.core</groupId>\n             <artifactId>wildfly-launcher</artifactId>\n         </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-runtime</artifactId>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>org.wildfly.core</groupId>\n+            <artifactId>wildfly-jar-boot</artifactId>\n+        </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2ODk4Mg=="}, "originalCommit": {"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjQ3MTQ3OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxOTo1M1rOGCu4Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1Nzo1MVrOGKsoWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg==", "bodyText": "You could expose the currentProcessState from the Server and avoid polling with a management Operation.\nThe benefits are you will get all the possible process states, in case of needing a different one instead of STOPPED, and it avoid any overhead executing the management operation. I used this on this issue: https://github.com/wildfly/wildfly-core/pull/4119/files#diff-ba94eab7c9f427c4ba24827d0908d9edR374", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405518426", "createdAt": "2020-04-08T13:19:53Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODkxMw==", "bodyText": "Good point, I removed DMR request and exposed the process state.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406038913", "createdAt": "2020-04-09T08:25:12Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MDE2OQ==", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413870169", "createdAt": "2020-04-23T14:57:51Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjc0MDgwOnYy", "diffSide": "RIGHT", "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoxOToyOVrOGCxg-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDozODowNlrOGKrjkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU5NA==", "bodyText": "Why do we need java.desktop? I cannot find the reason why this dependency is required", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405561594", "createdAt": "2020-04-08T14:19:29Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwNzc2MA==", "bodyText": "We need it for dependencies on java.beans.PropertyChangeListener", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406007760", "createdAt": "2020-04-09T07:27:48Z", "author": {"login": "jfdenise"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU5NA=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1MjU2MA==", "bodyText": "ok, thanks!", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413852560", "createdAt": "2020-04-23T14:38:06Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU5NA=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg5NDk2OnYy", "diffSide": "RIGHT", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MzoyMFrOGCzBaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDo1NjowN1rOGKsiQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ==", "bodyText": "The boolean argument should be yes instead of false. Doing so the internal variable that stores the currentProcessState gets updated upon an nitification.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405586281", "createdAt": "2020-04-08T14:53:20Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzOTAzNA==", "bodyText": "Ok.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406039034", "createdAt": "2020-04-09T08:25:24Z", "author": {"login": "jfdenise"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2ODYxMA==", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413868610", "createdAt": "2020-04-23T14:56:07Z", "author": {"login": "yersan"}, "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjkwNjgwOnYy", "diffSide": "RIGHT", "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NTo0OFrOGCzI5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoyODoyMVrOGDMw5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4ODE5Ng==", "bodyText": "Why do we need org.wildfly.common? I cannot find the reason why this dependency is required", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405588196", "createdAt": "2020-04-08T14:55:48Z", "author": {"login": "yersan"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>\n+        <module name=\"org.wildfly.common\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwODAzOA==", "bodyText": "Good catch, was a left over from the time we were using Embedded. I removed it.", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406008038", "createdAt": "2020-04-09T07:28:21Z", "author": {"login": "jfdenise"}, "path": "core-feature-pack/src/main/resources/modules/system/layers/base/org/wildfly/bootable-jar/main/module.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ JBoss, Home of Professional Open Source.\n+  ~ Copyright 2020, Red Hat, Inc., and individual contributors\n+  ~ as indicated by the @author tags. See the copyright.txt file in the\n+  ~ distribution for a full listing of individual contributors.\n+  ~\n+  ~ This is free software; you can redistribute it and/or modify it\n+  ~ under the terms of the GNU Lesser General Public License as\n+  ~ published by the Free Software Foundation; either version 2.1 of\n+  ~ the License, or (at your option) any later version.\n+  ~\n+  ~ This software is distributed in the hope that it will be useful,\n+  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ Lesser General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU Lesser General Public\n+  ~ License along with this software; if not, write to the Free\n+  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+  -->\n+\n+<module xmlns=\"urn:jboss:module:1.8\" name=\"org.wildfly.bootable-jar\">\n+    <properties>\n+        <property name=\"jboss.api\" value=\"private\"/>\n+    </properties>\n+\n+    <resources>\n+        <artifact name=\"${org.wildfly.core:wildfly-jar-runtime}\"/>\n+    </resources>\n+\n+    <exports>\n+        <exclude path=\"org/wildfly/core/jar/runtime/_private\"/>\n+    </exports>\n+\n+    <dependencies>\n+        <module name=\"java.xml\"/>\n+        <module name=\"java.desktop\"/>\n+        <module name=\"org.wildfly.common\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4ODE5Ng=="}, "originalCommit": {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3851, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}