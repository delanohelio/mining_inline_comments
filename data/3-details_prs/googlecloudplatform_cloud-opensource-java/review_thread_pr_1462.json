{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTczOTc2", "number": 1462, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo1NzoyMVrOEEYhIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjozMDo1NFrOEEeyFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDMxNDU5OnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo1NzoyMVrOGh-HNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyMjozNVrOGh_A_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3Mzg0NA==", "bodyText": "rewrite without continue", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438273844", "createdAt": "2020-06-10T16:57:21Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,109 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (classPath.isEmpty()) {\n+        // No artifact for this configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8855b8c4ded4dbfd1b3a868ea9d55c295d98b4b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4ODYzNw==", "bodyText": "Done.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438288637", "createdAt": "2020-06-10T17:22:35Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,109 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (classPath.isEmpty()) {\n+        // No artifact for this configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3Mzg0NA=="}, "originalCommit": {"oid": "e8855b8c4ded4dbfd1b3a868ea9d55c295d98b4b"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDMxNzkxOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo1ODowNVrOGh-JOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyMToxOVrOGh--MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3NDM2Mw==", "bodyText": "There are three placeholders but only two placefillers", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438274363", "createdAt": "2020-06-10T16:58:05Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,109 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (classPath.isEmpty()) {\n+        // No artifact for this configuration\n+        continue;\n+      }\n+      // TODO(suztomo): Specify entry points if reportOnlyReachable is true.\n+      LinkageChecker linkageChecker = LinkageChecker.create(classPath);\n+\n+      ImmutableSetMultimap<SymbolProblem, ClassFile> symbolProblems =\n+          linkageChecker.findSymbolProblems();\n+\n+      int errorCount = symbolProblems.keySet().size();\n+\n+      // TODO(suztomo): Show the dependency paths to the problematic artifacts.\n+      logger.error(\n+          \"Linkage Checker rule found {} error{}. Linkage error report:\\n{}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8855b8c4ded4dbfd1b3a868ea9d55c295d98b4b"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzkyMA==", "bodyText": "The 3 lines below are the 3 placefillers for the three {}.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438287920", "createdAt": "2020-06-10T17:21:19Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,109 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (classPath.isEmpty()) {\n+        // No artifact for this configuration\n+        continue;\n+      }\n+      // TODO(suztomo): Specify entry points if reportOnlyReachable is true.\n+      LinkageChecker linkageChecker = LinkageChecker.create(classPath);\n+\n+      ImmutableSetMultimap<SymbolProblem, ClassFile> symbolProblems =\n+          linkageChecker.findSymbolProblems();\n+\n+      int errorCount = symbolProblems.keySet().size();\n+\n+      // TODO(suztomo): Show the dependency paths to the problematic artifacts.\n+      logger.error(\n+          \"Linkage Checker rule found {} error{}. Linkage error report:\\n{}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3NDM2Mw=="}, "originalCommit": {"oid": "e8855b8c4ded4dbfd1b3a868ea9d55c295d98b4b"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDc1NTkxOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckerPluginExtension.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxOTowNjoxNFrOGiCmAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxOTozMVrOGiGsUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0NzI2Ng==", "bodyText": "Linkage", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438347266", "createdAt": "2020-06-10T19:06:14Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckerPluginExtension.java", "diffHunk": "@@ -16,20 +16,33 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.common.collect.ImmutableSet;\n+import java.util.List;\n+\n /**\n  * Properties to control the behavior of the Linakge Checker plugin.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca393f5be30e5eeec168eb74477835b7f044fc2"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNDQxOQ==", "bodyText": "Fixed", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438414419", "createdAt": "2020-06-10T21:19:31Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckerPluginExtension.java", "diffHunk": "@@ -16,20 +16,33 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.common.collect.ImmutableSet;\n+import java.util.List;\n+\n /**\n  * Properties to control the behavior of the Linakge Checker plugin.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0NzI2Ng=="}, "originalCommit": {"oid": "8ca393f5be30e5eeec168eb74477835b7f044fc2"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDc2MDMwOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxOTowNzozNFrOGiCo1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxOTo1MFrOGiGs2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0Nzk5MQ==", "bodyText": "does this log if errorCount is zero?", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438347991", "createdAt": "2020-06-10T19:07:34Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,107 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (!classPath.isEmpty()) {\n+        // TODO(suztomo): Specify entry points if reportOnlyReachable is true.\n+        LinkageChecker linkageChecker = LinkageChecker.create(classPath);\n+\n+        ImmutableSetMultimap<SymbolProblem, ClassFile> symbolProblems =\n+            linkageChecker.findSymbolProblems();\n+\n+        int errorCount = symbolProblems.keySet().size();\n+\n+        // TODO(suztomo): Show the dependency paths to the problematic artifacts.\n+        logger.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca393f5be30e5eeec168eb74477835b7f044fc2"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNDU1NA==", "bodyText": "Good catch. Fixed.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438414554", "createdAt": "2020-06-10T21:19:50Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,107 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      logger.info(\"Checking {}\", configuration);\n+      ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+      // TODO(suztomo): Should this include optional dependencies?\n+      //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+      for (ResolvedArtifact resolvedArtifact :\n+          configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+        ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+        DefaultArtifact artifact =\n+            new DefaultArtifact(\n+                moduleVersionId.getGroup(),\n+                moduleVersionId.getName(),\n+                null,\n+                null,\n+                moduleVersionId.getVersion(),\n+                null,\n+                resolvedArtifact.getFile());\n+        classPathBuilder.add(new ClassPathEntry(artifact));\n+      }\n+\n+      ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+      if (!classPath.isEmpty()) {\n+        // TODO(suztomo): Specify entry points if reportOnlyReachable is true.\n+        LinkageChecker linkageChecker = LinkageChecker.create(classPath);\n+\n+        ImmutableSetMultimap<SymbolProblem, ClassFile> symbolProblems =\n+            linkageChecker.findSymbolProblems();\n+\n+        int errorCount = symbolProblems.keySet().size();\n+\n+        // TODO(suztomo): Show the dependency paths to the problematic artifacts.\n+        logger.error(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0Nzk5MQ=="}, "originalCommit": {"oid": "8ca393f5be30e5eeec168eb74477835b7f044fc2"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTE5NTQxOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMDoxOFrOGiG_hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMDoxOFrOGiG_hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTMzMg==", "bodyText": "Memo: accessing the logger field is the reason why this method is not a static method, while I see making this static does not provide advantage.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438419332", "createdAt": "2020-06-10T21:30:18Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      foundError |= findLinkageErrors(configuration);\n+    }\n+\n+    if (foundError) {\n+      throw new GradleException(\n+          \"Linkage Checker found errors in configurations. See above for the details.\");\n+    }\n+  }\n+\n+  /** Returns true iff {@code configuration}'s artifacts contain linkage errors. */\n+  private boolean findLinkageErrors(Configuration configuration) throws IOException {\n+    ImmutableList.Builder<ClassPathEntry> classPathBuilder = ImmutableList.builder();\n+\n+    // TODO(suztomo): Should this include optional dependencies?\n+    //  Once we decide what to do with the optional dependencies, let's revisit this logic.\n+    for (ResolvedArtifact resolvedArtifact :\n+        configuration.getResolvedConfiguration().getResolvedArtifacts()) {\n+      ModuleVersionIdentifier moduleVersionId = resolvedArtifact.getModuleVersion().getId();\n+      DefaultArtifact artifact =\n+          new DefaultArtifact(\n+              moduleVersionId.getGroup(),\n+              moduleVersionId.getName(),\n+              null,\n+              null,\n+              moduleVersionId.getVersion(),\n+              null,\n+              resolvedArtifact.getFile());\n+      classPathBuilder.add(new ClassPathEntry(artifact));\n+    }\n+\n+    ImmutableList<ClassPathEntry> classPath = classPathBuilder.build();\n+    if (!classPath.isEmpty()) {\n+      // TODO(suztomo): Specify entry points if reportOnlyReachable is true.\n+      LinkageChecker linkageChecker = LinkageChecker.create(classPath);\n+\n+      ImmutableSetMultimap<SymbolProblem, ClassFile> symbolProblems =\n+          linkageChecker.findSymbolProblems();\n+\n+      int errorCount = symbolProblems.keySet().size();\n+\n+      // TODO(suztomo): Show the dependency paths to the problematic artifacts.\n+      if (errorCount > 0) {\n+        logger.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTMzNTMzOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyODozNFrOGiIY-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo0NDozN1rOGiIuKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MjIzNQ==", "bodyText": "private", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438442235", "createdAt": "2020-06-10T22:28:34Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NzY1OQ==", "bodyText": "Removed the field.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438447659", "createdAt": "2020-06-10T22:44:37Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MjIzNQ=="}, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTMzNjYwOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyOTowN1rOGiIZyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo0NDo0N1rOGiIuaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MjQ0MA==", "bodyText": "why do we have a logger field at all? Can we just call getLogger when we need it?", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438442440", "createdAt": "2020-06-10T22:29:07Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NzcyMw==", "bodyText": "That's a nice idea. Removed the logger field.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438447723", "createdAt": "2020-06-10T22:44:47Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MjQ0MA=="}, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTM0MTAwOnYy", "diffSide": "RIGHT", "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjozMDo1NFrOGiIcbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo0NjoyNFrOGiIwjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MzExNg==", "bodyText": "I'm not sure I've ever actually seen this operator used before. Bitwise assignment equal is strange. Consider simply\nif (findLinkageErrors(...))\n  foundError = true;\n}", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438443116", "createdAt": "2020-06-10T22:30:54Z", "author": {"login": "elharo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      foundError |= findLinkageErrors(configuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODI3MQ==", "bodyText": "Updated.", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1462#discussion_r438448271", "createdAt": "2020-06-10T22:46:24Z", "author": {"login": "suztomo"}, "path": "gradle-plugin/src/main/java/com/google/cloud/tools/dependencies/gradle/LinkageCheckTask.java", "diffHunk": "@@ -16,27 +16,115 @@\n \n package com.google.cloud.tools.dependencies.gradle;\n \n+import com.google.cloud.tools.opensource.classpath.ClassFile;\n+import com.google.cloud.tools.opensource.classpath.ClassPathEntry;\n import com.google.cloud.tools.opensource.classpath.LinkageChecker;\n+import com.google.cloud.tools.opensource.classpath.SymbolProblem;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n import java.io.IOException;\n+import org.eclipse.aether.artifact.DefaultArtifact;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.tasks.TaskAction;\n \n /**\n  * Task to run Linkage Checker for the dependencies of the Gradle project.\n  */\n public class LinkageCheckTask extends DefaultTask {\n+\n+  Logger logger;\n+\n   @TaskAction\n   public void run() throws IOException {\n+    logger = getLogger();\n+\n     LinkageCheckerPluginExtension extension =\n         getProject().getExtensions().findByType(LinkageCheckerPluginExtension.class);\n     if (extension == null) {\n       extension = new LinkageCheckerPluginExtension();\n     }\n \n-    // TODO(suztomo): run linkage checker for the dependencies of the Gradle project.\n-    String message = extension.getMessage();\n-    LinkageChecker linkageChecker = LinkageChecker.create(ImmutableList.of());\n-    System.out.println(\"Hello from \" + linkageChecker + \": \" + message);\n+    Project project = getProject();\n+    ImmutableSet.Builder<Configuration> configurationsBuilder = ImmutableSet.builder();\n+    if (extension.getConfigurations().isEmpty()) {\n+      // Should this default to runtime?\n+      logger.trace(\"No configuration specified, defaulting to all configurations\");\n+      for (Configuration configuration : project.getConfigurations()) {\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    } else {\n+      for (String configurationName : extension.getConfigurations()) {\n+        Configuration configuration = project.getConfigurations().getByName(configurationName);\n+        if (configuration.isCanBeResolved()) {\n+          configurationsBuilder.add(configuration);\n+        }\n+      }\n+    }\n+\n+    ImmutableSet<Configuration> configurations = configurationsBuilder.build();\n+\n+    boolean foundError = false;\n+    for (Configuration configuration : configurations) {\n+      foundError |= findLinkageErrors(configuration);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MzExNg=="}, "originalCommit": {"oid": "e30fef0bcb89ac588adce4ede15c79c912f7e596"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2596, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}