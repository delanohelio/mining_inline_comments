{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MjcwNDU3", "number": 4286, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNTozOVrOE8bqJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDozMzo1NlrOE8g8qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzMTcyOnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/EncryptSymmetric.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNTozOVrOH4i3XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNTozOVrOH4i3XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MzUzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return (long) Hashing.crc32c().hashBytes(data).asInt();\n          \n          \n            \n                return Hashing.crc32c().hashBytes(data).padToLong();", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529053532", "createdAt": "2020-11-23T23:05:39Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/EncryptSymmetric.java", "diffHunk": "@@ -38,20 +45,63 @@ public void encryptSymmetric() throws IOException {\n   // Encrypt data with a given key.\n   public void encryptSymmetric(\n       String projectId, String locationId, String keyRingId, String keyId, String plaintext)\n-      throws IOException {\n+      throws IOException, Exception {\n+\n+    System.err.println(\"TAMJAM1: \" + projectId);\n+\n     // Initialize client that will be used to send requests. This client only\n     // needs to be created once, and can be reused for multiple requests. After\n     // completing all of your requests, call the \"close\" method on the client to\n     // safely clean up any remaining background resources.\n+    EncryptResponse response;\n     try (KeyManagementServiceClient client = KeyManagementServiceClient.create()) {\n-      // Build the key version name from the project, location, key ring, key,\n-      // and key version.\n-      CryptoKeyName keyVersionName = CryptoKeyName.of(projectId, locationId, keyRingId, keyId);\n+      // Build the key name from the project, location, key ring, and key.\n+      CryptoKeyName cryptoKeyName = CryptoKeyName.of(projectId, locationId, keyRingId, keyId);\n+\n+      // Convert plaintext to ByteString.\n+      ByteString plaintextByteString = ByteString.copyFromUtf8(plaintext);\n+\n+      // Optional, but recommended: compute plaintext's CRC32C. See helper below.\n+      long plaintextCrc32c = getCrc32cAsLong(plaintextByteString.toByteArray());\n \n       // Encrypt the plaintext.\n-      EncryptResponse response = client.encrypt(keyVersionName, ByteString.copyFromUtf8(plaintext));\n-      System.out.printf(\"Ciphertext: %s%n\", response.getCiphertext().toStringUtf8());\n+      EncryptRequest request = EncryptRequest.newBuilder()\n+                               .setName(cryptoKeyName.toString())\n+                               .setPlaintext(plaintextByteString)\n+                               .setPlaintextCrc32C(\n+                                   Int64Value.newBuilder().setValue(plaintextCrc32c).build())\n+                               .build();\n+      response = client.encrypt(request);\n+    } catch (Exception e) {\n+      throw e;\n+    }\n+    // Optional, but recommended: perform integrity verification on response.\n+    // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+    // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+    System.err.println(\"TAMJAM2\");\n+    if (!response.getVerifiedPlaintextCrc32C()) {\n+      throw new IOException(\"Encrypt: request to server corrupted\");\n     }\n+\n+    // See helper below.\n+    if (!crcMatches(response.getCiphertextCrc32C().getValue(),\n+        response.getCiphertext().toByteArray())) {\n+      String details = String.format(\n+          \"Excpected=%d, Actual=%d, getCrc32cAsLong(test)=%d%n\",\n+          response.getCiphertextCrc32C().getValue(), getCrc32cAsLong(response.getCiphertext().toByteArray()),\n+          getCrc32cAsLong(\"test\"));\n+      throw new IOException(\"Encrypt: response from server corrupted. \" + details);\n+    }\n+\n+    System.out.printf(\"Ciphertext: %s%n\", response.getCiphertext().toStringUtf8());\n+  }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzMjU3OnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/GetPublicKey.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOH4i39A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOH4i39A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MzY4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return (long) Hashing.crc32c().hashBytes(data).asInt();\n          \n          \n            \n                return Hashing.crc32c().hashBytes(data).padToLong();", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529053684", "createdAt": "2020-11-23T23:06:00Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/GetPublicKey.java", "diffHunk": "@@ -51,8 +55,30 @@ public void getPublicKey(\n \n       // Get the public key.\n       PublicKey publicKey = client.getPublicKey(keyVersionName);\n+\n+      // Optional, but recommended: perform integrity verification on response.\n+      // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+      // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+      if (!publicKey.getName().equals(keyVersionName.toString())) {\n+        throw new IOException(\"GetPublicKey: request to server corrupted\");\n+      }\n+\n+      // See helper below.\n+      if (!crcMatches(publicKey.getPemCrc32C().getValue(),\n+          publicKey.getPemBytes().toByteArray())) {\n+        throw new IOException(\"GetPublicKey: response from server corrupted\");\n+      }\n+\n       System.out.printf(\"Public key: %s%n\", publicKey.getPem());\n     }\n   }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzMzI5OnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/SignAsymmetric.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjoxN1rOH4i4YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjoxN1rOH4i4YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1Mzc5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return (long) Hashing.crc32c().hashBytes(data).asInt();\n          \n          \n            \n                return Hashing.crc32c().hashBytes(data).padToLong();", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529053793", "createdAt": "2020-11-23T23:06:17Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/SignAsymmetric.java", "diffHunk": "@@ -70,14 +75,44 @@ public void signAsymmetric(\n       // Build the digest object.\n       Digest digest = Digest.newBuilder().setSha256(ByteString.copyFrom(hash)).build();\n \n+      // Optional, but recommended: compute digest's CRC32C. See helper below.\n+      long digestCrc32c = getCrc32cAsLong(hash);\n+\n       // Sign the digest.\n-      AsymmetricSignResponse result = client.asymmetricSign(keyVersionName, digest);\n+      AsymmetricSignRequest request =\n+          AsymmetricSignRequest.newBuilder()\n+              .setName(keyVersionName.toString())\n+              .setDigest(digest)\n+              .setDigestCrc32C(Int64Value.newBuilder().setValue(digestCrc32c).build())\n+              .build();\n+      AsymmetricSignResponse response = client.asymmetricSign(request);\n+\n+      // Optional, but recommended: perform integrity verification on response.\n+      // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+      // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+      if (!response.getVerifiedDigestCrc32C()) {\n+        throw new IOException(\"Encrypt: request to server corrupted\");\n+      }\n+\n+      // See helper below.\n+      if (!crcMatches(response.getSignatureCrc32C().getValue(),\n+          response.getSignature().toByteArray())) {\n+        throw new IOException(\"Encrypt: response from server corrupted\");\n+      }\n \n       // Get the signature.\n-      byte[] signature = result.getSignature().toByteArray();\n+      byte[] signature = response.getSignature().toByteArray();\n \n       System.out.printf(\"Signature %s%n\", signature);\n     }\n   }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzNTM3OnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/DecryptSymmetric.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNzowOFrOH4i5vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNzowOFrOH4i5vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NDE0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return (long) Hashing.crc32c().hashBytes(data).asInt();\n          \n          \n            \n                return Hashing.crc32c().hashBytes(data).padToLong();", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529054142", "createdAt": "2020-11-23T23:07:08Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/DecryptSymmetric.java", "diffHunk": "@@ -44,14 +51,40 @@ public void decryptSymmetric(\n     // completing all of your requests, call the \"close\" method on the client to\n     // safely clean up any remaining background resources.\n     try (KeyManagementServiceClient client = KeyManagementServiceClient.create()) {\n-      // Build the key version name from the project, location, key ring, and\n-      // key.\n+      // Build the key version from the project, location, key ring, and key.\n       CryptoKeyName keyName = CryptoKeyName.of(projectId, locationId, keyRingId, keyId);\n \n-      // Decrypt the response.\n-      DecryptResponse response = client.decrypt(keyName, ByteString.copyFrom(ciphertext));\n+      // Optional, but recommended: compute ciphertext's CRC32C. See helpers below.\n+      long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);\n+\n+      // Decrypt the ciphertext.\n+      DecryptRequest request =\n+          DecryptRequest.newBuilder()\n+              .setName(keyName.toString())\n+              .setCiphertext(ByteString.copyFrom(ciphertext))\n+              .setCiphertextCrc32C(\n+                  Int64Value.newBuilder().setValue(ceiphertextCrc32c).build())\n+              .build();\n+      DecryptResponse response = client.decrypt(request);\n+\n+      // Optional, but recommended: perform integrity verification on response.\n+      // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+      // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+      if (!crcMatches(response.getPlaintextCrc32C().getValue(),\n+          response.getPlaintext().toByteArray())) {\n+        throw new IOException(\"Decrypt: response from server corrupted, getCrc32cAsLong(test)=\" + getCrc32cAsLong(\"test\"));\n+      }\n+\n       System.out.printf(\"Plaintext: %s%n\", response.getPlaintext().toStringUtf8());\n     }\n   }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzNTgwOnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNzoyMVrOH4i6Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNzoyMVrOH4i6Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NDIxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return (long) Hashing.crc32c().hashBytes(data).asInt();\n          \n          \n            \n                return Hashing.crc32c().hashBytes(data).padToLong();", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529054214", "createdAt": "2020-11-23T23:07:21Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "diffHunk": "@@ -56,11 +61,41 @@ public void decryptAsymmetric(\n       CryptoKeyVersionName keyVersionName =\n           CryptoKeyVersionName.of(projectId, locationId, keyRingId, keyId, keyVersionId);\n \n+      // Optional, but recommended: compute ciphertext's CRC32C. See helpers below.\n+      long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);\n+\n       // Decrypt the ciphertext.\n-      AsymmetricDecryptResponse response =\n-          client.asymmetricDecrypt(keyVersionName, ByteString.copyFrom(ciphertext));\n+      AsymmetricDecryptRequest request =\n+          AsymmetricDecryptRequest.newBuilder()\n+              .setName(keyVersionName.toString())\n+              .setCiphertext(ByteString.copyFrom(ciphertext))\n+              .setCiphertextCrc32C(\n+                  Int64Value.newBuilder().setValue(ceiphertextCrc32c).build())\n+              .build();\n+      AsymmetricDecryptResponse response = client.asymmetricDecrypt(request);\n+\n+      // Optional, but recommended: perform integrity verification on response.\n+      // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+      // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+      if (!response.getVerifiedCiphertextCrc32C()) {\n+        throw new IOException(\"AsymmetricDecrypt: request to server corrupted\");\n+      }\n+\n+      if (!crcMatches(response.getPlaintextCrc32C().getValue(),\n+          response.getPlaintext().toByteArray())) {\n+        throw new IOException(\"AsymmetricDecrypt: response from server corrupted\");\n+      }\n+\n       System.out.printf(\"Plaintext: %s%n\", response.getPlaintext().toStringUtf8());\n     }\n   }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzOTAxOnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowODo0NFrOH4i8PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowODo0NFrOH4i8PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NDc4MA==", "bodyText": "Any reason you're using asInt() here? I tried this with padToLong() and the tests started to consistently pass. https://guava.dev/releases/19.0/api/docs/com/google/common/hash/HashCode.html#padToLong()", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529054780", "createdAt": "2020-11-23T23:08:44Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "diffHunk": "@@ -56,11 +61,41 @@ public void decryptAsymmetric(\n       CryptoKeyVersionName keyVersionName =\n           CryptoKeyVersionName.of(projectId, locationId, keyRingId, keyId, keyVersionId);\n \n+      // Optional, but recommended: compute ciphertext's CRC32C. See helpers below.\n+      long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);\n+\n       // Decrypt the ciphertext.\n-      AsymmetricDecryptResponse response =\n-          client.asymmetricDecrypt(keyVersionName, ByteString.copyFrom(ciphertext));\n+      AsymmetricDecryptRequest request =\n+          AsymmetricDecryptRequest.newBuilder()\n+              .setName(keyVersionName.toString())\n+              .setCiphertext(ByteString.copyFrom(ciphertext))\n+              .setCiphertextCrc32C(\n+                  Int64Value.newBuilder().setValue(ceiphertextCrc32c).build())\n+              .build();\n+      AsymmetricDecryptResponse response = client.asymmetricDecrypt(request);\n+\n+      // Optional, but recommended: perform integrity verification on response.\n+      // For more details on ensuring E2E in-transit integrity to and from Cloud KMS visit:\n+      // https://cloud.google.com/kms/docs/data-integrity-guidelines\n+      if (!response.getVerifiedCiphertextCrc32C()) {\n+        throw new IOException(\"AsymmetricDecrypt: request to server corrupted\");\n+      }\n+\n+      if (!crcMatches(response.getPlaintextCrc32C().getValue(),\n+          response.getPlaintext().toByteArray())) {\n+        throw new IOException(\"AsymmetricDecrypt: response from server corrupted\");\n+      }\n+\n       System.out.printf(\"Plaintext: %s%n\", response.getPlaintext().toStringUtf8());\n     }\n   }\n+\n+  private long getCrc32cAsLong(byte[] data) {\n+    return (long) Hashing.crc32c().hashBytes(data).asInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69dd25179e19a1937140d50abc7045c4678c974"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODg5ODMyOnYy", "diffSide": "RIGHT", "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDozMzo1N1rOH4rk9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MDo1NlrOH55kww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjI3OA==", "bodyText": "This spelling error shows up in a few other places. I'd suggest doing a global find/replace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);\n          \n          \n            \n                  long ciphertextCrc32c = getCrc32cAsLong(ciphertext);", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r529196278", "createdAt": "2020-11-24T04:33:57Z", "author": {"login": "shubha-rajan"}, "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "diffHunk": "@@ -56,11 +61,41 @@ public void decryptAsymmetric(\n       CryptoKeyVersionName keyVersionName =\n           CryptoKeyVersionName.of(projectId, locationId, keyRingId, keyId, keyVersionId);\n \n+      // Optional, but recommended: compute ciphertext's CRC32C. See helpers below.\n+      long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6deacfcbae09934a05f75e2f82fb9e700b845d0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDE3OQ==", "bodyText": "Thanks for catching that. Performed a global search/replace.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/4286#discussion_r530474179", "createdAt": "2020-11-25T15:50:56Z", "author": {"login": "iamtamjam"}, "path": "kms/src/main/java/kms/DecryptAsymmetric.java", "diffHunk": "@@ -56,11 +61,41 @@ public void decryptAsymmetric(\n       CryptoKeyVersionName keyVersionName =\n           CryptoKeyVersionName.of(projectId, locationId, keyRingId, keyId, keyVersionId);\n \n+      // Optional, but recommended: compute ciphertext's CRC32C. See helpers below.\n+      long ceiphertextCrc32c = getCrc32cAsLong(ciphertext);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjI3OA=="}, "originalCommit": {"oid": "a6deacfcbae09934a05f75e2f82fb9e700b845d0"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 712, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}