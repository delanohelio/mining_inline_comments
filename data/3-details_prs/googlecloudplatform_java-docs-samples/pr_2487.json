{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNTI0MTky", "number": 2487, "title": "feat: add backups samples", "bodyText": "Add samples for Spanner backups.", "createdAt": "2020-03-25T11:08:39Z", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487", "merged": true, "mergeCommit": {"oid": "40b452eff37f9a3b6a3c3e62884d14e96b40f55e"}, "closed": true, "closedAt": "2020-03-28T03:12:36Z", "author": {"login": "olavloite"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRTnOTAFqTM4MTY2MjI2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcR8LedAH2gAyMzkzNTI0MTkyOmZlNWZiZDg2OTZjN2VjMzhjMzJlOTFlYzNiYjI4Mzg2NmI0MWM2ZjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNjYyMjY4", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#pullrequestreview-381662268", "createdAt": "2020-03-26T02:26:34Z", "commit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMjoyNjozNFrOF71MYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMzoyOToyNFrOF72LfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI4MTgyNA==", "bodyText": "In the other languages, we ended up passing in a backupId as an argument. It would be good to do that here as well.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398281824", "createdAt": "2020-03-26T02:26:34Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI4ODU3Mw==", "bodyText": "Just trying to think of ways to reduce the length of the samples. Would the following work or would it be too unconventional?\nTimestamp expireTime = Timestamp.ofTimeMicroseconds(TimeUnit.MICROSECONDS.convert(\n    System.currentTimeMillis() + TimeUnit.DAYS.toMillis(14)), TimeUnit.MILLISECONDS);", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398288573", "createdAt": "2020-03-26T02:51:51Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI4OTA0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                }", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398289042", "createdAt": "2020-03-26T02:53:47Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI4OTA2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                }", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398289068", "createdAt": "2020-03-26T02:53:53Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI4OTcxMg==", "bodyText": "Same as above for simplifying the code.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398289712", "createdAt": "2020-03-26T02:56:29Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5MDE3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // isDone will return true if the operation has finished successfully or if it was cancelled\n          \n          \n            \n                  // or any other error occurred..\n          \n          \n            \n                  // isDone will return true when the operation is complete, regardless of whether it was successful or not.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398290175", "createdAt": "2020-03-26T02:58:21Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5MDQ2OQ==", "bodyText": "I would remove this.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398290469", "createdAt": "2020-03-26T02:59:29Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5MDc4Mg==", "bodyText": "I think the comment is sufficient and we can get rid of the println.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398290782", "createdAt": "2020-03-26T03:00:44Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5MTU0Mg==", "bodyText": "I realize we have this type of comment in the createDatabase sample but I'm wondering if we could get rid of it here to keep things concise.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398291542", "createdAt": "2020-03-26T03:03:43Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5Mjg0MQ==", "bodyText": "In the other samples, we ended up listing all optimize operations so if you could remove the name filter that would be great. Hope it doesn't mess up the tests too much.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398292841", "createdAt": "2020-03-26T03:09:12Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5MzkzMA==", "bodyText": "I think to keep things simpler we can just do:\n\"Database %s restored from backup is %s%% optimized\"\nThis is what we ended up doing in other languages. This way, you don't need to get the restoreDb or the restore info, etc.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398293930", "createdAt": "2020-03-26T03:13:38Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NDI2Nw==", "bodyText": "Can probably remove this too.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398294267", "createdAt": "2020-03-26T03:14:50Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NTY0Ng==", "bodyText": "I know this is how we defined it in the spec but we realized after that the samples tests won't be meaningful since these filter won't show anything. So we ended up doing the following:\n\nGet the backup ID as input to listBackups and filter on name:backupId.\nDatabase filter was changed to filter on the databaseId given as input.\nExpire time filter was changed to expire_time < (time now + 30 days).\nsize_bytes > X where X depends on the size of the database you're creating in other parts of the test. PHP is using X = 500 and Node.js is using X = 100.\ncreate_time >= (time now - 1 day)\n\nHope it's ok to make these changes.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398295646", "createdAt": "2020-03-26T03:20:14Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));\n+  }\n+  // [END spanner_list_database_operations]\n+\n+  // [START spanner_list_backups]\n+  static void listBackups(InstanceAdminClient instanceAdminClient, DatabaseId database) {\n+    Instance instance = instanceAdminClient.getInstance(database.getInstanceId().getInstance());\n+    // List all backups.\n+    System.out.println(\"All backups:\");\n+    for (Backup backup : instance.listBackups().iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups whose name contains 'users'.\n+    System.out.println(\"All backups with backup name containing \\\"users\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"name:users\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups for databases whose name contains the text 'bank'.\n+    System.out.println(\"All backups for databases with a name containing \\\"bank\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"database:bank\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups that expire before a certain time.\n+    System.out.println(\"All backups that expire before 2019-10-18T02:56:53Z:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"expire_time < \\\"2019-10-18T02:56:53Z\\\"\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with size greater than a certain number of bytes.\n+    System.out.println(\"All backups with size greater than 1000 bytes:\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"size_bytes > 1000\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with a create time after a certain timestamp and that are also ready.\n+    System.out.println(\"All databases created after 2019-10-18T02:56:53Z and that are ready:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"create_time >= \\\"2019-10-18T02:56:53Z\\\" AND state:READY\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NTkwOQ==", "bodyText": "We ended up passing in the backupId as an argument in the other languages. Could we also do that here?", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398295909", "createdAt": "2020-03-26T03:21:16Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));\n+  }\n+  // [END spanner_list_database_operations]\n+\n+  // [START spanner_list_backups]\n+  static void listBackups(InstanceAdminClient instanceAdminClient, DatabaseId database) {\n+    Instance instance = instanceAdminClient.getInstance(database.getInstanceId().getInstance());\n+    // List all backups.\n+    System.out.println(\"All backups:\");\n+    for (Backup backup : instance.listBackups().iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups whose name contains 'users'.\n+    System.out.println(\"All backups with backup name containing \\\"users\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"name:users\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups for databases whose name contains the text 'bank'.\n+    System.out.println(\"All backups for databases with a name containing \\\"bank\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"database:bank\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups that expire before a certain time.\n+    System.out.println(\"All backups that expire before 2019-10-18T02:56:53Z:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"expire_time < \\\"2019-10-18T02:56:53Z\\\"\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with size greater than a certain number of bytes.\n+    System.out.println(\"All backups with size greater than 1000 bytes:\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"size_bytes > 1000\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with a create time after a certain timestamp and that are also ready.\n+    System.out.println(\"All databases created after 2019-10-18T02:56:53Z and that are ready:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"create_time >= \\\"2019-10-18T02:56:53Z\\\" AND state:READY\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List backups using pagination.\n+    Page<Backup> page = instance.listBackups(Options.pageSize(10));\n+    while (true) {\n+      for (Backup backup : page.getValues()) {\n+        System.out.println(backup);\n+      }\n+      if (!page.hasNextPage()) {\n+        break;\n+      }\n+      page = page.getNextPage();\n+    }\n+  }\n+  // [END spanner_list_backups]\n+\n+  // [START spanner_restore_backup]\n+  static void restoreBackup(\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId sourceDatabaseId,\n+      DatabaseId restoreToDatabase) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            sourceDatabaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(sourceDatabaseId.getInstanceId(), backupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NjM3NA==", "bodyText": "Are you hitting this in the samples tests because a single instance is shared? We didn't do this for other languages but I think that might be because we're creating and destroying an instance for each test run.\nI'm a bit worried about the complexity of this in terms of a code sample since we just want to show users the simplest possible example.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398296374", "createdAt": "2020-03-26T03:23:05Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));\n+  }\n+  // [END spanner_list_database_operations]\n+\n+  // [START spanner_list_backups]\n+  static void listBackups(InstanceAdminClient instanceAdminClient, DatabaseId database) {\n+    Instance instance = instanceAdminClient.getInstance(database.getInstanceId().getInstance());\n+    // List all backups.\n+    System.out.println(\"All backups:\");\n+    for (Backup backup : instance.listBackups().iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups whose name contains 'users'.\n+    System.out.println(\"All backups with backup name containing \\\"users\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"name:users\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups for databases whose name contains the text 'bank'.\n+    System.out.println(\"All backups for databases with a name containing \\\"bank\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"database:bank\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups that expire before a certain time.\n+    System.out.println(\"All backups that expire before 2019-10-18T02:56:53Z:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"expire_time < \\\"2019-10-18T02:56:53Z\\\"\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with size greater than a certain number of bytes.\n+    System.out.println(\"All backups with size greater than 1000 bytes:\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"size_bytes > 1000\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with a create time after a certain timestamp and that are also ready.\n+    System.out.println(\"All databases created after 2019-10-18T02:56:53Z and that are ready:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"create_time >= \\\"2019-10-18T02:56:53Z\\\" AND state:READY\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List backups using pagination.\n+    Page<Backup> page = instance.listBackups(Options.pageSize(10));\n+    while (true) {\n+      for (Backup backup : page.getValues()) {\n+        System.out.println(backup);\n+      }\n+      if (!page.hasNextPage()) {\n+        break;\n+      }\n+      page = page.getNextPage();\n+    }\n+  }\n+  // [END spanner_list_backups]\n+\n+  // [START spanner_restore_backup]\n+  static void restoreBackup(\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId sourceDatabaseId,\n+      DatabaseId restoreToDatabase) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            sourceDatabaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(sourceDatabaseId.getInstanceId(), backupName);\n+    Backup backup = dbAdminClient.newBackupBuilder(backupId).build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(String.format(\n+        \"Restoring backup [%s] to database [%s]...\",\n+        backup.getId().toString(),\n+        restoreToDatabase.toString()));\n+    // Try the restore operation in a retry loop, as there is a limit on the number of restore\n+    // operations that is allowed to execute simultaneously, and we should retry if we hit this,\n+    // limit.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NjkwMw==", "bodyText": "Same here, it would be good to get the backupId as an input.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398296903", "createdAt": "2020-03-26T03:25:08Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));\n+  }\n+  // [END spanner_list_database_operations]\n+\n+  // [START spanner_list_backups]\n+  static void listBackups(InstanceAdminClient instanceAdminClient, DatabaseId database) {\n+    Instance instance = instanceAdminClient.getInstance(database.getInstanceId().getInstance());\n+    // List all backups.\n+    System.out.println(\"All backups:\");\n+    for (Backup backup : instance.listBackups().iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups whose name contains 'users'.\n+    System.out.println(\"All backups with backup name containing \\\"users\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"name:users\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups for databases whose name contains the text 'bank'.\n+    System.out.println(\"All backups for databases with a name containing \\\"bank\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"database:bank\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups that expire before a certain time.\n+    System.out.println(\"All backups that expire before 2019-10-18T02:56:53Z:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"expire_time < \\\"2019-10-18T02:56:53Z\\\"\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with size greater than a certain number of bytes.\n+    System.out.println(\"All backups with size greater than 1000 bytes:\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"size_bytes > 1000\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with a create time after a certain timestamp and that are also ready.\n+    System.out.println(\"All databases created after 2019-10-18T02:56:53Z and that are ready:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"create_time >= \\\"2019-10-18T02:56:53Z\\\" AND state:READY\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List backups using pagination.\n+    Page<Backup> page = instance.listBackups(Options.pageSize(10));\n+    while (true) {\n+      for (Backup backup : page.getValues()) {\n+        System.out.println(backup);\n+      }\n+      if (!page.hasNextPage()) {\n+        break;\n+      }\n+      page = page.getNextPage();\n+    }\n+  }\n+  // [END spanner_list_backups]\n+\n+  // [START spanner_restore_backup]\n+  static void restoreBackup(\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId sourceDatabaseId,\n+      DatabaseId restoreToDatabase) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            sourceDatabaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(sourceDatabaseId.getInstanceId(), backupName);\n+    Backup backup = dbAdminClient.newBackupBuilder(backupId).build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(String.format(\n+        \"Restoring backup [%s] to database [%s]...\",\n+        backup.getId().toString(),\n+        restoreToDatabase.toString()));\n+    // Try the restore operation in a retry loop, as there is a limit on the number of restore\n+    // operations that is allowed to execute simultaneously, and we should retry if we hit this,\n+    // limit.\n+    int restoreAttempts = 0;\n+    while (true) {\n+      try {\n+        OperationFuture<Database, RestoreDatabaseMetadata> op = backup.restore(restoreToDatabase);\n+        // Wait until the database has been restored.\n+        Database db = op.get();\n+        // Refresh database metadata and get the restore info.\n+        RestoreInfo restore = db.reload().getRestoreInfo();\n+        System.out.println(\n+            \"Restored database [\"\n+                + restore.getSourceDatabase().getName()\n+                + \"] from [\"\n+                + restore.getBackup().getName()\n+                + \"]\");\n+        break;\n+      } catch (ExecutionException e) {\n+        SpannerException se = (SpannerException) e.getCause();\n+        if (se.getErrorCode() == ErrorCode.FAILED_PRECONDITION\n+            && se.getMessage()\n+                .contains(\"Please retry the operation once the pending restores complete\")) {\n+          restoreAttempts++;\n+          if (restoreAttempts == 10) {\n+            System.out.println(\n+                \"Restore operation failed 10 times because of other pending restores. \"\n+                + \"Giving up restore.\");\n+            return;\n+          }\n+          // Wait and then retry.\n+          System.out.println(String.format(\n+              \"Restoring backup %s to database %s must wait because of other pending restore\",\n+              backup.getId().getBackup(),\n+              restoreToDatabase.getDatabase()));\n+          Uninterruptibles.sleepUninterruptibly(60L, TimeUnit.SECONDS);\n+        } else {\n+          throw se;\n+        }\n+      } catch (InterruptedException e) {\n+        throw SpannerExceptionFactory.propagateInterrupt(e);\n+      }\n+    }\n+  }\n+  // [END spanner_restore_backup]\n+\n+  // [START spanner_update_backup]\n+  static void updateBackup(DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5NzA5NQ==", "bodyText": "Same here regarding getting the backupId as in input.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398297095", "createdAt": "2020-03-26T03:26:02Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/main/java/com/example/spanner/SpannerSample.java", "diffHunk": "@@ -1473,9 +1503,371 @@ static void queryWithQueryOptions(DatabaseClient dbClient) {\n   }\n   // [END spanner_query_with_query_options]\n \n+  // [START spanner_create_backup]\n+  static void createBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Wait for the backup operation to complete.\n+      backup = op.get();\n+      System.out.println(\"Created backup [\" + backup.getId() + \"]\");\n+    } catch (ExecutionException e) {\n+      // If the operation failed during execution, expose the cause.\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      // Throw when a thread is waiting, sleeping, or otherwise occupied,\n+      // and the thread is interrupted, either before or during the activity.\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+    // Check that the backup has been created and is ready for use.\n+    if (!backup.isReady()) {\n+      System.out.println(\"Backup is not ready for use.\");\n+      throw new RuntimeException(\"Backup is not ready for use.\");\n+    }\n+    // Reload the metadata of the backup from the server.\n+    backup = backup.reload();\n+    System.out.println(\n+        String.format(\n+            \"Backup %s of size %d bytes was created at %s\",\n+            backup.getId().getName(),\n+            backup.getSize(),\n+            LocalDateTime.ofEpochSecond(\n+                backup.getProto().getCreateTime().getSeconds(),\n+                backup.getProto().getCreateTime().getNanos(),\n+                OffsetDateTime.now().getOffset())).toString());\n+  }\n+  // [END spanner_create_backup]\n+\n+  // [START spanner_cancel_create_backup]\n+  static void cancelCreateBackup(\n+      DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    String backupName =\n+        String.format(\n+            \"%s_%02d_cancel\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Set expire time to 14 days from now.\n+    long currentTimeInMicroSeconds =\n+        TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n+    long deltaTimeInMicroseconds = TimeUnit.MICROSECONDS.convert(14L, TimeUnit.DAYS);\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(currentTimeInMicroSeconds + deltaTimeInMicroseconds);\n+\n+    // Create a backup instance.\n+    Backup backup =\n+        dbAdminClient\n+            .newBackupBuilder(backupId)\n+            .setDatabase(databaseId)\n+            .setExpireTime(expireTime)\n+            .build();\n+    // Start the creation of a backup.\n+    System.out.println(\"Creating backup [\" + backup.getId() + \"]...\");\n+    OperationFuture<Backup, CreateBackupMetadata> op = backup.create();\n+    try {\n+      // Try to cancel the backup operation.\n+      System.out.println(\"Cancelling create backup operation for [\" + backup.getId() + \"]...\");\n+      dbAdminClient.cancelOperation(op.getName());\n+      // Get a polling future for the running operation. This future will regularly poll the server\n+      // for the current status of the backup operation.\n+      RetryingFuture<OperationSnapshot> pollingFuture = op.getPollingFuture();\n+      // Wait for the operation to finish.\n+      // isDone will return true if the operation has finished successfully or if it was cancelled\n+      // or any other error occurred..\n+      while (!pollingFuture.get().isDone()) {\n+        System.out.println(\"Waiting for the cancelled backup operation to finish...\");\n+        Thread.sleep(TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS));\n+      }\n+      if (pollingFuture.get().getErrorCode() == null) {\n+        // Backup was created before it could be cancelled. Delete the backup.\n+        System.out.println(\"Deleting backup [\" + backup.getId() + \"]...\");\n+        backup.delete();\n+      } else if (pollingFuture.get().getErrorCode().getCode() == StatusCode.Code.CANCELLED) {\n+        System.out.println(\"Backup operation for [\" + backup.getId() + \"] successfully cancelled\");\n+      }\n+    } catch (ExecutionException e) {\n+      throw (SpannerException) e.getCause();\n+    } catch (InterruptedException e) {\n+      throw SpannerExceptionFactory.propagateInterrupt(e);\n+    }\n+  }\n+  // [END spanner_cancel_create_backup]\n+\n+  // [START spanner_list_backup_operations]\n+  static void listBackupOperations(InstanceAdminClient instanceAdminClient, DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get create backup operations for the sample database.\n+    String filter =\n+        String.format(\n+            \"(metadata.database:%s) AND \"\n+                + \"(metadata.@type:type.googleapis.com/\"\n+                + \"google.spanner.admin.database.v1.CreateBackupMetadata)\",\n+            databaseId.getName());\n+    Page<Operation> operations = instance.listBackupOperations(Options.filter(filter));\n+    for (Operation op : operations.iterateAll()) {\n+      try {\n+        CreateBackupMetadata metadata = op.getMetadata().unpack(CreateBackupMetadata.class);\n+        System.out.println(\n+            String.format(\n+                \"Backup %s on database %s pending: %d%% complete\",\n+                metadata.getName(),\n+                metadata.getDatabase(),\n+                metadata.getProgress().getProgressPercent()));\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain CreateBackupMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+  }\n+  // [END spanner_list_backup_operations]\n+\n+  // [START spanner_list_database_operations]\n+  static void listDatabaseOperations(\n+      InstanceAdminClient instanceAdminClient,\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId databaseId) {\n+    Instance instance = instanceAdminClient.getInstance(databaseId.getInstanceId().getInstance());\n+    // Get optimize restored database operations for the sample database.\n+    String filter = String.format(\"(name:%s) AND (metadata.@type:type.googleapis.com/\"\n+                    + \"google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)\",\n+                    databaseId.getDatabase());\n+    for (Operation op : instance.listDatabaseOperations(Options.filter(filter)).iterateAll()) {\n+      try {\n+        OptimizeRestoredDatabaseMetadata metadata =\n+            op.getMetadata().unpack(OptimizeRestoredDatabaseMetadata.class);\n+        DatabaseId restoredDbId = DatabaseId.of(\n+            databaseId.getInstanceId(),\n+            metadata.getName().substring(metadata.getName().lastIndexOf('/') + 1));\n+        Database restoredDb = new Database(restoredDbId, State.UNSPECIFIED, dbAdminClient);\n+        if (restoredDb.exists()) {\n+          RestoreInfo restore = restoredDb.getRestoreInfo();\n+          if (restore != null) {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s restored from backup %s is optimized.\",\n+                    metadata.getName(), restore.getBackup().getName()));\n+          } else {\n+            System.out.println(\n+                String.format(\n+                    \"Database %s was restored from a backup and was optimized,\"\n+                    + \"but the restore information no longer exists.\",\n+                    metadata.getName()));\n+          }\n+        } else {\n+          System.out.println(\n+              String.format(\n+                  \"Database %s was restored from a backup and was optimized,\"\n+                  + \"but the database no longer exists.\",\n+                  metadata.getName()));\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        // The returned operation does not contain OptimizeRestoredDatabaseMetadata.\n+        System.err.println(e.getMessage());\n+      }\n+    }\n+    System.out.println(\n+        String.format(\"Listed all optimize operations for database %s\", databaseId.getDatabase()));\n+  }\n+  // [END spanner_list_database_operations]\n+\n+  // [START spanner_list_backups]\n+  static void listBackups(InstanceAdminClient instanceAdminClient, DatabaseId database) {\n+    Instance instance = instanceAdminClient.getInstance(database.getInstanceId().getInstance());\n+    // List all backups.\n+    System.out.println(\"All backups:\");\n+    for (Backup backup : instance.listBackups().iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups whose name contains 'users'.\n+    System.out.println(\"All backups with backup name containing \\\"users\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"name:users\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups for databases whose name contains the text 'bank'.\n+    System.out.println(\"All backups for databases with a name containing \\\"bank\\\":\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"database:bank\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups that expire before a certain time.\n+    System.out.println(\"All backups that expire before 2019-10-18T02:56:53Z:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"expire_time < \\\"2019-10-18T02:56:53Z\\\"\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with size greater than a certain number of bytes.\n+    System.out.println(\"All backups with size greater than 1000 bytes:\");\n+    for (Backup backup : instance.listBackups(Options.filter(\"size_bytes > 1000\")).iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List all backups with a create time after a certain timestamp and that are also ready.\n+    System.out.println(\"All databases created after 2019-10-18T02:56:53Z and that are ready:\");\n+    for (Backup backup :\n+        instance\n+            .listBackups(Options.filter(\"create_time >= \\\"2019-10-18T02:56:53Z\\\" AND state:READY\"))\n+            .iterateAll()) {\n+      System.out.println(backup);\n+    }\n+\n+    // List backups using pagination.\n+    Page<Backup> page = instance.listBackups(Options.pageSize(10));\n+    while (true) {\n+      for (Backup backup : page.getValues()) {\n+        System.out.println(backup);\n+      }\n+      if (!page.hasNextPage()) {\n+        break;\n+      }\n+      page = page.getNextPage();\n+    }\n+  }\n+  // [END spanner_list_backups]\n+\n+  // [START spanner_restore_backup]\n+  static void restoreBackup(\n+      DatabaseAdminClient dbAdminClient,\n+      DatabaseId sourceDatabaseId,\n+      DatabaseId restoreToDatabase) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            sourceDatabaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(sourceDatabaseId.getInstanceId(), backupName);\n+    Backup backup = dbAdminClient.newBackupBuilder(backupId).build();\n+    // Initiate the request which returns an OperationFuture.\n+    System.out.println(String.format(\n+        \"Restoring backup [%s] to database [%s]...\",\n+        backup.getId().toString(),\n+        restoreToDatabase.toString()));\n+    // Try the restore operation in a retry loop, as there is a limit on the number of restore\n+    // operations that is allowed to execute simultaneously, and we should retry if we hit this,\n+    // limit.\n+    int restoreAttempts = 0;\n+    while (true) {\n+      try {\n+        OperationFuture<Database, RestoreDatabaseMetadata> op = backup.restore(restoreToDatabase);\n+        // Wait until the database has been restored.\n+        Database db = op.get();\n+        // Refresh database metadata and get the restore info.\n+        RestoreInfo restore = db.reload().getRestoreInfo();\n+        System.out.println(\n+            \"Restored database [\"\n+                + restore.getSourceDatabase().getName()\n+                + \"] from [\"\n+                + restore.getBackup().getName()\n+                + \"]\");\n+        break;\n+      } catch (ExecutionException e) {\n+        SpannerException se = (SpannerException) e.getCause();\n+        if (se.getErrorCode() == ErrorCode.FAILED_PRECONDITION\n+            && se.getMessage()\n+                .contains(\"Please retry the operation once the pending restores complete\")) {\n+          restoreAttempts++;\n+          if (restoreAttempts == 10) {\n+            System.out.println(\n+                \"Restore operation failed 10 times because of other pending restores. \"\n+                + \"Giving up restore.\");\n+            return;\n+          }\n+          // Wait and then retry.\n+          System.out.println(String.format(\n+              \"Restoring backup %s to database %s must wait because of other pending restore\",\n+              backup.getId().getBackup(),\n+              restoreToDatabase.getDatabase()));\n+          Uninterruptibles.sleepUninterruptibly(60L, TimeUnit.SECONDS);\n+        } else {\n+          throw se;\n+        }\n+      } catch (InterruptedException e) {\n+        throw SpannerExceptionFactory.propagateInterrupt(e);\n+      }\n+    }\n+  }\n+  // [END spanner_restore_backup]\n+\n+  // [START spanner_update_backup]\n+  static void updateBackup(DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);\n+    // Get current backup metadata.\n+    Backup backup = dbAdminClient.newBackupBuilder(backupId).build().reload();\n+    // Add 30 days to the expire time.\n+    // Expire time must be within 366 days of the create time of the backup.\n+    Timestamp expireTime =\n+        Timestamp.ofTimeMicroseconds(\n+            TimeUnit.SECONDS.toMicros(backup.getExpireTime().getSeconds())\n+                + TimeUnit.NANOSECONDS.toMicros(backup.getExpireTime().getNanos())\n+                + TimeUnit.DAYS.toMicros(30L));\n+    System.out.println(String.format(\n+        \"Updating expire time of backup [%s] to %s...\",\n+        backupId.toString(),\n+        LocalDateTime.ofEpochSecond(\n+            expireTime.getSeconds(),\n+            expireTime.getNanos(),\n+            OffsetDateTime.now().getOffset()).toString()));\n+\n+    // Update expire time.\n+    backup = backup.toBuilder().setExpireTime(expireTime).build();\n+    backup.updateExpireTime();\n+    System.out.println(\"Updated backup [\" + backupId + \"]\");\n+  }\n+  // [END spanner_update_backup]\n+\n+  // [START spanner_delete_backup]\n+  static void deleteBackup(DatabaseAdminClient dbAdminClient, DatabaseId databaseId) {\n+    // Get the most recent sample backup of the sample database.\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            databaseId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(databaseId.getInstanceId(), backupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI5Nzk4MA==", "bodyText": "We ended up checking the outputs (like the backupId in listbackups) in the tests for other languages. I don't know if that's conventional in the Java tests but would it be possible to do that here?\nAt least in Node.js, I found it helpful to know when we hadn't defined the types correctly and it printed out \"undefined\".", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r398297980", "createdAt": "2020-03-26T03:29:24Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/test/java/com/example/spanner/SpannerSampleIT.java", "diffHunk": "@@ -241,6 +241,36 @@ public void testSample() throws Exception {\n     assertThat(out).contains(\"1 1 Total Junk\");\n     out = runSample(\"querywithqueryoptions\");\n     assertThat(out).contains(\"1 1 Total Junk\");\n+\n+    out = runSample(\"createbackup\");\n+    assertThat(out).contains(\"Created backup\");\n+\n+    out = runSample(\"cancelcreatebackup\");\n+    assertThat(out).contains(\"successfully cancelled\");\n+\n+    out = runSample(\"listbackupoperations\");\n+    assertThat(out).contains(\"pending\");\n+\n+    out = runSample(\"listdatabaseoperations\");\n+    assertThat(out).contains(\"optimize\");\n+\n+    out = runSample(\"listbackups\");\n+    assertThat(out).contains(databaseId);\n+\n+    out = runSample(\"restorebackup\");\n+    assertThat(out).contains(\"Restored database [\");\n+\n+    out = runSample(\"updatebackup\");\n+    assertThat(out).contains(\"Updated backup [\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc4477b02f5f9a561470128c853c2a0d014357a"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNTk3OTY4", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#pullrequestreview-382597968", "createdAt": "2020-03-27T06:03:44Z", "commit": {"oid": "7e92d0346b03debeef45a872d3a2bced92360e92"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNjowMzo0NFrOF8kLRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNjowNTowOFrOF8kMlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTU5MA==", "bodyText": "I think it's better to check for \"Updated backup [%s]\".", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r399051590", "createdAt": "2020-03-27T06:03:44Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/test/java/com/example/spanner/SpannerSampleIT.java", "diffHunk": "@@ -241,6 +252,83 @@ public void testSample() throws Exception {\n     assertThat(out).contains(\"1 1 Total Junk\");\n     out = runSample(\"querywithqueryoptions\");\n     assertThat(out).contains(\"1 1 Total Junk\");\n+\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            dbId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(dbId.getInstanceId(), backupName);\n+\n+    out = runSample(\"createbackup\");\n+    assertThat(out).contains(\"Created backup [\" + backupId + \"]\");\n+\n+    out = runSample(\"cancelcreatebackup\");\n+    assertThat(out).contains(\n+        \"Backup operation for [\" + backupId + \"_cancel] successfully cancelled\");\n+\n+    out = runSample(\"listbackupoperations\");\n+    assertThat(out).contains(\n+        String.format(\n+            \"Backup %s on database %s pending:\",\n+            backupId.getName(),\n+            dbId.getName()));\n+\n+    out = runSample(\"listbackups\");\n+    assertThat(out).contains(databaseId);\n+\n+    // Try the restore operation in a retry loop, as there is a limit on the number of restore\n+    // operations that is allowed to execute simultaneously, and we should retry if we hit this\n+    // limit.\n+    int restoreAttempts = 0;\n+    while (true) {\n+      try {\n+        out = runSample(\"restorebackup\");\n+        assertThat(out).contains(\n+            \"Restored database [\"\n+                + dbId.getName()\n+                + \"] from [\"\n+                + backupId.getName()\n+                + \"]\");\n+        break;\n+      } catch (SpannerException e) {\n+        if (e.getErrorCode() == ErrorCode.FAILED_PRECONDITION\n+            && e.getMessage()\n+                .contains(\"Please retry the operation once the pending restores complete\")) {\n+          restoreAttempts++;\n+          if (restoreAttempts == 10) {\n+            System.out.println(\n+                \"Restore operation failed 10 times because of other pending restores. \"\n+                + \"Giving up restore.\");\n+            break;\n+          }\n+          Uninterruptibles.sleepUninterruptibly(60L, TimeUnit.SECONDS);\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+\n+    out = runSample(\"listdatabaseoperations\");\n+    assertThat(out).contains(\n+        String.format(\n+            \"Database %s restored from backup\",\n+            DatabaseId.of(\n+                dbId.getInstanceId(),\n+                SpannerSample.createRestoredSampleDbId(dbId))\n+            .getName()));\n+\n+    out = runSample(\"updatebackup\");\n+    assertThat(out).contains(\n+        String.format(\"Updating expire time of backup [%s]\", backupId.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e92d0346b03debeef45a872d3a2bced92360e92"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTkyNQ==", "bodyText": "I think it would be good to test at least some of outputs with various filters. Let me know if you think it would be too flaky.", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#discussion_r399051925", "createdAt": "2020-03-27T06:05:08Z", "author": {"login": "skuruppu"}, "path": "spanner/cloud-client/src/test/java/com/example/spanner/SpannerSampleIT.java", "diffHunk": "@@ -241,6 +252,83 @@ public void testSample() throws Exception {\n     assertThat(out).contains(\"1 1 Total Junk\");\n     out = runSample(\"querywithqueryoptions\");\n     assertThat(out).contains(\"1 1 Total Junk\");\n+\n+    String backupName =\n+        String.format(\n+            \"%s_%02d\",\n+            dbId.getDatabase(), LocalDate.now().get(ChronoField.ALIGNED_WEEK_OF_YEAR));\n+    BackupId backupId = BackupId.of(dbId.getInstanceId(), backupName);\n+\n+    out = runSample(\"createbackup\");\n+    assertThat(out).contains(\"Created backup [\" + backupId + \"]\");\n+\n+    out = runSample(\"cancelcreatebackup\");\n+    assertThat(out).contains(\n+        \"Backup operation for [\" + backupId + \"_cancel] successfully cancelled\");\n+\n+    out = runSample(\"listbackupoperations\");\n+    assertThat(out).contains(\n+        String.format(\n+            \"Backup %s on database %s pending:\",\n+            backupId.getName(),\n+            dbId.getName()));\n+\n+    out = runSample(\"listbackups\");\n+    assertThat(out).contains(databaseId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e92d0346b03debeef45a872d3a2bced92360e92"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMTU3MjQ2", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2487#pullrequestreview-383157246", "createdAt": "2020-03-27T19:50:29Z", "commit": {"oid": "dd5eaf659e40f094d3d45253a0cd75d090bf8f9d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83e26d59ee415f6301b199f5227b53fdbf4897ef", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/83e26d59ee415f6301b199f5227b53fdbf4897ef", "committedDate": "2020-03-27T20:04:41Z", "message": "feat: add backups samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27c19f5ef55ca3cf9b21f13b4ffe3b097589d95d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/27c19f5ef55ca3cf9b21f13b4ffe3b097589d95d", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: include db name in filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba1ca21bf01a3f23c677deebcd2ab0c1ead91e37", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/ba1ca21bf01a3f23c677deebcd2ab0c1ead91e37", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: remove unknown filter option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd51dba952aacc5f4d5f62abca4d380e7e2f7bb9", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/fd51dba952aacc5f4d5f62abca4d380e7e2f7bb9", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: add filtering for database"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea20ea8b6323383e5235e5516c988cbbadead6f1", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/ea20ea8b6323383e5235e5516c988cbbadead6f1", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: style + max 1 pending restore operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6275db26762a2edba1017eeed12974488311ff8d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/6275db26762a2edba1017eeed12974488311ff8d", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: fix error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6f3022f774413f682b28b72fc7d175c36d165b5", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/b6f3022f774413f682b28b72fc7d175c36d165b5", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: another try at fixing the error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebfb117030b4b4d794b2357c1c788a4b59be4b9a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/ebfb117030b4b4d794b2357c1c788a4b59be4b9a", "committedDate": "2020-03-27T20:04:41Z", "message": "fix: extract SpannerException from cause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad27516fc81e2776d6c1473d5a4e344c9d679779", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/ad27516fc81e2776d6c1473d5a4e344c9d679779", "committedDate": "2020-03-27T20:05:14Z", "message": "fix: process review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7584d79846ea26804d0df53cd24161821d5238d1", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/7584d79846ea26804d0df53cd24161821d5238d1", "committedDate": "2020-03-27T20:05:14Z", "message": "fix: check for expected backup id in log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e695159a67a0a1951ea2652029adc14b55bef767", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/e695159a67a0a1951ea2652029adc14b55bef767", "committedDate": "2020-03-27T20:05:14Z", "message": "fix: verify that backup is found in list ops"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd5eaf659e40f094d3d45253a0cd75d090bf8f9d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/dd5eaf659e40f094d3d45253a0cd75d090bf8f9d", "committedDate": "2020-03-27T07:47:41Z", "message": "Merge branch 'spanner-backups' of github.com:olavloite/java-docs-samples into spanner-backups"}, "afterCommit": {"oid": "e695159a67a0a1951ea2652029adc14b55bef767", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/e695159a67a0a1951ea2652029adc14b55bef767", "committedDate": "2020-03-27T20:05:14Z", "message": "fix: verify that backup is found in list ops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe5fbd8696c7ec38c32e91ec3bb283866b41c6f1", "author": {"user": {"login": "skuruppu", "name": null}}, "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/fe5fbd8696c7ec38c32e91ec3bb283866b41c6f1", "committedDate": "2020-03-28T02:49:38Z", "message": "Merge branch 'master' into spanner-backups"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 869, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}