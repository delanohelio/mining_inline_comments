{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMDc4ODIz", "number": 1182, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNjoxOFrOEQQA9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNjoxOFrOEQQA9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDc1MDYxOnYy", "diffSide": "RIGHT", "path": "web/src/app/shared/store/classification-store/classification.state.ts", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNjoxOFrOG0TIpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMTowODowN1rOG0zFbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MjY0Ng==", "bodyText": "why key = null, but classificationId = undefined?\ni think classificationId should be null too, as we deliberatly set it to nothing", "url": "https://github.com/Taskana/taskana/pull/1182#discussion_r457492646", "createdAt": "2020-07-20T15:26:18Z", "author": {"login": "Tristan2357"}, "path": "web/src/app/shared/store/classification-store/classification.state.ts", "diffHunk": "@@ -118,33 +113,59 @@ export class ClassificationState implements NgxsAfterBootstrap {\n \n   @Action(RestoreSelectedClassification)\n   restoreSelectedClassification(ctx: StateContext<ClassificationStateModel>, action: RestoreSelectedClassification): Observable<any> {\n-    return this.classificationsService.getClassification(action.classificationId).pipe(\n-      take(1),\n-      tap(selectedClassification => ctx.patchState({ selectedClassification }))\n-    );\n+    const state = ctx.getState();\n+\n+    // check whether the classification already exists\n+    // returns true in case the classification was edited or copied\n+    if (state.classifications.some(classification => classification.classificationId === action.classificationId)) {\n+      return this.classificationsService.getClassification(action.classificationId).pipe(\n+        take(1),\n+        tap(selectedClassification => {\n+          ctx.patchState({ selectedClassification });\n+        })\n+      );\n+    }\n+\n+    // the classification is restored to a new classification\n+    const category = state.classificationTypes[state.selectedClassificationType][0];\n+    const { type, created, modified, domain, parentId, parentKey } = state.selectedClassification;\n+    ctx.patchState({ selectedClassification: { type, created, category, modified, domain, parentId, parentKey } });\n+\n+    return of(null);\n   }\n \n-  @Action(SetActiveAction)\n-  setActiveAction(ctx: StateContext<ClassificationStateModel>, action: SetActiveAction): Observable<null> {\n-    if (action.action === ACTION.CREATE) {\n-      // Initialization of a new classification\n-      const state: ClassificationStateModel = ctx.getState();\n-      const date = TaskanaDate.getDate();\n-      const initialClassification: Classification = {\n-        type: state.selectedClassificationType,\n-        category: state.classificationTypes[state.selectedClassificationType][0],\n-        created: date,\n-        modified: date,\n-        domain: this.domainService.getSelectedDomainValue(),\n-      };\n-      if (state.selectedClassification) {\n-        initialClassification.parentId = state.selectedClassification.classificationId;\n-        initialClassification.parentKey = state.selectedClassification.key;\n-      }\n-      ctx.patchState({ selectedClassification: initialClassification, action: action.action });\n-    } else {\n-      ctx.patchState({ action: action.action });\n+  @Action(CreateClassification)\n+  newCreateClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    // Initialization of a new classification\n+    const state: ClassificationStateModel = ctx.getState();\n+    const date = TaskanaDate.getDate();\n+    const initialClassification: Classification = {\n+      type: state.selectedClassificationType,\n+      category: state.classificationTypes[state.selectedClassificationType][0],\n+      created: date,\n+      modified: date,\n+      domain: this.domainService.getSelectedDomainValue(),\n+    };\n+    if (state.selectedClassification) {\n+      initialClassification.parentId = state.selectedClassification.classificationId;\n+      initialClassification.parentKey = state.selectedClassification.key;\n     }\n+    ctx.patchState({\n+      selectedClassification: initialClassification,\n+      badgeMessage: 'Creating new classification'\n+    });\n+    return of(null);\n+  }\n+\n+  @Action(CopyClassification)\n+  newCopyClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    const copy = { ...ctx.getState().selectedClassification };\n+    copy.key = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca0d8f6e3899f031ac8f47d949155912299b6fd8"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkzNDEzOA==", "bodyText": "other attributes are copied from the selected classification but id and key are not, so that user can write new key value, while id will be generated by backend when submitted. This behavior is similar to workbasket.", "url": "https://github.com/Taskana/taskana/pull/1182#discussion_r457934138", "createdAt": "2020-07-21T08:41:32Z", "author": {"login": "cnguyen-de"}, "path": "web/src/app/shared/store/classification-store/classification.state.ts", "diffHunk": "@@ -118,33 +113,59 @@ export class ClassificationState implements NgxsAfterBootstrap {\n \n   @Action(RestoreSelectedClassification)\n   restoreSelectedClassification(ctx: StateContext<ClassificationStateModel>, action: RestoreSelectedClassification): Observable<any> {\n-    return this.classificationsService.getClassification(action.classificationId).pipe(\n-      take(1),\n-      tap(selectedClassification => ctx.patchState({ selectedClassification }))\n-    );\n+    const state = ctx.getState();\n+\n+    // check whether the classification already exists\n+    // returns true in case the classification was edited or copied\n+    if (state.classifications.some(classification => classification.classificationId === action.classificationId)) {\n+      return this.classificationsService.getClassification(action.classificationId).pipe(\n+        take(1),\n+        tap(selectedClassification => {\n+          ctx.patchState({ selectedClassification });\n+        })\n+      );\n+    }\n+\n+    // the classification is restored to a new classification\n+    const category = state.classificationTypes[state.selectedClassificationType][0];\n+    const { type, created, modified, domain, parentId, parentKey } = state.selectedClassification;\n+    ctx.patchState({ selectedClassification: { type, created, category, modified, domain, parentId, parentKey } });\n+\n+    return of(null);\n   }\n \n-  @Action(SetActiveAction)\n-  setActiveAction(ctx: StateContext<ClassificationStateModel>, action: SetActiveAction): Observable<null> {\n-    if (action.action === ACTION.CREATE) {\n-      // Initialization of a new classification\n-      const state: ClassificationStateModel = ctx.getState();\n-      const date = TaskanaDate.getDate();\n-      const initialClassification: Classification = {\n-        type: state.selectedClassificationType,\n-        category: state.classificationTypes[state.selectedClassificationType][0],\n-        created: date,\n-        modified: date,\n-        domain: this.domainService.getSelectedDomainValue(),\n-      };\n-      if (state.selectedClassification) {\n-        initialClassification.parentId = state.selectedClassification.classificationId;\n-        initialClassification.parentKey = state.selectedClassification.key;\n-      }\n-      ctx.patchState({ selectedClassification: initialClassification, action: action.action });\n-    } else {\n-      ctx.patchState({ action: action.action });\n+  @Action(CreateClassification)\n+  newCreateClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    // Initialization of a new classification\n+    const state: ClassificationStateModel = ctx.getState();\n+    const date = TaskanaDate.getDate();\n+    const initialClassification: Classification = {\n+      type: state.selectedClassificationType,\n+      category: state.classificationTypes[state.selectedClassificationType][0],\n+      created: date,\n+      modified: date,\n+      domain: this.domainService.getSelectedDomainValue(),\n+    };\n+    if (state.selectedClassification) {\n+      initialClassification.parentId = state.selectedClassification.classificationId;\n+      initialClassification.parentKey = state.selectedClassification.key;\n     }\n+    ctx.patchState({\n+      selectedClassification: initialClassification,\n+      badgeMessage: 'Creating new classification'\n+    });\n+    return of(null);\n+  }\n+\n+  @Action(CopyClassification)\n+  newCopyClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    const copy = { ...ctx.getState().selectedClassification };\n+    copy.key = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MjY0Ng=="}, "originalCommit": {"oid": "ca0d8f6e3899f031ac8f47d949155912299b6fd8"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MDEyMQ==", "bodyText": "yes, but shouldn't both be set to null, as null indicates the explicit absence of value, while undefined should show, that the value has not been initiated", "url": "https://github.com/Taskana/taskana/pull/1182#discussion_r457940121", "createdAt": "2020-07-21T08:51:31Z", "author": {"login": "Tristan2357"}, "path": "web/src/app/shared/store/classification-store/classification.state.ts", "diffHunk": "@@ -118,33 +113,59 @@ export class ClassificationState implements NgxsAfterBootstrap {\n \n   @Action(RestoreSelectedClassification)\n   restoreSelectedClassification(ctx: StateContext<ClassificationStateModel>, action: RestoreSelectedClassification): Observable<any> {\n-    return this.classificationsService.getClassification(action.classificationId).pipe(\n-      take(1),\n-      tap(selectedClassification => ctx.patchState({ selectedClassification }))\n-    );\n+    const state = ctx.getState();\n+\n+    // check whether the classification already exists\n+    // returns true in case the classification was edited or copied\n+    if (state.classifications.some(classification => classification.classificationId === action.classificationId)) {\n+      return this.classificationsService.getClassification(action.classificationId).pipe(\n+        take(1),\n+        tap(selectedClassification => {\n+          ctx.patchState({ selectedClassification });\n+        })\n+      );\n+    }\n+\n+    // the classification is restored to a new classification\n+    const category = state.classificationTypes[state.selectedClassificationType][0];\n+    const { type, created, modified, domain, parentId, parentKey } = state.selectedClassification;\n+    ctx.patchState({ selectedClassification: { type, created, category, modified, domain, parentId, parentKey } });\n+\n+    return of(null);\n   }\n \n-  @Action(SetActiveAction)\n-  setActiveAction(ctx: StateContext<ClassificationStateModel>, action: SetActiveAction): Observable<null> {\n-    if (action.action === ACTION.CREATE) {\n-      // Initialization of a new classification\n-      const state: ClassificationStateModel = ctx.getState();\n-      const date = TaskanaDate.getDate();\n-      const initialClassification: Classification = {\n-        type: state.selectedClassificationType,\n-        category: state.classificationTypes[state.selectedClassificationType][0],\n-        created: date,\n-        modified: date,\n-        domain: this.domainService.getSelectedDomainValue(),\n-      };\n-      if (state.selectedClassification) {\n-        initialClassification.parentId = state.selectedClassification.classificationId;\n-        initialClassification.parentKey = state.selectedClassification.key;\n-      }\n-      ctx.patchState({ selectedClassification: initialClassification, action: action.action });\n-    } else {\n-      ctx.patchState({ action: action.action });\n+  @Action(CreateClassification)\n+  newCreateClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    // Initialization of a new classification\n+    const state: ClassificationStateModel = ctx.getState();\n+    const date = TaskanaDate.getDate();\n+    const initialClassification: Classification = {\n+      type: state.selectedClassificationType,\n+      category: state.classificationTypes[state.selectedClassificationType][0],\n+      created: date,\n+      modified: date,\n+      domain: this.domainService.getSelectedDomainValue(),\n+    };\n+    if (state.selectedClassification) {\n+      initialClassification.parentId = state.selectedClassification.classificationId;\n+      initialClassification.parentKey = state.selectedClassification.key;\n     }\n+    ctx.patchState({\n+      selectedClassification: initialClassification,\n+      badgeMessage: 'Creating new classification'\n+    });\n+    return of(null);\n+  }\n+\n+  @Action(CopyClassification)\n+  newCopyClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    const copy = { ...ctx.getState().selectedClassification };\n+    copy.key = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MjY0Ng=="}, "originalCommit": {"oid": "ca0d8f6e3899f031ac8f47d949155912299b6fd8"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAxNjExMA==", "bodyText": "Setting the id to null was also my first intuition but this leads to problems in the tree component since the classificationId is used as idField for the tree nodes.", "url": "https://github.com/Taskana/taskana/pull/1182#discussion_r458016110", "createdAt": "2020-07-21T11:08:07Z", "author": {"login": "sofie29"}, "path": "web/src/app/shared/store/classification-store/classification.state.ts", "diffHunk": "@@ -118,33 +113,59 @@ export class ClassificationState implements NgxsAfterBootstrap {\n \n   @Action(RestoreSelectedClassification)\n   restoreSelectedClassification(ctx: StateContext<ClassificationStateModel>, action: RestoreSelectedClassification): Observable<any> {\n-    return this.classificationsService.getClassification(action.classificationId).pipe(\n-      take(1),\n-      tap(selectedClassification => ctx.patchState({ selectedClassification }))\n-    );\n+    const state = ctx.getState();\n+\n+    // check whether the classification already exists\n+    // returns true in case the classification was edited or copied\n+    if (state.classifications.some(classification => classification.classificationId === action.classificationId)) {\n+      return this.classificationsService.getClassification(action.classificationId).pipe(\n+        take(1),\n+        tap(selectedClassification => {\n+          ctx.patchState({ selectedClassification });\n+        })\n+      );\n+    }\n+\n+    // the classification is restored to a new classification\n+    const category = state.classificationTypes[state.selectedClassificationType][0];\n+    const { type, created, modified, domain, parentId, parentKey } = state.selectedClassification;\n+    ctx.patchState({ selectedClassification: { type, created, category, modified, domain, parentId, parentKey } });\n+\n+    return of(null);\n   }\n \n-  @Action(SetActiveAction)\n-  setActiveAction(ctx: StateContext<ClassificationStateModel>, action: SetActiveAction): Observable<null> {\n-    if (action.action === ACTION.CREATE) {\n-      // Initialization of a new classification\n-      const state: ClassificationStateModel = ctx.getState();\n-      const date = TaskanaDate.getDate();\n-      const initialClassification: Classification = {\n-        type: state.selectedClassificationType,\n-        category: state.classificationTypes[state.selectedClassificationType][0],\n-        created: date,\n-        modified: date,\n-        domain: this.domainService.getSelectedDomainValue(),\n-      };\n-      if (state.selectedClassification) {\n-        initialClassification.parentId = state.selectedClassification.classificationId;\n-        initialClassification.parentKey = state.selectedClassification.key;\n-      }\n-      ctx.patchState({ selectedClassification: initialClassification, action: action.action });\n-    } else {\n-      ctx.patchState({ action: action.action });\n+  @Action(CreateClassification)\n+  newCreateClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    // Initialization of a new classification\n+    const state: ClassificationStateModel = ctx.getState();\n+    const date = TaskanaDate.getDate();\n+    const initialClassification: Classification = {\n+      type: state.selectedClassificationType,\n+      category: state.classificationTypes[state.selectedClassificationType][0],\n+      created: date,\n+      modified: date,\n+      domain: this.domainService.getSelectedDomainValue(),\n+    };\n+    if (state.selectedClassification) {\n+      initialClassification.parentId = state.selectedClassification.classificationId;\n+      initialClassification.parentKey = state.selectedClassification.key;\n     }\n+    ctx.patchState({\n+      selectedClassification: initialClassification,\n+      badgeMessage: 'Creating new classification'\n+    });\n+    return of(null);\n+  }\n+\n+  @Action(CopyClassification)\n+  newCopyClassification(ctx: StateContext<ClassificationStateModel>): Observable<null> {\n+    const copy = { ...ctx.getState().selectedClassification };\n+    copy.key = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MjY0Ng=="}, "originalCommit": {"oid": "ca0d8f6e3899f031ac8f47d949155912299b6fd8"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4112, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}