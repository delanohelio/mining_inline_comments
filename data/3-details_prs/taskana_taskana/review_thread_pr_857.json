{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1ODMwOTA4", "number": 857, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo0MTo1N1rODZ0TAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo0ODowM1rODZ0Zsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4Mzk3ODI2OnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo0MTo1N1rOFgavlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzo0NDoxM1rOFgcgOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg==", "bodyText": "Just out of curiosity:\nShould we instantiate the Handlers, so that mybatis doesnt do it via reflections?", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369536916", "createdAt": "2020-01-22T12:41:57Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjk4NA==", "bodyText": "Does that even matter?", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369536984", "createdAt": "2020-01-22T12:42:06Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NDU5Nw==", "bodyText": "I even don't know an interface that we could use to pass instantiated handlers to mybatis...", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369544597", "createdAt": "2020-01-22T13:00:04Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NzA3Mw==", "bodyText": "https://mybatis.org/mybatis-3/apidocs/reference/org/apache/ibatis/type/TypeHandlerRegistry.html\nwould be\nregister(TypeHandler typeHandler) for the MapTypeHandler\nand\nregister(Class javaType, TypeHandler<? extends T> typeHandler) for the InstantTypeHandler", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369547073", "createdAt": "2020-01-22T13:05:39Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NzYzMg==", "bodyText": "looking at the sourcecode of mybatis the register(Class ..) methods do some reflection magic and then call the regular register(TypeHandler<?> ..) methods. Do we want that reflection magic to happen?", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369547632", "createdAt": "2020-01-22T13:06:53Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0ODE0Mg==", "bodyText": "I'll see whether this works also and if so, register the instantiated typehandlers ...", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369548142", "createdAt": "2020-01-22T13:08:03Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU2NTc1NQ==", "bodyText": "Works fine. I switched to the registration with instantiated handlers ...", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369565755", "createdAt": "2020-01-22T13:44:13Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-core/src/main/java/pro/taskana/impl/TaskanaEngineImpl.java", "diffHunk": "@@ -232,6 +234,9 @@ protected SqlSessionManager createSqlSessionManager() {\n           e.getCause());\n     }\n \n+    // register type handlers\n+    configuration.getTypeHandlerRegistry().register(MapTypeHandler.class);\n+    configuration.getTypeHandlerRegistry().register(Instant.class, InstantTypeHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzNjkxNg=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4Mzk5MTQ1OnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/test/java/acceptance/persistence/UpdateObjectsUseUtcTimeStampsAccTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo0NjozN1rOFga3SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzowMzo1MVrOFgbUNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzODg4OQ==", "bodyText": "Since the timestamp behaviour should be done globally, do we need specific (complicated) test cases like this?\nCan't we just do it with one entity?", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369538889", "createdAt": "2020-01-22T12:46:37Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/test/java/acceptance/persistence/UpdateObjectsUseUtcTimeStampsAccTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package acceptance.persistence;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import acceptance.AbstractAccTest;\n+import java.sql.SQLException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.TimeZone;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.Classification;\n+import pro.taskana.ClassificationService;\n+import pro.taskana.JobService;\n+import pro.taskana.Task;\n+import pro.taskana.TaskService;\n+import pro.taskana.Workbasket;\n+import pro.taskana.WorkbasketAccessItem;\n+import pro.taskana.WorkbasketService;\n+import pro.taskana.WorkbasketType;\n+import pro.taskana.exceptions.AttachmentPersistenceException;\n+import pro.taskana.exceptions.ClassificationAlreadyExistException;\n+import pro.taskana.exceptions.ClassificationNotFoundException;\n+import pro.taskana.exceptions.ConcurrencyException;\n+import pro.taskana.exceptions.DomainNotFoundException;\n+import pro.taskana.exceptions.InvalidArgumentException;\n+import pro.taskana.exceptions.InvalidWorkbasketException;\n+import pro.taskana.exceptions.NotAuthorizedException;\n+import pro.taskana.exceptions.TaskAlreadyExistException;\n+import pro.taskana.exceptions.TaskNotFoundException;\n+import pro.taskana.exceptions.WorkbasketAlreadyExistException;\n+import pro.taskana.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.impl.JobServiceImpl;\n+import pro.taskana.impl.TaskImpl;\n+import pro.taskana.jobs.ScheduledJob;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+\n+/** Acceptance test for access to timestamps from different timezones. */\n+@ExtendWith(JaasExtension.class)\n+public class UpdateObjectsUseUtcTimeStampsAccTest extends AbstractAccTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NDEzNw==", "bodyText": "This testcase was created when we had to annotate each individual timestamp field.\nHowever, I think I doesn't hurt to test the timestamps on all persistent objects...", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369544137", "createdAt": "2020-01-22T12:58:57Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-core/src/test/java/acceptance/persistence/UpdateObjectsUseUtcTimeStampsAccTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package acceptance.persistence;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import acceptance.AbstractAccTest;\n+import java.sql.SQLException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.TimeZone;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.Classification;\n+import pro.taskana.ClassificationService;\n+import pro.taskana.JobService;\n+import pro.taskana.Task;\n+import pro.taskana.TaskService;\n+import pro.taskana.Workbasket;\n+import pro.taskana.WorkbasketAccessItem;\n+import pro.taskana.WorkbasketService;\n+import pro.taskana.WorkbasketType;\n+import pro.taskana.exceptions.AttachmentPersistenceException;\n+import pro.taskana.exceptions.ClassificationAlreadyExistException;\n+import pro.taskana.exceptions.ClassificationNotFoundException;\n+import pro.taskana.exceptions.ConcurrencyException;\n+import pro.taskana.exceptions.DomainNotFoundException;\n+import pro.taskana.exceptions.InvalidArgumentException;\n+import pro.taskana.exceptions.InvalidWorkbasketException;\n+import pro.taskana.exceptions.NotAuthorizedException;\n+import pro.taskana.exceptions.TaskAlreadyExistException;\n+import pro.taskana.exceptions.TaskNotFoundException;\n+import pro.taskana.exceptions.WorkbasketAlreadyExistException;\n+import pro.taskana.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.impl.JobServiceImpl;\n+import pro.taskana.impl.TaskImpl;\n+import pro.taskana.jobs.ScheduledJob;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+\n+/** Acceptance test for access to timestamps from different timezones. */\n+@ExtendWith(JaasExtension.class)\n+public class UpdateObjectsUseUtcTimeStampsAccTest extends AbstractAccTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzODg4OQ=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NjI5Mw==", "bodyText": "ok", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369546293", "createdAt": "2020-01-22T13:03:51Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/test/java/acceptance/persistence/UpdateObjectsUseUtcTimeStampsAccTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package acceptance.persistence;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import acceptance.AbstractAccTest;\n+import java.sql.SQLException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.TimeZone;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.Classification;\n+import pro.taskana.ClassificationService;\n+import pro.taskana.JobService;\n+import pro.taskana.Task;\n+import pro.taskana.TaskService;\n+import pro.taskana.Workbasket;\n+import pro.taskana.WorkbasketAccessItem;\n+import pro.taskana.WorkbasketService;\n+import pro.taskana.WorkbasketType;\n+import pro.taskana.exceptions.AttachmentPersistenceException;\n+import pro.taskana.exceptions.ClassificationAlreadyExistException;\n+import pro.taskana.exceptions.ClassificationNotFoundException;\n+import pro.taskana.exceptions.ConcurrencyException;\n+import pro.taskana.exceptions.DomainNotFoundException;\n+import pro.taskana.exceptions.InvalidArgumentException;\n+import pro.taskana.exceptions.InvalidWorkbasketException;\n+import pro.taskana.exceptions.NotAuthorizedException;\n+import pro.taskana.exceptions.TaskAlreadyExistException;\n+import pro.taskana.exceptions.TaskNotFoundException;\n+import pro.taskana.exceptions.WorkbasketAlreadyExistException;\n+import pro.taskana.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.impl.JobServiceImpl;\n+import pro.taskana.impl.TaskImpl;\n+import pro.taskana.jobs.ScheduledJob;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+\n+/** Acceptance test for access to timestamps from different timezones. */\n+@ExtendWith(JaasExtension.class)\n+public class UpdateObjectsUseUtcTimeStampsAccTest extends AbstractAccTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzODg4OQ=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4Mzk5NTM4OnYy", "diffSide": "RIGHT", "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo0ODowM1rOFga5nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzozNzowOFrOFgcRVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw==", "bodyText": "ZonedDateTime.now()", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369539487", "createdAt": "2020-01-22T12:48:03Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0Mzc5MA==", "bodyText": "ZonedDateTime.now() gives me the actual time in the current time zone, not in the UTC time zone. If I invoke ZonedDateTime.now() and print it, I see 2020-01-22 13:53:05, which is the current moment in the local time zone.\nIf I print at the same time the output of Instant.now().atZone(ZoneId.of(\"UTC\")), I see 2020-01-22 12:53:05 which is the current moment in UTC time zone.", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369543790", "createdAt": "2020-01-22T12:58:14Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0ODIzMQ==", "bodyText": "okay. Why did you use ZonedDateTime.now() in the SqlReplacerTests then? :)", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369548231", "createdAt": "2020-01-22T13:08:15Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0ODc0Mg==", "bodyText": "I was a little confused, because the change from LocalDateTime -> ZonedDateTime was not consistent. That's why I am asking \ud83d\udc4d", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369548742", "createdAt": "2020-01-22T13:09:24Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU1NzMyNg==", "bodyText": "In the SqlReplacerTests, it doesn't matter if you are using local time or utc time. These times are not persisted, only the correct matching and correct relative calculations are checked. However, I can change this in the SqlReplacer, too.", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369557326", "createdAt": "2020-01-22T13:27:33Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU1NzYzNQ==", "bodyText": "wanted to say \" ... change this in the SqlReplacerTests, too\"", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369557635", "createdAt": "2020-01-22T13:28:13Z", "author": {"login": "BerndBreier"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU2MTk0MA==", "bodyText": "If it doesn't matter then I dont care.", "url": "https://github.com/Taskana/taskana/pull/857#discussion_r369561940", "createdAt": "2020-01-22T13:37:08Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-data/src/main/java/pro/taskana/sampledata/SampleDataGenerator.java", "diffHunk": "@@ -33,18 +35,18 @@\n   private static final String CACHED_DROPDB = \"DROPDB\";\n   private static HashMap<String, List<String>> cachedScripts = new HashMap<>();\n   private final DataSource dataSource;\n-  private final LocalDateTime now;\n+  private final ZonedDateTime now;\n   /**\n    * This value cannot be automatically obtained by connection.getSchema(), because setting not yet\n    * existing schema will result into an SQL Exception.\n    */\n   private final String schema;\n \n   public SampleDataGenerator(DataSource dataSource, String schema) {\n-    this(dataSource, schema, LocalDateTime.now());\n+    this(dataSource, schema, Instant.now().atZone(ZoneId.of(\"UTC\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUzOTQ4Nw=="}, "originalCommit": {"oid": "9df1fbeb1db00bc4d05455e382a8cec554f9ac96"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4368, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}