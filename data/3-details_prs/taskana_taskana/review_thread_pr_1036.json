{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNDQwMzEx", "number": 1036, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzo1MToxM1rOD3g8Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMTo1MFrOD3hkGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTM3OTkxOnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/security/CurrentUserContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzo1MToxM1rOGNzhpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMDo0NTo1M1rOGN5UYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyODg3MQ==", "bodyText": "The new Method is called getAccesIds but is returning groups?", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417128871", "createdAt": "2020-04-29T07:51:13Z", "author": {"login": "sfrevel"}, "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/security/CurrentUserContext.java", "diffHunk": "@@ -48,34 +51,23 @@ public static String getUserid() {\n   public static List<String> getGroupIds() {\n     Subject subject = Subject.getSubject(AccessController.getContext());\n     LOGGER.trace(\"Subject of caller: {}\", subject);\n-    List<String> groupIds = new ArrayList<>();\n     if (subject != null) {\n       Set<Group> groups = subject.getPrincipals(Group.class);\n       LOGGER.trace(\"Public groups of caller: {}\", groups);\n-      for (Principal group : groups) {\n-        String groupNameFound = group.getName();\n-        String groupNameReturned = groupNameFound;\n-        if (shouldUseLowerCaseForAccessIds() && groupNameFound != null) {\n-          groupNameReturned = groupNameFound.toLowerCase();\n-        }\n-        LOGGER.trace(\n-            \"Found group id {}. Returning group Id: {}\", groupNameFound, groupNameReturned);\n-        groupIds.add(groupNameReturned);\n-      }\n-      return groupIds;\n+      return groups.stream()\n+          .map(Principal::getName)\n+          .filter(Objects::nonNull)\n+          .map(CurrentUserContext::convertAccessId)\n+          .collect(Collectors.toList());\n     }\n-    LOGGER.trace(\"No groupids found in subject!\");\n-    return groupIds;\n+    LOGGER.trace(\"No groupIds found in subject!\");\n+    return Collections.emptyList();\n   }\n \n   public static List<String> getAccessIds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyMzc3Nw==", "bodyText": "done", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417223777", "createdAt": "2020-04-29T10:45:53Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/security/CurrentUserContext.java", "diffHunk": "@@ -48,34 +51,23 @@ public static String getUserid() {\n   public static List<String> getGroupIds() {\n     Subject subject = Subject.getSubject(AccessController.getContext());\n     LOGGER.trace(\"Subject of caller: {}\", subject);\n-    List<String> groupIds = new ArrayList<>();\n     if (subject != null) {\n       Set<Group> groups = subject.getPrincipals(Group.class);\n       LOGGER.trace(\"Public groups of caller: {}\", groups);\n-      for (Principal group : groups) {\n-        String groupNameFound = group.getName();\n-        String groupNameReturned = groupNameFound;\n-        if (shouldUseLowerCaseForAccessIds() && groupNameFound != null) {\n-          groupNameReturned = groupNameFound.toLowerCase();\n-        }\n-        LOGGER.trace(\n-            \"Found group id {}. Returning group Id: {}\", groupNameFound, groupNameReturned);\n-        groupIds.add(groupNameReturned);\n-      }\n-      return groupIds;\n+      return groups.stream()\n+          .map(Principal::getName)\n+          .filter(Objects::nonNull)\n+          .map(CurrentUserContext::convertAccessId)\n+          .collect(Collectors.toList());\n     }\n-    LOGGER.trace(\"No groupids found in subject!\");\n-    return groupIds;\n+    LOGGER.trace(\"No groupIds found in subject!\");\n+    return Collections.emptyList();\n   }\n \n   public static List<String> getAccessIds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyODg3MQ=="}, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQxMTIwOnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODowMDoyOFrOGNz1Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMDoxNzo1MFrOGN4cXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzg1OA==", "bodyText": "could we use childrenMap instead of map", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417133858", "createdAt": "2020-04-29T08:00:28Z", "author": {"login": "sfrevel"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwOTQzNg==", "bodyText": "done", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417209436", "createdAt": "2020-04-29T10:17:50Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzg1OA=="}, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQxOTk4OnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODowMjo1NlrOGNz6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMDoxODo0MlrOGN4d_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTE3NQ==", "bodyText": "could we use dynamicNodes or children instead of collect?", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417135175", "createdAt": "2020-04-29T08:02:56Z", "author": {"login": "sfrevel"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {\n+    nodes.forEach(\n+        node -> {\n+          if (node instanceof DynamicContainer) {\n+            DynamicContainer container = (DynamicContainer) node;\n+            List<DynamicNode> collect = container.getChildren().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwOTg1NA==", "bodyText": "done", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417209854", "createdAt": "2020-04-29T10:18:42Z", "author": {"login": "mustaphazorgati"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {\n+    nodes.forEach(\n+        node -> {\n+          if (node instanceof DynamicContainer) {\n+            DynamicContainer container = (DynamicContainer) node;\n+            List<DynamicNode> collect = container.getChildren().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTE3NQ=="}, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ3OTI5OnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMToxMVrOGN0fcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMToxMVrOGN0fcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDY5MQ==", "bodyText": "So this test has to be extracted from this class, because the target of TestExecutionListeners annotation is ElementType.Type?", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417144691", "createdAt": "2020-04-29T08:21:11Z", "author": {"login": "sfrevel"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "diffHunk": "@@ -58,33 +80,649 @@ void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_BeforeEach() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n+  // endregion\n+\n+  // region JaasExtension#interceptAfterEachMethod\n+\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @AfterEach\n+  void should_SetJaasSubject_When_AnnotationExists_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"aftereach\");\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @WithAccessId(user = \"afterach2\")\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptAfterAllMethod\n+\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @AfterAll\n+  static void should_SetJaasSubject_When_AnnotationExists_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"afterall\");\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @WithAccessId(user = \"afterall2\")\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestMethod\n+\n+  @Test\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n   @WithAccessId(user = \"user\")\n   @Test\n   void should_SetJaasSubject_When_AnnotationExists_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).isEmpty();\n+  }\n+\n+  @WithAccessId(\n+      user = \"user\",\n+      groups = {\"hans\", \"peter\"})\n+  @Test\n+  void should_SetJaasSubjectWithGroups_When_AnnotationExistsWithGroups_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).containsOnly(\"hans\", \"peter\");\n+  }\n+\n+  @WithAccessId(user = \"user\")\n+  @Test\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotInjectParameter_When_ParameterIsPresent_On_Test(WithAccessId accessId) {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n   }\n \n   @WithAccessId(user = \"user\")\n   @WithAccessId(user = \"user2\")\n   @Test\n-  @Disabled(\"can we make this work somehow?\")\n-  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_Test() {\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_ThrowException_When_MultipleAnnotationsExist_On_Test() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ4MTg1OnYy", "diffSide": "RIGHT", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMTo1MFrOGN0g_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyMTo1MFrOGN0g_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NTA4NQ==", "bodyText": "see comment on should_ThrowException_When_MultipleAnnotationsExist_On_Test", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417145085", "createdAt": "2020-04-29T08:21:50Z", "author": {"login": "sfrevel"}, "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "diffHunk": "@@ -58,33 +80,649 @@ void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_BeforeEach() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n+  // endregion\n+\n+  // region JaasExtension#interceptAfterEachMethod\n+\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @AfterEach\n+  void should_SetJaasSubject_When_AnnotationExists_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"aftereach\");\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @WithAccessId(user = \"afterach2\")\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptAfterAllMethod\n+\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @AfterAll\n+  static void should_SetJaasSubject_When_AnnotationExists_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"afterall\");\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @WithAccessId(user = \"afterall2\")\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestMethod\n+\n+  @Test\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n   @WithAccessId(user = \"user\")\n   @Test\n   void should_SetJaasSubject_When_AnnotationExists_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).isEmpty();\n+  }\n+\n+  @WithAccessId(\n+      user = \"user\",\n+      groups = {\"hans\", \"peter\"})\n+  @Test\n+  void should_SetJaasSubjectWithGroups_When_AnnotationExistsWithGroups_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).containsOnly(\"hans\", \"peter\");\n+  }\n+\n+  @WithAccessId(user = \"user\")\n+  @Test\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotInjectParameter_When_ParameterIsPresent_On_Test(WithAccessId accessId) {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n   }\n \n   @WithAccessId(user = \"user\")\n   @WithAccessId(user = \"user2\")\n   @Test\n-  @Disabled(\"can we make this work somehow?\")\n-  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_Test() {\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_ThrowException_When_MultipleAnnotationsExist_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n-  @Test\n-  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+  // endregion\n+\n+  // region JaasExtension#interceptTestFactory\n+\n+  @TestFactory\n+  List<DynamicTest> should_NotSetJaasSubject_When_AnnotationIsMissing_On_TestFactory() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+    return Collections.emptyList();\n+  }\n+\n+  @WithAccessId(user = \"testfactory\")\n+  @TestFactory\n+  List<DynamicTest> should_SetJaasSubject_When_AnnotationExists_On_TestFactory() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"testfactory\");\n+    return Collections.emptyList();\n+  }\n+\n+  @WithAccessId(user = \"testfactory1\")\n+  @WithAccessId(user = \"testfactory2\")\n+  @TestFactory\n+  List<DynamicTest>\n+      should_SetJaasSubjectFromFirstAnnotation_When_MultipleAnnotationsExists_On_TestFactory() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"testfactory1\");\n+    return Collections.emptyList();\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestTemplateMethod\n+\n+  @TestTemplate\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotFindContextProvider_When_AnnotationIsMissing_On_TestTemplate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5"}, "originalPosition": 196}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4351, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}