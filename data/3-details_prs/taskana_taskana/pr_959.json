{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyOTE5MTMz", "number": 959, "title": "TSK-1143 UpdateTask with Planned sometimes fails", "bodyText": "Sonar is green: https://sonarcloud.io/dashboard?branch=TSK-1143&id=BerndBreier_taskana", "createdAt": "2020-03-03T12:19:18Z", "url": "https://github.com/Taskana/taskana/pull/959", "merged": true, "mergeCommit": {"oid": "5126781c7ab48f786a9a435ed610ce0e74c6d0ee"}, "closed": true, "closedAt": "2020-03-19T13:43:18Z", "author": {"login": "BerndBreier"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKBbYKABqjMwOTE5Mzk1MTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPMGeogFqTM3NzcyODAxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa67e03b2c5c582aeb0b67f4093b927f4a4566d1", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/fa67e03b2c5c582aeb0b67f4093b927f4a4566d1", "committedDate": "2020-03-03T11:58:50Z", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, "afterCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/210fe992514065931a6e222e8a00ee0e1ebeed09", "committedDate": "2020-03-03T12:23:08Z", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzYyNzc0", "url": "https://github.com/Taskana/taskana/pull/959#pullrequestreview-368762774", "createdAt": "2020-03-04T13:10:45Z", "commit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxMDo0NVrOFxsnEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzo1NDo1OFrOFxuHew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NTQ0Mw==", "bodyText": "setting planned twice does not make sense, does it?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387655443", "createdAt": "2020-03-04T13:10:45Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +336,21 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()\n+      throws NotAuthorizedException, TaskNotFoundException, ClassificationNotFoundException,\n+          InvalidArgumentException, InvalidStateException, ConcurrencyException,\n+          AttachmentPersistenceException {\n+    TaskService taskService = taskanaEngine.getTaskService();\n+    Task task = taskService.getTask(\"TKI:000000000000000000000000000000000030\");\n+    task.setPlanned(Instant.now());\n+    task.setPlanned(getInstant(\"2020-04-21T07:00:00\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTM1OA==", "bodyText": "Can we use a MessageFormatter here?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387659358", "createdAt": "2020-03-04T13:17:46Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls,\n+      BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task, Instant now)\n+      throws InvalidArgumentException {\n+    List<Attachment> attachments = task.getAttachments();\n+    if (attachments != null) {\n+      for (Attachment attachment : attachments) {\n+        AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+        attachmentImpl.setId(IdGenerator.generateWithPrefix(ID_PREFIX_ATTACHMENT));\n+        attachmentImpl.setTaskId(task.getId());\n+        attachmentImpl.setCreated(now);\n+        attachmentImpl.setModified(now);\n+        ObjectReference objRef = attachmentImpl.getObjectReference();\n+        validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n+        attachmentMapper.insert(attachmentImpl);\n+      }\n+    }\n+  }\n+\n+  void deleteRemovedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to deleteRemovedAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+\n+    final List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<String> newAttachmentIds = new ArrayList<>();\n+    if (newAttachments != null && !newAttachments.isEmpty()) {\n+      newAttachmentIds =\n+          newAttachments.stream().map(Attachment::getId).collect(Collectors.toList());\n+    }\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (oldAttachments != null && !oldAttachments.isEmpty()) {\n+      final List<String> newAttIds = newAttachmentIds;\n+      oldAttachments.forEach(\n+          a -> {\n+            if (!newAttIds.contains(a.getId())) {\n+              attachmentMapper.deleteAttachment(a.getId());\n+              LOGGER.debug(\n+                  \"TaskService.updateTask() for TaskId={} DELETED an Attachment={}.\",\n+                  newTaskImpl.getId(),\n+                  a);\n+            }\n+          });\n+    }\n+    LOGGER.debug(\"exit from deleteRemovedAttachmentsOnTaskUpdate()\");\n+  }\n+\n+  void insertNewAttachmentOnTaskUpdate(TaskImpl newTaskImpl, Attachment attachment)\n+      throws AttachmentPersistenceException {\n+    LOGGER.debug(\"entry to insertNewAttachmentOnTaskUpdate()\");\n+    AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+    initAttachment(attachmentImpl, newTaskImpl);\n+\n+    try {\n+      attachmentMapper.insert(attachmentImpl);\n+      LOGGER.debug(\n+          \"TaskService.updateTask() for TaskId={} INSERTED an Attachment={}.\",\n+          newTaskImpl.getId(),\n+          attachmentImpl);\n+    } catch (PersistenceException e) {\n+      throw new AttachmentPersistenceException(\n+          \"Cannot insert the Attachement \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTUxMQ==", "bodyText": "Why don't we call initAttachment()?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387659511", "createdAt": "2020-03-04T13:18:05Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls,\n+      BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task, Instant now)\n+      throws InvalidArgumentException {\n+    List<Attachment> attachments = task.getAttachments();\n+    if (attachments != null) {\n+      for (Attachment attachment : attachments) {\n+        AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+        attachmentImpl.setId(IdGenerator.generateWithPrefix(ID_PREFIX_ATTACHMENT));\n+        attachmentImpl.setTaskId(task.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MTcxNQ==", "bodyText": "why is this one public while the other are not?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387661715", "createdAt": "2020-03-04T13:22:12Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDkxMw==", "bodyText": "This does not make sense. If we can generalize the validation, then it should be part of ObjectReference instead of AttachmentHandler. If it is specific to task or attachment, it has to be placed in the corresponding service.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387664913", "createdAt": "2020-03-04T13:27:56Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1587,86 +1496,11 @@ private void validateCustomFields(Map<String, String> customFieldsToUpdate)\n         .list();\n   }\n \n-  private void validateObjectReference(ObjectReference objRef, String objRefType, String objName)\n-      throws InvalidArgumentException {\n-    LOGGER.debug(\"entry to validateObjectReference()\");\n-    // check that all values in the ObjectReference are set correctly\n-    if (objRef == null) {\n-      throw new InvalidArgumentException(objRefType + \" of \" + objName + \" must not be null\");\n-    } else if (objRef.getCompany() == null || objRef.getCompany().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Company of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystem() == null || objRef.getSystem().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"System of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystemInstance() == null || objRef.getSystemInstance().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"SystemInstance of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getType() == null || objRef.getType().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Type of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getValue() == null || objRef.getValue().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Value of\" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    }\n-    LOGGER.debug(\"exit from validateObjectReference()\");\n-  }\n-\n-  private PrioDurationHolder handleAttachments(TaskImpl task) throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"entry to handleAttachments(task = {})\", task);\n-    }\n-\n-    List<Attachment> attachments = task.getAttachments();\n-    if (attachments == null || attachments.isEmpty()) {\n-      return new PrioDurationHolder(null, Integer.MIN_VALUE);\n-    }\n-\n-    PrioDurationHolder actualPrioDuration = new PrioDurationHolder(MAX_DURATION, Integer.MIN_VALUE);\n-\n-    Iterator<Attachment> i = attachments.iterator();\n-    while (i.hasNext()) {\n-      Attachment attachment = i.next();\n-      if (attachment == null) {\n-        i.remove();\n-      } else {\n-        actualPrioDuration = handleNonNullAttachment(actualPrioDuration, attachment);\n-      }\n-    }\n-    if (MAX_DURATION.equals(actualPrioDuration.getLeft())) {\n-      actualPrioDuration = new PrioDurationHolder(null, actualPrioDuration.getRight());\n-    }\n-\n-    LOGGER.debug(\"exit from handleAttachments(), returning {}\", actualPrioDuration);\n-    return actualPrioDuration;\n-  }\n-\n-  private PrioDurationHolder handleNonNullAttachment(\n-      PrioDurationHolder actualPrioDuration, Attachment attachment)\n-      throws InvalidArgumentException {\n-    ObjectReference objRef = attachment.getObjectReference();\n-    validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n-    if (attachment.getClassificationSummary() == null) {\n-      throw new InvalidArgumentException(\n-          \"Classification of attachment \" + attachment + \" must not be null\");\n-    } else {\n-      ClassificationSummary classificationSummary = attachment.getClassificationSummary();\n-      if (classificationSummary != null) {\n-        actualPrioDuration =\n-            getNewPrioDuration(\n-                actualPrioDuration,\n-                classificationSummary.getPriority(),\n-                classificationSummary.getServiceLevel());\n-      }\n-    }\n-    return actualPrioDuration;\n-  }\n-\n-  private void standardUpdateActions(\n-      TaskImpl oldTaskImpl, TaskImpl newTaskImpl, PrioDurationHolder prioDurationFromAttachments)\n-      throws InvalidArgumentException, ConcurrencyException, ClassificationNotFoundException,\n-          InvalidStateException {\n-    validateObjectReference(newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n+  private void standardUpdateActions(TaskImpl oldTaskImpl, TaskImpl newTaskImpl)\n+      throws InvalidArgumentException, ConcurrencyException, InvalidStateException,\n+          AttachmentPersistenceException, ClassificationNotFoundException {\n+    attachmentHandler.validateObjectReference(\n+        newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTg3OA==", "bodyText": "why don't just check modified? It doesn't make sense to me to check the rest as well...", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387665878", "createdAt": "2020-03-04T13:29:41Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1587,86 +1496,11 @@ private void validateCustomFields(Map<String, String> customFieldsToUpdate)\n         .list();\n   }\n \n-  private void validateObjectReference(ObjectReference objRef, String objRefType, String objName)\n-      throws InvalidArgumentException {\n-    LOGGER.debug(\"entry to validateObjectReference()\");\n-    // check that all values in the ObjectReference are set correctly\n-    if (objRef == null) {\n-      throw new InvalidArgumentException(objRefType + \" of \" + objName + \" must not be null\");\n-    } else if (objRef.getCompany() == null || objRef.getCompany().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Company of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystem() == null || objRef.getSystem().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"System of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystemInstance() == null || objRef.getSystemInstance().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"SystemInstance of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getType() == null || objRef.getType().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Type of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getValue() == null || objRef.getValue().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Value of\" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    }\n-    LOGGER.debug(\"exit from validateObjectReference()\");\n-  }\n-\n-  private PrioDurationHolder handleAttachments(TaskImpl task) throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"entry to handleAttachments(task = {})\", task);\n-    }\n-\n-    List<Attachment> attachments = task.getAttachments();\n-    if (attachments == null || attachments.isEmpty()) {\n-      return new PrioDurationHolder(null, Integer.MIN_VALUE);\n-    }\n-\n-    PrioDurationHolder actualPrioDuration = new PrioDurationHolder(MAX_DURATION, Integer.MIN_VALUE);\n-\n-    Iterator<Attachment> i = attachments.iterator();\n-    while (i.hasNext()) {\n-      Attachment attachment = i.next();\n-      if (attachment == null) {\n-        i.remove();\n-      } else {\n-        actualPrioDuration = handleNonNullAttachment(actualPrioDuration, attachment);\n-      }\n-    }\n-    if (MAX_DURATION.equals(actualPrioDuration.getLeft())) {\n-      actualPrioDuration = new PrioDurationHolder(null, actualPrioDuration.getRight());\n-    }\n-\n-    LOGGER.debug(\"exit from handleAttachments(), returning {}\", actualPrioDuration);\n-    return actualPrioDuration;\n-  }\n-\n-  private PrioDurationHolder handleNonNullAttachment(\n-      PrioDurationHolder actualPrioDuration, Attachment attachment)\n-      throws InvalidArgumentException {\n-    ObjectReference objRef = attachment.getObjectReference();\n-    validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n-    if (attachment.getClassificationSummary() == null) {\n-      throw new InvalidArgumentException(\n-          \"Classification of attachment \" + attachment + \" must not be null\");\n-    } else {\n-      ClassificationSummary classificationSummary = attachment.getClassificationSummary();\n-      if (classificationSummary != null) {\n-        actualPrioDuration =\n-            getNewPrioDuration(\n-                actualPrioDuration,\n-                classificationSummary.getPriority(),\n-                classificationSummary.getServiceLevel());\n-      }\n-    }\n-    return actualPrioDuration;\n-  }\n-\n-  private void standardUpdateActions(\n-      TaskImpl oldTaskImpl, TaskImpl newTaskImpl, PrioDurationHolder prioDurationFromAttachments)\n-      throws InvalidArgumentException, ConcurrencyException, ClassificationNotFoundException,\n-          InvalidStateException {\n-    validateObjectReference(newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n+  private void standardUpdateActions(TaskImpl oldTaskImpl, TaskImpl newTaskImpl)\n+      throws InvalidArgumentException, ConcurrencyException, InvalidStateException,\n+          AttachmentPersistenceException, ClassificationNotFoundException {\n+    attachmentHandler.validateObjectReference(\n+        newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n     // TODO: not safe to rely only on different timestamps.\n     // With fast execution below 1ms there will be no concurrencyException\n     if (oldTaskImpl.getModified() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3ODg1Mw==", "bodyText": "I don't like to have this hidden in \"standardUpdateActions\".", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387678853", "createdAt": "2020-03-04T13:52:47Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1694,6 +1528,16 @@ private void standardUpdateActions(\n       newTaskImpl.setPlanned(oldTaskImpl.getPlanned());\n     }\n \n+    if (newTaskImpl.getClassificationSummary() == null) {\n+      newTaskImpl.setClassificationSummary(oldTaskImpl.getClassificationSummary());\n+    }\n+\n+    attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3OTM1OQ==", "bodyText": "Does this handle setPlanned as well. If it does, we probably don't need to initialize it in line 1528.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387679359", "createdAt": "2020-03-04T13:53:37Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1694,6 +1528,16 @@ private void standardUpdateActions(\n       newTaskImpl.setPlanned(oldTaskImpl.getPlanned());\n     }\n \n+    if (newTaskImpl.getClassificationSummary() == null) {\n+      newTaskImpl.setClassificationSummary(oldTaskImpl.getClassificationSummary());\n+    }\n+\n+    attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+\n+    updateClassificationSummary(newTaskImpl, oldTaskImpl);\n+\n+    newTaskImpl = serviceLevelHandler.updatePrioPlannedDueOfTask(newTaskImpl, oldTaskImpl, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MDEyMw==", "bodyText": "by the way: should attachment and tasks have the same modification timestamp? It would probably nice, wouldn't it?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387680123", "createdAt": "2020-03-04T13:54:58Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1706,393 +1550,24 @@ private void standardUpdateActions(\n           String.format(TASK_WITH_ID_IS_NOT_READY, oldTaskImpl.getId(), oldTaskImpl.getState()));\n     }\n \n-    updateClassificationRelatedProperties(oldTaskImpl, newTaskImpl, prioDurationFromAttachments);\n-\n     newTaskImpl.setModified(Instant.now());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09"}, "originalPosition": 454}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/210fe992514065931a6e222e8a00ee0e1ebeed09", "committedDate": "2020-03-03T12:23:08Z", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, "afterCommit": {"oid": "20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "committedDate": "2020-03-10T13:34:59Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "committedDate": "2020-03-10T13:34:59Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, "afterCommit": {"oid": "287226c31c38cb20e9aa488a82ff4cee23aab123", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/287226c31c38cb20e9aa488a82ff4cee23aab123", "committedDate": "2020-03-11T07:21:24Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "287226c31c38cb20e9aa488a82ff4cee23aab123", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/287226c31c38cb20e9aa488a82ff4cee23aab123", "committedDate": "2020-03-11T07:21:24Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, "afterCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/24bdd185806073bf75631ac0fb11135fb7bc5640", "committedDate": "2020-03-11T07:45:52Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MDExNjIx", "url": "https://github.com/Taskana/taskana/pull/959#pullrequestreview-375011621", "createdAt": "2020-03-16T08:51:49Z", "commit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo1MTo0OVrOF2qdRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMToyMDoxN1rOF2vj7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzA0Nw==", "bodyText": "Shouldn't we move this test to the service level tests to have them all together in one file?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392863047", "createdAt": "2020-03-16T08:51:49Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +342,20 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzM4Mw==", "bodyText": "I think most of the Exceptions will no longer be thrown by this test. Please verify.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392863383", "createdAt": "2020-03-16T08:52:30Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +342,20 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()\n+      throws NotAuthorizedException, TaskNotFoundException, ClassificationNotFoundException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NTM0MA==", "bodyText": "Please validate the throws statement. It contains too many Exceptions, which will no longer be thrown by this test.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392865340", "createdAt": "2020-03-16T08:56:19Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -83,26 +83,32 @@ void testThrowsExceptionIfMandatoryPrimaryObjectReferenceIsNotSetOrIncomplete()\n     assertThatThrownBy(() -> taskService.updateTask(task))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzI5Nw==", "bodyText": "Please validate the throws declarations in the entire file.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392867297", "createdAt": "2020-03-16T09:00:08Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzQxNA==", "bodyText": "This is not used anywhere.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392867414", "createdAt": "2020-03-16T09:00:22Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2ODAzNw==", "bodyText": "Please correct the uppercase H.\nIs this not noticed by checkstyle?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392868037", "createdAt": "2020-03-16T09:01:37Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    // test bulk operation setPlanned...\n+    BulkOperationResults<String, TaskanaException> results =\n+        taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, Arrays.asList(taskId));\n+    Task task = taskService.getTask(taskId);\n+    assertThat(results.containsErrors()).isFalse();\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWitHTaskUpdate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MDk1Mw==", "bodyText": "I'm a bit surprised that this test has no side effect as it changes all test data. Are you sure that we do not have any dependencies to the other tests?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392870953", "createdAt": "2020-03-16T09:07:39Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    // test bulk operation setPlanned...\n+    BulkOperationResults<String, TaskanaException> results =\n+        taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, Arrays.asList(taskId));\n+    Task task = taskService.getTask(taskId);\n+    assertThat(results.containsErrors()).isFalse();\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWitHTaskUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    Task task = taskService.getTask(taskId);\n+    // test update of planned date via updateTask()\n+    task.setPlanned(task.getPlanned().plus(Duration.ofDays(3)));\n+    task = taskService.updateTask(task);\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetDuePropertyOnSingleTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    Task task = taskService.getTask(taskId);\n+\n+    // test update of due that fails\n+    task.setDue(planned.plus(Duration.ofDays(8)));\n+    Task finalTask = task;\n+    assertThatThrownBy(\n+        () -> {\n+            taskService.updateTask(finalTask);\n+        })\n+        .isInstanceOf(InvalidArgumentException.class);\n+\n+    // update due and planned as expected.\n+    task = taskService.getTask(taskId);\n+    task.setDue(planned.plus(Duration.ofDays(3)));\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    task.setPlanned(task.getDue().plus(Duration.ofDays(-1)));\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+\n+    // update due and planned as expected.\n+    task = taskService.getTask(taskId);\n+    task.setDue(planned.plus(Duration.ofDays(3)));\n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskUpdateWithNulls()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    final Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    Task task = taskService.getTask(taskId);\n+    \n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setDue(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setPlanned(planned.plus(Duration.ofDays(13)));\n+    task.setDue(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setDue(planned.plus(Duration.ofDays(13)));\n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(13)));\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnAllTasks()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxNDkxOQ==", "bodyText": "Do we need the distinction between creation and update? Or could we at least use the same insertion method?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392914919", "createdAt": "2020-03-16T10:28:01Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package pro.taskana.task.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls, BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw==", "bodyText": "This is some kind of precondition checking, isn't it? So we could move it even before \"openConnection\"?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392922763", "createdAt": "2020-03-16T10:37:18Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -399,18 +389,20 @@ public Attachment newAttachment() {\n   @Override\n   public Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n-          ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException {\n+          NotAuthorizedException, AttachmentPersistenceException, InvalidStateException,\n+          ClassificationNotFoundException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\"entry to updateTask(task = {}, userId = {})\", task, userId);\n     TaskImpl newTaskImpl = (TaskImpl) task;\n     TaskImpl oldTaskImpl;\n     try {\n       taskanaEngine.openConnection();\n       oldTaskImpl = (TaskImpl) getTask(newTaskImpl.getId());\n-      PrioDurationHolder prioDurationFromAttachments =\n-          handleAttachmentsOnTaskUpdate(oldTaskImpl, newTaskImpl);\n-      standardUpdateActions(oldTaskImpl, newTaskImpl, prioDurationFromAttachments);\n+\n+      newTaskImpl = checkConcurrencyAndSetModified(newTaskImpl, oldTaskImpl);\n+\n+      attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+      standardUpdateActions(oldTaskImpl, newTaskImpl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyNjUxNA==", "bodyText": "Ok, just saw that we need the old task impl for some checks. But maybe we could still extract the preconditions (e.g. check that no information is changed that must not be changed)? From my point of view this would improve the maintainability.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392926514", "createdAt": "2020-03-16T10:41:24Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -399,18 +389,20 @@ public Attachment newAttachment() {\n   @Override\n   public Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n-          ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException {\n+          NotAuthorizedException, AttachmentPersistenceException, InvalidStateException,\n+          ClassificationNotFoundException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\"entry to updateTask(task = {}, userId = {})\", task, userId);\n     TaskImpl newTaskImpl = (TaskImpl) task;\n     TaskImpl oldTaskImpl;\n     try {\n       taskanaEngine.openConnection();\n       oldTaskImpl = (TaskImpl) getTask(newTaskImpl.getId());\n-      PrioDurationHolder prioDurationFromAttachments =\n-          handleAttachmentsOnTaskUpdate(oldTaskImpl, newTaskImpl);\n-      standardUpdateActions(oldTaskImpl, newTaskImpl, prioDurationFromAttachments);\n+\n+      newTaskImpl = checkConcurrencyAndSetModified(newTaskImpl, oldTaskImpl);\n+\n+      attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+      standardUpdateActions(oldTaskImpl, newTaskImpl);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw=="}, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTExOQ==", "bodyText": "This should rather be placed in TaskServiceImpl, shouldn't it. It has nothing to do with service levels.\nMaybe we should rename it to getTasks? It does the same as getTask but or multiple tasks.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392935119", "createdAt": "2020-03-16T10:55:05Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -645,10 +637,14 @@ public void forceDeleteTask(String taskId)\n     try {\n       taskanaEngine.openConnection();\n       // use only elements we are authorized for\n-      Pair<List<String>, BulkOperationResults<String, TaskanaException>> resultsPair =\n-          filterForAuthorizedTasks(taskIds);\n+      Pair<List<MinimalTaskSummary>, BulkLog> resultsPair =\n+          serviceLevelHandler.filterTasksForExistenceAndAuthorization(taskIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjQxMA==", "bodyText": "These should already be included in the first result, correct? So we should not query the database again.", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392936410", "createdAt": "2020-03-16T10:57:38Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -658,13 +654,7 @@ public void forceDeleteTask(String taskId)\n           return bulkLog;\n         } else {\n           // check the outcome\n-          List<MinimalTaskSummary> existingMinimalTaskSummaries =\n-              taskMapper.findExistingTasks(taskIds, null);\n-          // add exceptions for non existing tasks\n-          bulkLog.addAllErrors(\n-              serviceLevelHander.addExceptionsForNonExistingTasks(\n-                  taskIds, existingMinimalTaskSummaries));\n-          // add exceptions of all remaining tasks whose owners were not set\n+          existingMinimalTaskSummaries = taskMapper.findExistingTasks(taskIds, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzOTk3MA==", "bodyText": "This is only used from the refresh job, isn't it? Does it need to be public for this?\nWould it be possible to apply our bulk scheme here as well?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392939970", "createdAt": "2020-03-16T11:04:01Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -736,7 +726,8 @@ public void forceDeleteTask(String taskId)\n     return affectedTaskIds;\n   }\n \n-  public void refreshPriorityAndDueDate(String taskId) throws ClassificationNotFoundException {\n+  public void refreshPriorityAndDueDateOnClassificationUpdate(String taskId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MTk1NQ==", "bodyText": "Why is this one public while the other operations are not?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392941955", "createdAt": "2020-03-16T11:07:56Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -66,13 +68,12 @@ public ServiceLevelHandler(\n   // - For each task iterate through all referenced classifications and find minimum ServiceLevel\n   // - collect the results into a map Duration -> List of tasks\n   // - for each duration in this map update due date of all associated tasks\n-  public BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasksImpl(\n-      Instant planned, List<String> argTaskIds) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+  public BulkLog setPlannedPropertyOfTasksImpl(Instant planned, List<String> argTaskIds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NjY2OQ==", "bodyText": "Wouldn't it be nicer to move this to the converter?\nLike:\nnewTaskImpl.setDue(converter.addWorkingDaysToTimestamp(newTaskImpl.getPlanned(), durationPrioHolder.getDuration());\nWhat do you think?", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392946669", "createdAt": "2020-03-16T11:20:17Z", "author": {"login": "holgerhagen"}, "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -82,69 +83,207 @@ public ServiceLevelHandler(\n         findAllInvolvedClassifications(existingTasksAuthorizedFor, attachments);\n     List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n         resolveDurationsInClassifications(allInvolvedClassifications);\n-    Map<Duration, List<TaskDuration>> tasksPerDuration =\n-        getTasksPerDuration(\n+    Map<Duration, List<String>> durationToTaskIdsMap =\n+        getDurationToTaskIdsMap(\n             existingTasksAuthorizedFor, attachments, allInvolvedClassificationsWithDuration);\n-    bulkLog.addAllErrors(updateAffectedTasks(planned, tasksPerDuration));\n+    BulkLog updateResult = updatePlannedPropertyOfAffectedTasks(planned, durationToTaskIdsMap);\n+    bulkLog.addAllErrors(updateResult);\n \n     return bulkLog;\n   }\n \n-  BulkOperationResults<String, TaskanaException> addExceptionsForNonExistingTasks(\n+  BulkLog addExceptionsForNonExistingTasksToBulkLog(\n       List<String> requestTaskIds, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    BulkLog bulkLog = new BulkLog();\n     List<String> nonExistingTaskIds = new ArrayList<>(requestTaskIds);\n     List<String> existingTaskIds =\n         existingMinimalTaskSummaries.stream()\n             .map(MinimalTaskSummary::getTaskId)\n             .collect(Collectors.toList());\n     nonExistingTaskIds.removeAll(existingTaskIds);\n-    for (String taskId : nonExistingTaskIds) {\n-      bulkLog.addError(taskId, new TaskNotFoundException(taskId, \"Task was not found\"));\n-    }\n+    nonExistingTaskIds.forEach(\n+        taskId ->\n+            bulkLog.addError(taskId, new TaskNotFoundException(taskId, \"Task was not found\")));\n     return bulkLog;\n   }\n \n-  private BulkOperationResults<String, TaskanaException> updateAffectedTasks(\n-      Instant planned, Map<Duration, List<TaskDuration>> tasksPerDuration) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-    TaskImpl referenceTask = new TaskImpl();\n-    referenceTask.setPlanned(planned);\n-    for (Map.Entry<Duration, List<TaskDuration>> entry : tasksPerDuration.entrySet()) {\n-      List<String> taskIdsToUpdate =\n-          entry.getValue().stream().map(TaskDuration::getTaskId).collect(Collectors.toList());\n-      long days = converter.convertWorkingDaysToDays(planned, entry.getKey().toDays());\n-      Instant due = planned.plus(Duration.ofDays(days));\n-      referenceTask.setDue(due);\n-      referenceTask.setModified(Instant.now());\n-      long numTasksUpdated = taskMapper.updateTaskDueDates(taskIdsToUpdate, referenceTask);\n-      if (numTasksUpdated != taskIdsToUpdate.size()) {\n-        bulkLog.addAllErrors(\n-            checkResultsOfTasksUpdateAndAddErrorsToBulkLog(\n-                taskIdsToUpdate, referenceTask, numTasksUpdated));\n+  TaskImpl updatePrioPlannedDueOfTask(\n+      TaskImpl newTaskImpl, TaskImpl oldTaskImpl, boolean forRefreshOnClassificationUpdate)\n+      throws InvalidArgumentException {\n+    boolean onlyPriority = false;\n+    if (newTaskImpl.getClassificationSummary() == null\n+        || newTaskImpl.getClassificationSummary().getServiceLevel() == null) {\n+      onlyPriority = true;\n+    }\n+\n+    if (isPriorityAndDurationAlreadyCorrect(newTaskImpl, oldTaskImpl)) {\n+      return newTaskImpl;\n+    }\n+\n+    if (newTaskImpl.getPlanned() == null && newTaskImpl.getDue() == null) {\n+      newTaskImpl.setPlanned(Instant.now());\n+    }\n+\n+    DurationPrioHolder durationPrioHolder = determineTaskPrioDuration(newTaskImpl, onlyPriority);\n+    newTaskImpl.setPriority(durationPrioHolder.getPriority());\n+    if (onlyPriority) {\n+      return newTaskImpl;\n+    }\n+    // classification update\n+    if (forRefreshOnClassificationUpdate) {\n+      newTaskImpl.setDue(newPlannedDueInstant(newTaskImpl, durationPrioHolder.getDuration(), true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26aee8d1ae0d895d957a4979b3df2dfd9cb5cbf5", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/26aee8d1ae0d895d957a4979b3df2dfd9cb5cbf5", "committedDate": "2020-03-17T18:02:57Z", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d54a91fae547ba9c49b8496a60713da788e5f888", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/d54a91fae547ba9c49b8496a60713da788e5f888", "committedDate": "2020-03-17T18:13:58Z", "message": "TSK-1143 UpdateTask planned - comments from Holger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bea58eddcd996d9196b443545aa2fd3cc634dc20", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/bea58eddcd996d9196b443545aa2fd3cc634dc20", "committedDate": "2020-03-17T18:13:59Z", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "committedDate": "2020-03-18T07:38:13Z", "message": "TSK-1143 even more comments from Holger"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05ec16acb77adb16c7652506b76aaf269aaa65e0", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/05ec16acb77adb16c7652506b76aaf269aaa65e0", "committedDate": "2020-03-16T15:14:19Z", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, "afterCommit": {"oid": "2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "author": {"user": {"login": "BerndBreier", "name": null}}, "url": "https://github.com/Taskana/taskana/commit/2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "committedDate": "2020-03-18T07:38:13Z", "message": "TSK-1143 even more comments from Holger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NzI4MDE3", "url": "https://github.com/Taskana/taskana/pull/959#pullrequestreview-377728017", "createdAt": "2020-03-19T13:40:53Z", "commit": {"oid": "2eb10e2e130ff9fa80af960b4da4783d60bbd7c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4511, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}