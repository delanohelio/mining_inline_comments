{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NTQ4MDg3", "number": 720, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MDo1MVrOEd1obw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0Mzo0N1rOEfkDRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzIyODYzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalPlanDSL.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MDo1MVrOHJPbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowMTo0MVrOHJXM9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjAxMw==", "bodyText": "Some use a constant like DEFAULT_NO_OF_RESULTS and some have 10 hardcoded. Should probably be consistent with the constant.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452013", "createdAt": "2020-08-28T17:50:51Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalPlanDSL.java", "diffHunk": "@@ -83,6 +84,16 @@ public static LogicalPlan dedupe(\n         input, Arrays.asList(fields), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static LogicalPlan rareTopN(LogicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groupByList, Expression... fields) {\n+    return rareTopN(input, rareTopFlag, 10, groupByList, fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTM4MQ==", "bodyText": "Used the variable/function to get default value wherever required. hardcoded values are used for the test purpose.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479579381", "createdAt": "2020-08-29T00:01:41Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalPlanDSL.java", "diffHunk": "@@ -83,6 +84,16 @@ public static LogicalPlan dedupe(\n         input, Arrays.asList(fields), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static LogicalPlan rareTopN(LogicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groupByList, Expression... fields) {\n+    return rareTopN(input, rareTopFlag, 10, groupByList, fields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjAxMw=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzIyOTY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/PhysicalPlanDSL.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MToxMlrOHJPcGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MToxMlrOHJPcGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjE4Ng==", "bodyText": "Same comment on constant for 10.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452186", "createdAt": "2020-08-28T17:51:12Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/PhysicalPlanDSL.java", "diffHunk": "@@ -80,6 +80,17 @@ public static DedupeOperator dedupe(\n         input, Arrays.asList(expressions), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static RareTopNOperator rareTopN(PhysicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groups, Expression... expressions) {\n+    return rareTopN(input, rareTopFlag, 10, groups, expressions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI0Mzc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0OVrOHJPkwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0OVrOHJPkwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDQwMg==", "bodyText": "We should use tags like @return and such when doing java docs for return values. Similar comment for @param for parameter. Would generally have this nit across the code.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479454402", "createdAt": "2020-08-28T17:55:49Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzMzMDUwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoyNTo1N1rOHJQa1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoyNTo1N1rOHJQa1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2ODI0NQ==", "bodyText": "This javadoc isn't very useful. Comments should help the developer understand the code and provide value like \"what, why, how\".", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479468245", "createdAt": "2020-08-28T18:25:57Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzM0ODAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODozMjoyMlrOHJQl4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzozODowOFrOHJW8Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MTA3NQ==", "bodyText": "Missing license header.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479471075", "createdAt": "2020-08-28T18:32:22Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTA1NA==", "bodyText": "added", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479575054", "createdAt": "2020-08-28T23:38:08Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MTA3NQ=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzM1NDMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODozNDo0M1rOHJQpqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo0NDowM1rOHJXAbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjA0Mg==", "bodyText": "In a different method we use ImmutableList.of() here. Let's be consistent.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472042", "createdAt": "2020-08-28T18:34:43Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Logical Rare and TopN Plan.\n+ */\n+@Getter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+public class LogicalRareTopN extends LogicalPlan {\n+\n+  private final LogicalPlan child;\n+  private final Boolean rareTopFlag;\n+  private final Integer noOfResults;\n+  private final List<Expression> fieldList;\n+  private final List<Expression> groupByList;\n+\n+  @Override\n+  public List<LogicalPlan> getChild() {\n+    return Collections.singletonList(child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NjE3Mg==", "bodyText": "Replaced ImmutableList.of(child) in RareTopN.java with Collections.singletonList(child)", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479576172", "createdAt": "2020-08-28T23:44:03Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Logical Rare and TopN Plan.\n+ */\n+@Getter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+public class LogicalRareTopN extends LogicalPlan {\n+\n+  private final LogicalPlan child;\n+  private final Boolean rareTopFlag;\n+  private final Integer noOfResults;\n+  private final List<Expression> fieldList;\n+  private final List<Expression> groupByList;\n+\n+  @Override\n+  public List<LogicalPlan> getChild() {\n+    return Collections.singletonList(child);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjA0Mg=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzM1Njc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODozNTo0MVrOHJQrMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo0Mjo0MVrOHJW_hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQzMg==", "bodyText": "We are missing the license header here.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472432", "createdAt": "2020-08-28T18:35:41Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTk0Mg==", "bodyText": "added", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479575942", "createdAt": "2020-08-28T23:42:41Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQzMg=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzM5MTU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo0Njo1M1rOHJQ_cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1NTowNlrOHJXIrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzYxNg==", "bodyText": "findTop() and findRare() have the same implementation, except the comparator is different. We could just have a single find() function that takes in a comparator instead.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479477616", "createdAt": "2020-08-28T18:46:53Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODI4NQ==", "bodyText": "replaced with find() function", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479578285", "createdAt": "2020-08-28T23:55:06Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzYxNg=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzQwNzYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo1MzowNFrOHJRJeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzo1NjowM1rOHJXJRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MDE4Ng==", "bodyText": "This algorithm for building this list is too complicated. I think you can model this more easily with streams.\nmap.entrySet().stream()\n.sort(ValueComparator)\n.limit(noOfResults)\nPass in different comparator for rare vs. top.\n.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479480186", "createdAt": "2020-08-28T18:53:04Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODQzNg==", "bodyText": "Thanks. Added this in find() function.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479578436", "createdAt": "2020-08-28T23:56:03Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MDE4Ng=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzQyMDgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo1ODoxMVrOHJRR5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDowMzozMlrOHJXOAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MjM0MA==", "bodyText": "Usually you don't want to return the specific type and instead return the interface unless the caller really needs to work with LinkedHashMap in particular.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479482340", "createdAt": "2020-08-28T18:58:11Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public LinkedHashMap<String, ExprValue> fieldKeyMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTY1MQ==", "bodyText": "Thanks. Changed return type to Map.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479579651", "createdAt": "2020-08-29T00:03:32Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public LinkedHashMap<String, ExprValue> fieldKeyMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MjM0MA=="}, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg0MDc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1NDo1OVrOHJc9tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDozMToxMlrOHKIMrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3Mzc4MA==", "bodyText": "Missing the license header.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479673780", "createdAt": "2020-08-29T17:54:59Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MjEyNg==", "bodyText": "added", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480382126", "createdAt": "2020-08-31T20:31:12Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3Mzc4MA=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg0MzA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1ODowMVrOHJc-yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDozMjo1NlrOHKIPzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDA1OQ==", "bodyText": "Lets use fieldExprList.stream().map(...).collect(Collectors.toList())", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674059", "createdAt": "2020-08-29T17:58:01Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MjkyNw==", "bodyText": "Switched to stream", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480382927", "createdAt": "2020-08-31T20:32:56Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDA1OQ=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg0OTM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNjoyOFrOHJdBtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDozNDoxNlrOHKISQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDgwNw==", "bodyText": "Are you using guava? Can you use Streams.zip().collect(Collectors.toMap(...))?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674807", "createdAt": "2020-08-29T18:06:28Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzU1NA==", "bodyText": "Replaced with Streams.zip()...", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480383554", "createdAt": "2020-08-31T20:34:16Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDgwNw=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg1MDA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzoyMVrOHJdCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDozNDozMFrOHKISzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDg5NA==", "bodyText": "Switch to stream", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674894", "createdAt": "2020-08-29T18:07:21Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzY5Mg==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480383692", "createdAt": "2020-08-31T20:34:30Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDg5NA=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg1MDIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzo0M1rOHJdCIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDozNTowOFrOHKIUEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA==", "bodyText": "Switch to stream.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674914", "createdAt": "2020-08-29T18:07:43Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {\n+        this.groupByValueList.add(groupExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of group field and group field value.\n+     */\n+    public Map<String, ExprValue> groupKeyMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDk5Mg==", "bodyText": "This is the same logic and return type as for FieldKey#fieldKeyMap. Can they derive from a common base, or use a generic parameter?\nThe constructor is also pretty much the same.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674992", "createdAt": "2020-08-29T18:08:51Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {\n+        this.groupByValueList.add(groupExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of group field and group field value.\n+     */\n+    public Map<String, ExprValue> groupKeyMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NDAxOA==", "bodyText": "Used common class for finding group & field key", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480384018", "createdAt": "2020-08-31T20:35:08Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {\n+        this.groupByValueList.add(groupExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of group field and group field value.\n+     */\n+    public Map<String, ExprValue> groupKeyMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5ODg1ODIyOnYy", "diffSide": "RIGHT", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODoxODo1OVrOHJdGDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo0MTowN1rOHKIfgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NTkxNg==", "bodyText": "Code is the same for these two methods, except differing by the flag. Can they be combined into a helper? If the two context classes have the same methods...", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479675916", "createdAt": "2020-08-29T18:18:59Z", "author": {"login": "jduo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +203,62 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  /**\n+   * Rare command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitRareCommand(RareCommandContext ctx) {\n+    List<UnresolvedExpression> groupList = ctx.byClause() == null ? Collections.emptyList() :\n+        ctx.byClause()\n+            .fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(this::visitExpression)\n+            .collect(Collectors.toList());\n+    return new RareTopN(\n+\n+        /**\n+         * Setting rareTopFlag to FALSE will return list of rare values\n+         */\n+        Boolean.FALSE,\n+        ArgumentFactory.getArgumentList(ctx),\n+        ctx.fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(field -> (Field) visitExpression(field))\n+            .collect(Collectors.toList()),\n+        groupList\n+    );\n+  }\n+\n+  /**\n+   * Top command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitTopCommand(TopCommandContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4Njk0Nw==", "bodyText": "Added helper methods for getting a list of groups & fields. Can't add other arguments in helper since that requires respective command context object", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480386947", "createdAt": "2020-08-31T20:41:07Z", "author": {"login": "rupal-bq"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +203,62 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  /**\n+   * Rare command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitRareCommand(RareCommandContext ctx) {\n+    List<UnresolvedExpression> groupList = ctx.byClause() == null ? Collections.emptyList() :\n+        ctx.byClause()\n+            .fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(this::visitExpression)\n+            .collect(Collectors.toList());\n+    return new RareTopN(\n+\n+        /**\n+         * Setting rareTopFlag to FALSE will return list of rare values\n+         */\n+        Boolean.FALSE,\n+        ArgumentFactory.getArgumentList(ctx),\n+        ctx.fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(field -> (Field) visitExpression(field))\n+            .collect(Collectors.toList()),\n+        groupList\n+    );\n+  }\n+\n+  /**\n+   * Top command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitTopCommand(TopCommandContext ctx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NTkxNg=="}, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA2NTk0OnYy", "diffSide": "RIGHT", "path": "docs/experiment/ppl/cmd/rare.rst", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMDo1MFrOHLGfKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDozNDowM1rOHLM0Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng==", "bodyText": "how many value for each field will be returned? 10?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481402666", "createdAt": "2020-09-01T20:10:50Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NjYwMg==", "bodyText": "10 values per group for each field", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481446602", "createdAt": "2020-09-01T21:37:53Z", "author": {"login": "rupal-bq"}, "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MTA1MA==", "bodyText": "could you add this to the doc? I think the max value = 10, right?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481491050", "createdAt": "2020-09-01T23:41:03Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNjM5NQ==", "bodyText": "Yes, the max is 10. Added in the Description section.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481506395", "createdAt": "2020-09-02T00:34:03Z", "author": {"login": "rupal-bq"}, "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA3MTE4OnYy", "diffSide": "RIGHT", "path": "docs/experiment/ppl/cmd/top.rst", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMjozMlrOHLGiWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzo0MToxNlrOHLL4rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw==", "bodyText": "why the rare command doesn't has thsi paramater?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481403483", "createdAt": "2020-09-01T20:12:32Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NTkwNA==", "bodyText": "Rare doesn't have N because it's not in the syntax given in this documentation: https://docs.splunk.com/Documentation/Splunk/8.0.2/SearchReference/Rare", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481445904", "createdAt": "2020-09-01T21:36:16Z", "author": {"login": "rupal-bq"}, "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0ODM4MA==", "bodyText": "limit controls the number of results for rare but support for top-options isn't covered in this PR.\nShould I add parameter N for rare?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481448380", "createdAt": "2020-09-01T21:42:05Z", "author": {"login": "rupal-bq"}, "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MTExNw==", "bodyText": "no need now, just confirm,", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481491117", "createdAt": "2020-09-01T23:41:16Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA4NDM0OnYy", "diffSide": "RIGHT", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjowOVrOHLGp8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzowMDoyM1rOHLLFxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg==", "bodyText": "could you also change the stats command to use these genric method?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405426", "createdAt": "2020-09-01T20:16:09Z", "author": {"login": "penghuo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NTA4Ng==", "bodyText": "will do", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481445086", "createdAt": "2020-09-01T21:34:29Z", "author": {"login": "rupal-bq"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODA4NQ==", "bodyText": "used getGroupByList in stats command", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478085", "createdAt": "2020-09-01T23:00:23Z", "author": {"login": "rupal-bq"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA4NDc1OnYy", "diffSide": "RIGHT", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjoxNVrOHLGqLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzowMDo1NlrOHLLGgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQ4NQ==", "bodyText": "ditto", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405485", "createdAt": "2020-09-01T20:16:15Z", "author": {"login": "penghuo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {\n+    return ctx.fieldList().fieldExpression().stream().map(this::visitExpression)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<Field> getFieldList(FieldListContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODI3NA==", "bodyText": "used getFieldList for dedup command", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478274", "createdAt": "2020-09-01T23:00:56Z", "author": {"login": "rupal-bq"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {\n+    return ctx.fieldList().fieldExpression().stream().map(this::visitExpression)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<Field> getFieldList(FieldListContext ctx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQ4NQ=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDE0MTg5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMzoyN1rOHLHMfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzowMjozMFrOHLLIdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA==", "bodyText": "why the value is List instead of just Map?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481414270", "createdAt": "2020-09-01T20:33:27Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<Key, List<HashMap<Key, Integer>>> groupListMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzU1MQ==", "bodyText": "Thanks for noticing. The list is not required here. I will remove it.\nI had list<list<ExprValue>> before I understood every input has values for the entire row and not just for a cell. Looks like I missed this while updating the structure.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481453551", "createdAt": "2020-09-01T21:54:07Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<Key, List<HashMap<Key, Integer>>> groupListMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODc3Mw==", "bodyText": "removed list", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478773", "createdAt": "2020-09-01T23:02:30Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<Key, List<HashMap<Key, Integer>>> groupListMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA=="}, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTMwNTgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzozOTo0MlrOHL6OeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMjo1MDowOVrOHMNlAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ==", "bodyText": "Should this be a boolean instead of Boolean? Would an enum with values RARE or TOP be better? I can't tell if setting this to true means rare or top.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482250361", "createdAt": "2020-09-02T17:39:42Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;\n+\n+import com.amazon.opendistroforelasticsearch.sql.ast.AbstractNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Argument;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Field;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.UnresolvedExpression;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+/**\n+ * AST node represent RareTopN operation.\n+ */\n+@Getter\n+@Setter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+public class RareTopN extends UnresolvedPlan {\n+\n+  private UnresolvedPlan child;\n+  private final Boolean rareTopFlag;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwODI3NA==", "bodyText": "Will add enum", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482508274", "createdAt": "2020-09-02T21:49:53Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;\n+\n+import com.amazon.opendistroforelasticsearch.sql.ast.AbstractNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Argument;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Field;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.UnresolvedExpression;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+/**\n+ * AST node represent RareTopN operation.\n+ */\n+@Getter\n+@Setter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+public class RareTopN extends UnresolvedPlan {\n+\n+  private UnresolvedPlan child;\n+  private final Boolean rareTopFlag;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU2NzQyNw==", "bodyText": "replaced with enum", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482567427", "createdAt": "2020-09-02T22:50:09Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;\n+\n+import com.amazon.opendistroforelasticsearch.sql.ast.AbstractNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Argument;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Field;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.UnresolvedExpression;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+/**\n+ * AST node represent RareTopN operation.\n+ */\n+@Getter\n+@Setter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+public class RareTopN extends UnresolvedPlan {\n+\n+  private UnresolvedPlan child;\n+  private final Boolean rareTopFlag;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTMxMzUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MTo1NVrOHL6TSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTo1Mjo0MlrOHMKGyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MTU5NQ==", "bodyText": "Can this and noOfResults just be primitive ints?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482251595", "createdAt": "2020-09-02T17:41:55Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxMDUzOA==", "bodyText": "Yes, I can replace it with primitive ints. All other operators had an object of Integer so I just followed the same structure. Should I use primitive instead?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482510538", "createdAt": "2020-09-02T21:52:42Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MTU5NQ=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTMxNzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MzowMFrOHL6VoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMzo0MToyNlrOHMPr1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg==", "bodyText": "Let's add a precondition check here and on next() to verify open() has been called.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252192", "createdAt": "2020-09-02T17:43:00Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNjgwNQ==", "bodyText": "Can you elaborate more? Like what should we return if a condition fails? Maybe Null?\nI have simply followed the logic of AggregationOperator here. It might not be required since open() is updating an iterator and if open() isn't called then hasNext() will simply return false since there are no elements. And when hasNext() will return false, next() won't be called.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482536805", "createdAt": "2020-09-02T22:24:50Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMTk0Mg==", "bodyText": "I would add Precondition.checkNotNull(iterator) here. But really depends on what coding style is preferred.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482601942", "createdAt": "2020-09-02T23:41:26Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTMxOTczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0Mzo0N1rOHL6XVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNzoxMDozNVrOHNV7Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA==", "bodyText": "Should we do something to indicate that input is no longer usable or throw an error if open() is called more than once?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252628", "createdAt": "2020-09-02T17:43:47Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxOTU2Ng==", "bodyText": "I am not sure if it is possible to call open() more than once for a single request. AggregationOperator & SortOperator also override open() and it doesn't throw an error so I assumed it's not required.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482519566", "createdAt": "2020-09-02T22:04:06Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjI2MQ==", "bodyText": "I would suggest using Precondition.checkNull(iterator) here to fail fast if open() accidentally gets called more than once.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482602261", "createdAt": "2020-09-02T23:42:33Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MjcxMQ==", "bodyText": "open() gets called only once", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r483752711", "createdAt": "2020-09-04T17:10:35Z", "author": {"login": "rupal-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2009, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}