{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNzE3MDA2", "number": 667, "title": "Support NULL and MISSING value in response", "bodyText": "Description of changes\n\nAuto add FIELDS * for PPL command.\nIn Analyzer, expend SELECT * to SELECT all fields.\nExtract type info from QueryPlan and add to QueryResponse.\nSupport NULL and MISSING value in response. https://github.com/penghuo/sql/blob/pr-select-all/docs/user/general/values.rst\n\n\nProblem Statements\nBackground\nBefore explain the current issue, firstly, let\u2019s setup the context.\nSample Data\nLet\u2019s explain the problem with an example,  the bank index which has 2 fields.\n    \"mappings\" : {\n      \"properties\" : {\n        \"account_number\" : {\n          \"type\" : \"long\"\n        },\n        \"age\" : {\n          \"type\" : \"integer\"\n        }\n      }\n    }\n\nThen we add some data to the index.\nPOST bank/_doc/1\n{\"account_number\":1,\"age\":31}\n\n// age is null\nPOST bank/_doc/2\n{\"account_number\":2,\"age\":null}\n\n// age is missing\nPOST bank/_doc/3\n{\"account_number\":3}\n\nJDBC and JSON data format\nThen, we define the response data format for query \u201cSELECT account_number FROM bank\u201d as follows.\n\nJDBC Format. There there mandatory fields, \u201cfield name\u201d, \u201cfield type\u201d and \u201cdata\u201d. e.g.\n\n{\n  \"schema\": [{\n    \"name\": \"account_number\",\n    \"type\": \"long\"\n  }],\n  \"total\": 3,\n  \"datarows\": [\n    [1],\n    [2],\n    [3]\n  ],\n  \"size\": 3\n}\n\n\nJSON Format, comparing with JDBC format, it doesn\u2019t have schema field\n\n{\n  \"datarows\": [\n    {\"account_number\": 1},\n    {\"account_number\": 2},\n    {\"account_number\": 3}\n  ]\n}\n\nIssue 1. Represent NULL and MISSING in Response\nWith these sample data and response data format in mind, let go through more query and examine their results.\nConsidering the query:** SELECT age, account_number FROM bank. **\nThe JDBC format doesn\u2019t have MISSING value. If the field exist in the schema but missed in the document, it should considered as NULL value.\nThe JSON format could represent the MISSING value properly.\n* JDBC Format\n{\n  \"schema\": [\n    {\n      \"name\": \"age\",\n      \"type\": \"integer\"\n    },\n    {\n      \"name\": \"account_number\",\n      \"type\": \"long\"\n    }\n  ],\n  \"total\": 3,\n  \"datarows\": [\n    [\n      31,\n      1\n    ],\n    [\n      null,\n      2\n    ],\n    [\n      null,\n      3\n    ],\n  ],\n  \"size\": 3\n}\n\n* JSON Format\n{\n  \"datarows\": [\n    {\"age\": 1, \"account_number\": 1},\n    {\"age\": null, \"account_number\": 2},\n    {\"account_number\": 3}\n  ]\n}\n\nIssue 2. ExprValue to JDBC format\nBased on our current impementation, all the SQL operator is translated to chain of PhysicalOpeartor. Each PhysicalOpeartor provide the ExprValue as the return value. The protocol pull the result from PhysicalOperator and transalte to the expected format. e.g. Taking the above query as example, the result of the PhysicalOpeartor is a list of ExprValues.\n[\n    {\"age\": ExprIntegerValue(1), \"account_number\": ExprIntegerValue(1)},\n    {\"age\": ExprNullValue(), \"account_number\": ExprIntegerValue(2)},\n    {\"account_number\": ExprIntegerValue(3)}\n]\n\nThe current solution is extract field name and field type from the data itself. This solution has two problems\n\nIt is impossible to derive the type from NULL value.\nIf the field is missing in the ExprValue, there is no way to derive it.\n\nIssue 3. The Type info is missing\nIn current design, the Protocol is a seperate module which work independently with QueryEngine. The Protocol module receive the list of ExprTupleValue from QueryEngine, then the Protocol module format the result based on the type of ExprValue. the problem is ExprNullValue and ExprMissingValue doesn\u2019t have type assosicate with it. thus the Protocol module can\u2019t derive the type info from input ExprTupleValue directly.\nIssue 4. What is *(all field) means in SELECT\nIn current design, the SELECT * clause ingored in the AST builder logic, because it means select all the data from input operator. The issue is similar as Issue 3 that if the input operator produce NULL or MISSING value, then the Protocol have no idea to derive type info from it.\nRequirements\n\nThe JDBC format should been supported. The MISSING and NULL value should been representd as NULL.\nThe JSON format should been supported.\nThe Protocol module should receive the QueryResponse which include schema and data.\n\nSolution\nInclud NULL and MISSING value in the QueryResult (Issue 1, 2)\nThe SELECT operator will be translated to PhysicalOpeartor with a list of expression to resolve ExprValue from input data. With the above example, when handling NULL and MISSING value, the expected output data should be as follows.\n[\n    {\"age\": ExprIntegerValue(1), \"account_number\": ExprIntegerValue(1)},\n    {\"age\": ExprNullValue(), \"account_number\": ExprIntegerValue(2)},\n    {\"age\": ExprMissingValue(), \"account_number\": ExprIntegerValue(3)}\n]\n\nAn aditionial list of Schema is also required to when protocol is JDBC.\n{\n  \"schema\": [\n    {\n      \"name\": \"age\",\n      \"type\": \"integer\"\n    },\n    {\n      \"name\": \"account_number\",\n      \"type\": \"long\"\n    }\n  ]    \n}\n\nThen the protocol module could easily translate the JDBC format or JSON format.\nExpend SELECT * to SELECT ...fields (Issue 4)\nIn our current implementation, in SQL, the SELECT * is ignored and in PPL there even no fields * command. This solution works fine for JSON format which doesn\u2019t require schema, but it doens\u2019s works for JDBC format.\nThe proposal in here is\n\nAutomatically add the fields command to PPL query\nExpand SELECT * to SELECT ...fields.\n\nAutomatically add fields * to PPL query\nComparing with SQL, the PPL grammer doesn\u2019t require the Fields command is the last command. Thus, the fields * command should been automatically added.\nThe automatically added logic is if the last operator is not Fields command, the Fields * command will been added.\nExpand SELECT * to SELECT ...fields\nIn Analyzer, we should expend the * to all fields in the current scope. There are two issues we need to address,\n\nNo all the fields in the current scope should been used to expand *. The original scope is from Elasticsearch mapping which include nested mapping. In current design, only the top fields will be retrived from the current scope, all the nested fields will been ignored.\nThe scope should been dynamtic maintain in the Analyzer. For example, the stats command will define the new scope.\n\nRetrive Type Info from ProjectOperator and Expose to Protocol (Issue 3)\nAfter expending the * and automatically add fields, the type info could been retrived from ProjectOperator. Then the Protocol could get schema and data from QueryEngine.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-08-06T00:50:29Z", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/667", "merged": true, "mergeCommit": {"oid": "6021470092cdc77b5b6e2a6f0a99ee2f820394b5"}, "closed": true, "closedAt": "2020-08-10T17:55:47Z", "author": {"login": "penghuo"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8E5KsAH2gAyNDYzNzE3MDA2OmY1NDkyMDUzYjllYTNjYWEyZTJjMTYwMDNhNmQ0MWZjZjhkYTUwNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9lqzRAFqTQ2NDQzMTI5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f5492053b9ea3caa2e2c16003a6d41fcf8da5065", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/f5492053b9ea3caa2e2c16003a6d41fcf8da5065", "committedDate": "2020-08-06T00:43:36Z", "message": "Support NULL and MISSING value in response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjk5Njgz", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/667#pullrequestreview-463699683", "createdAt": "2020-08-08T00:35:37Z", "commit": {"oid": "f5492053b9ea3caa2e2c16003a6d41fcf8da5065"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNTozOFrOG9sC7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNTozOFrOG9sC7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzk2Nw==", "bodyText": "Should we pass expr.getAlias() as second argument?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/667#discussion_r467337967", "createdAt": "2020-08-08T00:35:38Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/ProjectOperator.java", "diffHunk": "@@ -60,11 +62,15 @@ public ExprValue next() {\n     ImmutableMap.Builder<String, ExprValue> mapBuilder = new Builder<>();\n     for (NamedExpression expr : projectList) {\n       ExprValue exprValue = expr.valueOf(inputValue.bindingTuples());\n-      // missing value is ignored.\n-      if (!exprValue.isMissing()) {\n-        mapBuilder.put(expr.getName(), exprValue);\n-      }\n+      mapBuilder.put(expr.getName(), exprValue);\n     }\n     return ExprTupleValue.fromExprValueMap(mapBuilder.build());\n   }\n+\n+  @Override\n+  public ExecutionEngine.Schema schema() {\n+    return new ExecutionEngine.Schema(getProjectList().stream()\n+        .map(expr -> new ExecutionEngine.Schema.Column(expr.getName(),\n+            expr.getName(), expr.type())).collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5492053b9ea3caa2e2c16003a6d41fcf8da5065"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6974a902ec12c604c0262cfff19752496a5c61f8", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/6974a902ec12c604c0262cfff19752496a5c61f8", "committedDate": "2020-08-10T16:53:45Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDMxMjky", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/667#pullrequestreview-464431292", "createdAt": "2020-08-10T17:28:42Z", "commit": {"oid": "6974a902ec12c604c0262cfff19752496a5c61f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 612, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}