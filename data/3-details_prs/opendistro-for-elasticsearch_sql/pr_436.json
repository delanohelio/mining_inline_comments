{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTM2NDc5", "number": 436, "title": "Add support of Resolved Expression", "bodyText": "Expression\nThere are two types of Expression in the core engine. One is Unresolved Expression which is used to build the AST. The other is Resolved Expression which is used in the logical plan and execution plan.\nUnresolved Expression\nAs the name indicated, the unresolved expression is the output of the AST builder which logically represent the literal identifier and function in the command, e.g. the function if(error == 200, \"OK\", \"Error\". is been represent as the following AST\nIFExpression\n    Expression: condition;  // EqExpression(Identifier(error), Literal(200)\n    Expression: trueReturn; // Literal(\"OK\")\n    Expression: falseReturn;// Literal(\"Error\")\n\nBefore introducing the resolved expression, we want highlight the difference between resolved expression and unresolved expression firstly.\n\nThe Unresolved Expression is the logical expression, which only has constructor but without observer method.\nThe  Unresolved Expression is constructed without semantic check.\nThe Unresolved Expression can\u2019t been evaluated in the environment.\n\nResolved Expression\nThe resolved expression is the core concept in the core engine which is the compiled from unresolved expression in the  Analyzer stage. If not specifically pointed out, in the following section we use expression for short.\nEach logical plan could include expression. The expression server different purpose in the core engine.\n\nExpression could be evaluated with BindingTuple.  Each logical plan node could denote as f,  which f(stream(BindingTuple)) \u2192 stream(BindingTuple). The the expression in each command should have the ability to evaluate with BindingTuple.\nExpression should type value. The type check in semantic check is based on each expression has type info, then the type check could be executed during the expression construct time.\nExpression to Elasticsearch DSL/Painless script.\n\nExpression Definition\nInstead of list the full expression system definition, in here, we list the sample expression definition for demo purpose\nExpression := literal(var)\nExpression := ref(var)\nExpression := add(Expression, Expression)\n...\n\nThen the constructor and observer of the expression systems are\nConstructors\nadd: Exp x Exp -> Exp\nliteral: ExprVal -> Exp\nref: Var -> Exp\n\nobserver:\nvalueOf: Exp x BindingTuple -> ExprVal\ntypeOf: Exp x BindingTuple -> TypeVal\n\nBuild Expression from Unresolved Expression\nIn compile stage, the resolved expression is built from unresolved expression with semantic check. Let\u2019s use the example to explain the build process.\nThe expression builder have two goals,\n\nBuild the resolved expression from unresolved expression.\nDo the semantic analysis during the build process.\n\n// Identifier Type Mapping\n{\n    \"a\": integer,\n    \"b\": double\n}\n\n// (1) Unresolved Expression in AST\nuAddExpression = uAdd(uRef(\"a\"), uRef(\"b\"))\n\n// (2) Resolve the uAddExpression recursively\n// uAddExpression is the function need to be resolved in the FunctionRepository with signature\n// The function signature is name + argument types\nresolve(uAddExpression)\n\n// (3) resolve argument\nresolve(uref(\"a\")) -> ref(\"a\")\nresolve(uref(\"b\")) -> ref(\"b\")\n\n// (4) argument type\nref(\"a\").typeOf(typeMapping) -> integer\nref(\"b\").typeOf(typeMapping) -> double\n\n// (5) resolve the uAddExpression in FunctionRepository\nFunctionRepository.resolve(\"add\", (integer, double)) -> add(ref(\"a\"), ref(\"b\"))\n\nIn this section, we explain the procedure to build resolved expression from resolved expression, on the next section we will introduce the semantic analysis procedure.\nSemantic Analysis\nThe semantic analysis include\n1. Label checking: index not found, field not found\n2. Type checking: wrong field type, wrong number of parameters (if not specified in grammar)\n3. Scope checking: function used in wrong place\n\nFrom dragon book\n\nAn important part of semantic analysis is type checking. where the compiler checks that each operator has matching operands\n\nActually, the major part in Build Expression from Unresolved Expression is doing the semantic analysis. The following section explain each part in detail.\nExpression Type Evaluation\nWhen evaluate the expression type, we could dive the expression into three categories.\n\nliteral expression: the type is determined by the value type. e.g. literal(1).typeOf() \u2192 Integer\nref expression: the type is determined by resolved the filed in the context, e.g. ref(\u201ca\u201d).typeOf({\u201ca\u201d, Integer}) \u2192 Integer. Note that, the semantic label checking is happened ruing this stage.\nfunction expression: the type is determined by the procedure\u2019s return type. e.g. add(Integer, Integer) \u2192 Integer.\n\nResolve Unresolved Function in FunctionRepository\nAs we list in Build Expression from Unresolved Expression, the unresolved procedure should be resolved in the FunctionRepository with FunctionSignature\nFunctionSignature\nThe function signature is the combination of the function name and a list of parameters type. The function signature distinguish the expression from each other.\nOverloading of Function\nThe function could have different meaning depend on the parameter type. Overloading is programmer friendly polymorphic feature, where a programmer needs to remember only one method name for similar type of operations on different types and number of parameters. The compiler takes care of calling the right function by looking at what type and number of parameters are passed. e.g. the add function could have serval overloading version depend on the parameter.\nDouble add(Double, Double)\nFloat add(Float, Float)\nLong add(Long, Long)\nInteger add(Integer, Integer)\n\nIf the unresolved function has the type exactly match one of the signature, then it could be resolved to one of the overloading version. e.g., The unresolved function has signature: <\u201cadd\u201d, (Double, Double)> which could be resolved to resolved function has signature <\u201cadd\u201d, (Double, Double)> directly.\nBut what if the unresolved expression has parameter which doesn\u2019t exactly match the any of the function signature? The next section will provide one solution.\nWidening Primitive Conversion\nThe widening primitive conversion make the expression signature with widening primitive could accept parameter with narrow primitive.\ne.g. The unresolved function has signature <\"add\", (Float``*, Integer)>*** **which doesn\u2019t have exactly match registered resolved function. resolved directly, Then we need to apply the widening conversion rule and choose the best match resolved function.\n\nwidening conversion rule. The widening conversion rules are given by the hierarchy below (From dragon book) which define the compatible type. then the by applying the widening conversion rule, the <\"add\", (Float``*, Integer)** is compatible with <\"add\", (Double, Double)>, <\"add\", (Float, Integer)> . *Then, the next problem is how to choose the best match.\ncompatible distance. We define the the compatible distance as  SUM(distance(UPi, RFj)), which\n\nTFi is the Type of the i argument in the unresolved function signature, RFi is the Type of the i argument in the registered function signature.\nThe distance is then measured by the node distance in the tree. In which\n\ndistance = 0, when two types are identical.\ndistance = INTEGER.MAX, when two types are not compatible.\ndistance = distanceInTree(type1, type2)\n\n\n\n\nAt the end, we choose the matching registered resolved function with the nearest distance.\n\nREF: https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html\nFunctionRepository\nWe refer the FunctionRepository many times but didn\u2019t touch it yet. The FunctionRepository maintain the predefined the resolved function builder. The unresolved function could be resolved in the function context if possible and get the resolved function.\nEach function bundle is identified by the function name in the FunctionRepository. Each function bundle include a bunch of overloaded function builder with different signature. e.g.\nDouble add(Double, Double)\nFloat add(Float, Float)\nLong add(Long, Long)\nInteger add(Integer, Integer)\n\nExpression Value Evaluation\nIn execution stage, the expression is evaluated with BindingTuple as the env and produce the ExprVal as the result. Let\u2019s take an example to explain the behavior.\n// BindingTuple\n{\n    \"a\": 1,\n    \"b\": 2\n}\n\n// Construct Expression by using Expression DSL\naddExpression = add(ref(\"a\"), ref(\"b\"))\n\n// Evaluate Expression with BindingTuple.\n// The evaluation is executed in application order.\naddExpression.valueOf(bindingTuple)\n-> (+ ref(\"a\").valueOf(bindingTuple) ref(\"b\").valueOf(bindingTuple))\n-> (+ 1 2)\n-> 3\n\n// wrap to ExprInterValue\nExprValue = intervalue(3)\n\nNull\nIf there is an operand evaluates to a NULL value, the enclosing operator will return NULL\nMissing\nIn conventional type checking, if a symbol value can\u2019t been resolved in the env, the exception will been thrown.\nIn permissive mode,\n\nif a symbol value can\u2019t been resolved in the value env, it will return special Missing value.\nif a symbol type can\u2019t been resolved in the type env, the exception will been thrown.\n\nIn general, if any operand evaluates to a MISSING value, the enclosing operator will return MISSING; if none of operands evaluates to a MISSING value but there is an operand evaluates to a NULL value, the enclosing operator will return NULL\nHowever, there are a few exceptions listed in comparison operators and logical operators.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-04-21T22:15:35Z", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436", "merged": true, "mergeCommit": {"oid": "54049bd088f686c09233b9b4820b821b37756b99"}, "closed": true, "closedAt": "2020-04-23T18:10:07Z", "author": {"login": "penghuo"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZlNEWgH2gAyNDA2OTM2NDc5OjdhYWRjNTZlN2M5ZjQ4OTQ4N2Y0YTBlNGY1ZDA3NzBkMDliN2EzODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcagVTwgFqTM5OTMyMDkyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7aadc56e7c9f489487f4a0e4f5d0770d09b7a389", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/7aadc56e7c9f489487f4a0e4f5d0770d09b7a389", "committedDate": "2020-04-20T20:34:57Z", "message": "update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a492de27fa080938b8b8c5c95602448a7083021", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/1a492de27fa080938b8b8c5c95602448a7083021", "committedDate": "2020-04-21T04:51:00Z", "message": "update ut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4", "committedDate": "2020-04-21T22:04:56Z", "message": "add more ut"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzE4ODQw", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#pullrequestreview-397718840", "createdAt": "2020-04-21T22:24:44Z", "commit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoyNDo0NVrOGJbBtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoxNTo0NVrOGJdw-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMzE3NQ==", "bodyText": "One of the two STRING should be STRUCT? Probably JDK EnumSet could be good use here if order doesn't matter.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412533175", "createdAt": "2020-04-21T22:24:45Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/data/model/ExprType.java", "diffHunk": "@@ -29,4 +32,7 @@\n     ARRAY,\n \n     MISSING;\n+\n+    public static List<ExprType> NUMBERS = Arrays.asList(DOUBLE, FLOAT, LONG, INTEGER);\n+    public static List<ExprType> VALID = Arrays.asList(DOUBLE, FLOAT, LONG, INTEGER, BOOLEAN, STRING, STRING, ARRAY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0Mzg3Mg==", "bodyText": "Missed JavaDoc here.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412543872", "createdAt": "2020-04-21T22:48:35Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/data/model/ExprType.java", "diffHunk": "@@ -15,6 +15,9 @@\n \n package com.amazon.opendistroforelasticsearch.sql.data.model;\n \n+import java.util.Arrays;\n+import java.util.List;\n+\n public enum ExprType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NTU3MA==", "bodyText": "The generic type name could be more clear? For example, Environment<Symbol, Value> or <Name, Value> etc.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412545570", "createdAt": "2020-04-21T22:52:32Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/env/Environment.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.env;\n+\n+/**\n+ * The definition of the environment.\n+ */\n+public interface Environment<T, R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MjU5OA==", "bodyText": "Since exception is thrown if function name or #args unmatched, I think we can also throw exception for param types directly?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412562598", "createdAt": "2020-04-21T23:33:35Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionSignature.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.exception.ExpressionEvaluationException;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.List;\n+\n+/**\n+ * Function signature is composed by function name and arguments list.\n+ */\n+@Getter\n+@RequiredArgsConstructor\n+@EqualsAndHashCode\n+public class FunctionSignature {\n+    private final FunctionName functionName;\n+    private final List<ExprType> paramTypeList;\n+\n+    /**\n+     * Check the function signature match or not.\n+     *\n+     * @return 0: exactly match, Integer.MAX: not match, by widening rule small number means better match.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MzY1NA==", "bodyText": "So we just need the closest signature which means the PriorityQueue could be replaced by a FunctionSignature and an integer as its similarity?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412563654", "createdAt": "2020-04-21T23:36:23Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionResolver.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.exception.ExpressionEvaluationException;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Singular;\n+\n+import java.util.AbstractMap;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The Function Resolver hold the overload {@link FunctionExpressionBuilder} implementation.\n+ * is composed by {@link FunctionName} which identified the function name\n+ * and a map of {@link FunctionSignature} and {@link FunctionExpressionBuilder}\n+ * to represent the overloaded implementation\n+ */\n+@Builder\n+@RequiredArgsConstructor\n+public class FunctionResolver {\n+    @Getter\n+    private final FunctionName functionName;\n+    @Singular(\"functionBundle\")\n+    private final Map<FunctionSignature, FunctionExpressionBuilder> functionBundle;\n+\n+    /**\n+     * Resolve the {@link FunctionExpressionBuilder} by using input {@link FunctionSignature}.\n+     * If found the {@link FunctionExpressionBuilder} exactly match the input {@link FunctionSignature}, return it.\n+     * If applying the widening rule, found the most match one, return it.\n+     * If nothing found, throw {@link ExpressionEvaluationException}\n+     */\n+    public FunctionExpressionBuilder resolve(FunctionSignature unresolvedSignature) {\n+        PriorityQueue<Map.Entry<Integer, FunctionSignature>> functionMatchQueue = new PriorityQueue<>(\n+                Comparator.comparing(Map.Entry::getKey));\n+\n+        for (FunctionSignature functionSignature : functionBundle.keySet()) {\n+            int matchingDegree = unresolvedSignature.match(functionSignature);\n+            if (matchingDegree == 0) {\n+                return functionBundle.get(functionSignature);\n+            } else if (matchingDegree != Integer.MAX_VALUE) {\n+                functionMatchQueue.add(new AbstractMap.SimpleEntry<>(matchingDegree, functionSignature));\n+            }\n+        }\n+\n+        if (functionMatchQueue.isEmpty()) {\n+            throw new ExpressionEvaluationException(\n+                    String.format(\"%s function expected %s, but get %s\", functionName,\n+                            formatFunctions(functionBundle.keySet()),\n+                            formatTypes(unresolvedSignature.getParamTypeList())\n+                    ));\n+        } else {\n+            return functionBundle.get(functionMatchQueue.peek().getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjMwNw==", "bodyText": "Better to have some doc for T, U, R's meaning.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412566307", "createdAt": "2020-04-21T23:43:22Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/scalar/OperatorUtils.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.scalar;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionExpressionBuilder;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionName;\n+import lombok.experimental.UtilityClass;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+@UtilityClass\n+public class OperatorUtils {\n+    public static <T, R> FunctionExpressionBuilder binaryOperator(FunctionName functionName,\n+                                                                  BiFunction<T, T, R> function,\n+                                                                  Function<ExprValue, T> observer,\n+                                                                  ExprType returnType) {\n+        return binaryOperator(functionName, function, observer, observer, returnType);\n+    }\n+\n+    public static <T, U, R> FunctionExpressionBuilder binaryOperator(FunctionName functionName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MDcyNA==", "bodyText": "Is it better to use IMPOSSIBLE_WIDENING?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412570724", "createdAt": "2020-04-21T23:55:03Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionSignature.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.exception.ExpressionEvaluationException;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.List;\n+\n+/**\n+ * Function signature is composed by function name and arguments list.\n+ */\n+@Getter\n+@RequiredArgsConstructor\n+@EqualsAndHashCode\n+public class FunctionSignature {\n+    private final FunctionName functionName;\n+    private final List<ExprType> paramTypeList;\n+\n+    /**\n+     * Check the function signature match or not.\n+     *\n+     * @return 0: exactly match, Integer.MAX: not match, by widening rule small number means better match.\n+     */\n+    public int match(FunctionSignature functionSignature) {\n+        if (!functionName.equals(functionSignature.getFunctionName())) {\n+            throw new ExpressionEvaluationException(\n+                    String.format(\"expression name: %s and %s doesn't match\",\n+                            functionName,\n+                            functionSignature.getFunctionName()));\n+        }\n+        List<ExprType> functionTypeList = functionSignature.getParamTypeList();\n+        if (paramTypeList.size() != functionTypeList.size()) {\n+            throw new ExpressionEvaluationException(\n+                    String.format(\"%s expression expected %d argument, but actually are %d\",\n+                            functionName,\n+                            paramTypeList.size(),\n+                            functionTypeList.size()));\n+        }\n+        int matchDegree = 0;\n+        for (int i = 0; i < paramTypeList.size(); i++) {\n+            ExprType paramType = paramTypeList.get(i);\n+            ExprType funcType = functionTypeList.get(i);\n+            int match = WideningTypeRule.distance(paramType, funcType);\n+            if (match == Integer.MAX_VALUE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MTA3Ng==", "bodyText": "\"but distance(FLOAT, INTEGER) =\" impossible?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412571076", "createdAt": "2020-04-21T23:55:59Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/WideningTypeRule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.exception.ExpressionEvaluationException;\n+import com.google.common.collect.ImmutableMap;\n+import lombok.experimental.UtilityClass;\n+\n+import java.util.Map;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.ARRAY;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.BOOLEAN;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.DOUBLE;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.LONG;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.MISSING;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.STRING;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.STRUCT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprType.UNKNOWN;\n+\n+/**\n+ * The definition of widening type rule for expression value.\n+ * ExprType     Widens to data types\n+ * INTEGER      LONG, FLOAT, DOUBLE\n+ * LONG         FLOAT, DOUBLE\n+ * FLOAT        DOUBLE\n+ * DOUBLE       DOUBLE\n+ * STRING       STRING\n+ * BOOLEAN      BOOLEAN\n+ * ARRAY        ARRAY\n+ * STRUCT       STRUCT\n+ */\n+@UtilityClass\n+public class WideningTypeRule {\n+    public static final int IMPOSSIBLE_WIDENING = Integer.MAX_VALUE;\n+    public static final int TYPE_EQUAL = 0;\n+\n+    private static final Map<ExprType, ExprType> typeToWidenParent;\n+\n+    static {\n+        ImmutableMap.Builder<ExprType, ExprType> builder = new ImmutableMap.Builder<>();\n+        builder.put(INTEGER, LONG);\n+        builder.put(LONG, FLOAT);\n+        builder.put(FLOAT, DOUBLE);\n+        builder.put(DOUBLE, UNKNOWN);\n+        builder.put(STRING, UNKNOWN);\n+        builder.put(BOOLEAN, UNKNOWN);\n+        builder.put(ARRAY, UNKNOWN);\n+        builder.put(STRUCT, UNKNOWN);\n+        builder.put(MISSING, UNKNOWN);\n+        typeToWidenParent = builder.build();\n+    }\n+\n+    /**\n+     * The widening distance is calculated from the leaf to root.\n+     * e.g. distance(INTEGER, FLOAT) = 2, but distance(FLOAT, INTEGER) =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3ODA0Mg==", "bodyText": "Just a question, do we handle NULL or MISSING somewhere? Not sure about SPL spec but both are following some rules to propagate during evaluation in SQL and PartiQL spec.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#discussion_r412578042", "createdAt": "2020-04-22T00:15:45Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/scalar/OperatorUtils.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.scalar;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionExpressionBuilder;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionName;\n+import lombok.experimental.UtilityClass;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+@UtilityClass\n+public class OperatorUtils {\n+    public static <T, R> FunctionExpressionBuilder binaryOperator(FunctionName functionName,\n+                                                                  BiFunction<T, T, R> function,\n+                                                                  Function<ExprValue, T> observer,\n+                                                                  ExprType returnType) {\n+        return binaryOperator(functionName, function, observer, observer, returnType);\n+    }\n+\n+    public static <T, U, R> FunctionExpressionBuilder binaryOperator(FunctionName functionName,\n+                                                                     BiFunction<T, U, R> function,\n+                                                                     Function<ExprValue, T> observer1,\n+                                                                     Function<ExprValue, U> observer2,\n+                                                                     ExprType returnType) {\n+        return arguments -> new FunctionExpression(functionName, arguments) {\n+            @Override\n+            public ExprValue valueOf(Environment<Expression, ExprValue> env) {\n+                ExprValue arg1 = arguments.get(0).valueOf(env);\n+                ExprValue arg2 = arguments.get(1).valueOf(env);\n+                return ExprValueUtils.fromObjectValue(\n+                        function.apply(observer1.apply(arg1), observer2.apply(arg2)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a6aae95203cb2f8de26b00d3b1d2d277a18a7a4"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f78f79de915555f33a435881270260a3004e1ec4", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/f78f79de915555f33a435881270260a3004e1ec4", "committedDate": "2020-04-23T04:20:21Z", "message": "support missing and null value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40d1e903f99b73c3cb5c47c31fa16f2a7ff0ab7f", "author": {"user": {"login": "penghuo", "name": "Peng Huo"}}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/40d1e903f99b73c3cb5c47c31fa16f2a7ff0ab7f", "committedDate": "2020-04-23T14:49:47Z", "message": "update doc and BuiltinFunctionRepository interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzAwNzQ1", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#pullrequestreview-399300745", "createdAt": "2020-04-23T17:02:58Z", "commit": {"oid": "40d1e903f99b73c3cb5c47c31fa16f2a7ff0ab7f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzIwOTIy", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/436#pullrequestreview-399320922", "createdAt": "2020-04-23T17:28:21Z", "commit": {"oid": "40d1e903f99b73c3cb5c47c31fa16f2a7ff0ab7f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 658, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}