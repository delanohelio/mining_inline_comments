{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3Mjg2MzE0", "number": 620, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzoyNjo1MlrOETCXIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzozOTowMlrOETCiBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzk3MDkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzoyNjo1MlrOG4jMBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozNToyMlrOG4-QhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0OTk1Ng==", "bodyText": "np: the impl() for binary function returns Function as below rather than SerializableFunction?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/620#discussion_r461949956", "createdAt": "2020-07-28T23:26:52Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.experimental.UtilityClass;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Function Define Utility.\n+ */\n+@UtilityClass\n+public class FunctionDSL {\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>... functions) {\n+    return define(functionName, Arrays.asList(functions));\n+  }\n+\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 List<Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>> functions) {\n+\n+    FunctionResolver.FunctionResolverBuilder builder = FunctionResolver.builder();\n+    builder.functionName(functionName);\n+    for (Function<FunctionName, Pair<FunctionSignature, FunctionBuilder>> func : functions) {\n+      Pair<FunctionSignature, FunctionBuilder> functionBuilder = func.apply(functionName);\n+      builder.functionBundle(functionBuilder.getKey(), functionBuilder.getValue());\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Unary Function Implementation.\n+   *\n+   * @param function   {@link ExprValue} based unary function.\n+   * @param returnType return type.\n+   * @param argsType   argument type.\n+   * @return Unary Function Implementation.\n+   */\n+  public SerializableFunction<FunctionName, Pair<FunctionSignature, FunctionBuilder>> impl(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b44d420d0b836ffff636ba39d1a1d90c50439ffb"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MzQ3Nw==", "bodyText": "Done.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/620#discussion_r462393477", "createdAt": "2020-07-29T15:35:22Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.experimental.UtilityClass;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Function Define Utility.\n+ */\n+@UtilityClass\n+public class FunctionDSL {\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>... functions) {\n+    return define(functionName, Arrays.asList(functions));\n+  }\n+\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 List<Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>> functions) {\n+\n+    FunctionResolver.FunctionResolverBuilder builder = FunctionResolver.builder();\n+    builder.functionName(functionName);\n+    for (Function<FunctionName, Pair<FunctionSignature, FunctionBuilder>> func : functions) {\n+      Pair<FunctionSignature, FunctionBuilder> functionBuilder = func.apply(functionName);\n+      builder.functionBundle(functionBuilder.getKey(), functionBuilder.getValue());\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Unary Function Implementation.\n+   *\n+   * @param function   {@link ExprValue} based unary function.\n+   * @param returnType return type.\n+   * @param argsType   argument type.\n+   * @return Unary Function Implementation.\n+   */\n+  public SerializableFunction<FunctionName, Pair<FunctionSignature, FunctionBuilder>> impl(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0OTk1Ng=="}, "originalCommit": {"oid": "b44d420d0b836ffff636ba39d1a1d90c50439ffb"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzk5ODc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzozOTowMlrOG4jcBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0MDowNFrOG4-dYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDA1NA==", "bodyText": "I may miss it somewhere. Where is this MISSING/NULL check logic for the impl() below?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/620#discussion_r461954054", "createdAt": "2020-07-28T23:39:02Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.experimental.UtilityClass;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Function Define Utility.\n+ */\n+@UtilityClass\n+public class FunctionDSL {\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>... functions) {\n+    return define(functionName, Arrays.asList(functions));\n+  }\n+\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 List<Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>> functions) {\n+\n+    FunctionResolver.FunctionResolverBuilder builder = FunctionResolver.builder();\n+    builder.functionName(functionName);\n+    for (Function<FunctionName, Pair<FunctionSignature, FunctionBuilder>> func : functions) {\n+      Pair<FunctionSignature, FunctionBuilder> functionBuilder = func.apply(functionName);\n+      builder.functionBundle(functionBuilder.getKey(), functionBuilder.getValue());\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Unary Function Implementation.\n+   *\n+   * @param function   {@link ExprValue} based unary function.\n+   * @param returnType return type.\n+   * @param argsType   argument type.\n+   * @return Unary Function Implementation.\n+   */\n+  public SerializableFunction<FunctionName, Pair<FunctionSignature, FunctionBuilder>> impl(\n+      SerializableFunction<ExprValue, ExprValue> function,\n+      ExprType returnType,\n+      ExprType argsType) {\n+\n+    return functionName -> {\n+      FunctionSignature functionSignature =\n+          new FunctionSignature(functionName, Collections.singletonList(argsType));\n+      FunctionBuilder functionBuilder =\n+          arguments -> new FunctionExpression(functionName, arguments) {\n+            @Override\n+            public ExprValue valueOf(Environment<Expression, ExprValue> valueEnv) {\n+              ExprValue value = arguments.get(0).valueOf(valueEnv);\n+              if (value.isMissing()) {\n+                return ExprValueUtils.missingValue();\n+              } else if (value.isNull()) {\n+                return ExprValueUtils.nullValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b44d420d0b836ffff636ba39d1a1d90c50439ffb"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5Njc2OA==", "bodyText": "Good points.\nRemove the NULL/MISSING generic handling logic in FunctionDSL.impl, and provide another utilit method nullMissingHandling to the client. The reason for doing that is (1) most of operator/function follow the generic missing/null handling logic. (2) but some doesn't follow that e.g. and/or/xor.\n  public SerializableFunction<ExprValue, ExprValue> nullMissingHandling(\n      SerializableFunction<ExprValue, ExprValue> function) {\n    return value -> {\n      if (value.isMissing()) {\n        return ExprValueUtils.missingValue();\n      } else if (value.isNull()) {\n        return ExprValueUtils.nullValue();\n      } else {\n        return function.apply(value);\n      }\n    };\n  }\n\nThe client could make decision whetehr it want to follow the generic rule or not.\nFunctionDSL.impl(FunctionDSL.nullMissingHandling(DateTimeFunction::exprDayOfMonth),\n            INTEGER, DATE)", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/620#discussion_r462396768", "createdAt": "2020-07-29T15:40:04Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/function/FunctionDSL.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.function;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.FunctionExpression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.env.Environment;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.experimental.UtilityClass;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Function Define Utility.\n+ */\n+@UtilityClass\n+public class FunctionDSL {\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>... functions) {\n+    return define(functionName, Arrays.asList(functions));\n+  }\n+\n+  /**\n+   * Define overloaded function with implementation.\n+   *\n+   * @param functionName function name.\n+   * @param functions    a list of function implementation.\n+   * @return FunctionResolver.\n+   */\n+  public FunctionResolver define(FunctionName functionName,\n+                                 List<Function<FunctionName, Pair<FunctionSignature,\n+                                     FunctionBuilder>>> functions) {\n+\n+    FunctionResolver.FunctionResolverBuilder builder = FunctionResolver.builder();\n+    builder.functionName(functionName);\n+    for (Function<FunctionName, Pair<FunctionSignature, FunctionBuilder>> func : functions) {\n+      Pair<FunctionSignature, FunctionBuilder> functionBuilder = func.apply(functionName);\n+      builder.functionBundle(functionBuilder.getKey(), functionBuilder.getValue());\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Unary Function Implementation.\n+   *\n+   * @param function   {@link ExprValue} based unary function.\n+   * @param returnType return type.\n+   * @param argsType   argument type.\n+   * @return Unary Function Implementation.\n+   */\n+  public SerializableFunction<FunctionName, Pair<FunctionSignature, FunctionBuilder>> impl(\n+      SerializableFunction<ExprValue, ExprValue> function,\n+      ExprType returnType,\n+      ExprType argsType) {\n+\n+    return functionName -> {\n+      FunctionSignature functionSignature =\n+          new FunctionSignature(functionName, Collections.singletonList(argsType));\n+      FunctionBuilder functionBuilder =\n+          arguments -> new FunctionExpression(functionName, arguments) {\n+            @Override\n+            public ExprValue valueOf(Environment<Expression, ExprValue> valueEnv) {\n+              ExprValue value = arguments.get(0).valueOf(valueEnv);\n+              if (value.isMissing()) {\n+                return ExprValueUtils.missingValue();\n+              } else if (value.isNull()) {\n+                return ExprValueUtils.nullValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDA1NA=="}, "originalCommit": {"oid": "b44d420d0b836ffff636ba39d1a1d90c50439ffb"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1966, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}