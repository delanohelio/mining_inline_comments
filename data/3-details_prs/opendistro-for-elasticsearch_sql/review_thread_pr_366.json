{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjI1MzQ4", "number": 366, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyNjo0M1rODfq5Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyNjo0M1rODfq5Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTM1MjMxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistroforelasticsearch/sql/doctest/core/response/SqlResponseFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyNjo0M1rOFpgpig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNzo1NjoxMlrOFqscIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3MDg1OA==", "bodyText": "minor, Implement Ordering seems much readable.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/366#discussion_r379070858", "createdAt": "2020-02-13T19:26:43Z", "author": {"login": "penghuo"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/sql/doctest/core/response/SqlResponseFormat.java", "diffHunk": "@@ -84,4 +73,63 @@ public String format(SqlResponse sqlResponse) {\n      */\n     public abstract String format(SqlResponse sqlResponse);\n \n+    /**\n+     * Note that we put this format() here because it's shared by two format enums.\n+     * @param sqlResponse   original response from plugin\n+     * @param isSorted      true to sort the result or just leave it as is\n+     */\n+    protected String format(SqlResponse sqlResponse, boolean isSorted) {\n+        JSONObject body = new JSONObject(sqlResponse.body());\n+        if (body.isNull(\"schema\")) {\n+            throw new IllegalStateException(\n+                \"Only JDBC response can be formatted to table: \" + sqlResponse.body());\n+        }\n+\n+        Object[] header = parseHeader(body.getJSONArray(\"schema\"));\n+        List<Object[]> rows = parseDataRows(body.getJSONArray(\"datarows\"), isSorted);\n+\n+        DataTable table = new DataTable(header);\n+        for (Object[] row : rows) {\n+            table.addRow(row);\n+        }\n+        return table.toString();\n+    }\n+\n+    private Object[] parseHeader(JSONArray schema) {\n+        Object[] header = new Object[schema.length()];\n+        for (int i = 0; i < header.length; i++) {\n+            JSONObject nameType = schema.getJSONObject(i);\n+            header[i] = nameType.optString(\"alias\", nameType.getString(\"name\"));\n+        }\n+        return header;\n+    }\n+\n+    private List<Object[]> parseDataRows(JSONArray rows, boolean isSorted) {\n+        List<Object[]> rowsToSort = new ArrayList<>();\n+        for (Object row : rows) {\n+            rowsToSort.add(((JSONArray) row).toList().toArray());\n+        }\n+\n+        if (isSorted) {\n+            sort(rowsToSort);\n+        }\n+        return rowsToSort;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a957a12431cdfbb71cf00469e97b848330d0956"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMxMjYxMA==", "bodyText": "Good suggestion. I tried it out but our case seems different (sorting 2 lists of objects and Ordering only works for object comparison). Will refactor this part if I can find how to covert it to list comparator later. Thanks!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/366#discussion_r380312610", "createdAt": "2020-02-17T17:56:12Z", "author": {"login": "dai-chen"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/sql/doctest/core/response/SqlResponseFormat.java", "diffHunk": "@@ -84,4 +73,63 @@ public String format(SqlResponse sqlResponse) {\n      */\n     public abstract String format(SqlResponse sqlResponse);\n \n+    /**\n+     * Note that we put this format() here because it's shared by two format enums.\n+     * @param sqlResponse   original response from plugin\n+     * @param isSorted      true to sort the result or just leave it as is\n+     */\n+    protected String format(SqlResponse sqlResponse, boolean isSorted) {\n+        JSONObject body = new JSONObject(sqlResponse.body());\n+        if (body.isNull(\"schema\")) {\n+            throw new IllegalStateException(\n+                \"Only JDBC response can be formatted to table: \" + sqlResponse.body());\n+        }\n+\n+        Object[] header = parseHeader(body.getJSONArray(\"schema\"));\n+        List<Object[]> rows = parseDataRows(body.getJSONArray(\"datarows\"), isSorted);\n+\n+        DataTable table = new DataTable(header);\n+        for (Object[] row : rows) {\n+            table.addRow(row);\n+        }\n+        return table.toString();\n+    }\n+\n+    private Object[] parseHeader(JSONArray schema) {\n+        Object[] header = new Object[schema.length()];\n+        for (int i = 0; i < header.length; i++) {\n+            JSONObject nameType = schema.getJSONObject(i);\n+            header[i] = nameType.optString(\"alias\", nameType.getString(\"name\"));\n+        }\n+        return header;\n+    }\n+\n+    private List<Object[]> parseDataRows(JSONArray rows, boolean isSorted) {\n+        List<Object[]> rowsToSort = new ArrayList<>();\n+        for (Object row : rows) {\n+            rowsToSort.add(((JSONArray) row).toList().toArray());\n+        }\n+\n+        if (isSorted) {\n+            sort(rowsToSort);\n+        }\n+        return rowsToSort;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3MDg1OA=="}, "originalCommit": {"oid": "7a957a12431cdfbb71cf00469e97b848330d0956"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2174, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}