{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNjQ1NDgz", "number": 663, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjozNzo0NlrOEWA9TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzowNzo0MFrOEWBWFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTE5ODIxOnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/data/value/ElasticsearchExprValueFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjozNzo0NlrOG9Geyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzozMDo1OFrOG9HhKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyMjUwNw==", "bodyText": "Add some comments? Why not construct the different value based on Type?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466722507", "createdAt": "2020-08-06T22:37:46Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/data/value/ElasticsearchExprValueFactory.java", "diffHunk": "@@ -121,6 +124,49 @@ private ExprValue construct(String field, JsonNode value) {\n     }\n   }\n \n+  /**\n+   * Construct ExprValue from field and its value object. Throw exception if trying\n+   * to construct from field of unsupported type.\n+   *\n+   * @param field   field name\n+   * @param value   value object\n+   * @return        ExprValue\n+   */\n+  public ExprValue construct(String field, Object value) {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+\n+    ExprType type = type(field);\n+    if (type.equals(INTEGER)) {\n+      return constructInteger((Integer) value);\n+    } else if (type.equals(LONG)) {\n+      return constructLong((Long) value);\n+    } else if (type.equals(FLOAT)) {\n+      return constructFloat((Float) value);\n+    } else if (type.equals(DOUBLE)) {\n+      return constructDouble((Double) value);\n+    } else if (type.equals(STRING)) {\n+      return constructString((String) value);\n+    } else if (type.equals(BOOLEAN)) {\n+      return constructBoolean((Boolean) value);\n+    } else if (type.equals(TIMESTAMP)) {\n+      if (value instanceof Number) {\n+        return constructTimestamp((Long) value);\n+      } else if (value instanceof Instant) {\n+        return constructTimestamp((Instant) value);\n+      } else {\n+        return constructTimestamp(String.valueOf(value));\n+      }\n+    } else if (ES_TEXT.isCompatible(type)) {\n+      return new ElasticsearchExprTextValue((String) value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczOTQ5Ng==", "bodyText": "Sure, will add a new ExprValue class to differentiate text and multi-field.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466739496", "createdAt": "2020-08-06T23:30:58Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/data/value/ElasticsearchExprValueFactory.java", "diffHunk": "@@ -121,6 +124,49 @@ private ExprValue construct(String field, JsonNode value) {\n     }\n   }\n \n+  /**\n+   * Construct ExprValue from field and its value object. Throw exception if trying\n+   * to construct from field of unsupported type.\n+   *\n+   * @param field   field name\n+   * @param value   value object\n+   * @return        ExprValue\n+   */\n+  public ExprValue construct(String field, Object value) {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+\n+    ExprType type = type(field);\n+    if (type.equals(INTEGER)) {\n+      return constructInteger((Integer) value);\n+    } else if (type.equals(LONG)) {\n+      return constructLong((Long) value);\n+    } else if (type.equals(FLOAT)) {\n+      return constructFloat((Float) value);\n+    } else if (type.equals(DOUBLE)) {\n+      return constructDouble((Double) value);\n+    } else if (type.equals(STRING)) {\n+      return constructString((String) value);\n+    } else if (type.equals(BOOLEAN)) {\n+      return constructBoolean((Boolean) value);\n+    } else if (type.equals(TIMESTAMP)) {\n+      if (value instanceof Number) {\n+        return constructTimestamp((Long) value);\n+      } else if (value instanceof Instant) {\n+        return constructTimestamp((Instant) value);\n+      } else {\n+        return constructTimestamp(String.valueOf(value));\n+      }\n+    } else if (ES_TEXT.isCompatible(type)) {\n+      return new ElasticsearchExprTextValue((String) value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyMjUwNw=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTIyMTU0OnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/ElasticsearchIndex.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo0ODozM1rOG9GtCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0MDoxM1rOG9sFUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNjE1NA==", "bodyText": "What happen if there are multiple filter, e.g. source=index | filter a = 1 | filter b = 1", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466726154", "createdAt": "2020-08-06T22:48:33Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/ElasticsearchIndex.java", "diffHunk": "@@ -87,6 +92,20 @@ public PhysicalPlan implement(LogicalPlan plan) {\n      * index scan.\n      */\n     return plan.accept(new DefaultImplementor<ElasticsearchIndexScan>() {\n+          @Override\n+          public PhysicalPlan visitFilter(LogicalFilter node, ElasticsearchIndexScan context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczOTcxNw==", "bodyText": "Good point. Will double check and add PPL IT (ex. where | fields | where) to make sure this can be handled properly. Thanks!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466739717", "createdAt": "2020-08-06T23:31:41Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/ElasticsearchIndex.java", "diffHunk": "@@ -87,6 +92,20 @@ public PhysicalPlan implement(LogicalPlan plan) {\n      * index scan.\n      */\n     return plan.accept(new DefaultImplementor<ElasticsearchIndexScan>() {\n+          @Override\n+          public PhysicalPlan visitFilter(LogicalFilter node, ElasticsearchIndexScan context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNjE1NA=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODU3Nw==", "bodyText": "Added logic to handle multiple filter operator pushdown and UT/IT to test. We may need to improve our planner soon since current index scan operator assumes all push down is around original data source. I guess if we do where | stats | where, the result would be wrong.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r467338577", "createdAt": "2020-08-08T00:40:13Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/ElasticsearchIndex.java", "diffHunk": "@@ -87,6 +92,20 @@ public PhysicalPlan implement(LogicalPlan plan) {\n      * index scan.\n      */\n     return plan.accept(new DefaultImplementor<ElasticsearchIndexScan>() {\n+          @Override\n+          public PhysicalPlan visitFilter(LogicalFilter node, ElasticsearchIndexScan context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNjE1NA=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTIyNjI2OnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/ExpressionScriptEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo1MDo0NFrOG9Gv6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMToyMzo0NlrOG9oPBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNjg4OQ==", "bodyText": "our expression -> core engine expression?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466726889", "createdAt": "2020-08-06T22:50:44Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/ExpressionScriptEngine.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script;\n+\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter.ExpressionFilterScriptFactory;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.serialization.ExpressionSerializer;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import lombok.RequiredArgsConstructor;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+\n+/**\n+ * Custom expression script engine that supports using our expression code in DSL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NTUyNw==", "bodyText": "Done!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r467275527", "createdAt": "2020-08-07T21:23:46Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/ExpressionScriptEngine.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script;\n+\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter.ExpressionFilterScriptFactory;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.serialization.ExpressionSerializer;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import lombok.RequiredArgsConstructor;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+\n+/**\n+ * Custom expression script engine that supports using our expression code in DSL", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNjg4OQ=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTIyODY4OnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo1MTo1NVrOG9GxYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMToyNDoyOFrOG9oRIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNzI2Nw==", "bodyText": "we ourserlves?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466727267", "createdAt": "2020-08-06T22:51:55Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NjA2Nw==", "bodyText": "Done!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r467276067", "createdAt": "2020-08-07T21:24:28Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNzI2Nw=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTI1NDQ4OnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzowNDoxNVrOG9HA4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMjozNjoxMVrOG9qm9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMTIzNQ==", "bodyText": "Missing handling?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466731235", "createdAt": "2020-08-06T23:04:15Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.\n+    SpecialPermission.check();\n+\n+    return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+      Set<ReferenceExpression> fields = extractFields(expression);\n+      ElasticsearchExprValueFactory valueFactory = buildValueFactory(fields);\n+      Map<String, ExprValue> valueEnv = buildValueEnv(fields, valueFactory);\n+      ExprValue result = evaluateExpression(valueEnv);\n+      return (Boolean) result.value();\n+    });\n+  }\n+\n+  private Set<ReferenceExpression> extractFields(Expression expr) {\n+    Set<ReferenceExpression> fields = new HashSet<>();\n+    expr.accept(new ExpressionNodeVisitor<Object, Set<ReferenceExpression>>() {\n+      @Override\n+      public Object visitReference(ReferenceExpression node, Set<ReferenceExpression> context) {\n+        context.add(node);\n+        return null;\n+      }\n+    }, fields);\n+    return fields;\n+  }\n+\n+  private ElasticsearchExprValueFactory buildValueFactory(Set<ReferenceExpression> fields) {\n+    Map<String, ExprType> typeEnv = fields.stream()\n+                                          .collect(toMap(\n+                                              ReferenceExpression::getAttr,\n+                                              ReferenceExpression::type));\n+    return new ElasticsearchExprValueFactory(typeEnv);\n+  }\n+\n+  private Map<String, ExprValue> buildValueEnv(Set<ReferenceExpression> fields,\n+                                               ElasticsearchExprValueFactory valueFactory) {\n+    Map<String, ExprValue> valueEnv = new HashMap<>();\n+    for (ReferenceExpression field : fields) {\n+      String fieldName = field.getAttr();\n+      ExprValue exprValue = valueFactory.construct(fieldName, getDocValue(field));\n+      valueEnv.put(fieldName, exprValue);\n+    }\n+    return valueEnv;\n+  }\n+\n+  private Object getDocValue(ReferenceExpression field) {\n+    String fieldName = getDocValueName(field);\n+    ScriptDocValues<?> docValue = getDoc().get(fieldName);\n+    if (docValue == null || docValue.isEmpty()) {\n+      return null;\n+    }\n+\n+    Object value = docValue.get(0);\n+    if (value instanceof ChronoZonedDateTime) {\n+      return ((ChronoZonedDateTime<?>) value).toInstant();\n+    }\n+    return castNumberToFieldType(value, field.type());\n+  }\n+\n+  /**\n+   * Text field doesn't have doc value (exception thrown even when you call \"get\")\n+   * Limitation: assume inner field name is always \"keyword\".\n+   */\n+  private String getDocValueName(ReferenceExpression field) {\n+    String fieldName = field.getAttr();\n+    if (field.type() == ES_TEXT_KEYWORD) {\n+      fieldName += \".keyword\";\n+    }\n+    return fieldName;\n+  }\n+\n+  /**\n+   * DocValue only support long and double so cast to integer and float if needed.\n+   * The doc value must be Long and Double for expr type Long/Integer and Double/Float respectively.\n+   * Otherwise there must be bugs in our engine that causes the mismatch.\n+   */\n+  private Object castNumberToFieldType(Object value, ExprType type) {\n+    if (type == INTEGER) {\n+      return ((Long) value).intValue();\n+    } else if (type == FLOAT) {\n+      return ((Double) value).floatValue();\n+    } else {\n+      return value;\n+    }\n+  }\n+\n+  private ExprValue evaluateExpression(Map<String, ExprValue> valueEnv) {\n+    ExprTupleValue tupleValue = ExprTupleValue.fromExprValueMap(valueEnv);\n+    ExprValue result = expression.valueOf(tupleValue.bindingTuples());\n+\n+    if (result.isNull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc0MDAyMQ==", "bodyText": "Since no missing concept in JAVA, will add a MISSING constant in value factory. And will add test case for null field.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466740021", "createdAt": "2020-08-06T23:32:41Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.\n+    SpecialPermission.check();\n+\n+    return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+      Set<ReferenceExpression> fields = extractFields(expression);\n+      ElasticsearchExprValueFactory valueFactory = buildValueFactory(fields);\n+      Map<String, ExprValue> valueEnv = buildValueEnv(fields, valueFactory);\n+      ExprValue result = evaluateExpression(valueEnv);\n+      return (Boolean) result.value();\n+    });\n+  }\n+\n+  private Set<ReferenceExpression> extractFields(Expression expr) {\n+    Set<ReferenceExpression> fields = new HashSet<>();\n+    expr.accept(new ExpressionNodeVisitor<Object, Set<ReferenceExpression>>() {\n+      @Override\n+      public Object visitReference(ReferenceExpression node, Set<ReferenceExpression> context) {\n+        context.add(node);\n+        return null;\n+      }\n+    }, fields);\n+    return fields;\n+  }\n+\n+  private ElasticsearchExprValueFactory buildValueFactory(Set<ReferenceExpression> fields) {\n+    Map<String, ExprType> typeEnv = fields.stream()\n+                                          .collect(toMap(\n+                                              ReferenceExpression::getAttr,\n+                                              ReferenceExpression::type));\n+    return new ElasticsearchExprValueFactory(typeEnv);\n+  }\n+\n+  private Map<String, ExprValue> buildValueEnv(Set<ReferenceExpression> fields,\n+                                               ElasticsearchExprValueFactory valueFactory) {\n+    Map<String, ExprValue> valueEnv = new HashMap<>();\n+    for (ReferenceExpression field : fields) {\n+      String fieldName = field.getAttr();\n+      ExprValue exprValue = valueFactory.construct(fieldName, getDocValue(field));\n+      valueEnv.put(fieldName, exprValue);\n+    }\n+    return valueEnv;\n+  }\n+\n+  private Object getDocValue(ReferenceExpression field) {\n+    String fieldName = getDocValueName(field);\n+    ScriptDocValues<?> docValue = getDoc().get(fieldName);\n+    if (docValue == null || docValue.isEmpty()) {\n+      return null;\n+    }\n+\n+    Object value = docValue.get(0);\n+    if (value instanceof ChronoZonedDateTime) {\n+      return ((ChronoZonedDateTime<?>) value).toInstant();\n+    }\n+    return castNumberToFieldType(value, field.type());\n+  }\n+\n+  /**\n+   * Text field doesn't have doc value (exception thrown even when you call \"get\")\n+   * Limitation: assume inner field name is always \"keyword\".\n+   */\n+  private String getDocValueName(ReferenceExpression field) {\n+    String fieldName = field.getAttr();\n+    if (field.type() == ES_TEXT_KEYWORD) {\n+      fieldName += \".keyword\";\n+    }\n+    return fieldName;\n+  }\n+\n+  /**\n+   * DocValue only support long and double so cast to integer and float if needed.\n+   * The doc value must be Long and Double for expr type Long/Integer and Double/Float respectively.\n+   * Otherwise there must be bugs in our engine that causes the mismatch.\n+   */\n+  private Object castNumberToFieldType(Object value, ExprType type) {\n+    if (type == INTEGER) {\n+      return ((Long) value).intValue();\n+    } else if (type == FLOAT) {\n+      return ((Double) value).floatValue();\n+    } else {\n+      return value;\n+    }\n+  }\n+\n+  private ExprValue evaluateExpression(Map<String, ExprValue> valueEnv) {\n+    ExprTupleValue tupleValue = ExprTupleValue.fromExprValueMap(valueEnv);\n+    ExprValue result = expression.valueOf(tupleValue.bindingTuples());\n+\n+    if (result.isNull()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMTIzNQ=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNDQyMA==", "bodyText": "I added missing value check here. But I found that there seems no way to differentiate null and missing in doc value. I tried the following index. Both null_field and missing_field in 2nd doc gives a script doc value object with empty list inside. Will confirm and come back to this later.\nPUT null_and_missing/_doc/1\n{\n  \"null_field\": \"abc\",\n  \"missing_field\": 456\n}\n\nPUT null_and_missing/_doc/2\n{\n  \"null_field\": null\n}", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r467314420", "createdAt": "2020-08-07T22:36:11Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.\n+    SpecialPermission.check();\n+\n+    return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+      Set<ReferenceExpression> fields = extractFields(expression);\n+      ElasticsearchExprValueFactory valueFactory = buildValueFactory(fields);\n+      Map<String, ExprValue> valueEnv = buildValueEnv(fields, valueFactory);\n+      ExprValue result = evaluateExpression(valueEnv);\n+      return (Boolean) result.value();\n+    });\n+  }\n+\n+  private Set<ReferenceExpression> extractFields(Expression expr) {\n+    Set<ReferenceExpression> fields = new HashSet<>();\n+    expr.accept(new ExpressionNodeVisitor<Object, Set<ReferenceExpression>>() {\n+      @Override\n+      public Object visitReference(ReferenceExpression node, Set<ReferenceExpression> context) {\n+        context.add(node);\n+        return null;\n+      }\n+    }, fields);\n+    return fields;\n+  }\n+\n+  private ElasticsearchExprValueFactory buildValueFactory(Set<ReferenceExpression> fields) {\n+    Map<String, ExprType> typeEnv = fields.stream()\n+                                          .collect(toMap(\n+                                              ReferenceExpression::getAttr,\n+                                              ReferenceExpression::type));\n+    return new ElasticsearchExprValueFactory(typeEnv);\n+  }\n+\n+  private Map<String, ExprValue> buildValueEnv(Set<ReferenceExpression> fields,\n+                                               ElasticsearchExprValueFactory valueFactory) {\n+    Map<String, ExprValue> valueEnv = new HashMap<>();\n+    for (ReferenceExpression field : fields) {\n+      String fieldName = field.getAttr();\n+      ExprValue exprValue = valueFactory.construct(fieldName, getDocValue(field));\n+      valueEnv.put(fieldName, exprValue);\n+    }\n+    return valueEnv;\n+  }\n+\n+  private Object getDocValue(ReferenceExpression field) {\n+    String fieldName = getDocValueName(field);\n+    ScriptDocValues<?> docValue = getDoc().get(fieldName);\n+    if (docValue == null || docValue.isEmpty()) {\n+      return null;\n+    }\n+\n+    Object value = docValue.get(0);\n+    if (value instanceof ChronoZonedDateTime) {\n+      return ((ChronoZonedDateTime<?>) value).toInstant();\n+    }\n+    return castNumberToFieldType(value, field.type());\n+  }\n+\n+  /**\n+   * Text field doesn't have doc value (exception thrown even when you call \"get\")\n+   * Limitation: assume inner field name is always \"keyword\".\n+   */\n+  private String getDocValueName(ReferenceExpression field) {\n+    String fieldName = field.getAttr();\n+    if (field.type() == ES_TEXT_KEYWORD) {\n+      fieldName += \".keyword\";\n+    }\n+    return fieldName;\n+  }\n+\n+  /**\n+   * DocValue only support long and double so cast to integer and float if needed.\n+   * The doc value must be Long and Double for expr type Long/Integer and Double/Float respectively.\n+   * Otherwise there must be bugs in our engine that causes the mismatch.\n+   */\n+  private Object castNumberToFieldType(Object value, ExprType type) {\n+    if (type == INTEGER) {\n+      return ((Long) value).intValue();\n+    } else if (type == FLOAT) {\n+      return ((Double) value).floatValue();\n+    } else {\n+      return value;\n+    }\n+  }\n+\n+  private ExprValue evaluateExpression(Map<String, ExprValue> valueEnv) {\n+    ExprTupleValue tupleValue = ExprTupleValue.fromExprValueMap(valueEnv);\n+    ExprValue result = expression.valueOf(tupleValue.bindingTuples());\n+\n+    if (result.isNull()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMTIzNQ=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTI2MTY1OnYy", "diffSide": "RIGHT", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzowNzo0MFrOG9HFRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMzozMzoxNVrOG9HjrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMjM1OQ==", "bodyText": "NP, Could we impl BindingTuple and encapsulate these logic in that to achive the same concept of valueEnv.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466732359", "createdAt": "2020-08-06T23:07:40Z", "author": {"login": "penghuo"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.\n+    SpecialPermission.check();\n+\n+    return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+      Set<ReferenceExpression> fields = extractFields(expression);\n+      ElasticsearchExprValueFactory valueFactory = buildValueFactory(fields);\n+      Map<String, ExprValue> valueEnv = buildValueEnv(fields, valueFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc0MDE0MQ==", "bodyText": "Sure, will add a new Environment class to encapsulate the map data structure. Thanks!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/663#discussion_r466740141", "createdAt": "2020-08-06T23:33:15Z", "author": {"login": "dai-chen"}, "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/storage/script/filter/ExpressionFilterScript.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.storage.script.filter;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.type.ElasticsearchDataType.ES_TEXT_KEYWORD;\n+import static java.util.stream.Collectors.toMap;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchExprValueFactory;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ExpressionNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.expression.ReferenceExpression;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.EqualsAndHashCode;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.SpecialPermission;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.FilterScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+/**\n+ * Expression script executor that executes the expression on each document\n+ * and determine if the document is supposed to be filtered out or not.\n+ */\n+@EqualsAndHashCode(callSuper = false)\n+class ExpressionFilterScript extends FilterScript {\n+\n+  /**\n+   * Expression to execute.\n+   */\n+  private final Expression expression;\n+\n+  public ExpressionFilterScript(Expression expression,\n+                                SearchLookup lookup,\n+                                LeafReaderContext context,\n+                                Map<String, Object> params) {\n+    super(params, lookup, context);\n+    this.expression = expression;\n+  }\n+\n+  @Override\n+  public boolean execute() {\n+    // Check we ourselves are not being called by unprivileged code.\n+    SpecialPermission.check();\n+\n+    return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+      Set<ReferenceExpression> fields = extractFields(expression);\n+      ElasticsearchExprValueFactory valueFactory = buildValueFactory(fields);\n+      Map<String, ExprValue> valueEnv = buildValueEnv(fields, valueFactory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMjM1OQ=="}, "originalCommit": {"oid": "154358a1b3e0a5a3a93c9abcdcccda482b087fc3"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1982, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}