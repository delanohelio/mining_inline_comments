{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1ODM0NzA5", "number": 764, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0MjowMlrOEpkt7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0MzowMFrOEpkvIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDI4NjUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0MjowMlrOHbUvLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoyMzozMlrOHbWFcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzM1Nw==", "bodyText": "Not sure the use case. Do you try to do something like this format.replace(\"%\\W\", () -> replace).\nIf so, i recommended to consider the https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)\nwhich provide the more clean code structure.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498413357", "createdAt": "2020-10-01T17:42:02Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNTQ0MQ==", "bodyText": "I didn't realize I could do this, tahnks for the suggestion! I have updated with this change.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498435441", "createdAt": "2020-10-01T18:23:32Z", "author": {"login": "lyndonb-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzM1Nw=="}, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDI4OTYzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzo0MzowMFrOHbUxMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxODo0NFrOHbV7yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzg3Mw==", "bodyText": "What is the expected result if the user input the format string which we doesn't support?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498413873", "createdAt": "2020-10-01T17:43:00Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {\n+    String format = formatExpr.stringValue();\n+    final LocalDateTime date = dateExpr.datetimeValue();\n+    for (Map.Entry<String, DateTimeFormatHandler> handler: HANDLERS.entrySet()) {\n+      if (format.contains(handler.getKey())) {\n+        format = format.replace(handler.getKey(), handler.getValue().getFormat(date));\n+      }\n+    }\n+    format = literalReplace(format);\n+\n+    // English Locale matches SQL requirements.\n+    // 'AM'/'PM' instead of 'a.m.'/'p.m.'\n+    // 'Sat' instead of 'Sat.' etc\n+    return new ExprStringValue(date.format(DateTimeFormatter.ofPattern(format, Locale.ENGLISH)));\n+  }\n+\n+  /**\n+   * Returns English suffix of incoming value.\n+   * @param val Incoming value.\n+   * @return English suffix as String (st, nd, rd, th)\n+   */\n+  private static String getSuffix(int val) {\n+    // The numbers 11, 12, and 13 do not follow general suffix rules.\n+    if ((SUFFIX_SPECIAL_START_TH <= val) && (val <= SUFFIX_SPECIAL_END_TH)) {\n+      return SUFFIX_SPECIAL_TH;\n+    }\n+    return SUFFIX_CONVERTER.getOrDefault(val % 10, SUFFIX_SPECIAL_TH);\n+  }\n+\n+  /**\n+   * Goes through format String and replaces any %x with 'x' where x is unmapped.\n+   * @param format Incoming format String without mapping completed.\n+   * @return Outgoing format String with mapping completed.\n+   */\n+  private static String literalReplace(String format) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNTk4OQ==", "bodyText": "Do you mean a format we don't support, such as %z?\nAccording to the documentation for MySQL it should come out as just z, so using the DateTimeFormatter specification, to get a literal out, we wrap in ', so %z => 'z'.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498415989", "createdAt": "2020-10-01T17:46:41Z", "author": {"login": "lyndonb-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {\n+    String format = formatExpr.stringValue();\n+    final LocalDateTime date = dateExpr.datetimeValue();\n+    for (Map.Entry<String, DateTimeFormatHandler> handler: HANDLERS.entrySet()) {\n+      if (format.contains(handler.getKey())) {\n+        format = format.replace(handler.getKey(), handler.getValue().getFormat(date));\n+      }\n+    }\n+    format = literalReplace(format);\n+\n+    // English Locale matches SQL requirements.\n+    // 'AM'/'PM' instead of 'a.m.'/'p.m.'\n+    // 'Sat' instead of 'Sat.' etc\n+    return new ExprStringValue(date.format(DateTimeFormatter.ofPattern(format, Locale.ENGLISH)));\n+  }\n+\n+  /**\n+   * Returns English suffix of incoming value.\n+   * @param val Incoming value.\n+   * @return English suffix as String (st, nd, rd, th)\n+   */\n+  private static String getSuffix(int val) {\n+    // The numbers 11, 12, and 13 do not follow general suffix rules.\n+    if ((SUFFIX_SPECIAL_START_TH <= val) && (val <= SUFFIX_SPECIAL_END_TH)) {\n+      return SUFFIX_SPECIAL_TH;\n+    }\n+    return SUFFIX_CONVERTER.getOrDefault(val % 10, SUFFIX_SPECIAL_TH);\n+  }\n+\n+  /**\n+   * Goes through format String and replaces any %x with 'x' where x is unmapped.\n+   * @param format Incoming format String without mapping completed.\n+   * @return Outgoing format String with mapping completed.\n+   */\n+  private static String literalReplace(String format) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzg3Mw=="}, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMjEzNA==", "bodyText": "Got it, does it covered in the test cases also?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498432134", "createdAt": "2020-10-01T18:17:09Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {\n+    String format = formatExpr.stringValue();\n+    final LocalDateTime date = dateExpr.datetimeValue();\n+    for (Map.Entry<String, DateTimeFormatHandler> handler: HANDLERS.entrySet()) {\n+      if (format.contains(handler.getKey())) {\n+        format = format.replace(handler.getKey(), handler.getValue().getFormat(date));\n+      }\n+    }\n+    format = literalReplace(format);\n+\n+    // English Locale matches SQL requirements.\n+    // 'AM'/'PM' instead of 'a.m.'/'p.m.'\n+    // 'Sat' instead of 'Sat.' etc\n+    return new ExprStringValue(date.format(DateTimeFormatter.ofPattern(format, Locale.ENGLISH)));\n+  }\n+\n+  /**\n+   * Returns English suffix of incoming value.\n+   * @param val Incoming value.\n+   * @return English suffix as String (st, nd, rd, th)\n+   */\n+  private static String getSuffix(int val) {\n+    // The numbers 11, 12, and 13 do not follow general suffix rules.\n+    if ((SUFFIX_SPECIAL_START_TH <= val) && (val <= SUFFIX_SPECIAL_END_TH)) {\n+      return SUFFIX_SPECIAL_TH;\n+    }\n+    return SUFFIX_CONVERTER.getOrDefault(val % 10, SUFFIX_SPECIAL_TH);\n+  }\n+\n+  /**\n+   * Goes through format String and replaces any %x with 'x' where x is unmapped.\n+   * @param format Incoming format String without mapping completed.\n+   * @return Outgoing format String with mapping completed.\n+   */\n+  private static String literalReplace(String format) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzg3Mw=="}, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMjk2OA==", "bodyText": "Yes", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/764#discussion_r498432968", "createdAt": "2020-10-01T18:18:44Z", "author": {"login": "lyndonb-bq"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/datetime/DateTimeFormatterUtil.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.sql.expression.datetime;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This class converts a SQL style DATE_FORMAT format specifier and converts it to a\n+ * Java SimpleDateTime format.\n+ */\n+class DateTimeFormatterUtil {\n+  private static final int SUFFIX_SPECIAL_START_TH = 11;\n+  private static final int SUFFIX_SPECIAL_END_TH = 13;\n+  private static final String SUFFIX_SPECIAL_TH = \"th\";\n+  private static final Map<Integer, String> SUFFIX_CONVERTER =\n+      ImmutableMap.<Integer, String>builder()\n+      .put(1, \"st\").put(2, \"nd\").put(3, \"rd\").build();\n+\n+  // The following have special cases that need handling outside of the format options provided\n+  // by the DateTimeFormatter class.\n+  interface DateTimeFormatHandler {\n+    String getFormat(LocalDateTime date);\n+  }\n+\n+  private static final Map<String, DateTimeFormatHandler> HANDLERS =\n+      ImmutableMap.<String, DateTimeFormatHandler>builder()\n+      .put(\"%a\", (date) -> \"EEE\") // %a => EEE - Abbreviated weekday name (Sun..Sat)\n+      .put(\"%b\", (date) -> \"LLL\") // %b => LLL - Abbreviated month name (Jan..Dec)\n+      .put(\"%c\", (date) -> \"MM\") // %c => MM - Month, numeric (0..12)\n+      .put(\"%d\", (date) -> \"dd\") // %d => dd - Day of the month, numeric (00..31)\n+      .put(\"%e\", (date) -> \"d\") // %e => d - Day of the month, numeric (0..31)\n+      .put(\"%H\", (date) -> \"HH\") // %H => HH - (00..23)\n+      .put(\"%h\", (date) -> \"hh\") // %h => hh - (01..12)\n+      .put(\"%I\", (date) -> \"hh\") // %I => hh - (01..12)\n+      .put(\"%i\", (date) -> \"mm\") // %i => mm - Minutes, numeric (00..59)\n+      .put(\"%j\", (date) -> \"DDD\") // %j => DDD - (001..366)\n+      .put(\"%k\", (date) -> \"H\") // %k => H - (0..23)\n+      .put(\"%l\", (date) -> \"h\") // %l => h - (1..12)\n+      .put(\"%p\", (date) -> \"a\") // %p => a - AM or PM\n+      .put(\"%M\", (date) -> \"LLLL\") // %M => LLLL - Month name (January..December)\n+      .put(\"%m\", (date) -> \"MM\") // %m => MM - Month, numeric (00..12)\n+      .put(\"%r\", (date) -> \"hh:mm:ss a\") // %r => hh:mm:ss a - hh:mm:ss followed by AM or PM\n+      .put(\"%S\", (date) -> \"ss\") // %S => ss - Seconds (00..59)\n+      .put(\"%s\", (date) -> \"ss\") // %s => ss - Seconds (00..59)\n+      .put(\"%T\", (date) -> \"HH:mm:ss\") // %T => HH:mm:ss\n+      .put(\"%W\", (date) -> \"EEEE\") // %W => EEEE - Weekday name (Sunday..Saturday)\n+      .put(\"%Y\", (date) -> \"yyyy\") // %Y => yyyy - Year, numeric, 4 digits\n+      .put(\"%y\", (date) -> \"yy\") // %y => yy - Year, numeric, 2 digits\n+      // The following are not directly supported by DateTimeFormatter.\n+      .put(\"%D\", (date) -> // %w - Day of month with English suffix\n+          String.format(\"'%d%s'\", date.getDayOfMonth(), getSuffix(date.getDayOfMonth())))\n+      .put(\"%f\", (date) -> // %f - Microseconds\n+          String.format(\"'%d'\", (date.getNano() / 1000)))\n+      .put(\"%w\", (date) -> // %w - Day of week (0 indexed)\n+          String.format(\"'%d'\", date.getDayOfWeek().getValue()))\n+      .put(\"%U\", (date) -> // %U Week where Sunday is the first day - WEEK() mode 0\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(0, date.toLocalDate())))\n+      .put(\"%u\", (date) -> // %u Week where Monday is the first day - WEEK() mode 1\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(1, date.toLocalDate())))\n+      .put(\"%V\", (date) -> // %V Week where Sunday is the first day - WEEK() mode 2 used with %X\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(2, date.toLocalDate())))\n+      .put(\"%v\", (date) -> // %v Week where Monday is the first day - WEEK() mode 3 used with %x\n+          String.format(\"'%d'\", CalendarLookup.getWeekNumber(3, date.toLocalDate())))\n+      .put(\"%X\", (date) -> // %X Year for week where Sunday is the first day, 4 digits used with %V\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(2, date.toLocalDate())))\n+      .put(\"%x\", (date) -> // %x Year for week where Monday is the first day, 4 digits used with %v\n+          String.format(\"'%d'\", CalendarLookup.getYearNumber(3, date.toLocalDate())))\n+      .build();\n+\n+  private static final String MOD = \"%\";\n+  private static final String QUOTE_LITERAL = \"'\";\n+\n+  private DateTimeFormatterUtil() {\n+  }\n+\n+  /**\n+   * Format the date using the date format String.\n+   * @param dateExpr the date ExprValue of Date/Datetime/Timestamp/String type.\n+   * @param formatExpr the format ExprValue of String type.\n+   * @return Date formatted using format and returned as a String.\n+   */\n+  static ExprValue getFormattedDate(ExprValue dateExpr, ExprValue formatExpr) {\n+    String format = formatExpr.stringValue();\n+    final LocalDateTime date = dateExpr.datetimeValue();\n+    for (Map.Entry<String, DateTimeFormatHandler> handler: HANDLERS.entrySet()) {\n+      if (format.contains(handler.getKey())) {\n+        format = format.replace(handler.getKey(), handler.getValue().getFormat(date));\n+      }\n+    }\n+    format = literalReplace(format);\n+\n+    // English Locale matches SQL requirements.\n+    // 'AM'/'PM' instead of 'a.m.'/'p.m.'\n+    // 'Sat' instead of 'Sat.' etc\n+    return new ExprStringValue(date.format(DateTimeFormatter.ofPattern(format, Locale.ENGLISH)));\n+  }\n+\n+  /**\n+   * Returns English suffix of incoming value.\n+   * @param val Incoming value.\n+   * @return English suffix as String (st, nd, rd, th)\n+   */\n+  private static String getSuffix(int val) {\n+    // The numbers 11, 12, and 13 do not follow general suffix rules.\n+    if ((SUFFIX_SPECIAL_START_TH <= val) && (val <= SUFFIX_SPECIAL_END_TH)) {\n+      return SUFFIX_SPECIAL_TH;\n+    }\n+    return SUFFIX_CONVERTER.getOrDefault(val % 10, SUFFIX_SPECIAL_TH);\n+  }\n+\n+  /**\n+   * Goes through format String and replaces any %x with 'x' where x is unmapped.\n+   * @param format Incoming format String without mapping completed.\n+   * @return Outgoing format String with mapping completed.\n+   */\n+  private static String literalReplace(String format) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzg3Mw=="}, "originalCommit": {"oid": "1656d753712b0b726278e0b1cc43c3aa70e85a0a"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1893, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}