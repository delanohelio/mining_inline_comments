{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NTQ4MDg3", "number": 720, "title": "Support Top/Rare Command In PPL", "bodyText": "Issue #685\nDescription of changes:\n\ncore: added support for rare/top operation in a logical & physical layer\nppl:  added AstBuilder logic for rare and top command\nupdated documentation with examples for using rare and top command\n\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-08-28T17:40:17Z", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720", "merged": true, "mergeCommit": {"oid": "94f2d3252e4ed2db78cb9d76a0747f25d28f1723"}, "closed": true, "closedAt": "2020-09-08T17:06:53Z", "author": {"login": "rupal-bq"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_5SzJAH2gAyNDc1NTQ4MDg3OjVmZTVhYTc3ZGYwNDM3M2Y0ODNkYTEyN2ViYzdmZDY5MGNhY2Y4Njg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdGyUBNAFqTQ3NzkxOTk5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5fe5aa77df04373f483da127ebc7fd690cacf868", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/5fe5aa77df04373f483da127ebc7fd690cacf868", "committedDate": "2020-08-17T21:28:26Z", "message": "ast - rare and top command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c2000afbff13760abb719b9c129568334c1ab18", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/4c2000afbff13760abb719b9c129568334c1ab18", "committedDate": "2020-08-18T00:25:48Z", "message": "fix build failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d98f316718ef08d03f4142c2dd81662a1886d66", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/2d98f316718ef08d03f4142c2dd81662a1886d66", "committedDate": "2020-08-18T00:44:11Z", "message": "fix build failure - test coverage ratio for ppl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "740a9f04177154cd307a05dfd8f6a5c692dc4c88", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/740a9f04177154cd307a05dfd8f6a5c692dc4c88", "committedDate": "2020-08-18T19:45:35Z", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "016a886fe57dad1662b4bb54aef10f046cb930e9", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/016a886fe57dad1662b4bb54aef10f046cb930e9", "committedDate": "2020-08-26T03:40:44Z", "message": "add logical, physical plan for rare & top"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "574cadb3921094138f91e13f82ff1b6cd7d5db58", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/574cadb3921094138f91e13f82ff1b6cd7d5db58", "committedDate": "2020-08-26T03:49:12Z", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4aa9151583114345f057b84d3f24f009bcfb034", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/b4aa9151583114345f057b84d3f24f009bcfb034", "committedDate": "2020-08-26T20:59:39Z", "message": "merge rare & top operator since both commands operate identical to each other"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372bf314472a53bfe7dcb0ef46bc41352e5acb9b", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/372bf314472a53bfe7dcb0ef46bc41352e5acb9b", "committedDate": "2020-08-28T02:55:19Z", "message": "add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01245a3a71dedac6d8bb636cab2e62700c401ef4", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/01245a3a71dedac6d8bb636cab2e62700c401ef4", "committedDate": "2020-08-28T04:09:31Z", "message": "update docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97cef7f1bca51240ab6fb15a4600046dfbca2241", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/97cef7f1bca51240ab6fb15a4600046dfbca2241", "committedDate": "2020-08-28T04:10:39Z", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c41319b976392d3394642d4b627404c80bb2c074", "committedDate": "2020-08-28T17:29:44Z", "message": "add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTE5Nzcy", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-477919772", "createdAt": "2020-08-28T17:50:51Z", "commit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MDo1MVrOHJPbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MDo1MVrOHJPbbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjAxMw==", "bodyText": "Some use a constant like DEFAULT_NO_OF_RESULTS and some have 10 hardcoded. Should probably be consistent with the constant.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452013", "createdAt": "2020-08-28T17:50:51Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalPlanDSL.java", "diffHunk": "@@ -83,6 +84,16 @@ public static LogicalPlan dedupe(\n         input, Arrays.asList(fields), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static LogicalPlan rareTopN(LogicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groupByList, Expression... fields) {\n+    return rareTopN(input, rareTopFlag, 10, groupByList, fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTQ0NDk0", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-477944494", "createdAt": "2020-08-28T18:32:22Z", "commit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODozMjoyMlrOHJQl4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo1ODoxMVrOHJRR5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MTA3NQ==", "bodyText": "Missing license header.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479471075", "createdAt": "2020-08-28T18:32:22Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjA0Mg==", "bodyText": "In a different method we use ImmutableList.of() here. Let's be consistent.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472042", "createdAt": "2020-08-28T18:34:43Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Logical Rare and TopN Plan.\n+ */\n+@Getter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+public class LogicalRareTopN extends LogicalPlan {\n+\n+  private final LogicalPlan child;\n+  private final Boolean rareTopFlag;\n+  private final Integer noOfResults;\n+  private final List<Expression> fieldList;\n+  private final List<Expression> groupByList;\n+\n+  @Override\n+  public List<LogicalPlan> getChild() {\n+    return Collections.singletonList(child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQzMg==", "bodyText": "We are missing the license header here.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472432", "createdAt": "2020-08-28T18:35:41Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzYxNg==", "bodyText": "findTop() and findRare() have the same implementation, except the comparator is different. We could just have a single find() function that takes in a comparator instead.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479477616", "createdAt": "2020-08-28T18:46:53Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MDE4Ng==", "bodyText": "This algorithm for building this list is too complicated. I think you can model this more easily with streams.\nmap.entrySet().stream()\n.sort(ValueComparator)\n.limit(noOfResults)\nPass in different comparator for rare vs. top.\n.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479480186", "createdAt": "2020-08-28T18:53:04Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MjM0MA==", "bodyText": "Usually you don't want to return the specific type and instead return the interface unless the caller really needs to work with LinkedHashMap in particular.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479482340", "createdAt": "2020-08-28T18:58:11Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public LinkedHashMap<String, ExprValue> fieldKeyMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 240}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e4353428d8edbfe9f13e13b5e48516e21edef9", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c9e4353428d8edbfe9f13e13b5e48516e21edef9", "committedDate": "2020-08-28T23:34:56Z", "message": "addressing PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "committedDate": "2020-08-28T23:47:59Z", "message": "fix build error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ0NzAy", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478144702", "createdAt": "2020-08-29T17:54:59Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1NDo1OVrOHJc9tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1NDo1OVrOHJc9tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3Mzc4MA==", "bodyText": "Missing the license header.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479673780", "createdAt": "2020-08-29T17:54:59Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ0ODgw", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478144880", "createdAt": "2020-08-29T17:58:00Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1ODowMVrOHJc-yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo1ODowMVrOHJc-yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDA1OQ==", "bodyText": "Lets use fieldExprList.stream().map(...).collect(Collectors.toList())", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674059", "createdAt": "2020-08-29T17:58:01Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ1Mzc2", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478145376", "createdAt": "2020-08-29T18:06:28Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNjoyOFrOHJdBtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNjoyOFrOHJdBtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDgwNw==", "bodyText": "Are you using guava? Can you use Streams.zip().collect(Collectors.toMap(...))?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674807", "createdAt": "2020-08-29T18:06:28Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ1NDQw", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478145440", "createdAt": "2020-08-29T18:07:21Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzoyMVrOHJdCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzoyMVrOHJdCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDg5NA==", "bodyText": "Switch to stream", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674894", "createdAt": "2020-08-29T18:07:21Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 240}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ1NDU2", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478145456", "createdAt": "2020-08-29T18:07:43Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzo0M1rOHJdCIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODowNzo0M1rOHJdCIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA==", "bodyText": "Switch to stream.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674914", "createdAt": "2020-08-29T18:07:43Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {\n+        this.groupByValueList.add(groupExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of group field and group field value.\n+     */\n+    public Map<String, ExprValue> groupKeyMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 248}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ2MTcx", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478146171", "createdAt": "2020-08-29T18:18:59Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODoxODo1OVrOHJdGDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxODoxODo1OVrOHJdGDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NTkxNg==", "bodyText": "Code is the same for these two methods, except differing by the flag. Can they be combined into a helper? If the two context classes have the same methods...", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479675916", "createdAt": "2020-08-29T18:18:59Z", "author": {"login": "jduo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +203,62 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  /**\n+   * Rare command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitRareCommand(RareCommandContext ctx) {\n+    List<UnresolvedExpression> groupList = ctx.byClause() == null ? Collections.emptyList() :\n+        ctx.byClause()\n+            .fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(this::visitExpression)\n+            .collect(Collectors.toList());\n+    return new RareTopN(\n+\n+        /**\n+         * Setting rareTopFlag to FALSE will return list of rare values\n+         */\n+        Boolean.FALSE,\n+        ArgumentFactory.getArgumentList(ctx),\n+        ctx.fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(field -> (Field) visitExpression(field))\n+            .collect(Collectors.toList()),\n+        groupList\n+    );\n+  }\n+\n+  /**\n+   * Top command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitTopCommand(TopCommandContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ2MjU0", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-478146254", "createdAt": "2020-08-29T18:20:34Z", "commit": {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/a802b55e56f40655b03ca2325128a7f83fda7534", "committedDate": "2020-08-31T20:09:55Z", "message": "address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDc5NDk1", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-480079495", "createdAt": "2020-09-01T20:10:50Z", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMDo1MFrOHLGfKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMDo1MFrOHLGfKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng==", "bodyText": "how many value for each field will be returned? 10?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481402666", "createdAt": "2020-09-01T20:10:50Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDgwNTI3", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-480080527", "createdAt": "2020-09-01T20:12:31Z", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMjozMlrOHLGiWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMjozMlrOHLGiWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw==", "bodyText": "why the rare command doesn't has thsi paramater?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481403483", "createdAt": "2020-09-01T20:12:32Z", "author": {"login": "penghuo"}, "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDgzMDU0", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-480083054", "createdAt": "2020-09-01T20:16:09Z", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjowOVrOHLGp8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjowOVrOHLGp8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg==", "bodyText": "could you also change the stats command to use these genric method?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405426", "createdAt": "2020-09-01T20:16:09Z", "author": {"login": "penghuo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDgzMTM5", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-480083139", "createdAt": "2020-09-01T20:16:15Z", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjoxNVrOHLGqLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxNjoxNVrOHLGqLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQ4NQ==", "bodyText": "ditto", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405485", "createdAt": "2020-09-01T20:16:15Z", "author": {"login": "penghuo"}, "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {\n+    return ctx.fieldList().fieldExpression().stream().map(this::visitExpression)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<Field> getFieldList(FieldListContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDk0MzE2", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-480094316", "createdAt": "2020-09-01T20:33:27Z", "commit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMzoyN1rOHLHMfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMzoyN1rOHLHMfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA==", "bodyText": "why the value is List instead of just Map?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481414270", "createdAt": "2020-09-01T20:33:27Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<Key, List<HashMap<Key, Integer>>> groupListMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534"}, "originalPosition": 130}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe9d9baa59577fd1733a16bee716e84014f7a08", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/0fe9d9baa59577fd1733a16bee716e84014f7a08", "committedDate": "2020-09-01T22:35:26Z", "message": "address PR comments:\n- remove list\n- use generic getGroupByList function for stats\n- use generic getFieldList function for dedup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c3300618281f939d0fdc96099b14e8893a5611b", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/8c3300618281f939d0fdc96099b14e8893a5611b", "committedDate": "2020-09-01T22:48:11Z", "message": "use interface instead of specific type for input of find()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/1612815dc5fc4edb4f392d8f87fae06955586560", "committedDate": "2020-09-02T00:32:16Z", "message": "update doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDYzNjM3", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-481063637", "createdAt": "2020-09-02T17:39:42Z", "commit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzozOTo0MlrOHL6OeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzozOTo0MlrOHL6OeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ==", "bodyText": "Should this be a boolean instead of Boolean? Would an enum with values RARE or TOP be better? I can't tell if setting this to true means rare or top.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482250361", "createdAt": "2020-09-02T17:39:42Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;\n+\n+import com.amazon.opendistroforelasticsearch.sql.ast.AbstractNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Argument;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Field;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.UnresolvedExpression;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+/**\n+ * AST node represent RareTopN operation.\n+ */\n+@Getter\n+@Setter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+public class RareTopN extends UnresolvedPlan {\n+\n+  private UnresolvedPlan child;\n+  private final Boolean rareTopFlag;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDY4NTAz", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-481068503", "createdAt": "2020-09-02T17:41:54Z", "commit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MTo1NVrOHL6TSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MTo1NVrOHL6TSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MTU5NQ==", "bodyText": "Can this and noOfResults just be primitive ints?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482251595", "createdAt": "2020-09-02T17:41:55Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDcwOTc2", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-481070976", "createdAt": "2020-09-02T17:43:00Z", "commit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MzowMFrOHL6VoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0MzowMFrOHL6VoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg==", "bodyText": "Let's add a precondition check here and on next() to verify open() has been called.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252192", "createdAt": "2020-09-02T17:43:00Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDcyNzE4", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-481072718", "createdAt": "2020-09-02T17:43:47Z", "commit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0Mzo0N1rOHL6XVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo0Mzo0N1rOHL6XVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA==", "bodyText": "Should we do something to indicate that input is no longer usable or throw an error if open() is called more than once?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252628", "createdAt": "2020-09-02T17:43:47Z", "author": {"login": "jduo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77d6bf32a868174b6dfa314c2d722c15d393696f", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/77d6bf32a868174b6dfa314c2d722c15d393696f", "committedDate": "2020-09-02T22:49:37Z", "message": "replace rareTopFlag with enum"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyODIxNTcz", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-482821573", "createdAt": "2020-09-04T17:06:32Z", "commit": {"oid": "77d6bf32a868174b6dfa314c2d722c15d393696f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTE5OTk4", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#pullrequestreview-477919998", "createdAt": "2020-08-28T17:51:12Z", "commit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1MToxMlrOHJPcGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoyNTo1N1rOHJQa1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjE4Ng==", "bodyText": "Same comment on constant for 10.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452186", "createdAt": "2020-08-28T17:51:12Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/PhysicalPlanDSL.java", "diffHunk": "@@ -80,6 +80,17 @@ public static DedupeOperator dedupe(\n         input, Arrays.asList(expressions), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static RareTopNOperator rareTopN(PhysicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groups, Expression... expressions) {\n+    return rareTopN(input, rareTopFlag, 10, groups, expressions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDQwMg==", "bodyText": "We should use tags like @return and such when doing java docs for return values. Similar comment for @param for parameter. Would generally have this nit across the code.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479454402", "createdAt": "2020-08-28T17:55:49Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2ODI0NQ==", "bodyText": "This javadoc isn't very useful. Comments should help the developer understand the code and provide value like \"what, why, how\".", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479468245", "createdAt": "2020-08-28T18:25:57Z", "author": {"login": "raymond-lum-zz"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41319b976392d3394642d4b627404c80bb2c074"}, "originalPosition": 219}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 631, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}