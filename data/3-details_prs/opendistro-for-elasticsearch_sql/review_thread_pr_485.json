{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTU2ODEy", "number": 485, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzowNTo0MFrOD_Fvmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoxMTo1OFrOD_FyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDgwOTg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzowNTo0MFrOGZlquQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo1Njo1OVrOGanqWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ==", "bodyText": "Notice that HistoricalDeduper is using ConcurrentHashMap, so just wonder if thread safe is also needed here by synchronized or AtomicReference?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r429484729", "createdAt": "2020-05-22T23:05:40Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;\n+      }\n+      dedupeKeyBuilder.add(exprValue);\n+    }\n+    List<ExprValue> dedupeKey = dedupeKeyBuilder.build();\n+    int seenTimes = deduper.seenTimes(dedupeKey);\n+    return seenTimes <= allowedDuplication;\n+  }\n+\n+  /**\n+   * Return how many times the dedupeKey has been seen before. The side effect is the seen times\n+   * will add 1 times after calling this function.\n+   *\n+   * @param <K> dedupe key\n+   */\n+  interface Deduper<K> {\n+\n+    int seenTimes(K dedupeKey);\n+  }\n+\n+  /** The Historical Deduper monitor the duplicated element with all the seen value. */\n+  static class HistoricalDeduper<K> implements Deduper<K> {\n+    private final Map<K, Integer> seenMap = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {\n+      seenMap.putIfAbsent(dedupeKey, 0);\n+      return seenMap.computeIfPresent(dedupeKey, (k, v) -> v + 1);\n+    }\n+  }\n+\n+  /**\n+   * The Consecutive Deduper monitor the duplicated element with consecutive seen value. It means\n+   * only the consecutive duplicated value will be counted.\n+   */\n+  static class ConsecutiveDeduper<K> implements Deduper<K> {\n+    private K lastSeenDedupeKey = null;\n+    private Integer consecutiveCount = 0;\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjkzMg==", "bodyText": "Done. Refactor the Deduper. Get rid of hierarchy", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430536932", "createdAt": "2020-05-26T16:14:42Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;\n+      }\n+      dedupeKeyBuilder.add(exprValue);\n+    }\n+    List<ExprValue> dedupeKey = dedupeKeyBuilder.build();\n+    int seenTimes = deduper.seenTimes(dedupeKey);\n+    return seenTimes <= allowedDuplication;\n+  }\n+\n+  /**\n+   * Return how many times the dedupeKey has been seen before. The side effect is the seen times\n+   * will add 1 times after calling this function.\n+   *\n+   * @param <K> dedupe key\n+   */\n+  interface Deduper<K> {\n+\n+    int seenTimes(K dedupeKey);\n+  }\n+\n+  /** The Historical Deduper monitor the duplicated element with all the seen value. */\n+  static class HistoricalDeduper<K> implements Deduper<K> {\n+    private final Map<K, Integer> seenMap = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {\n+      seenMap.putIfAbsent(dedupeKey, 0);\n+      return seenMap.computeIfPresent(dedupeKey, (k, v) -> v + 1);\n+    }\n+  }\n+\n+  /**\n+   * The Consecutive Deduper monitor the duplicated element with consecutive seen value. It means\n+   * only the consecutive duplicated value will be counted.\n+   */\n+  static class ConsecutiveDeduper<K> implements Deduper<K> {\n+    private K lastSeenDedupeKey = null;\n+    private Integer consecutiveCount = 0;\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ=="}, "originalCommit": {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NTk3OQ==", "bodyText": "Thanks!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430565979", "createdAt": "2020-05-26T16:56:59Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;\n+      }\n+      dedupeKeyBuilder.add(exprValue);\n+    }\n+    List<ExprValue> dedupeKey = dedupeKeyBuilder.build();\n+    int seenTimes = deduper.seenTimes(dedupeKey);\n+    return seenTimes <= allowedDuplication;\n+  }\n+\n+  /**\n+   * Return how many times the dedupeKey has been seen before. The side effect is the seen times\n+   * will add 1 times after calling this function.\n+   *\n+   * @param <K> dedupe key\n+   */\n+  interface Deduper<K> {\n+\n+    int seenTimes(K dedupeKey);\n+  }\n+\n+  /** The Historical Deduper monitor the duplicated element with all the seen value. */\n+  static class HistoricalDeduper<K> implements Deduper<K> {\n+    private final Map<K, Integer> seenMap = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {\n+      seenMap.putIfAbsent(dedupeKey, 0);\n+      return seenMap.computeIfPresent(dedupeKey, (k, v) -> v + 1);\n+    }\n+  }\n+\n+  /**\n+   * The Consecutive Deduper monitor the duplicated element with consecutive seen value. It means\n+   * only the consecutive duplicated value will be counted.\n+   */\n+  static class ConsecutiveDeduper<K> implements Deduper<K> {\n+    private K lastSeenDedupeKey = null;\n+    private Integer consecutiveCount = 0;\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ=="}, "originalCommit": {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDgxNjg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzoxMTo1OFrOGZlu4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNToxNzo0OVrOGajMsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NTc5Mg==", "bodyText": "Probably safer to do null check before return in case this Boolean is null? Or verify this in constructor and save as boolean if it's required non-null?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r429485792", "createdAt": "2020-05-22T23:11:58Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5Mjg1MA==", "bodyText": "Done. add the @nonnull at the constructor.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430492850", "createdAt": "2020-05-26T15:17:49Z", "author": {"login": "penghuo"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NTc5Mg=="}, "originalCommit": {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2091, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}