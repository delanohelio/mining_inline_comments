{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNjk0NTkw", "number": 540, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzoyNDo0OFrOEJ3lcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTo1MjoyM1rOENbNEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzgzMzQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/DSL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzoyNDo0OFrOGql7bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTo0MjowNFrOGwGaSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDc5OA==", "bodyText": "np: can all these methods reuse a method like FunctionExpression  compile(BuiltinFunctionName name, Expression...exprs)", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r447314798", "createdAt": "2020-06-29T23:24:48Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/DSL.java", "diffHunk": "@@ -58,6 +58,38 @@ public FunctionExpression abs(Environment<Expression, ExprType> env, Expression.\n         repository.compile(BuiltinFunctionName.ABS.getName(), Arrays.asList(expressions), env);\n   }\n \n+  public FunctionExpression ceil(Environment<Expression, ExprType> env, Expression... expressions) {\n+    return (FunctionExpression)\n+        repository.compile(BuiltinFunctionName.CEIL.getName(), Arrays.asList(expressions), env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4OTg2Ng==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r453089866", "createdAt": "2020-07-10T21:42:04Z", "author": {"login": "chloe-zh"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/DSL.java", "diffHunk": "@@ -58,6 +58,38 @@ public FunctionExpression abs(Environment<Expression, ExprType> env, Expression.\n         repository.compile(BuiltinFunctionName.ABS.getName(), Arrays.asList(expressions), env);\n   }\n \n+  public FunctionExpression ceil(Environment<Expression, ExprType> env, Expression... expressions) {\n+    return (FunctionExpression)\n+        repository.compile(BuiltinFunctionName.CEIL.getName(), Arrays.asList(expressions), env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDc5OA=="}, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTE3NTMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0NjozOFrOGrFbcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1MDozOFrOGwFQwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg5Nw==", "bodyText": "What's the difference between this new method and binaryOperator() above?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r447830897", "createdAt": "2020-06-30T16:46:38Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "diffHunk": "@@ -104,6 +104,57 @@ public String toString() {\n         };\n   }\n \n+  /**\n+   * Construct {@link FunctionBuilder} which call function with arguments produced by observer1 and\n+   * observer2 In general, if any operand evaluates to a MISSING value, the enclosing operator will\n+   * return MISSING; if none of operands evaluates to a MISSING value but there is an operand\n+   * evaluates to a NULL value, the enclosing operator will return NULL.\n+   *\n+   * @param functionName function name\n+   * @param function     {@link BiFunction}\n+   * @param observer1    extract the value of type T from the first argument\n+   * @param observer2    extract the value of type U from the second argument\n+   * @param returnType   return type\n+   * @param <T>          the type of the first argument to the function\n+   * @param <U>          the type of the second argument to the function\n+   * @param <R>          the type of the result of the function\n+   * @return {@link FunctionBuilder}\n+   */\n+  public static <T, U, R> FunctionBuilder doubleArgFunc(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc3MDU5NA==", "bodyText": "only the toString method is different, for example operator add with args a and b is to a + b, and function log with the args is to log(a, b)", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r451770594", "createdAt": "2020-07-08T19:16:46Z", "author": {"login": "chloe-zh"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "diffHunk": "@@ -104,6 +104,57 @@ public String toString() {\n         };\n   }\n \n+  /**\n+   * Construct {@link FunctionBuilder} which call function with arguments produced by observer1 and\n+   * observer2 In general, if any operand evaluates to a MISSING value, the enclosing operator will\n+   * return MISSING; if none of operands evaluates to a MISSING value but there is an operand\n+   * evaluates to a NULL value, the enclosing operator will return NULL.\n+   *\n+   * @param functionName function name\n+   * @param function     {@link BiFunction}\n+   * @param observer1    extract the value of type T from the first argument\n+   * @param observer2    extract the value of type U from the second argument\n+   * @param returnType   return type\n+   * @param <T>          the type of the first argument to the function\n+   * @param <U>          the type of the second argument to the function\n+   * @param <R>          the type of the result of the function\n+   * @return {@link FunctionBuilder}\n+   */\n+  public static <T, U, R> FunctionBuilder doubleArgFunc(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg5Nw=="}, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MTA0MA==", "bodyText": "Okay. For now toString seems being used for column name in response, I think we can treat arithmetic and function toString same way later when column name is retrieved in other way.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r453071040", "createdAt": "2020-07-10T20:50:38Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "diffHunk": "@@ -104,6 +104,57 @@ public String toString() {\n         };\n   }\n \n+  /**\n+   * Construct {@link FunctionBuilder} which call function with arguments produced by observer1 and\n+   * observer2 In general, if any operand evaluates to a MISSING value, the enclosing operator will\n+   * return MISSING; if none of operands evaluates to a MISSING value but there is an operand\n+   * evaluates to a NULL value, the enclosing operator will return NULL.\n+   *\n+   * @param functionName function name\n+   * @param function     {@link BiFunction}\n+   * @param observer1    extract the value of type T from the first argument\n+   * @param observer2    extract the value of type U from the second argument\n+   * @param returnType   return type\n+   * @param <T>          the type of the first argument to the function\n+   * @param <U>          the type of the second argument to the function\n+   * @param <R>          the type of the result of the function\n+   * @return {@link FunctionBuilder}\n+   */\n+  public static <T, U, R> FunctionBuilder doubleArgFunc(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg5Nw=="}, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTE4MzkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/arthmetic/MathematicalFunction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0ODo0OVrOGrFgxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDoxMDowOFrOGu3iSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMjI2MA==", "bodyText": "Exact same as ceil()?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r447832260", "createdAt": "2020-06-30T16:48:49Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/arthmetic/MathematicalFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.operator.arthmetic;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.doubleArgFunc;\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.unaryOperator;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionRepository;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionBuilder;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionResolver;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionSignature;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class MathematicalFunction {\n+  /**\n+   * Register Mathematical Functions.\n+   *\n+   * @param repository {@link BuiltinFunctionRepository}.\n+   */\n+  public static void register(BuiltinFunctionRepository repository) {\n+    repository.register(abs());\n+    repository.register(ceil());\n+    repository.register(ceiling());\n+    repository.register(exp());\n+    repository.register(floor());\n+    repository.register(ln());\n+    repository.register(log());\n+  }\n+\n+  /**\n+   * Definition of abs() function.\n+   * The supported signature of abs() function are\n+   * INT -> INT\n+   * LONG -> LONG\n+   * FLOAT -> FLOAT\n+   * DOUBLE -> DOUBLE\n+   */\n+  private static FunctionResolver abs() {\n+    return new FunctionResolver(\n+        BuiltinFunctionName.ABS.getName(),\n+        singleArgumentFunction(\n+            BuiltinFunctionName.ABS.getName(), Math::abs, Math::abs, Math::abs, Math::abs));\n+  }\n+\n+  /**\n+   * Definition of ceil(x)/ceiling(x) function.\n+   * Calculate the next highest integer that x rounds up to\n+   * The supported signature of ceil/ceiling function is\n+   * DOUBLE -> LONG\n+   */\n+  private static FunctionResolver ceil() {\n+    FunctionName functionName = BuiltinFunctionName.CEIL.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEIL.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());\n+  }\n+\n+  private static FunctionResolver ceiling() {\n+    FunctionName functionName = BuiltinFunctionName.CEILING.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEILING.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc3MDgwNA==", "bodyText": "Yes the same function but with different registered name", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r451770804", "createdAt": "2020-07-08T19:17:08Z", "author": {"login": "chloe-zh"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/arthmetic/MathematicalFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.operator.arthmetic;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.doubleArgFunc;\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.unaryOperator;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionRepository;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionBuilder;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionResolver;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionSignature;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class MathematicalFunction {\n+  /**\n+   * Register Mathematical Functions.\n+   *\n+   * @param repository {@link BuiltinFunctionRepository}.\n+   */\n+  public static void register(BuiltinFunctionRepository repository) {\n+    repository.register(abs());\n+    repository.register(ceil());\n+    repository.register(ceiling());\n+    repository.register(exp());\n+    repository.register(floor());\n+    repository.register(ln());\n+    repository.register(log());\n+  }\n+\n+  /**\n+   * Definition of abs() function.\n+   * The supported signature of abs() function are\n+   * INT -> INT\n+   * LONG -> LONG\n+   * FLOAT -> FLOAT\n+   * DOUBLE -> DOUBLE\n+   */\n+  private static FunctionResolver abs() {\n+    return new FunctionResolver(\n+        BuiltinFunctionName.ABS.getName(),\n+        singleArgumentFunction(\n+            BuiltinFunctionName.ABS.getName(), Math::abs, Math::abs, Math::abs, Math::abs));\n+  }\n+\n+  /**\n+   * Definition of ceil(x)/ceiling(x) function.\n+   * Calculate the next highest integer that x rounds up to\n+   * The supported signature of ceil/ceiling function is\n+   * DOUBLE -> LONG\n+   */\n+  private static FunctionResolver ceil() {\n+    FunctionName functionName = BuiltinFunctionName.CEIL.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEIL.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());\n+  }\n+\n+  private static FunctionResolver ceiling() {\n+    FunctionName functionName = BuiltinFunctionName.CEILING.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEILING.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMjI2MA=="}, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NzU3OA==", "bodyText": "I see. I think we can refactor these kind of similar function family later by generating from same method with different argument, such as substr and substring, log and log2 etc.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r451797578", "createdAt": "2020-07-08T20:10:08Z", "author": {"login": "dai-chen"}, "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/arthmetic/MathematicalFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.expression.operator.arthmetic;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.doubleArgFunc;\n+import static com.amazon.opendistroforelasticsearch.sql.expression.operator.OperatorUtils.unaryOperator;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprType;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.BuiltinFunctionRepository;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionBuilder;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionName;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionResolver;\n+import com.amazon.opendistroforelasticsearch.sql.expression.function.FunctionSignature;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class MathematicalFunction {\n+  /**\n+   * Register Mathematical Functions.\n+   *\n+   * @param repository {@link BuiltinFunctionRepository}.\n+   */\n+  public static void register(BuiltinFunctionRepository repository) {\n+    repository.register(abs());\n+    repository.register(ceil());\n+    repository.register(ceiling());\n+    repository.register(exp());\n+    repository.register(floor());\n+    repository.register(ln());\n+    repository.register(log());\n+  }\n+\n+  /**\n+   * Definition of abs() function.\n+   * The supported signature of abs() function are\n+   * INT -> INT\n+   * LONG -> LONG\n+   * FLOAT -> FLOAT\n+   * DOUBLE -> DOUBLE\n+   */\n+  private static FunctionResolver abs() {\n+    return new FunctionResolver(\n+        BuiltinFunctionName.ABS.getName(),\n+        singleArgumentFunction(\n+            BuiltinFunctionName.ABS.getName(), Math::abs, Math::abs, Math::abs, Math::abs));\n+  }\n+\n+  /**\n+   * Definition of ceil(x)/ceiling(x) function.\n+   * Calculate the next highest integer that x rounds up to\n+   * The supported signature of ceil/ceiling function is\n+   * DOUBLE -> LONG\n+   */\n+  private static FunctionResolver ceil() {\n+    FunctionName functionName = BuiltinFunctionName.CEIL.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEIL.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());\n+  }\n+\n+  private static FunctionResolver ceiling() {\n+    FunctionName functionName = BuiltinFunctionName.CEILING.getName();\n+    return new FunctionResolver(\n+        BuiltinFunctionName.CEILING.getName(),\n+        new ImmutableMap.Builder<FunctionSignature, FunctionBuilder>()\n+            .put(\n+                new FunctionSignature(functionName, Arrays.asList(ExprType.DOUBLE)),\n+                unaryOperator(\n+                    functionName, v -> ((long) Math.ceil(v)), ExprValueUtils::getDoubleValue,\n+                    ExprType.LONG))\n+            .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMjI2MA=="}, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTIwODE3OnYy", "diffSide": "RIGHT", "path": "integ-test/src/test/java/com/amazon/opendistroforelasticsearch/sql/ppl/MathematicalFunctionIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1NDo0OFrOGrFv3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1NDo0OFrOGrFv3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjEyNg==", "bodyText": "For assertion on floating-point number, please check if we're using matcher like isCloseTo() to avoid precision problem.", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r447836126", "createdAt": "2020-06-30T16:54:48Z", "author": {"login": "dai-chen"}, "path": "integ-test/src/test/java/com/amazon/opendistroforelasticsearch/sql/ppl/MathematicalFunctionIT.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ppl;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.legacy.TestsConstants.TEST_INDEX_BANK;\n+import static com.amazon.opendistroforelasticsearch.sql.util.MatcherUtils.rows;\n+import static com.amazon.opendistroforelasticsearch.sql.util.MatcherUtils.schema;\n+import static com.amazon.opendistroforelasticsearch.sql.util.MatcherUtils.verifyDataRows;\n+import static com.amazon.opendistroforelasticsearch.sql.util.MatcherUtils.verifySchema;\n+\n+import java.io.IOException;\n+import org.json.JSONObject;\n+import org.junit.jupiter.api.Test;\n+\n+public class MathematicalFunctionIT extends PPLIntegTestCase {\n+\n+  @Override\n+  public void init() throws IOException {\n+    loadIndex(Index.BANK);\n+    loadIndex(Index.BANK_WITH_NULL_VALUES);\n+  }\n+\n+  @Test\n+  public void testAbs() throws IOException {\n+    JSONObject result =\n+        executeQuery(\n+            String.format(\n+                \"source=%s | eval f = abs(age) | fields f\", TEST_INDEX_BANK));\n+    verifySchema(result, schema(\"f\", null, \"integer\"));\n+    verifyDataRows(\n+        result,\n+        rows(32), rows(36), rows(28), rows(33), rows(36), rows(39), rows(34));\n+  }\n+\n+  @Test\n+  public void testCeil() throws IOException {\n+    JSONObject result =\n+        executeQuery(\n+            String.format(\n+                \"source=%s | eval f = ceil(age) | fields f\", TEST_INDEX_BANK));\n+    verifySchema(result, schema(\"f\", null, \"long\"));\n+    verifyDataRows(\n+        result,\n+        rows(32), rows(36), rows(28), rows(33), rows(36), rows(39), rows(34));\n+  }\n+\n+  @Test\n+  public void testExp() throws IOException {\n+    JSONObject result =\n+        executeQuery(\n+            String.format(\n+                \"source=%s | eval f = exp(age) | fields f\", TEST_INDEX_BANK));\n+    verifySchema(result, schema(\"f\", null, \"double\"));\n+    verifyDataRows(\n+        result, rows(Math.exp(32)), rows(Math.exp(36)), rows(Math.exp(28)), rows(Math.exp(33)),\n+        rows(Math.exp(36)), rows(Math.exp(39)), rows(Math.exp(34)));\n+  }\n+\n+  @Test\n+  public void testFloor() throws IOException {\n+    JSONObject result =\n+        executeQuery(\n+            String.format(\n+                \"source=%s | eval f = floor(age) | fields f\", TEST_INDEX_BANK));\n+    verifySchema(result, schema(\"f\", null, \"long\"));\n+    verifyDataRows(\n+        result,\n+        rows(32), rows(36), rows(28), rows(33), rows(36), rows(39), rows(34));\n+  }\n+\n+  @Test\n+  public void testLn() throws IOException {\n+    JSONObject result =\n+        executeQuery(\n+            String.format(\n+                \"source=%s | eval f = ln(age) | fields f\", TEST_INDEX_BANK));\n+    verifySchema(result, schema(\"f\", null, \"double\"));\n+    verifyDataRows(\n+        result, rows(Math.log(32)), rows(Math.log(36)), rows(Math.log(28)), rows(Math.log(33)),\n+        rows(Math.log(36)), rows(Math.log(39)), rows(Math.log(34)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ed20c556d36e9f874bd1b290465895d9486fec"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTEyNjU5OnYy", "diffSide": "RIGHT", "path": "integ-test/src/test/java/com/amazon/opendistroforelasticsearch/sql/util/MatcherUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTo1MjoyM1rOGwGnzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjo1Mzo0MlrOGwHuEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5MzMyNQ==", "bodyText": "np: allMatch(v -> valuesAreClose...) ?", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r453093325", "createdAt": "2020-07-10T21:52:23Z", "author": {"login": "dai-chen"}, "path": "integ-test/src/test/java/com/amazon/opendistroforelasticsearch/sql/util/MatcherUtils.java", "diffHunk": "@@ -239,8 +233,29 @@ protected boolean matchesSafely(JSONArray array) {\n     };\n   }\n \n-  public static IsCloseTo closeTo(Number value) {\n-    return new IsCloseTo(value.doubleValue(), 1e-10);\n+  public static TypeSafeMatcher<JSONArray> closeTo(Number... values) {\n+    final double error = 1e-10;\n+    return new TypeSafeMatcher<JSONArray>() {\n+      @Override\n+      protected boolean matchesSafely(JSONArray item) {\n+        List<Number> expectedValues = new ArrayList<>(Arrays.asList(values));\n+        List<Number> actualValues = new ArrayList<>();\n+        item.iterator().forEachRemaining(v -> actualValues.add((Number) v));\n+        return actualValues.stream()\n+            .map(v -> (valuesAreClose(v, expectedValues.get(actualValues.indexOf(v)))))\n+            .reduce((a, b) -> a && b)\n+            .get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef44d0bad611273f85882da34f4e9d7fa1b5bc9b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExMTMxMw==", "bodyText": "Done, thanks!", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/540#discussion_r453111313", "createdAt": "2020-07-10T22:53:42Z", "author": {"login": "chloe-zh"}, "path": "integ-test/src/test/java/com/amazon/opendistroforelasticsearch/sql/util/MatcherUtils.java", "diffHunk": "@@ -239,8 +233,29 @@ protected boolean matchesSafely(JSONArray array) {\n     };\n   }\n \n-  public static IsCloseTo closeTo(Number value) {\n-    return new IsCloseTo(value.doubleValue(), 1e-10);\n+  public static TypeSafeMatcher<JSONArray> closeTo(Number... values) {\n+    final double error = 1e-10;\n+    return new TypeSafeMatcher<JSONArray>() {\n+      @Override\n+      protected boolean matchesSafely(JSONArray item) {\n+        List<Number> expectedValues = new ArrayList<>(Arrays.asList(values));\n+        List<Number> actualValues = new ArrayList<>();\n+        item.iterator().forEachRemaining(v -> actualValues.add((Number) v));\n+        return actualValues.stream()\n+            .map(v -> (valuesAreClose(v, expectedValues.get(actualValues.indexOf(v)))))\n+            .reduce((a, b) -> a && b)\n+            .get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5MzMyNQ=="}, "originalCommit": {"oid": "ef44d0bad611273f85882da34f4e9d7fa1b5bc9b"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2125, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}