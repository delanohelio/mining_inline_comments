{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NzUxNjQy", "number": 2312, "title": "Add Lua language support", "bodyText": "Adds Lua parsing support. Closes #1931.\nThere isn't support yet for using semgrep patterns yet; this only allows parsing the AST with semgrep-core. #2280 needs to be finished first.\nThere are a lot of changes to other submodules needed:\nreturntocorp/pfff#362\nreturntocorp/semgrep-grammars#9\nreturntocorp/ocaml-tree-sitter-semgrep#131\nreturntocorp/ocaml-tree-sitter-lang#3\nAlso, the version of tree-sitter-lua used was customized to fix some issues.\nAzganoth/tree-sitter-lua@master...Ruin0x11:fix-call-expression", "createdAt": "2020-12-27T01:24:04Z", "url": "https://github.com/returntocorp/semgrep/pull/2312", "merged": true, "mergeCommit": {"oid": "76580e4c2c1b91f177b612a94bdf3097602f5be8"}, "closed": true, "closedAt": "2020-12-31T13:59:53Z", "author": {"login": "Ruin0x11"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdp4SwXAH2gAyNTQ1NzUxNjQyOjk4ZDY2MjljNjkxMTRjMmIwOTliYzFiYjk5NjIwMTg3NjA5ZTY1Yzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdrkYqdAFqTU2MDM1NTk1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "98d6629c69114c2b099bc1bb99620187609e65c8", "author": {"user": {"login": "Ruin0x11", "name": null}}, "url": "https://github.com/returntocorp/semgrep/commit/98d6629c69114c2b099bc1bb99620187609e65c8", "committedDate": "2020-12-26T08:03:18Z", "message": "Add Lua parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21349a7e77f1bc12f03ef7d980b83a217bffd3a5", "author": {"user": {"login": "Ruin0x11", "name": null}}, "url": "https://github.com/returntocorp/semgrep/commit/21349a7e77f1bc12f03ef7d980b83a217bffd3a5", "committedDate": "2020-12-27T00:56:48Z", "message": "Improve Lua parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b", "author": {"user": {"login": "Ruin0x11", "name": null}}, "url": "https://github.com/returntocorp/semgrep/commit/762c48a1671b05590e0541c6c103e76ba0f1c84b", "committedDate": "2020-12-27T01:39:09Z", "message": "Run pre-commit hooks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MTk2OTQ1", "url": "https://github.com/returntocorp/semgrep/pull/2312#pullrequestreview-559196945", "createdAt": "2020-12-28T15:44:28Z", "commit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNTo0NDoyOFrOIL8RfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMDoxMjoyNVrOIMBM2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM5Mjc2NA==", "bodyText": "why this?", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549392764", "createdAt": "2020-12-28T15:44:28Z", "author": {"login": "aryx"}, "path": "Makefile", "diffHunk": "@@ -67,7 +67,7 @@ setup:\n \tgit submodule update --init --recursive\n \topam update -y\n \topam install -y --deps-only ./semgrep-core/pfff\n-\tcd ocaml-tree-sitter && ./scripts/install-tree-sitter-lib\n+\t# cd ocaml-tree-sitter && ./scripts/install-tree-sitter-lib", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNjYyNg==", "bodyText": "Maybe we can reuse Static to represent local def. static int f() { ...} declare a local function in C (local to the file; not exported).", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549416626", "createdAt": "2020-12-28T17:00:26Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNjc1MA==", "bodyText": "probably need to use Dot or the name type with its qualifier instead of just using a string.", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549416750", "createdAt": "2020-12-28T17:01:04Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }\n+\n+\n+let map_function_name_field (env : env) ((v1, v2) : CST.function_name_field): string =\n+  let (v1, _) =\n+    str env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \".\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  String.concat \".\" (v1::v2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNzI2NQ==", "bodyText": "Could be just Div, not FloorDiv.", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549417265", "createdAt": "2020-12-28T17:02:57Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }\n+\n+\n+let map_function_name_field (env : env) ((v1, v2) : CST.function_name_field): string =\n+  let (v1, _) =\n+    str env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \".\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  String.concat \".\" (v1::v2)\n+\n+let map_function_name (env : env) ((v1, v2) : CST.function_name) =\n+  let (name, tok) =\n+    (match v1 with\n+     | `Id tok ->\n+         (fst (str env tok), tok) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+     | `Func_name_field ((v1, v2) as x) -> (map_function_name_field env x, v1)\n+    )\n+  in\n+  (match v2 with\n+   | Some (v1, v2) ->\n+       let colon = token env v1 (* \":\" *) in\n+       let (s, _) =\n+         str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       (String.concat \":\" [name; s], tok)\n+   | None -> (name, tok))\n+\n+let rec map_expression_list (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr list =\n+  let v1 = map_expression env v1 in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 = map_expression env v2 in\n+      v2\n+    ) v2\n+  in\n+  (v1::v2)\n+\n+and map_expression_tuple (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr =\n+  let v1 = map_expression_list env (v1, v2) in\n+  G.Tuple (G.fake_bracket v1)\n+\n+and map_anon_arguments (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.arguments =\n+  let v1 = map_expression_list env (v1, v2) in\n+  List.map (fun (v1: G.expr) -> G.Arg v1) v1\n+\n+and map_arguments (env : env) (x : CST.arguments): G.arguments G.bracket =\n+  (match x with\n+   | `LPAR_opt_exp_rep_COMMA_exp_RPAR (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"(\" *) in\n+       let v2 =\n+         (match v2 with\n+          | Some x -> map_anon_arguments env x\n+          | None -> [])\n+       in\n+       let v3 = token env v3 (* \")\" *) in\n+       (v1, v2, v3)\n+   | `Table x -> fb [G.Arg (map_table env x)]\n+   | `Str tok -> fb [G.Arg (string_literal env tok)](* string *)\n+  )\n+\n+and map_binary_operation (env : env) (x : CST.binary_operation) =\n+  (match x with\n+   | `Exp_or_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"or\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Or, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_and_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"and\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.And, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Lt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_EQEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"==\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Eq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDEEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.NotEq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.GtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Gt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_BAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"|\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitOr, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDE_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitNot, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_AMP_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"&\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitAnd, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTLT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSL, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTGT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">>\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSR, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PLUS_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"+\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Plus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"-\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Minus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_STAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"*\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mult, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"/\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.FloorDiv, v2), fb [G.Arg v1; G.Arg v3])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNzQwMA==", "bodyText": "ah ok, you probably know better; I am not familiar with Lua.", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549417400", "createdAt": "2020-12-28T17:03:19Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }\n+\n+\n+let map_function_name_field (env : env) ((v1, v2) : CST.function_name_field): string =\n+  let (v1, _) =\n+    str env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \".\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  String.concat \".\" (v1::v2)\n+\n+let map_function_name (env : env) ((v1, v2) : CST.function_name) =\n+  let (name, tok) =\n+    (match v1 with\n+     | `Id tok ->\n+         (fst (str env tok), tok) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+     | `Func_name_field ((v1, v2) as x) -> (map_function_name_field env x, v1)\n+    )\n+  in\n+  (match v2 with\n+   | Some (v1, v2) ->\n+       let colon = token env v1 (* \":\" *) in\n+       let (s, _) =\n+         str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       (String.concat \":\" [name; s], tok)\n+   | None -> (name, tok))\n+\n+let rec map_expression_list (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr list =\n+  let v1 = map_expression env v1 in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 = map_expression env v2 in\n+      v2\n+    ) v2\n+  in\n+  (v1::v2)\n+\n+and map_expression_tuple (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr =\n+  let v1 = map_expression_list env (v1, v2) in\n+  G.Tuple (G.fake_bracket v1)\n+\n+and map_anon_arguments (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.arguments =\n+  let v1 = map_expression_list env (v1, v2) in\n+  List.map (fun (v1: G.expr) -> G.Arg v1) v1\n+\n+and map_arguments (env : env) (x : CST.arguments): G.arguments G.bracket =\n+  (match x with\n+   | `LPAR_opt_exp_rep_COMMA_exp_RPAR (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"(\" *) in\n+       let v2 =\n+         (match v2 with\n+          | Some x -> map_anon_arguments env x\n+          | None -> [])\n+       in\n+       let v3 = token env v3 (* \")\" *) in\n+       (v1, v2, v3)\n+   | `Table x -> fb [G.Arg (map_table env x)]\n+   | `Str tok -> fb [G.Arg (string_literal env tok)](* string *)\n+  )\n+\n+and map_binary_operation (env : env) (x : CST.binary_operation) =\n+  (match x with\n+   | `Exp_or_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"or\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Or, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_and_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"and\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.And, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Lt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_EQEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"==\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Eq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDEEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.NotEq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.GtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Gt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_BAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"|\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitOr, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDE_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitNot, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_AMP_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"&\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitAnd, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTLT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSL, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTGT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">>\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSR, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PLUS_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"+\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Plus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"-\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Minus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_STAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"*\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mult, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"/\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.FloorDiv, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASHSLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"//\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Div, v2), fb [G.Arg v1; G.Arg v3])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxODAwMg==", "bodyText": "you can do\nlet (s, tok) = str env tok in\nG.L (G.Float (s, tok))", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549418002", "createdAt": "2020-12-28T17:05:21Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }\n+\n+\n+let map_function_name_field (env : env) ((v1, v2) : CST.function_name_field): string =\n+  let (v1, _) =\n+    str env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \".\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  String.concat \".\" (v1::v2)\n+\n+let map_function_name (env : env) ((v1, v2) : CST.function_name) =\n+  let (name, tok) =\n+    (match v1 with\n+     | `Id tok ->\n+         (fst (str env tok), tok) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+     | `Func_name_field ((v1, v2) as x) -> (map_function_name_field env x, v1)\n+    )\n+  in\n+  (match v2 with\n+   | Some (v1, v2) ->\n+       let colon = token env v1 (* \":\" *) in\n+       let (s, _) =\n+         str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       (String.concat \":\" [name; s], tok)\n+   | None -> (name, tok))\n+\n+let rec map_expression_list (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr list =\n+  let v1 = map_expression env v1 in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 = map_expression env v2 in\n+      v2\n+    ) v2\n+  in\n+  (v1::v2)\n+\n+and map_expression_tuple (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr =\n+  let v1 = map_expression_list env (v1, v2) in\n+  G.Tuple (G.fake_bracket v1)\n+\n+and map_anon_arguments (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.arguments =\n+  let v1 = map_expression_list env (v1, v2) in\n+  List.map (fun (v1: G.expr) -> G.Arg v1) v1\n+\n+and map_arguments (env : env) (x : CST.arguments): G.arguments G.bracket =\n+  (match x with\n+   | `LPAR_opt_exp_rep_COMMA_exp_RPAR (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"(\" *) in\n+       let v2 =\n+         (match v2 with\n+          | Some x -> map_anon_arguments env x\n+          | None -> [])\n+       in\n+       let v3 = token env v3 (* \")\" *) in\n+       (v1, v2, v3)\n+   | `Table x -> fb [G.Arg (map_table env x)]\n+   | `Str tok -> fb [G.Arg (string_literal env tok)](* string *)\n+  )\n+\n+and map_binary_operation (env : env) (x : CST.binary_operation) =\n+  (match x with\n+   | `Exp_or_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"or\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Or, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_and_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"and\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.And, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Lt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_EQEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"==\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Eq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDEEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.NotEq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.GtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Gt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_BAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"|\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitOr, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDE_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitNot, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_AMP_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"&\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitAnd, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTLT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSL, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTGT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">>\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSR, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PLUS_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"+\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Plus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"-\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Minus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_STAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"*\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mult, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"/\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.FloorDiv, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASHSLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"//\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Div, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PERC_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"%\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mod, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DOTDOT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"..\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Concat, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_HAT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"^\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitXor, v2), fb [G.Arg v1; G.Arg v3])\n+  )\n+\n+and map_statement_list (env : env) (x: CST.statement list) : G.stmt list =\n+  let v1 = List.map (map_statement env) x in\n+  List.flatten v1\n+\n+and map_statements_and_return (env : env) ((v1, v2)): G.stmt list =\n+  let v1 = map_statement_list env v1 in\n+  let v3 =\n+    (match v2 with\n+     | Some x -> let v4 = map_return_statement env x in\n+         List.append v1 [v4]\n+     | None -> v1)\n+  in\n+  v3\n+\n+and map_do_block (env : env) ((v1, v2, v3, v4)): G.stmt =\n+  let v1 = token env v1 (* \"do\" *) in\n+  let v2 = map_statements_and_return env (v2, v3) in\n+  let v3 = token env v4 (* \"end\" *) in\n+  G.Block (v1, v2, v3) |> G.s\n+\n+and map_else_ (env : env) ((v1, v2, v3) : CST.else_): G.stmt =\n+  let v1 = token env v1 (* \"else\" *) in\n+  let stmt_list = map_statements_and_return env (v2, v3) in\n+  G.Block (G.fake_bracket stmt_list) |> G.s\n+\n+(* and map_elseif (env : env) ((v1, v2, v3, v4, v5) : CST.elseif) =\n+ *   let v1 = token env v1 (\\* \"elseif\" *\\) in\n+ *   let v2 = map_expression env v2 in\n+ *   let v3 = token env v3 (\\* \"then\" *\\) in\n+ *   let v4 = List.map (map_statement env) v4 in\n+ *   let v5 =\n+ *     (match v5 with\n+ *     | Some x -> map_return_statement env x\n+ *     | None -> todo env ())\n+ *   in\n+ *   todo env (v1, v2, v3, v4, v5) *)\n+\n+and map_expression (env : env) (x : CST.expression): G.expr =\n+  (match x with\n+   | `Spread tok -> G.Ellipsis (token env tok) (* \"...\" *)\n+   | `Prefix x -> map_prefix env x\n+   | `Func_defi (v1, v2) ->\n+       let t = token env v1 (* \"function\" *) in\n+       let v2 = map_function_body env v2 v1 in\n+       G.Lambda v2\n+   | `Table x -> map_table env x\n+   | `Bin_oper x -> map_binary_operation env x\n+   | `Un_oper (v1, v2) ->\n+       let (op, tok) =\n+         (match v1 with\n+          | `Not tok -> (G.Plus, tok) (* \"not\" *)\n+          | `HASH tok -> (G.Length, tok) (* \"#\" *)\n+          | `DASH tok -> (G.Minus, tok) (* \"-\" *)\n+          | `TILDE tok -> (G.BitNot, tok) (* \"~\" *)\n+         )\n+       in\n+       let v2 = map_expression env v2 in\n+       G.Call (G.IdSpecial (G.Op op, token env tok), fb [G.Arg v2])\n+\n+   | `Str tok -> string_literal env tok (* string *)\n+   | `Num tok -> G.L (G.Float (fst (str env tok), token env tok)) (* number *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3MzQ5Ng==", "bodyText": "impressive work! Thx a lot! Lots of boilerplate to fill.", "url": "https://github.com/returntocorp/semgrep/pull/2312#discussion_r549473496", "createdAt": "2020-12-28T20:12:25Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_lua_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,739 @@\n+(* Ruin0x11\n+ *\n+ * Copyright (c) 2020\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+*)\n+open Common\n+module CST = Tree_sitter_lua.CST\n+module H = Parse_tree_sitter_helpers\n+module PI = Parse_info\n+(* open AST_generic *)\n+module G = AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* lua parser using ocaml-tree-sitter-lang/lua and converting\n+ * directly to pfff/h_program-lang/ast_generic.ml\n+ *\n+*)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+let _fake = AST_generic.fake\n+let token = H.token\n+let str = H.str\n+let sc = PI.fake_info \";\"\n+let fb = G.fake_bracket\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/lua/Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the lua CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(* let todo (env : env) _ =\n+ *    failwith \"not implemented\" *)\n+\n+let deoptionalize l =\n+  let rec deopt acc = function\n+    | [] -> List.rev acc\n+    | None::tl -> deopt acc tl\n+    | Some x::tl -> deopt (x::acc) tl\n+  in\n+  deopt [] l\n+\n+let identifier (env : env) (tok : CST.identifier): G.ident =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let ident (env : env) (tok : CST.identifier) =\n+  G.Id (identifier env tok, G.empty_id_info ())\n+\n+let string_literal (env : env) (tok :CST.identifier) =\n+  G.L (G.String (str env tok))\n+\n+let map_field_sep (env : env) (x : CST.field_sep) =\n+  (match x with\n+   | `COMMA tok -> token env tok (* \",\" *)\n+   | `SEMI tok -> token env tok (* \";\" *)\n+  )\n+\n+(* let map_number (env : env) (tok : CST.number) =\n+ *   token env tok (\\* number *\\) *)\n+\n+(* let map_identifier (env : env) (tok : CST.identifier) =\n+ *   token env tok (\\* pattern [a-zA-Z_][a-zA-Z0-9_]* *\\) *)\n+\n+(* let map_string_ (env : env) (tok : CST.string_) =\n+ *   token env tok (\\* string *\\) *)\n+\n+let map_parameters (env : env) ((v1, v2, v3) : CST.parameters): G.parameters =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some (v1, v2, v3) ->\n+         let v1 =\n+           (match v1 with\n+            | `Self tok -> G.ParamClassic (G.param_of_id (identifier env tok)) (* \"self\" *)\n+            | `Spread tok -> G.ParamEllipsis (token env tok) (* \"...\" *)\n+            | `Id tok ->\n+                G.ParamClassic (G.param_of_id (identifier env tok)) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+           )\n+         in\n+         let v2 =\n+           List.map (fun (v1, v2) ->\n+             let v1 = token env v1 (* \",\" *) in\n+             let v2 =\n+               identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+             in\n+             Some (G.ParamClassic ((G.param_of_id v2)))\n+           ) v2\n+         in\n+         let v3 =\n+           (match v3 with\n+            | Some (v1, v2) ->\n+                let v1 = token env v1 (* \",\" *) in\n+                let v2 = token env v2 (* \"...\" *) in\n+                Some (G.ParamEllipsis v2)\n+            | None -> None)\n+         in\n+         deoptionalize (List.concat [[Some v1]; v2; [v3]])\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v2\n+\n+let map_local_variable_declarator (env : env) ((v1, v2) : CST.local_variable_declarator) (local : PI.token_mutable): G.entity =\n+  let ident =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  let name = G.EId (ident, G.empty_id_info ()) in (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  { G.name = name; attrs = [G.KeywordAttr (G.LocalDef, local)]; tparams = [] }\n+\n+\n+let map_function_name_field (env : env) ((v1, v2) : CST.function_name_field): string =\n+  let (v1, _) =\n+    str env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \".\" *) in\n+      let (s, _) =\n+        str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      s\n+    ) v2\n+  in\n+  String.concat \".\" (v1::v2)\n+\n+let map_function_name (env : env) ((v1, v2) : CST.function_name) =\n+  let (name, tok) =\n+    (match v1 with\n+     | `Id tok ->\n+         (fst (str env tok), tok) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+     | `Func_name_field ((v1, v2) as x) -> (map_function_name_field env x, v1)\n+    )\n+  in\n+  (match v2 with\n+   | Some (v1, v2) ->\n+       let colon = token env v1 (* \":\" *) in\n+       let (s, _) =\n+         str env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       (String.concat \":\" [name; s], tok)\n+   | None -> (name, tok))\n+\n+let rec map_expression_list (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr list =\n+  let v1 = map_expression env v1 in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 = map_expression env v2 in\n+      v2\n+    ) v2\n+  in\n+  (v1::v2)\n+\n+and map_expression_tuple (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.expr =\n+  let v1 = map_expression_list env (v1, v2) in\n+  G.Tuple (G.fake_bracket v1)\n+\n+and map_anon_arguments (env : env) ((v1, v2) : CST.anon_exp_rep_COMMA_exp_0bb260c): G.arguments =\n+  let v1 = map_expression_list env (v1, v2) in\n+  List.map (fun (v1: G.expr) -> G.Arg v1) v1\n+\n+and map_arguments (env : env) (x : CST.arguments): G.arguments G.bracket =\n+  (match x with\n+   | `LPAR_opt_exp_rep_COMMA_exp_RPAR (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"(\" *) in\n+       let v2 =\n+         (match v2 with\n+          | Some x -> map_anon_arguments env x\n+          | None -> [])\n+       in\n+       let v3 = token env v3 (* \")\" *) in\n+       (v1, v2, v3)\n+   | `Table x -> fb [G.Arg (map_table env x)]\n+   | `Str tok -> fb [G.Arg (string_literal env tok)](* string *)\n+  )\n+\n+and map_binary_operation (env : env) (x : CST.binary_operation) =\n+  (match x with\n+   | `Exp_or_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"or\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Or, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_and_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"and\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.And, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Lt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_EQEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"==\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Eq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDEEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.NotEq, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTEQ_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">=\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.GtE, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Gt, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_BAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"|\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitOr, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_TILDE_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"~\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitNot, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_AMP_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"&\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitAnd, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_LTLT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"<<\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSL, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_GTGT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \">>\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.LSR, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PLUS_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"+\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Plus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"-\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Minus, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_STAR_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"*\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mult, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"/\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.FloorDiv, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_SLASHSLASH_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"//\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Div, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_PERC_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"%\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Mod, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_DOTDOT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"..\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.Concat, v2), fb [G.Arg v1; G.Arg v3])\n+   | `Exp_HAT_exp (v1, v2, v3) ->\n+       let v1 = map_expression env v1 in\n+       let v2 = token env v2 (* \"^\" *) in\n+       let v3 = map_expression env v3 in\n+       G.Call (G.IdSpecial (G.Op G.BitXor, v2), fb [G.Arg v1; G.Arg v3])\n+  )\n+\n+and map_statement_list (env : env) (x: CST.statement list) : G.stmt list =\n+  let v1 = List.map (map_statement env) x in\n+  List.flatten v1\n+\n+and map_statements_and_return (env : env) ((v1, v2)): G.stmt list =\n+  let v1 = map_statement_list env v1 in\n+  let v3 =\n+    (match v2 with\n+     | Some x -> let v4 = map_return_statement env x in\n+         List.append v1 [v4]\n+     | None -> v1)\n+  in\n+  v3\n+\n+and map_do_block (env : env) ((v1, v2, v3, v4)): G.stmt =\n+  let v1 = token env v1 (* \"do\" *) in\n+  let v2 = map_statements_and_return env (v2, v3) in\n+  let v3 = token env v4 (* \"end\" *) in\n+  G.Block (v1, v2, v3) |> G.s\n+\n+and map_else_ (env : env) ((v1, v2, v3) : CST.else_): G.stmt =\n+  let v1 = token env v1 (* \"else\" *) in\n+  let stmt_list = map_statements_and_return env (v2, v3) in\n+  G.Block (G.fake_bracket stmt_list) |> G.s\n+\n+(* and map_elseif (env : env) ((v1, v2, v3, v4, v5) : CST.elseif) =\n+ *   let v1 = token env v1 (\\* \"elseif\" *\\) in\n+ *   let v2 = map_expression env v2 in\n+ *   let v3 = token env v3 (\\* \"then\" *\\) in\n+ *   let v4 = List.map (map_statement env) v4 in\n+ *   let v5 =\n+ *     (match v5 with\n+ *     | Some x -> map_return_statement env x\n+ *     | None -> todo env ())\n+ *   in\n+ *   todo env (v1, v2, v3, v4, v5) *)\n+\n+and map_expression (env : env) (x : CST.expression): G.expr =\n+  (match x with\n+   | `Spread tok -> G.Ellipsis (token env tok) (* \"...\" *)\n+   | `Prefix x -> map_prefix env x\n+   | `Func_defi (v1, v2) ->\n+       let t = token env v1 (* \"function\" *) in\n+       let v2 = map_function_body env v2 v1 in\n+       G.Lambda v2\n+   | `Table x -> map_table env x\n+   | `Bin_oper x -> map_binary_operation env x\n+   | `Un_oper (v1, v2) ->\n+       let (op, tok) =\n+         (match v1 with\n+          | `Not tok -> (G.Plus, tok) (* \"not\" *)\n+          | `HASH tok -> (G.Length, tok) (* \"#\" *)\n+          | `DASH tok -> (G.Minus, tok) (* \"-\" *)\n+          | `TILDE tok -> (G.BitNot, tok) (* \"~\" *)\n+         )\n+       in\n+       let v2 = map_expression env v2 in\n+       G.Call (G.IdSpecial (G.Op op, token env tok), fb [G.Arg v2])\n+\n+   | `Str tok -> string_literal env tok (* string *)\n+   | `Num tok -> G.L (G.Float (fst (str env tok), token env tok)) (* number *)\n+   | `Nil tok -> G.L (G.Null (token env tok)) (* \"nil\" *)\n+   | `True tok -> G.L (G.Bool (true, token env tok)) (* \"true\" *)\n+   | `False tok -> G.L (G.Bool (false, token env tok)) (* \"false\" *)\n+   | `Id tok ->\n+       ident env tok (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  )\n+\n+and map_field (env : env) (x : CST.field): G.expr =\n+  let (ent, tok, def) = (match x with\n+    | `LBRACK_exp_RBRACK_EQ_exp (v1, v2, v3, v4, v5) ->\n+        let v1 = token env v1 (* \"[\" *) in\n+        let v2 = map_expression env v2 in\n+        let v3 = token env v3 (* \"]\" *) in\n+        let v4 = token env v4 (* \"=\" *) in\n+        let v5 = map_expression env v5 in\n+        (v2, v3, v5)\n+    | `Id_EQ_exp (v1, v2, v3) ->\n+        let v1 =\n+          identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+        in\n+        let v2 = token env v2 (* \"=\" *) in\n+        let v3 = map_expression env v3 in\n+        (G.Id (v1, G.empty_id_info ()), v2, v3)\n+    | `Exp x -> let expr = map_expression env x in\n+        let ident = G.IdSpecial (G.NextArrayIndex, G.fake \"next_array_index\") in\n+        (ident, G.fake \"=\", expr)\n+  )\n+  in\n+  G.Assign (ent, tok, def)\n+\n+and map_field_sequence (env : env) ((v1, v2, v3) : CST.field_sequence): G.expr list =\n+  let v1 = map_field env v1 in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = map_field_sep env v1 in\n+      let v2 = map_field env v2 in\n+      v2\n+    ) v2\n+  in\n+  let v3 =\n+    (match v3 with\n+     | Some x -> [map_field_sep env x]\n+     | None -> [])\n+  in\n+  (v1::v2)\n+\n+and map_function_body (env : env) ((v1, v2, v3, v4) : CST.function_body) (name: CST.identifier): G.function_definition =\n+  let v1 = map_parameters env v1 in\n+  let body = map_do_block env (name, v2, v3, v4) in\n+  { G.fparams = v1; frettype = None; fkind = (G.Function, token env name); fbody = body }\n+\n+and map_function_call_expr (env : env) (x : CST.function_call_statement): G.expr =\n+  (match x with\n+   | `Prefix_args (v1, v2) ->\n+       let v1 = map_prefix env v1 in\n+       let v2 = map_arguments env v2 in\n+       G.Call (v1, v2)\n+   | `Prefix_COLON_id_args (v1, v2, v3, v4) ->\n+       let v1 = map_prefix env v1 in\n+       let v2 = token env v2 (* \":\" *) in\n+       let v3 =\n+         ident env v3 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       let tbl = G.Arg v3 in\n+       let v4 = map_arguments env v4 in\n+       G.Call (v1, v4)\n+  )\n+\n+\n+and map_function_call_statement (env : env) (x : CST.function_call_statement): G.stmt =\n+  let expr = map_function_call_expr env x in\n+  G.ExprStmt (expr, sc) |> G.s\n+\n+and map_in_loop_expression (env : env) ((v1, v2, v3, v4, v5) : CST.in_loop_expression) =\n+  let v1 =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let var: G.variable_definition = { vinit = None; vtype = None } in\n+  let for_init_var = G.ForInitVar (G.basic_entity v1 [], var) in\n+  let v2 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 =\n+        identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+      in\n+      let var: G.variable_definition = { vinit = None; vtype = None } in\n+      G.ForInitVar (G.basic_entity v2 [], var)\n+    ) v2\n+  in\n+  (* TODO *)\n+  let v3 = token env v3 (* \"in\" *) in\n+  let v4 = map_expression env v4 in\n+  let v5 =\n+    List.map (fun (v1, v2) ->\n+      let v1 = token env v1 (* \",\" *) in\n+      let v2 = map_expression env v2 in\n+      v2\n+    ) v5\n+  in\n+  G.ForIn (for_init_var::v2, (v4::v5))\n+\n+and map_loop_expression (env : env) ((v1, v2, v3, v4, v5, v6) : CST.loop_expression) =\n+  let v1 =\n+    identifier env v1 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+  in\n+  let v2 = token env v2 (* \"=\" *) in\n+  let v3 = map_expression env v3 in\n+  let var: G.variable_definition = { vinit = None; vtype = None } in\n+  let for_init_var = G.ForInitVar (G.basic_entity v1 [], var) in\n+  let v4 = token env v4 (* \",\" *) in\n+  let v5 = map_expression env v5 in\n+  let v6 =\n+    (match v6 with\n+     | Some (v1, v2) ->\n+         let v1 = token env v1 (* \",\" *) in\n+         let v2 = map_expression env v2 in\n+         Some v2\n+     | None -> None)\n+  in\n+  G.ForClassic ([for_init_var], Some v5, v6)\n+\n+and map_prefix (env : env) (x : CST.prefix): G.expr =\n+  (match x with\n+   | `Var_decl x -> map_variable_declarator_expr env x\n+   | `Func_call_stmt x -> map_function_call_expr env x\n+   | `LPAR_exp_RPAR (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"(\" *) in\n+       let v2 = map_expression env v2 in\n+       let v3 = token env v3 (* \")\" *) in\n+       v2\n+  )\n+\n+and map_return_statement (env : env) ((v1, v2, v3) : CST.return_statement) =\n+  let v1 = token env v1 (* \"return\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some x -> Some (map_expression_tuple env x)\n+     | None -> None)\n+  in\n+  let v3 =\n+    (match v3 with\n+     | Some tok -> token env tok (* \";\" *)\n+     | None -> sc)\n+  in\n+  G.Return (v1, v2, v3) |> G.s\n+\n+and map_statement (env : env) (x : CST.statement): G.stmt list =\n+  (match x with\n+   | `Exp x -> [G.ExprStmt (map_expression env x, sc) |> G.s]\n+   | `Var_decl (v1, v2, v3, v4, v5) ->\n+       let v1 = map_variable_declarator env v1 in\n+       let v2 =\n+         List.map (fun (v1, v2) ->\n+           let v1 = token env v1 (* \",\" *) in\n+           let v2 = map_variable_declarator env v2 in\n+           v2\n+         ) v2\n+       in\n+       let v3 = token env v3 (* \"=\" *) in\n+       let v4 = map_expression env v4 in\n+       let v5 =\n+         List.map (fun (v1, v2) ->\n+           let v1 = token env v1 (* \",\" *) in\n+           let v2 = map_expression env v2 in\n+           v2\n+         ) v5\n+       in\n+       let ent = v1 in (* TODO multi assign support *)\n+       [G.DefStmt (ent, G.VarDef {G.vinit = Some v4; G.vtype = None}) |> G.s]\n+   | `Local_var_decl (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"local\" *) in\n+       let v2 = map_local_variable_declarator env v2 v1 in\n+       let v3 =\n+         (match v3 with\n+          | Some (v1, v2, v3) ->\n+              let v1 = token env v1 (* \"=\" *) in\n+              let v2 = map_expression env v2 in\n+              let v3 =\n+                List.map (fun (v1, v2) ->\n+                  let v1 = token env v1 (* \",\" *) in\n+                  let v2 = map_expression env v2 in\n+                  v2\n+                ) v3\n+              in\n+              (v2::v3)\n+          | None -> [])\n+       in\n+       let ent = v2 in (* TODO multi assign support *)\n+       [G.DefStmt (ent, G.VarDef {G.vinit = Some (List.nth v3 0); G.vtype = None}) |> G.s]\n+   | `Do_stmt (v1, v2, v3, v4) ->\n+       [map_do_block env (v1, v2, v3, v4)]\n+   | `If_stmt (v1, v2, v3, v4, v5, v6, v7, v8) ->\n+       let v1 = token env v1 (* \"if\" *) in\n+       let v2 = map_expression env v2 in\n+       let v3 = token env v3 (* \"then\" *) in\n+       let stmt_list = G.Block (G.fake_bracket (map_statements_and_return env (v4, v5))) |> G.s in\n+       let elseifs = List.fold_left (fun (acc: G.stmt option) ((v1, v2, v3, v4, v5) : CST.elseif) ->\n+         let v1 = token env v1 (* \"elseif\" *) in\n+         let v2 = map_expression env v2 in\n+         let v3 = token env v3 (* \"then\" *) in\n+         let stmt_list = G.Block (G.fake_bracket (map_statements_and_return env (v4, v5))) |> G.s in\n+         Some ((G.If (v1, v2, stmt_list, acc)) |> G.s)\n+       ) None v6 in\n+       let v7 =\n+         (match v7 with\n+          | Some x -> Some (map_else_ env x)\n+          | None -> None)\n+       in\n+       let v8 = token env v8 (* \"end\" *) in\n+       let ifstmt = (match v7 with\n+         | Some else_ -> G.If (v1, v2, stmt_list, Some else_)\n+         | None -> G.If (v1, v2, stmt_list, elseifs)\n+       ) in\n+       [ifstmt |> G.s]\n+   | `While_stmt (v1, v2, v3, v4, v5, v6) ->\n+       let v1 = token env v1 (* \"while\" *) in\n+       let v2 = map_expression env v2 in\n+       let block = map_do_block env (v3, v4, v5, v6) in\n+       [G.While (v1, v2, block) |> G.s]\n+   | `Repeat_stmt (v1, v2, v3, v4, v5) ->\n+       let t = token env v1 in (* \"repeat\" *)\n+       let block = map_do_block env (v1, v2, v3, v4) in\n+       let v5 = map_expression env v5 in\n+       [G.DoWhile (t, block, v5) |> G.s]\n+   | `For_stmt (v1, v2, v3, v4, v5, v6) ->\n+       let v1 = token env v1 (* \"for\" *) in\n+       let v2 = map_loop_expression env v2 in\n+       let v3 = map_do_block env (v3, v4, v5, v6) in\n+       [G.For (v1, v2, v3) |> G.s]\n+   | `For_in_stmt (v1, v2, v3, v4, v5, v6) ->\n+       let v1 = token env v1 (* \"for\" *) in\n+       let v2 = map_in_loop_expression env v2 in\n+       let block = map_do_block env (v3, v4, v5, v6) in\n+       [G.For (v1, v2, block) |> G.s]\n+   | `Goto_stmt (v1, v2) ->\n+       let v1 = token env v1 (* \"goto\" *) in\n+       let v2 =\n+         identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       [G.Goto (v1, v2) |> G.s]\n+   | `Brk_stmt tok ->\n+       let v1 = token env tok (* \"break\" *) in\n+       [G.Break (v1, LNone, sc) |> G.s]\n+   | `Label_stmt (v1, v2, v3) ->\n+       let v1 = token env v1 (* \"::\" *) in\n+       let v2 =\n+         identifier env v2 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       let v3 = token env v3 (* \"::\" *) in\n+       [G.Label (v2, G.empty_fbody) |> G.s]\n+   | `Empty_stmt tok -> [] (* \";\" *)\n+   | `Func_stmt (v1, v2, v3) ->\n+       let (s, v2) = map_function_name env v2 in\n+       let tok = token env v2 in\n+       let v3 = map_function_body env v3 v1 in\n+       let ent = G.basic_entity (s, tok) [] in\n+       [G.DefStmt (ent, G.FuncDef v3) |> G.s]\n+   | `Local_func_stmt (v1, v2, v3, v4) ->\n+       let v1 = token env v1 (* \"local\" *) in\n+       let tok = token env v2 (* \"function\" *) in\n+       let v3 =\n+         identifier env v3 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       let v4 = map_function_body env v4 v2 in\n+       let ent = G.basic_entity v3 [G.KeywordAttr (G.LocalDef, v1)] in\n+       [G.DefStmt (ent, G.FuncDef v4) |> G.s]\n+   | `Func_call_stmt x -> [map_function_call_statement env x]\n+  )\n+\n+and map_table (env : env) ((v1, v2, v3) : CST.table): G.expr =\n+  let v1 = token env v1 (* \"{\" *) in\n+  let v2 =\n+    (match v2 with\n+     | Some x -> map_field_sequence env x\n+     | None -> [])\n+  in\n+  let v3 = token env v3 (* \"}\" *) in\n+  G.Container (G.Dict, (v1, v2, v3))\n+\n+and map_variable_declarator_expr (env : env) (x : CST.variable_declarator): G.expr =\n+  (match x with\n+   | `Id tok ->\n+       ident env tok (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+   | `Self tok ->\n+       ident env tok (* \"self\" *)\n+   | `Prefix_LBRACK_exp_RBRACK (v1, v2, v3, v4) ->\n+       let v1 = map_prefix env v1 in\n+       let v2 = token env v2 (* \"[\" *) in\n+       let v3 = map_expression env v3 in\n+       let v4 = token env v4 (* \"]\" *) in\n+       let qual = G.QExpr (v1, v4) in\n+       let expr = G.ArrayAccess (v1, (v2, v3, v4)) in\n+       expr\n+   | `Field_exp (v1, v2, v3) ->\n+       let v1 = map_prefix env v1 in\n+       let v2 = token env v2 (* \".\" *) in\n+       let v3 =\n+         identifier env v3 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+       in\n+       let qual = G.QExpr (v1, v2) in\n+       let name = (v3, { G.name_qualifier = Some qual; G.name_typeargs = None }) in\n+       G.IdQualified (name, G.empty_id_info ())\n+  )\n+\n+and map_variable_declarator (env : env) (x : CST.variable_declarator): G.entity =\n+  let s = (match x with\n+    | `Id tok ->\n+        G.EId (identifier env tok, G.empty_id_info ()) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+    | `Self tok ->\n+        G.EId (identifier env tok, G.empty_id_info ()) (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+    | `Prefix_LBRACK_exp_RBRACK (v1, v2, v3, v4) ->\n+        let v1 = map_prefix env v1 in\n+        let v2 = token env v2 (* \"[\" *) in\n+        let v3 = map_expression env v3 in\n+        let v4 = token env v4 (* \"]\" *) in\n+        let qual = G.QExpr (v1, v4) in\n+        let expr = G.ArrayAccess (v1, (v2, v3, v4)) in\n+        G.EDynamic expr\n+    | `Field_exp (v1, v2, v3) ->\n+        let v1 = map_prefix env v1 in\n+        let v2 = token env v2 (* \".\" *) in\n+        let v3 =\n+          identifier env v3 (* pattern [a-zA-Z_][a-zA-Z0-9_]* *)\n+        in\n+        let qual = G.QExpr (v1, v2) in\n+        let name = (v3, { G.name_qualifier = Some qual; G.name_typeargs = None }) in\n+        G.EName name\n+  )\n+  in\n+  { G.name = s; attrs = []; tparams = [] }\n+\n+\n+\n+let map_program (env : env) ((v1, v2) : CST.program): G.program =\n+  map_statements_and_return env (v1, v2)\n+\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+let parse file =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "originalPosition": 719}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5Mjg4NTgy", "url": "https://github.com/returntocorp/semgrep/pull/2312#pullrequestreview-559288582", "createdAt": "2020-12-28T20:14:34Z", "commit": {"oid": "762c48a1671b05590e0541c6c103e76ba0f1c84b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23020932e4f6198aab5905a53192d68748761abb", "author": {"user": {"login": "Ruin0x11", "name": null}}, "url": "https://github.com/returntocorp/semgrep/commit/23020932e4f6198aab5905a53192d68748761abb", "committedDate": "2020-12-31T09:32:33Z", "message": "Use qualified name for function definition (Lua)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMzU1OTUy", "url": "https://github.com/returntocorp/semgrep/pull/2312#pullrequestreview-560355952", "createdAt": "2020-12-31T13:59:30Z", "commit": {"oid": "23020932e4f6198aab5905a53192d68748761abb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 850, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}