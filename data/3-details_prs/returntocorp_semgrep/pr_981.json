{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMzQzMDY5", "number": 981, "title": "Refactor main into OutputHandler", "bodyText": "The idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\nNot everything is wired up to it yet, I wanted to keep this diff under control & match current behavior exactly. Future diffs will build on this to:\n\nremove every call to print_error, print_msg, print_debug outside of OutputHandler\nincorporate all errors in to the structured JSON output\nmove all semgrep-lang parse errors into SemgrepErrorWithSpan\nmove semgrep-core parse errors into SemgrepErrorWithSpan", "createdAt": "2020-06-11T21:34:23Z", "url": "https://github.com/returntocorp/semgrep/pull/981", "merged": true, "mergeCommit": {"oid": "c826dc5d0e6c896dff0a39e841376de133fc9460"}, "closed": true, "closedAt": "2020-06-12T18:17:03Z", "author": {"login": "rcoh"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqVRIOgBqjM0MzYwNDI2NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqmPEOgFqTQyOTkxMzc5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2e2092f1b5d408cc6c2316abb4e7ba03a5d09cd", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/e2e2092f1b5d408cc6c2316abb4e7ba03a5d09cd", "committedDate": "2020-06-11T21:31:38Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}, "afterCommit": {"oid": "f8b110b4a3a181b958992be45438c51685a400f0", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/f8b110b4a3a181b958992be45438c51685a400f0", "committedDate": "2020-06-11T21:37:29Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8b110b4a3a181b958992be45438c51685a400f0", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/f8b110b4a3a181b958992be45438c51685a400f0", "committedDate": "2020-06-11T21:37:29Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}, "afterCommit": {"oid": "3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "committedDate": "2020-06-11T22:04:27Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "committedDate": "2020-06-12T14:47:52Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "committedDate": "2020-06-11T22:04:27Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}, "afterCommit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "committedDate": "2020-06-12T14:47:52Z", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODIxNjEy", "url": "https://github.com/returntocorp/semgrep/pull/981#pullrequestreview-429821612", "createdAt": "2020-06-12T15:10:05Z", "commit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxMDowNlrOGjHoUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxMjowN1rOGjHsxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODM1NQ==", "bodyText": "What's the advantage of a context manager here? Can we just initialize OutputHandlers where necessary and continue to let __main__ be the final arbiter of exceptions and exiting? It seems odd to have our output handler doing a sys.exit for us.", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439478355", "createdAt": "2020-06-12T15:10:06Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODQyNw==", "bodyText": "This feels kinda hamfisted compared to using Python's builtin mechanism for doing this:\ntry:\n    ...\nexcept ExceptionType1:\n    ...\nexcept ExceptionType2:\n    ...", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439478427", "createdAt": "2020-06-12T15:10:11Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    handler = OutputHandler(output_settings)\n+    try:\n+        yield handler\n+    except Exception as ex:\n+        handler.handle_unhandled_exception(ex)\n+    finally:\n+        exit_code = handler.close()\n+        sys.exit(exit_code)\n+\n+\n+class OutputHandler:\n+    \"\"\"\n+    Handle all output in a central location. Rather than calling `print_error` directly,\n+    you should call `handle_*` as appropriate.\n+\n+    In normal usage, it should be constructed via the contextmanager, `managed_output`. It ensures that everything\n+    is handled properly if exceptions are thrown.\n+\n+    If you need to stop execution immediately (think carefully if you really want this!), throw an exception.\n+    If this is normal behavior, the exception _must_ inherit from `SemgrepError`.\n+\n+    If you want execution to continue, _report_ the exception via the appropriate `handle_*` method.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        output_settings: OutputSettings,\n+        stderr: IO = sys.stderr,\n+        stdout: IO = sys.stdout,\n+    ):\n+        self.settings = output_settings\n+        self.stderr = stderr\n+        self.stdout = stdout\n+\n+        self.rule_matches: List[RuleMatch] = []\n+        self.debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]] = {}\n+        self.rules: FrozenSet[Rule] = frozenset()\n+        self.semgrep_core_errors: List[Dict[str, Any]] = []\n+        self.semgrep_rule_errors: List[SemgrepError] = []\n+        self.has_output = False\n+\n+        self.exit_code = 0\n+        self.final_error: Optional[Exception] = None\n+\n+    def handle_semgrep_core_errors(self, semgrep_errors: List[Dict[str, Any]]) -> None:\n+        \"\"\"\n+        Report errors coming directly from semgrep-core (raw JSON objects)\n+        \"\"\"\n+        self.semgrep_core_errors += semgrep_errors\n+        if self.settings.output_format == OutputFormat.TEXT:\n+            for error in semgrep_errors:\n+                print_error(pretty_error(error))\n+\n+    def handle_semgrep_rule_errors(self, error: SemgrepError) -> None:\n+        \"\"\"\n+        Report parse errors from semgrep rules. Either:\n+        - when the pattern fails to parse in semgrep-core\n+        - when the YAML or YAML structure is invalid\n+        \"\"\"\n+        self.semgrep_rule_errors.append(error)\n+        self._output_exception(error)\n+\n+    def handle_semgrep_core_output(\n+        self,\n+        rule_matches_by_rule: Dict[Rule, List[RuleMatch]],\n+        debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]],\n+    ) -> None:\n+        self.has_output = True\n+        self.rules = self.rules.union(rule_matches_by_rule.keys())\n+        self.rule_matches += [\n+            match\n+            for matches_of_one_rule in rule_matches_by_rule.values()\n+            for match in matches_of_one_rule\n+        ]\n+\n+        self.debug_steps_by_rule.update(debug_steps_by_rule)\n+\n+    def handle_unhandled_exception(self, ex: Exception) -> None:\n+        \"\"\"\n+        This is called by the context manager upon an unhandled exception. If you want to record a final\n+        error & set the exit code, but keep executing to perform cleanup tasks, call this method.\n+        \"\"\"\n+        if isinstance(ex, SemgrepError):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3OTQ5Mg==", "bodyText": "Instead of dealing with something like final_error we could just continue to catch exceptions in __main__ and output their contents there. If you still want to use something like _output_exception you could make a @staticmethod (it doesn't use self anyway) and use it in __main__.\nAgain, it feels kinda weird to have our output handler also manage all program exceptions as well. What if we want to catch and handle them elsewhere?", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439479492", "createdAt": "2020-06-12T15:12:07Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    handler = OutputHandler(output_settings)\n+    try:\n+        yield handler\n+    except Exception as ex:\n+        handler.handle_unhandled_exception(ex)\n+    finally:\n+        exit_code = handler.close()\n+        sys.exit(exit_code)\n+\n+\n+class OutputHandler:\n+    \"\"\"\n+    Handle all output in a central location. Rather than calling `print_error` directly,\n+    you should call `handle_*` as appropriate.\n+\n+    In normal usage, it should be constructed via the contextmanager, `managed_output`. It ensures that everything\n+    is handled properly if exceptions are thrown.\n+\n+    If you need to stop execution immediately (think carefully if you really want this!), throw an exception.\n+    If this is normal behavior, the exception _must_ inherit from `SemgrepError`.\n+\n+    If you want execution to continue, _report_ the exception via the appropriate `handle_*` method.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        output_settings: OutputSettings,\n+        stderr: IO = sys.stderr,\n+        stdout: IO = sys.stdout,\n+    ):\n+        self.settings = output_settings\n+        self.stderr = stderr\n+        self.stdout = stdout\n+\n+        self.rule_matches: List[RuleMatch] = []\n+        self.debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]] = {}\n+        self.rules: FrozenSet[Rule] = frozenset()\n+        self.semgrep_core_errors: List[Dict[str, Any]] = []\n+        self.semgrep_rule_errors: List[SemgrepError] = []\n+        self.has_output = False\n+\n+        self.exit_code = 0\n+        self.final_error: Optional[Exception] = None\n+\n+    def handle_semgrep_core_errors(self, semgrep_errors: List[Dict[str, Any]]) -> None:\n+        \"\"\"\n+        Report errors coming directly from semgrep-core (raw JSON objects)\n+        \"\"\"\n+        self.semgrep_core_errors += semgrep_errors\n+        if self.settings.output_format == OutputFormat.TEXT:\n+            for error in semgrep_errors:\n+                print_error(pretty_error(error))\n+\n+    def handle_semgrep_rule_errors(self, error: SemgrepError) -> None:\n+        \"\"\"\n+        Report parse errors from semgrep rules. Either:\n+        - when the pattern fails to parse in semgrep-core\n+        - when the YAML or YAML structure is invalid\n+        \"\"\"\n+        self.semgrep_rule_errors.append(error)\n+        self._output_exception(error)\n+\n+    def handle_semgrep_core_output(\n+        self,\n+        rule_matches_by_rule: Dict[Rule, List[RuleMatch]],\n+        debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]],\n+    ) -> None:\n+        self.has_output = True\n+        self.rules = self.rules.union(rule_matches_by_rule.keys())\n+        self.rule_matches += [\n+            match\n+            for matches_of_one_rule in rule_matches_by_rule.values()\n+            for match in matches_of_one_rule\n+        ]\n+\n+        self.debug_steps_by_rule.update(debug_steps_by_rule)\n+\n+    def handle_unhandled_exception(self, ex: Exception) -> None:\n+        \"\"\"\n+        This is called by the context manager upon an unhandled exception. If you want to record a final\n+        error & set the exit code, but keep executing to perform cleanup tasks, call this method.\n+        \"\"\"\n+        if isinstance(ex, SemgrepError):\n+            self.exit_code = ex.code\n+        else:\n+            self.exit_code = FATAL_EXIT_CODE\n+        self.final_error = ex\n+\n+    def _output_exception(self, ex: Exception) -> None:\n+        if isinstance(ex, SemgrepError):\n+            print_error(str(ex))\n+        else:\n+            # If it isn't a known SemgrepError, bail hard.\n+            print_error(PLEASE_FILE_ISSUE_TEXT)\n+            raise ex\n+\n+    def close(self) -> int:\n+        \"\"\"\n+        Close the output handler.\n+\n+        This will write any output that hasn't been written so far. It returns\n+        the exit code of the program.\n+        \"\"\"\n+        # TODO: incorporate final_error into JSON output (https://github.com/returntocorp/semgrep/issues/746)\n+        if self.final_error:\n+            self._output_exception(self.final_error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/8c89bad9103521f5565ed6b989017bbc7338f65c", "committedDate": "2020-06-12T16:43:54Z", "message": "Remove sys.exit call from managed_output"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f54a9146b31105c2cac92002b4a7307916a177f", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/1f54a9146b31105c2cac92002b4a7307916a177f", "committedDate": "2020-06-12T16:00:40Z", "message": "Remove sys.exit call from managed_output"}, "afterCommit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c", "author": {"user": {"login": "rcoh", "name": "Russell Cohen"}}, "url": "https://github.com/returntocorp/semgrep/commit/8c89bad9103521f5565ed6b989017bbc7338f65c", "committedDate": "2020-06-12T16:43:54Z", "message": "Remove sys.exit call from managed_output"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTExNTY1", "url": "https://github.com/returntocorp/semgrep/pull/981#pullrequestreview-429911565", "createdAt": "2020-06-12T17:18:01Z", "commit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzoxODowMVrOGjLy6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzoxODowMVrOGjLy6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjYwMg==", "bodyText": "I think we can avoid the indirection with final_error by doing something like:\n    try:\n        yield output_handler\n    except SemgrepError as ex:\n        output_handler.close()\n        print_error(str(ex))\n        raise\n    except Exception:\n        output_handler.close()\n        raise\n    else:\n        output_handler.close()\nA bit wonky with output_handler.close() in each block, but it's necessary for the different print ordering with SemgrepError.", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439546602", "createdAt": "2020-06-12T17:18:01Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +185,167 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    \"\"\"\n+    Context manager to capture uncaught exceptions &\n+    \"\"\"\n+    output_handler = OutputHandler(output_settings)\n+    try:\n+        yield output_handler\n+    except Exception as ex:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTEzNzkz", "url": "https://github.com/returntocorp/semgrep/pull/981#pullrequestreview-429913793", "createdAt": "2020-06-12T17:21:52Z", "commit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzoyMTo1MlrOGjL5nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNzoyMTo1MlrOGjL5nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0ODMxOQ==", "bodyText": "Ahh, that makes sense \ud83d\udc4d", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439548319", "createdAt": "2020-06-12T17:21:52Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +185,167 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    \"\"\"\n+    Context manager to capture uncaught exceptions &\n+    \"\"\"\n+    output_handler = OutputHandler(output_settings)\n+    try:\n+        yield output_handler\n+    except Exception as ex:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjYwMg=="}, "originalCommit": {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1532, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}