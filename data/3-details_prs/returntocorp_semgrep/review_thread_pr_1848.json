{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0OTM2MjI4", "number": 1848, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo1NzoyM1rOEunJLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo1NzoyM1rOEunJLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzExMjc5OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/spacegrep.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo1NzoyM1rOHjIl1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo1NzoyM1rOHjIl1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwMjk2Nw==", "bodyText": "ok, I'll look into this. I specifically added 1 here and there before exporting to json because a comment I found in the ocaml code said so.", "url": "https://github.com/returntocorp/semgrep/pull/1848#discussion_r506602967", "createdAt": "2020-10-16T16:57:23Z", "author": {"login": "mjambon"}, "path": "semgrep/semgrep/spacegrep.py", "diffHunk": "@@ -0,0 +1,93 @@\n+import json\n+import logging\n+import re\n+import subprocess\n+from pathlib import Path\n+from typing import Any\n+from typing import cast\n+from typing import Dict\n+from typing import List\n+from typing import Optional\n+\n+logger = logging.getLogger(__name__)\n+\n+from semgrep.constants import PLEASE_FILE_ISSUE_TEXT\n+from semgrep.constants import SPACEGREP_PATH\n+from semgrep.core_exception import CoreException\n+from semgrep.error import InvalidPatternError\n+from semgrep.pattern import Pattern\n+from semgrep.pattern_match import PatternMatch\n+from semgrep.util import sub_run\n+\n+\n+def run_spacegrep(patterns: List[Pattern], targets: List[Path]) -> dict:\n+    matches: List[dict] = []\n+    errors: List[dict] = []\n+    for pattern in patterns:\n+        if not isinstance(pattern._pattern, str):\n+            raise NotImplementedError(\n+                f\"Support for {type(pattern._pattern)} has not been implemented yet.\"\n+            )\n+        pattern_str = pattern._pattern  # TODO: Handle pattern Dict\n+        for target in targets:\n+            cmd = [\n+                SPACEGREP_PATH,\n+                \"--output-format\",\n+                \"semgrep\",\n+                \"-d\",\n+                str(target),\n+                pattern_str,\n+            ]\n+            p = sub_run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+            raw_output = p.stdout\n+            raw_error = p.stderr\n+\n+            output_json = _parse_spacegrep_output(raw_output)\n+            output_json[\"matches\"] = _patch_id(pattern, output_json.get(\"matches\", []))\n+            output_json[\"matches\"] = _patch_lines(output_json.get(\"matches\", []))\n+\n+            matches.extend(output_json[\"matches\"])\n+            errors.extend(output_json[\"errors\"])\n+\n+    return {\n+        \"matches\": matches,\n+        \"errors\": errors,\n+    }\n+\n+\n+def _parse_spacegrep_output(raw_output: bytes) -> dict:\n+    try:\n+        output = raw_output.decode(\"utf-8\")\n+        data = json.loads(output)\n+        return cast(dict, data)\n+    except Exception:\n+        logger.error(\"spacegrep output could not be parsed as JSON.\")\n+        return {}\n+\n+\n+def _patch_id(pattern: Pattern, matches: List[dict]) -> List[dict]:\n+    patched = []\n+    for match in matches:\n+        match[\"check_id\"] = pattern._id\n+        patched.append(match)\n+    return patched\n+\n+\n+def _patch_lines(matches: List[dict]) -> List[dict]:\n+    patched = []\n+    for match in matches:\n+        with open(match[\"path\"], \"r\") as fin:\n+            data = fin.readlines()\n+        start_l = match.get(\"start\", {}).get(\"line\", 0)\n+        start_c = match.get(\"start\", {}).get(\"col\", 0)\n+        end_l = match.get(\"end\", {}).get(\"line\", 0)\n+        end_c = match.get(\"end\", {}).get(\"col\", 0)\n+\n+        lines = data[start_l - 2 : end_l - 1]\n+        lines[0] = lines[0][start_c - 1 :]\n+        lines[-1] = lines[-1][: end_c - 1]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fedf0277198505571dc8a9dfe85aadc857de79f"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4810, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}