{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NjQwOTg1", "number": 5, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrODZ9dIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrODZ9dIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTQ3ODcyOnYy", "diffSide": "RIGHT", "path": "lint.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrOFgpX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrOFgpX3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3NjYwNg==", "bodyText": "I think you currently need also to have -sgrep_lint as an argument.", "url": "https://github.com/returntocorp/semgrep/pull/5#discussion_r369776606", "createdAt": "2020-01-22T20:07:10Z", "author": {"login": "aryx"}, "path": "lint.py", "diffHunk": "@@ -0,0 +1,94 @@\n+#!/usr/bin/env python3\n+import os\n+import pathlib\n+import subprocess\n+import sys\n+import tempfile\n+import traceback\n+from pathlib import PurePath\n+\n+import click\n+import yaml\n+\n+# validate input yaml files\n+\n+# validate patterns inside yaml files\n+\n+# glob yaml files into a single rule files, adjusting check ids\n+MUST_HAVE_KEYS = set(['id', 'pattern', 'message', 'languages', 'severity'])\n+YML_EXTENSIONS = ['.yml', '.yaml']\n+\n+SGREP_PATH = \"sgrep\"\n+\n+\n+def print_error(e):\n+    sys.stderr.write(e + os.linesep)\n+    sys.stderr.flush()\n+\n+\n+def parse_sgrep_yml(file_path: str):\n+    #print_error(f'loading rules from {file_path}...')\n+    try:\n+        y = yaml.safe_load(open(file_path))\n+    except FileNotFoundError:\n+        return None\n+    except yaml.scanner.ScannerError as se:\n+        print_error(se)\n+        return None\n+\n+    if not 'rules' in y:\n+        print_error(f'{file_path} should have top-level key named `rules`')\n+        return None\n+\n+    rules = []\n+    for i, rule in enumerate(y['rules']):\n+        if not rule:\n+            continue\n+        rule_id_err_msg = f'(rule id: {rule[\"id\"]})' if ('id' in rule) else ''\n+        if MUST_HAVE_KEYS != set(rule.keys()):\n+            print_error(\n+                f'{file_path} is missing keys at rule {i}{rule_id_err_msg}, must have: {MUST_HAVE_KEYS}')\n+        else:\n+            rules.append(rule)\n+    return rules\n+\n+\n+@click.command()\n+@click.argument(\"yaml_file_or_dirs\", nargs=1, type=click.Path(),\n+                #help=f\"The YAML file or directory of YAML files ending in {YML_EXTENSIONS} with rules\",\n+                )\n+@click.argument(\"target_files_or_dirs\", nargs=-1, type=click.Path())\n+def main(yaml_file_or_dirs, target_files_or_dirs):\n+    all_rules = []\n+    errors, not_errors = 0, 0\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):\n+        dirs.sort()\n+        for filename in sorted(files):\n+            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+                full_path = os.path.join(root, filename)\n+                rules_in_file = parse_sgrep_yml(full_path)\n+                if rules_in_file is None:\n+                    errors += 1\n+                else:\n+                    not_errors += 1\n+                    for rule in rules_in_file:\n+                        prefix = '.'.join([x for x in PurePath(\n+                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                        rule['id'] = new_id\n+                    all_rules.extend(list(rules_in_file))\n+\n+    # create unified yml file\n+    unified = {'rules': list(all_rules)}\n+    print_error(\n+        f'running {len(all_rules)} rules from {not_errors} yaml files ({errors} yaml files were invalid)')\n+    with tempfile.NamedTemporaryFile('w') as fout:\n+        fout.write(yaml.safe_dump(unified, sort_keys=False))\n+        fout.flush()\n+        cmd = f'{SGREP_PATH} -rule_file={fout.name} {\" \".join(list(target_files_or_dirs))}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4859, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}