{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDk4Mjcy", "number": 1395, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozMzo1OVrOETT2hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NjowMFrOETUcJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjgzNjU0OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Rules_filter.ml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozMzo1OVrOG4-M0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyODoxOVrOG5K3cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MjUzMQ==", "bodyText": "\ud83d\ude1b", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462392531", "createdAt": "2020-07-29T15:33:59Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDMwMg==", "bodyText": "I haven't used Re. Based on the project description, it's faster than Pcre and Str only on large regexps. This is presumably due to using an algorithm with polynomial rather than exponential asymptotic complexity, but with a greater startup cost due to the construction of an automaton.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462594302", "createdAt": "2020-07-29T21:16:38Z", "author": {"login": "mjambon"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MjUzMQ=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMDA0OA==", "bodyText": "I was reading this article on the subject the other day: https://swtch.com/~rsc/regexp/regexp1.html\nIt's interesting to grasp how the path-merging algorithm works and why it has no problem handling regular expressions made of many nodes.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462600048", "createdAt": "2020-07-29T21:28:19Z", "author": {"login": "mjambon"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MjUzMQ=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg1NDI5OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Rules_filter.ml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozNzo1OFrOG4-X4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODo0MDo0MFrOG5ZqeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NTM2MA==", "bodyText": "Have you looked at the implications of running this on, e.g., a large minified js file? It looks like we need to load the entire file into a single block of memory here (not sure how the internals of ocaml Str work, but I assume it wraps a contiguous character array).\nIt might be worth wrapping this in a max memory guard.\nPresumably a streaming solution is even better, but probably an annoying implementation.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462395360", "createdAt": "2020-07-29T15:37:58Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NzM0OA==", "bodyText": "if we're slow with read_file, it will be far slower with parsing it and matching it.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462397348", "createdAt": "2020-07-29T15:40:51Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NTM2MA=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzgxNw==", "bodyText": "Isn't parsing guarded by max_memory though? Or does that also apply to this load?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462623817", "createdAt": "2020-07-29T22:21:37Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NTM2MA=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0MjQ4OQ==", "bodyText": "The whole parsing and matching is guarded by max_memory. But again, if we exceed memory with read_file, there's no way we can generate the AST for this file, which uses far more memory.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462842489", "createdAt": "2020-07-30T08:40:40Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NTM2MA=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg4NTQ3OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Rules_filter.ml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NToxMFrOG4-rhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjowNzoxMlrOG4_oNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDM4OQ==", "bodyText": "Is this correctly exhaustive?\nI'm wondering what will happen with file and package names, e.g.:\nimport \"fmt\"\npackage foo;", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462400389", "createdAt": "2020-07-29T15:45:10Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMTI1OQ==", "bodyText": "Reflecting on ^^, I think we need a mechanism to log which rules are rejected for each file. Can we print this to stderr in verbose / debug mode?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462401259", "createdAt": "2020-07-29T15:46:24Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDM4OQ=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNTA4Mw==", "bodyText": "Yes use -debug", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462415083", "createdAt": "2020-07-29T16:05:53Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDM4OQ=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNTkyNg==", "bodyText": "It was not exhaustive first, but after a few iterations i got make test and semgreprule test working", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462415926", "createdAt": "2020-07-29T16:07:12Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDM4OQ=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg5MzQ3OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Rules_filter.ml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NzowM1rOG4-wmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoyMTo1OFrOG5MU0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMTY5MA==", "bodyText": "... and it's here \ud83d\ude1b . Can we add the filename to the debug message?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462401690", "createdAt": "2020-07-29T15:47:03Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in\n+  rules |> List.filter (fun rule ->\n+    let pat = rule.R.pattern in\n+    let xs = extract_specific_strings lang pat in\n+    (* pr2_gen xs; *)\n+    let match_ =\n+    (* we could avoid running multiple regexps on the same file\n+     * by first orring them and do the and only of the or succeed,\n+     * but probably not worth the opti.\n+      let t = xs |> List.map (fun x -> regexp_matching_str x) |> Re.alt in\n+      let re = compile_regexp t in\n+      run_regexp re str\n+      *)\n+      (* Note that right now we do a for_all but it mighe be incorrect\n+       * at some point if the pattern contains DisjExpr for example, in\n+       * which case we will need extract_specific_strings to directly\n+       * extract a complex regexp instead handling itself disjunction.\n+       *)\n+      xs |> List.for_all (fun x ->\n+         let t = regexp_matching_str x in\n+         let re = compile_regexp t in\n+         run_regexp re str\n+    )\n+\n+    in\n+    if !Flag.debug && not match_\n+    then pr2 (spf \"filtering rule %s\" rule.R.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNjMzOA==", "bodyText": "It is already display before as PARSING foo.js", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462416338", "createdAt": "2020-07-29T16:07:50Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in\n+  rules |> List.filter (fun rule ->\n+    let pat = rule.R.pattern in\n+    let xs = extract_specific_strings lang pat in\n+    (* pr2_gen xs; *)\n+    let match_ =\n+    (* we could avoid running multiple regexps on the same file\n+     * by first orring them and do the and only of the or succeed,\n+     * but probably not worth the opti.\n+      let t = xs |> List.map (fun x -> regexp_matching_str x) |> Re.alt in\n+      let re = compile_regexp t in\n+      run_regexp re str\n+      *)\n+      (* Note that right now we do a for_all but it mighe be incorrect\n+       * at some point if the pattern contains DisjExpr for example, in\n+       * which case we will need extract_specific_strings to directly\n+       * extract a complex regexp instead handling itself disjunction.\n+       *)\n+      xs |> List.for_all (fun x ->\n+         let t = regexp_matching_str x in\n+         let re = compile_regexp t in\n+         run_regexp re str\n+    )\n+\n+    in\n+    if !Flag.debug && not match_\n+    then pr2 (spf \"filtering rule %s\" rule.R.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMTY5MA=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk1Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462623952", "createdAt": "2020-07-29T22:21:58Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in\n+  rules |> List.filter (fun rule ->\n+    let pat = rule.R.pattern in\n+    let xs = extract_specific_strings lang pat in\n+    (* pr2_gen xs; *)\n+    let match_ =\n+    (* we could avoid running multiple regexps on the same file\n+     * by first orring them and do the and only of the or succeed,\n+     * but probably not worth the opti.\n+      let t = xs |> List.map (fun x -> regexp_matching_str x) |> Re.alt in\n+      let re = compile_regexp t in\n+      run_regexp re str\n+      *)\n+      (* Note that right now we do a for_all but it mighe be incorrect\n+       * at some point if the pattern contains DisjExpr for example, in\n+       * which case we will need extract_specific_strings to directly\n+       * extract a complex regexp instead handling itself disjunction.\n+       *)\n+      xs |> List.for_all (fun x ->\n+         let t = regexp_matching_str x in\n+         let re = compile_regexp t in\n+         run_regexp re str\n+    )\n+\n+    in\n+    if !Flag.debug && not match_\n+    then pr2 (spf \"filtering rule %s\" rule.R.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMTY5MA=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg5ODg1OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/dune", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0ODoxOFrOG4-z_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoyMjo0OVrOG5MWCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjU1Ng==", "bodyText": "I assume this shouldn't be added to this PR?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462402556", "createdAt": "2020-07-29T15:48:18Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/dune", "diffHunk": "@@ -7,6 +7,7 @@\n    pfff-config\n    pfff-h_program-lang\n    pfff-lang_GENERIC pfff-lang_GENERIC-analyze\n+   pfff-lang_js pfff-lang_js-analyze", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNjc5Nw==", "bodyText": "Actually i need this because of the ugly reference to Astjs.special", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462416797", "createdAt": "2020-07-29T16:08:32Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/dune", "diffHunk": "@@ -7,6 +7,7 @@\n    pfff-config\n    pfff-h_program-lang\n    pfff-lang_GENERIC pfff-lang_GENERIC-analyze\n+   pfff-lang_js pfff-lang_js-analyze", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjU1Ng=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDI2NA==", "bodyText": "\"neat\"", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462624264", "createdAt": "2020-07-29T22:22:49Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/dune", "diffHunk": "@@ -7,6 +7,7 @@\n    pfff-config\n    pfff-h_program-lang\n    pfff-lang_GENERIC pfff-lang_GENERIC-analyze\n+   pfff-lang_js pfff-lang_js-analyze", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjU1Ng=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjkzMjg2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NjowMFrOG4_JnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODozNzoyOFrOG5ZjYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwODA5Mg==", "bodyText": "Can we invert this flag?\nIMO this performance optimization could result in a surprising behavior, and I can anticipate it being quite difficult for users to debug.\nSince most users are likely to not encounter a serious performance issue, I'd rather default filtering to off, then recommend turning this on in our performance troubleshooting documentation.\ncc. @ievans @dlukeomalley for additional thoughts.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462408092", "createdAt": "2020-07-29T15:56:00Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -975,6 +975,8 @@ let options () =\n     (*e: [[Main_semgrep_core.options]] other cases *)\n     \"-use_parsing_cache\", Arg.Set_string use_parsing_cache,\n     \" <dir> save and use parsed ASTs in a cache at given directory. Caller responsiblity to clear cache\";\n+    \"-no_filter_rules_regexp\", Arg.Clear Flag.filter_rules_regexp,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0MDY3NQ==", "bodyText": "ok, I'll invert the flag for now.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462840675", "createdAt": "2020-07-30T08:37:28Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -975,6 +975,8 @@ let options () =\n     (*e: [[Main_semgrep_core.options]] other cases *)\n     \"-use_parsing_cache\", Arg.Set_string use_parsing_cache,\n     \" <dir> save and use parsed ASTs in a cache at given directory. Caller responsiblity to clear cache\";\n+    \"-no_filter_rules_regexp\", Arg.Clear Flag.filter_rules_regexp,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwODA5Mg=="}, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4977, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}