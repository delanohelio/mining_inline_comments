{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3Njc0ODY2", "number": 1242, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoxOToxMFrOEN5Cdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoxNDowOVrOEOegsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAxNDYyOnYy", "diffSide": "RIGHT", "path": "semgrep-core/data/basic_tainting.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoxOToxMFrOGwv5eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDo0OToxMFrOGw_5gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA==", "bodyText": "FWIW, I'd probably s/track/taint here for specificity", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453769594", "createdAt": "2020-07-13T16:19:10Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -1,5 +1,6 @@\n rules:\n   - id: classic\n+    mode: track", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTIzMQ==", "bodyText": "what does s/track/taint mean? something like track-mode: True where track-mode: False is the default?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453965231", "createdAt": "2020-07-13T22:05:06Z", "author": {"login": "chmccreery"}, "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -1,5 +1,6 @@\n rules:\n   - id: classic\n+    mode: track", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzMTc0NA==", "bodyText": "Oohh just swap the words \ud83e\udd26\u200d\u2640\ufe0f  yes will do", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454031744", "createdAt": "2020-07-14T00:49:10Z", "author": {"login": "chmccreery"}, "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -1,5 +1,6 @@\n rules:\n   - id: classic\n+    mode: track", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAxNjA2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/data/basic_tainting.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoxOTozM1rOGwv6cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoxOTozM1rOGwv6cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTg0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                languages: [python, python]\n          \n          \n            \n                languages: [python]", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453769840", "createdAt": "2020-07-13T16:19:33Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -11,5 +12,18 @@ rules:\n       - sanitize(...)\n       - sanitize1(...)\n     message: A user input source() went into a dangerous sink()\n+    languages: [python, python]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAyNDYwOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/core_runner.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyMTo0NFrOGwv_pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzozMzowNVrOGxo7CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ==", "bodyText": "I'd probably make this an enum instead of a str to avoid future potential bugs.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453771175", "createdAt": "2020-07-13T16:21:44Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -217,6 +217,72 @@ def _write_equivalences_file(self, fp: IO, equivalences: List[Equivalence]) -> N\n         yaml.dump({\"equivalences\": [e.to_json() for e in equivalences]}, fp)\n         fp.flush()\n \n+    def _run_core_command(\n+        self,\n+        patterns_json: List[Any],\n+        patterns: List[Pattern],\n+        targets: List[Path],\n+        language: Language,\n+        rule: Rule,\n+        rules_flag: str,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1MjA4NQ==", "bodyText": "Like this? https://docs.python.org/3.4/library/enum.html\nSo it would be of type Mode and would evaluate to search = 1 and taint = 2 or something like that?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454052085", "createdAt": "2020-07-14T01:58:58Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -217,6 +217,72 @@ def _write_equivalences_file(self, fp: IO, equivalences: List[Equivalence]) -> N\n         yaml.dump({\"equivalences\": [e.to_json() for e in equivalences]}, fp)\n         fp.flush()\n \n+    def _run_core_command(\n+        self,\n+        patterns_json: List[Any],\n+        patterns: List[Pattern],\n+        targets: List[Path],\n+        language: Language,\n+        rule: Rule,\n+        rules_flag: str,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzQ3MQ==", "bodyText": "I think enum is the wrong word for me to use.\nI mean this:\nMode = NewType(\"Mode\", str)\n\nSearchMode = Mode(\"search\")\nTaintMode = Mode(\"taint\")", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454657471", "createdAt": "2020-07-14T21:30:55Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -217,6 +217,72 @@ def _write_equivalences_file(self, fp: IO, equivalences: List[Equivalence]) -> N\n         yaml.dump({\"equivalences\": [e.to_json() for e in equivalences]}, fp)\n         fp.flush()\n \n+    def _run_core_command(\n+        self,\n+        patterns_json: List[Any],\n+        patterns: List[Pattern],\n+        targets: List[Path],\n+        language: Language,\n+        rule: Rule,\n+        rules_flag: str,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzg4MA==", "bodyText": "done", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703880", "createdAt": "2020-07-14T23:33:05Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -217,6 +217,72 @@ def _write_equivalences_file(self, fp: IO, equivalences: List[Equivalence]) -> N\n         yaml.dump({\"equivalences\": [e.to_json() for e in equivalences]}, fp)\n         fp.flush()\n \n+    def _run_core_command(\n+        self,\n+        patterns_json: List[Any],\n+        patterns: List[Pattern],\n+        targets: List[Path],\n+        language: Language,\n+        rule: Rule,\n+        rules_flag: str,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAyOTIwOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/core_runner.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyMjo1MVrOGwwChg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyMjo1MVrOGwwChg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTkxMA==", "bodyText": "This function is probably complex enough that we want to subfunction it.\nI can show you a fun PyCharm-fu to automate this.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453771910", "createdAt": "2020-07-13T16:22:51Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +291,93 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n-        for language, all_patterns_for_language in self._group_patterns_by_language(\n-            [rule]\n-        ).items():\n-            try:\n+        if rule._mode == \"track\":\n+            for language in rule._languages:\n                 targets = target_manager.get_files(\n                     language, rule.includes, rule.excludes\n                 )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n-\n-            if targets == []:\n-                continue\n-\n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n-\n-                try:\n-                    patterns_re = [\n-                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                        for pattern in patterns_json\n-                    ]\n-                except re.error as err:\n-                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n-\n-                re_fn = functools.partial(get_re_matches, patterns_re)\n-                with multiprocessing.Pool(self._jobs) as pool:\n-                    matches = pool.map(re_fn, targets)\n-\n-                outputs.extend(\n-                    single_match\n-                    for file_matches in matches\n-                    for single_match in file_matches\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]\n+                pattern = Pattern(\n+                    0, rule.expression, rule.severity, language, rule._yaml.span\n                 )\n \n-            patterns_json = [p.to_json() for p in patterns]\n-            with tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as pattern_file, tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as target_file, tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as equiv_file:\n-                yaml = YAML()\n-                yaml.dump({\"rules\": patterns_json}, pattern_file)\n-                pattern_file.flush()\n-                target_file.write(\"\\n\".join(str(t) for t in targets))\n-                target_file.flush()\n-\n-                cmd = [SEMGREP_PATH] + [\n-                    \"-lang\",\n+                output_json = self._run_core_command(\n+                    [pattern_json],\n+                    [pattern],\n+                    targets,\n                     language,\n-                    \"-rules_file\",\n-                    pattern_file.name,\n-                    \"-j\",\n-                    str(self._jobs),\n-                    \"-target_file\",\n-                    target_file.name,\n-                    \"-use_parsing_cache\",\n+                    rule,\n+                    \"-tainting_rules_file\",\n                     cache_dir,\n-                ]\n-\n-                if equivalences:\n-                    self._write_equivalences_file(equiv_file, equivalences)\n-                    cmd += [\"-equivalences\", equiv_file.name]\n+                )\n \n-                core_run = sub_run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+        else:\n+            for language, all_patterns_for_language in self._group_patterns_by_language(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAzMzczOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/evaluation.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyMzo1NlrOGwwFRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDo1MTo0OVrOGw5ZRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MjYxNA==", "bodyText": "We probably want to be consistent with the _mode comparisons, so we have a consistent fallback mode.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453772614", "createdAt": "2020-07-13T16:23:56Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"search\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyNTE5MQ==", "bodyText": "good point- just fixed this", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453925191", "createdAt": "2020-07-13T20:51:49Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"search\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MjYxNA=="}, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDAzOTE3OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/semgrep_main.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyNToxOVrOGwwIrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjoyNToxOVrOGwwIrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MzQ4NQ==", "bodyText": "I'm guessing we can probably simplify this logic with the above. Happy to hack through it with you.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453773485", "createdAt": "2020-07-13T16:25:19Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -61,8 +61,18 @@ def validate_single_rule(\n             + [e.span for e in extra_key_spans],\n             help=help_msg,\n         )\n-\n-    # Raises InvalidRuleSchemaError if fails to parse\n+    else:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTE5ODAyOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/core_runner.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODo0NTowM1rOGxgpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzozMzo1NlrOGxo8Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODI2NA==", "bodyText": "[0] always makes me nervous because what if rules is empty or there are mixed rules and you only consider the first case. I would generally tend to use map, filter, partition logic here.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454568264", "createdAt": "2020-07-14T18:45:03Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -150,11 +150,16 @@ def _flatten_rule_patterns(self, rules: List[Rule]) -> Iterator[Pattern]:\n     def _group_patterns_by_language(\n         self, rules: List[Rule]\n     ) -> Dict[Language, List[Pattern]]:\n-        # a rule can have multiple patterns inside it. Flatten these so we can send semgrep a single yml file list of patterns\n-        patterns: List[Pattern] = list(self._flatten_rule_patterns(rules))\n+\n         by_lang: Dict[Language, List[Pattern]] = collections.defaultdict(list)\n-        for pattern in patterns:\n-            by_lang[pattern.language].append(pattern)\n+        if rules[0]._mode == \"taint\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDE1NA==", "bodyText": "re-factored it so this isn't even a list (it was always [rule] before, and doesn't need to become a list until later)", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454704154", "createdAt": "2020-07-14T23:33:56Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -150,11 +150,16 @@ def _flatten_rule_patterns(self, rules: List[Rule]) -> Iterator[Pattern]:\n     def _group_patterns_by_language(\n         self, rules: List[Rule]\n     ) -> Dict[Language, List[Pattern]]:\n-        # a rule can have multiple patterns inside it. Flatten these so we can send semgrep a single yml file list of patterns\n-        patterns: List[Pattern] = list(self._flatten_rule_patterns(rules))\n+\n         by_lang: Dict[Language, List[Pattern]] = collections.defaultdict(list)\n-        for pattern in patterns:\n-            by_lang[pattern.language].append(pattern)\n+        if rules[0]._mode == \"taint\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODI2NA=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTIwMjkxOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/core_runner.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODo0NjoxM1rOGxgsCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTo0NTo1MVrOGxrNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA==", "bodyText": "do we also support metadata?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454568970", "createdAt": "2020-07-14T18:46:13Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +296,58 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n         for language, all_patterns_for_language in self._group_patterns_by_language(\n             [rule]\n         ).items():\n-            try:\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n \n+            targets = self.get_files_for_language(language, rule, target_manager)\n             if targets == []:\n                 continue\n \n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n+            if rule._mode == \"taint\":\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNDY0Ng==", "bodyText": "There's an auxiliary metadata field outside of patterns, which I assume is what Drew is referring to?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454714646", "createdAt": "2020-07-15T00:08:27Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +296,58 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n         for language, all_patterns_for_language in self._group_patterns_by_language(\n             [rule]\n         ).items():\n-            try:\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n \n+            targets = self.get_files_for_language(language, rule, target_manager)\n             if targets == []:\n                 continue\n \n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n+            if rule._mode == \"taint\":\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MTI0OA==", "bodyText": "Ah, great! I just added a check for this to say it isn't supported", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454741248", "createdAt": "2020-07-15T01:45:51Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +296,58 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n         for language, all_patterns_for_language in self._group_patterns_by_language(\n             [rule]\n         ).items():\n-            try:\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n \n+            targets = self.get_files_for_language(language, rule, target_manager)\n             if targets == []:\n                 continue\n \n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n+            if rule._mode == \"taint\":\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTIwNDAzOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/evaluation.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODo0NjozNVrOGxgsvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzozMTo0NFrOGxo5Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTE1MA==", "bodyText": "make a constant?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454569150", "createdAt": "2020-07-14T18:46:35Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"track\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzQ1MQ==", "bodyText": "done", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703451", "createdAt": "2020-07-14T23:31:44Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"track\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTE1MA=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTIwNTUxOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/rule.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODo0NzowMVrOGxgtrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzozMjowM1rOGxo50g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTM4OA==", "bodyText": "make mode a constant?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454569388", "createdAt": "2020-07-14T18:47:01Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +67,33 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, mode = self._taint_or_search_patterns_validation(self._yaml)\n+        self._mode = mode\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, str]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzU3MA==", "bodyText": "done", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703570", "createdAt": "2020-07-14T23:32:03Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +67,33 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, mode = self._taint_or_search_patterns_validation(self._yaml)\n+        self._mode = mode\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, str]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTM4OA=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc1OTY2OnYy", "diffSide": "RIGHT", "path": ".pre-commit-config.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyOTowMFrOGxmBuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjowNjowNVrOGxnC2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjQ0MQ==", "bodyText": "I assume you don't want to comment changes to this file?", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454656441", "createdAt": "2020-07-14T21:29:00Z", "author": {"login": "nbrahms"}, "path": ".pre-commit-config.yaml", "diffHunk": "@@ -40,32 +40,32 @@ repos:\n         additional_dependencies: [\"flake8-bugbear==20.1.4\"]\n         args: [\"--select=B,E9,F63,F7,F82\"]\n \n-  - repo: https://github.com/returntocorp/semgrep\n-    rev: 'v0.12.0'\n-    hooks:\n-      - id: semgrep-develop\n-        name: Semgrep Python\n-        types: [python]\n-        exclude: \"^semgrep/tests/.+$|^install-scripts/.+$|^release-scripts/.+$|^semgrep/setup.py$\"\n-        args: ['--config', 'https://semgrep.live/p/python', '--error']\n+  # - repo: https://github.com/returntocorp/semgrep", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MzExMw==", "bodyText": "Oh yeah, we just changed this so that it would run on my machine, right? Or should I delete the commented-out pieces and commit the change? I guess I didn't understand what the impact of this was/if it was supposed to be pushed up", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454673113", "createdAt": "2020-07-14T22:06:05Z", "author": {"login": "chmccreery"}, "path": ".pre-commit-config.yaml", "diffHunk": "@@ -40,32 +40,32 @@ repos:\n         additional_dependencies: [\"flake8-bugbear==20.1.4\"]\n         args: [\"--select=B,E9,F63,F7,F82\"]\n \n-  - repo: https://github.com/returntocorp/semgrep\n-    rev: 'v0.12.0'\n-    hooks:\n-      - id: semgrep-develop\n-        name: Semgrep Python\n-        types: [python]\n-        exclude: \"^semgrep/tests/.+$|^install-scripts/.+$|^release-scripts/.+$|^semgrep/setup.py$\"\n-        args: ['--config', 'https://semgrep.live/p/python', '--error']\n+  # - repo: https://github.com/returntocorp/semgrep", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjQ0MQ=="}, "originalCommit": {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjE0OTk2OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/semgrep_main.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoxMTo1M1rOGxppKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoyMzozMlrOGxp1uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNTY4OQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454715689", "createdAt": "2020-07-15T00:11:53Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -46,23 +46,37 @@ def validate_single_rule(\n     rule: YamlMap = rule_yaml.value\n \n     rule_keys = set({k.value for k in rule.keys()})\n-    if not rule_keys.issuperset(YAML_MUST_HAVE_KEYS):\n-        missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n-\n-        extra_keys: Set[str] = rule_keys - YAML_ALL_VALID_RULE_KEYS\n-        extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n-        help_msg = None\n-        if extra_keys:\n-            help_msg = f\"Unexpected keys {extra_keys} found. Is one of these a typo of {missing_keys}?\"\n+    extra_keys = rule_keys - YAML_ALL_VALID_RULE_KEYS\n+    extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n+    missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n+\n+    if missing_keys and extra_keys:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxODkwNQ==", "bodyText": "\ud83d\ude04", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454718905", "createdAt": "2020-07-15T00:23:32Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -46,23 +46,37 @@ def validate_single_rule(\n     rule: YamlMap = rule_yaml.value\n \n     rule_keys = set({k.value for k in rule.keys()})\n-    if not rule_keys.issuperset(YAML_MUST_HAVE_KEYS):\n-        missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n-\n-        extra_keys: Set[str] = rule_keys - YAML_ALL_VALID_RULE_KEYS\n-        extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n-        help_msg = None\n-        if extra_keys:\n-            help_msg = f\"Unexpected keys {extra_keys} found. Is one of these a typo of {missing_keys}?\"\n+    extra_keys = rule_keys - YAML_ALL_VALID_RULE_KEYS\n+    extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n+    missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n+\n+    if missing_keys and extra_keys:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNTY4OQ=="}, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjE1MjQ4OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/semgrep_types.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoxMzowOFrOGxpqiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoxMzowOFrOGxpqiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjA0Mw==", "bodyText": "nit:\nYAML_TAINT_KEYS = YAML_TAINT_MUST_HAVE_KEYS | { \"pattern-sanitizers\" }", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454716043", "createdAt": "2020-07-15T00:13:08Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/semgrep_types.py", "diffHunk": "@@ -57,14 +64,18 @@ class OPERATORS:\n     OPERATORS.EQUIVALENCES,\n     OPERATORS.REGEX,\n }\n+YAML_TOP_LEVEL_PATTERN_KEYS = {\n+    pattern_name\n+    for op in YAML_VALID_TOP_LEVEL_OPERATORS\n+    for pattern_name in OPERATOR_PATTERN_NAMES_MAP[op]\n+}\n+YAML_TAINT_KEYS = {\"pattern-sinks\", \"pattern-sources\", \"pattern-sanitizers\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjE1NDA4OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/rule.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDoxNDowOVrOGxprjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTo0NzoxOFrOGxrOYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA==", "bodyText": "You can just use rule_raw.get(\"mode\", DEFAULT_MODE) here, and remove a case below.", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454716300", "createdAt": "2020-07-15T00:14:09Z", "author": {"login": "nbrahms"}, "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +72,35 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, self._mode = self._taint_or_search_patterns_validation(\n+            self._yaml\n+        )\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, Mode]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMTc4NQ==", "bodyText": "It won't let me put more than 1 arg into get() because rule_raw is a YamlMap object, not a dictionary. Do you have another idea? This approach would be cleaner...", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454721785", "createdAt": "2020-07-15T00:34:18Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +72,35 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, self._mode = self._taint_or_search_patterns_validation(\n+            self._yaml\n+        )\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, Mode]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA=="}, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MTYwMw==", "bodyText": "It didn't like the \"or\" approach either, so I went with a ternary, which has a similar effect wrt code structure and complexity", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454741603", "createdAt": "2020-07-15T01:47:18Z", "author": {"login": "chmccreery"}, "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +72,35 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, self._mode = self._taint_or_search_patterns_validation(\n+            self._yaml\n+        )\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, Mode]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA=="}, "originalCommit": {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4520, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}