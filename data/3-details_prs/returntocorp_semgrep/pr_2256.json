{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTUzMDg1", "number": 2256, "title": "Preliminaries for matching with memoization", "bodyText": "This branch adds two main things:\n\nupdated and renamed test suite for matching performance (semgrep-core/perf)\ntoy sequence matcher\n\nThe toy matcher operates on sequences of chars, and matches a pattern over the entirety of the input sequence. See the readme for the motivations and usage.\nI added optional memoization of the recursive match function, which gives satisfying results (30x speedup on the quadratic test, 600x speedup on the cubic test). The difficulty in the implementation is to ensure that the full environment is captured in the cache key and then to use suitable hash and equal functions. Creating cache keys and looking up cache entries is expensive, and in this implementation it turned out that only caching a random 1/3 of all computations was 1.5x faster than caching them all.\nThese tests run as part of semgrep-core's make test.\nPlan for semgrep-core:\n\nport the kind of memoization we did here to semgrep-core statements.\nleave memoization optional to make performance comparisons easier - at least initially.\n\nThe plan for spacegrep is similar. It may be needed even more than for semgrep-core, but spacegrep currently avoids problems by limiting the span of ellipses to 10 lines (task #2255).", "createdAt": "2020-12-15T03:44:04Z", "url": "https://github.com/returntocorp/semgrep/pull/2256", "merged": true, "mergeCommit": {"oid": "a115916404ec5b5c8af29c6f4676acc3838606e7"}, "closed": true, "closedAt": "2021-01-13T10:55:15Z", "author": {"login": "mjambon"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmWWE9gFqTU1MjE5NDg0OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvtFv8gH2gAyNTM5OTUzMDg1Ojg0MzBhMDYzNzVlOTZlYzJiM2VlNWJiYjJjNmMyN2U5YmVmZTY0ZDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTk0ODQ5", "url": "https://github.com/returntocorp/semgrep/pull/2256#pullrequestreview-552194849", "createdAt": "2020-12-15T08:11:12Z", "commit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODoxMToxMlrOIF-DGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo0NzowNVrOIF_cHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMDM5Mg==", "bodyText": "maybe better to define a new type for those 3 variants instead of using option option.\ntype capture_ellipsis = NotInEllipsis | EllipsisButNoCapture | EllipsisCapture of string * char list", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543130392", "createdAt": "2020-12-15T08:11:12Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMTQyOA==", "bodyText": "Why not Any_char? Why symbol?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543131428", "createdAt": "2020-12-15T08:13:03Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMzQxOA==", "bodyText": "Why not closer to what semgrep does and use:\ntype pattern =\n| Literal of char\n| Metavar of string\n| Ellipsis\ninstead of split in 2 with pattern_atom and pattern with those option string.\nAlso why do you need to capture the content of an Ellipsis?\nIs it to imitate the ugly thing I do in semgrep-core to capture the range of the sequence of matched statements?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543133418", "createdAt": "2020-12-15T08:16:27Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMTQyOA=="}, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDAxOQ==", "bodyText": "Then this could be just:\nlet sampe_pattern = [\nLiteral 'A'; Metavar \"thing\"; Ellipsis; Metavar \"thing\"]", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543134019", "createdAt": "2020-12-15T08:17:21Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNzM0NA==", "bodyText": "why?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543137344", "createdAt": "2020-12-15T08:22:57Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzODI2MA==", "bodyText": "To make things more explicit? What do you win by having Backref and the string option in pattern to\nrepresent those 2 different things?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543138260", "createdAt": "2020-12-15T08:24:11Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNzM0NA=="}, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MDcxMA==", "bodyText": "this would be clearer if we had 3 constructors instead of Some Some.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543140710", "createdAt": "2020-12-15T08:27:54Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MTA3OA==", "bodyText": "You would not need those extra comments if None was NotInEllipsis.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543141078", "createdAt": "2020-12-15T08:28:33Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MjA4Mg==", "bodyText": "Can you add a comment explaining the intuition behind this caching idea. What do you try to cache\nand why it avoids work.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543142082", "createdAt": "2020-12-15T08:30:07Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0Mzg2OQ==", "bodyText": "would be nice  to have the return type here. What does a matcher return?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543143869", "createdAt": "2020-12-15T08:32:43Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjAxOA==", "bodyText": "Maybe a small comment saying that essentially the code below\nrecurse on the pattern list, and inside this recurse on the input list.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543146018", "createdAt": "2020-12-15T08:36:11Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjU4MA==", "bodyText": "Maybe better to be explicit here, given there's not so many cases in pattern_atom:\n| Any_symbol  | Symbol _ -> None", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543146580", "createdAt": "2020-12-15T08:36:59Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NzY1OA==", "bodyText": "Apparently either None when no match or a Some with a triplet with X, the environment, and the rest of the input.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543147658", "createdAt": "2020-12-15T08:38:45Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0Mzg2OQ=="}, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MTQ0Nw==", "bodyText": "Would be great to have an example where I can understand how memoizing would improve the performance.\nOn your sample_pattern, with a simple input like A B C C C C C C C C B C C\nwhy do we avoid redoing the same work thx to memoization?", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543151447", "createdAt": "2020-12-15T08:44:24Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MjkyMw==", "bodyText": "This is great!", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543152923", "createdAt": "2020-12-15T08:46:41Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match\n+  else\n+    get_from_cache := uncached_match;\n+\n+  let opt_captures =\n+    match match_ None Env.empty root_pat root_input with\n+    | None -> None\n+    | Some env -> Some (Env.bindings env)\n+  in\n+  opt_captures, stat\n+\n+(********** Tests **********)\n+\n+let print_time name f =\n+  let t1 = Unix.gettimeofday () in\n+  let res = f () in\n+  let t2 = Unix.gettimeofday () in\n+  printf \"%s: %.6f s\\n%!\" name (t2 -. t1);\n+  res\n+\n+let check_match ?cache pat input_str expected_opt_bindings =\n+  let sort = Option.map (List.sort compare) in\n+  let normalize opt_bindings =\n+    Option.map (fun bindings ->\n+      List.map (fun (var, symbols) -> (var, unparse symbols)) bindings\n+    ) opt_bindings\n+    |> sort\n+  in\n+  check_pattern pat;\n+  let input = parse input_str in\n+  let expected = sort expected_opt_bindings in\n+  let actual =\n+    let res, stat =\n+      print_time \"match function\" (fun () ->\n+        match_input ?cache pat input\n+      )\n+    in\n+    printf \"input length: %i\\n\" (String.length input_str);\n+    printf \"number of calls to the match function: %i\\n\" stat.match_calls;\n+    normalize res\n+  in\n+  print_result stdout actual;\n+  Alcotest.(check bool) \"equal\" true (expected = actual)\n+\n+let test_simple_symbol () =\n+  let pat = [Symbol 'A', Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_simple_ellipsis () =\n+  let pat = [Ellipsis, Some \"x\"] in\n+  let input = \"ABC\" in\n+  check_match pat input (Some [\"x\", \"ABC\"])\n+\n+let test_any_symbol () =\n+  let pat = [Any_symbol, Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_floating_symbol () =\n+  let pat = [\n+    Ellipsis, Some \"head\";\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"tail\";\n+  ] in\n+  let input = \"012345A6789\" in\n+  check_match pat input (Some [\n+    \"head\", \"012345\";\n+    \"a\", \"A\";\n+    \"tail\", \"6789\";\n+  ])\n+\n+let test_backref ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"orig\";\n+    Backref \"orig\", Some \"copy\";\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBC\" in\n+  check_match ~cache pat input (Some [\n+    \"orig\", \"B\";\n+    \"copy\", \"B\";\n+  ])\n+\n+let test_gap () =\n+  let pat = [\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"gap\";\n+    Symbol 'B', Some \"b\";\n+  ] in\n+  let input = \"A12B\" in\n+  check_match pat input (Some [\n+    \"a\", \"A\";\n+    \"gap\", \"12\";\n+    \"b\", \"B\";\n+  ])\n+\n+let test_backref_backtrack ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"x\";\n+    Ellipsis, None;\n+    Backref \"x\", None;\n+    Symbol 'C', None;\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBCA\" in\n+  check_match ~cache pat input (Some [\n+    \"x\", \"B\";\n+  ])\n+\n+(*\n+   Deterministically generate a random-looking string.\n+*)\n+let pseudo_random_string len pick_from =\n+  let n = String.length pick_from in\n+  assert (n > 0);\n+  Random.init 0;\n+  String.init len (fun _i ->\n+    pick_from.[Random.int n]\n+  )\n+\n+(*\n+   This is equivalent in semgrep to searching for a pattern like", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 508}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MzE4MA==", "bodyText": "can you explain why it's n^2, by unfolding the work done each time.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543153180", "createdAt": "2020-12-15T08:47:05Z", "author": {"login": "aryx"}, "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match\n+  else\n+    get_from_cache := uncached_match;\n+\n+  let opt_captures =\n+    match match_ None Env.empty root_pat root_input with\n+    | None -> None\n+    | Some env -> Some (Env.bindings env)\n+  in\n+  opt_captures, stat\n+\n+(********** Tests **********)\n+\n+let print_time name f =\n+  let t1 = Unix.gettimeofday () in\n+  let res = f () in\n+  let t2 = Unix.gettimeofday () in\n+  printf \"%s: %.6f s\\n%!\" name (t2 -. t1);\n+  res\n+\n+let check_match ?cache pat input_str expected_opt_bindings =\n+  let sort = Option.map (List.sort compare) in\n+  let normalize opt_bindings =\n+    Option.map (fun bindings ->\n+      List.map (fun (var, symbols) -> (var, unparse symbols)) bindings\n+    ) opt_bindings\n+    |> sort\n+  in\n+  check_pattern pat;\n+  let input = parse input_str in\n+  let expected = sort expected_opt_bindings in\n+  let actual =\n+    let res, stat =\n+      print_time \"match function\" (fun () ->\n+        match_input ?cache pat input\n+      )\n+    in\n+    printf \"input length: %i\\n\" (String.length input_str);\n+    printf \"number of calls to the match function: %i\\n\" stat.match_calls;\n+    normalize res\n+  in\n+  print_result stdout actual;\n+  Alcotest.(check bool) \"equal\" true (expected = actual)\n+\n+let test_simple_symbol () =\n+  let pat = [Symbol 'A', Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_simple_ellipsis () =\n+  let pat = [Ellipsis, Some \"x\"] in\n+  let input = \"ABC\" in\n+  check_match pat input (Some [\"x\", \"ABC\"])\n+\n+let test_any_symbol () =\n+  let pat = [Any_symbol, Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_floating_symbol () =\n+  let pat = [\n+    Ellipsis, Some \"head\";\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"tail\";\n+  ] in\n+  let input = \"012345A6789\" in\n+  check_match pat input (Some [\n+    \"head\", \"012345\";\n+    \"a\", \"A\";\n+    \"tail\", \"6789\";\n+  ])\n+\n+let test_backref ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"orig\";\n+    Backref \"orig\", Some \"copy\";\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBC\" in\n+  check_match ~cache pat input (Some [\n+    \"orig\", \"B\";\n+    \"copy\", \"B\";\n+  ])\n+\n+let test_gap () =\n+  let pat = [\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"gap\";\n+    Symbol 'B', Some \"b\";\n+  ] in\n+  let input = \"A12B\" in\n+  check_match pat input (Some [\n+    \"a\", \"A\";\n+    \"gap\", \"12\";\n+    \"b\", \"B\";\n+  ])\n+\n+let test_backref_backtrack ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"x\";\n+    Ellipsis, None;\n+    Backref \"x\", None;\n+    Symbol 'C', None;\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBCA\" in\n+  check_match ~cache pat input (Some [\n+    \"x\", \"B\";\n+  ])\n+\n+(*\n+   Deterministically generate a random-looking string.\n+*)\n+let pseudo_random_string len pick_from =\n+  let n = String.length pick_from in\n+  assert (n > 0);\n+  Random.init 0;\n+  String.init len (fun _i ->\n+    pick_from.[Random.int n]\n+  )\n+\n+(*\n+   This is equivalent in semgrep to searching for a pattern like\n+   '$A; ... foo;', in a file where the statement 'foo;' doesn't exist.\n+\n+   With the naive match algorithm, the complexity is O(n^2) where n is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220"}, "originalPosition": 511}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c8687dce67bab158595269f0a8c81d2a8fbc5f1", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/1c8687dce67bab158595269f0a8c81d2a8fbc5f1", "committedDate": "2020-12-16T02:28:06Z", "message": "Documentation"}, "afterCommit": {"oid": "fccef5bdff767540d87742ea1e5409fa78855b46", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/fccef5bdff767540d87742ea1e5409fa78855b46", "committedDate": "2020-12-16T02:56:20Z", "message": "Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDYwNzcz", "url": "https://github.com/returntocorp/semgrep/pull/2256#pullrequestreview-553460773", "createdAt": "2020-12-16T08:38:54Z", "commit": {"oid": "fccef5bdff767540d87742ea1e5409fa78855b46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25f2275011bf2efdb9707ea7e11a4c246604177e", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/25f2275011bf2efdb9707ea7e11a4c246604177e", "committedDate": "2021-01-11T22:54:55Z", "message": "Add toy matcher with a very first test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "736115f8939d4df5ea9807116f6760a8bf2e4c7b", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/736115f8939d4df5ea9807116f6760a8bf2e4c7b", "committedDate": "2021-01-11T22:54:55Z", "message": "Some tests for the toy matcher. Needs fixing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "769f1a9a8dd1b36b7c410d184bec0166ca31d63f", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/769f1a9a8dd1b36b7c410d184bec0166ca31d63f", "committedDate": "2021-01-11T22:54:55Z", "message": "Add tracing of match calls (up to 100 calls)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45a05fd2e637e07f1cb6d2f1dca3efb4be90cfed", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/45a05fd2e637e07f1cb6d2f1dca3efb4be90cfed", "committedDate": "2021-01-11T22:54:55Z", "message": "Fix ellipsis matching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bc25095be8c859544c3febe1b24a431f12cae10", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/0bc25095be8c859544c3febe1b24a431f12cae10", "committedDate": "2021-01-11T22:54:55Z", "message": "Add optional caching (memoization) to the toy matcher.\nPreliminary results:\n- the same test makes only 40,000 calls to the match function instead of\n  50,000,000 without caching.\n- the cached version takes slightly longer!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5ecc7eeff062cd5ef50e8c70cd322f6c19cc390", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/c5ecc7eeff062cd5ef50e8c70cd322f6c19cc390", "committedDate": "2021-01-11T22:54:55Z", "message": "Use more realistic (= non-uniform) test input, resulting in better\nperformance."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00e1e08ac55c0a6b22a6fec7185e34ed3ad37e8a", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/00e1e08ac55c0a6b22a6fec7185e34ed3ad37e8a", "committedDate": "2021-01-11T22:54:55Z", "message": "Only consult the cache on 1/3 of the inputs, making things a bit faster."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f70c91138ba9982f51d668dc27b2fcc1fe1efeab", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/f70c91138ba9982f51d668dc27b2fcc1fe1efeab", "committedDate": "2021-01-11T22:54:55Z", "message": "Add readme to toy matcher + add to semgrep-core 'make test'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f45b3f8bef527faffce898743f046beabd107488", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/f45b3f8bef527faffce898743f046beabd107488", "committedDate": "2021-01-11T22:54:55Z", "message": "Skip slow benchmark tests by default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eea9ace39b56a8a791e941c786391144e9c8d26", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/8eea9ace39b56a8a791e941c786391144e9c8d26", "committedDate": "2021-01-11T22:54:55Z", "message": "Unskip a test, eliminate semgrep warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02ef182d8bf35a6ee51b7d1fe6c45cc1415ccbde", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/02ef182d8bf35a6ee51b7d1fe6c45cc1415ccbde", "committedDate": "2021-01-11T22:54:55Z", "message": "Clarify ellipsis accumulator type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13d4db0b4c15c0a99c09a75af7f4c9771606103c", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/13d4db0b4c15c0a99c09a75af7f4c9771606103c", "committedDate": "2021-01-11T22:54:55Z", "message": "Add documentation and to-do"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71ef6d3bb6af029ad41c328c3dc7733963316e33", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/71ef6d3bb6af029ad41c328c3dc7733963316e33", "committedDate": "2021-01-11T22:54:55Z", "message": "Better style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c7753040cb21c924c6720bd1d24cda2acf4f4c7", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/5c7753040cb21c924c6720bd1d24cda2acf4f4c7", "committedDate": "2021-01-11T22:54:55Z", "message": "Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cc77dd6562746bafdedeb453f71959f56f18408", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/2cc77dd6562746bafdedeb453f71959f56f18408", "committedDate": "2021-01-11T22:57:14Z", "message": "Fix toy-matcher makefile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92280be5de234739f653febbf5709ed3e8e72b68", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/92280be5de234739f653febbf5709ed3e8e72b68", "committedDate": "2021-01-11T22:57:14Z", "message": "Carry around minimal environment in the toy matcher so as to minimize\nreuse of cache entries, whose keys include this set of bindings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2e3cdb40e4989d902992850df3742c459ddae8b", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/d2e3cdb40e4989d902992850df3742c459ddae8b", "committedDate": "2021-01-11T22:57:14Z", "message": "Document toy matcher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a1196b0ce1e53a8145603350b4894c4410fdd54", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/2a1196b0ce1e53a8145603350b4894c4410fdd54", "committedDate": "2021-01-12T07:05:44Z", "message": "Prepare pattern for cached matching (needs a few unit tests)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a8a331e489a8a6db3d8ba5fea6934cfb2871d47", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/9a8a331e489a8a6db3d8ba5fea6934cfb2871d47", "committedDate": "2021-01-09T02:56:37Z", "message": "Document toy matcher"}, "afterCommit": {"oid": "2a1196b0ce1e53a8145603350b4894c4410fdd54", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/2a1196b0ce1e53a8145603350b4894c4410fdd54", "committedDate": "2021-01-12T07:05:44Z", "message": "Prepare pattern for cached matching (needs a few unit tests)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25b58abb2f890635316cec8580cfb2024da9b9cf", "author": {"user": {"login": "mjambon", "name": "Martin Jambon"}}, "url": "https://github.com/returntocorp/semgrep/commit/25b58abb2f890635316cec8580cfb2024da9b9cf", "committedDate": "2021-01-12T22:21:43Z", "message": "Add 'Caching.prepare_target'"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MDI3Nzcy", "url": "https://github.com/returntocorp/semgrep/pull/2256#pullrequestreview-567027772", "createdAt": "2021-01-13T09:20:34Z", "commit": {"oid": "25b58abb2f890635316cec8580cfb2024da9b9cf"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOToyMDozNFrOISmUOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOToyMDozNFrOISmUOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM3MzA0OA==", "bodyText": "You can use the Logging module in pfff/commons/. It's not too bad. Look for the use of logger in other files.", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r556373048", "createdAt": "2021-01-13T09:20:34Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Caching.ml", "diffHunk": "@@ -0,0 +1,163 @@\n+(*\n+   Decorate a pattern and target ASTs to make the suitable for memoization\n+   during matching.\n+*)\n+\n+open Printf\n+open AST_generic\n+\n+(* A set of metavariables. Access cost is O(log n). *)\n+module Names = AST_generic.String_set\n+\n+(* Count the number of occurrences of each backreference of a metavariable. *)\n+module Name_counts = Map.Make (String)\n+\n+let print_names oc names =\n+  List.iter (fun s -> fprintf oc \"  %s\\n\" s) (Names.elements names)\n+\n+let print_name_counts oc name_counts =\n+  List.iter\n+    (fun (s, n) -> fprintf oc \"  %s: %i\\n\" s n)\n+    (Name_counts.bindings name_counts)\n+\n+let add_one k name_counts =\n+  match Name_counts.find_opt k name_counts with\n+  | None -> Name_counts.add k 1 name_counts\n+  | Some n -> Name_counts.add k (n + 1) name_counts\n+\n+let get_count k name_counts =\n+  match Name_counts.find_opt k name_counts with\n+  | None -> 0\n+  | Some n -> n\n+\n+let diff_count k ~new_counts ~old_counts =\n+  let n = get_count k new_counts - get_count k old_counts in\n+  assert (n >= 0);\n+  n\n+\n+let diff_backrefs bound_metavars ~new_backref_counts ~old_backref_counts =\n+  let not_backrefs_in_rest_of_pattern =\n+    Names.fold (fun k acc ->\n+      let added_backref_count =\n+        diff_count k\n+          ~new_counts:new_backref_counts\n+          ~old_counts:old_backref_counts\n+      in\n+      match added_backref_count with\n+      | 0 -> Names.add k acc\n+      | _ -> acc\n+    ) bound_metavars Names.empty\n+  in\n+  Names.diff bound_metavars not_backrefs_in_rest_of_pattern\n+\n+let create_create_id () =\n+  let n = ref 0 in\n+  fun () ->\n+    let id = !n in\n+    assert (id >= 0);\n+    incr n;\n+    id\n+\n+(*\n+   During matching a pattern node against a program node, we consult\n+   a cache to see if we already have run this before and return the\n+   cached result. This is memoization.\n+\n+   A cache key is formed from the contents of the pattern node,\n+   the program node, and all the environment that is sufficient to determine\n+   the result of the computation. The environment includes the set\n+   of bound metavariables that are referenced in the rest of the pattern.\n+   For this, it is correct to use all the bound metavariables rather than the\n+   ones that really needed. However, this reduces caching efficiency by having\n+   irrelevant parts of the environment, the unused metavariables, in the cache\n+   key.\n+\n+   This function decorates the pattern AST with the set of metavariables\n+   that are used in the rest of the pattern. This set is consulted at runtime\n+   to determine whether a captured metavariable should go into the cache key.\n+*)\n+let prepare_pattern ?(debug = false) any =\n+  let bound_metavars = ref Names.empty in\n+  let backref_counts = ref Name_counts.empty in\n+  let add_metavar name =\n+    if Names.mem name !bound_metavars then\n+      backref_counts := add_one name !backref_counts\n+    else\n+      bound_metavars := Names.add name !bound_metavars\n+  in\n+  let create_id = create_create_id () in\n+  (*\n+     This is the list of actions to run in reverse order of the original\n+     traversal of statements.\n+  *)\n+  let stack = ref [] in\n+  let add_to_stack f = stack := f :: ! stack in\n+\n+  let visitor = Visitor_AST.mk_visitor {\n+    Visitor_AST.default_visitor with\n+    kident = (fun (_k, _) (id, _tok) ->\n+      if debug then\n+        printf \"kident %s\\n\" id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b58abb2f890635316cec8580cfb2024da9b9cf"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "978f4a0f6ace6746205009b4138455d7e397f0f9", "author": {"user": {"login": "aryx", "name": "Yoann Padioleau"}}, "url": "https://github.com/returntocorp/semgrep/commit/978f4a0f6ace6746205009b4138455d7e397f0f9", "committedDate": "2021-01-13T10:18:59Z", "message": "Merge branch 'develop' into mj/match-perf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8430a06375e96ec2b3ee5bbb2c6c27e9befe64d9", "author": {"user": {"login": "aryx", "name": "Yoann Padioleau"}}, "url": "https://github.com/returntocorp/semgrep/commit/8430a06375e96ec2b3ee5bbb2c6c27e9befe64d9", "committedDate": "2021-01-13T10:23:41Z", "message": "Disable calls to Caching.prepare_xxx because of many test regressions.\nProbably comes from the need to provide an empty equal on s_backrefs\nlike we have for s_bf."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 838, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}