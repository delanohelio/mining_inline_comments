{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNDkxMjk4", "number": 946, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDoxNzoyMVrOEE5EJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjozOFrOEFNuRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTY0NzExOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/target_manager.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDoxNzoyMVrOGizBrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDoxNzoyMVrOGizBrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0MDc4MA==", "bodyText": "\"excludes\" here twice \u270c\ufe0f", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439140780", "createdAt": "2020-06-12T00:17:21Z", "author": {"login": "minusworld"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,223 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    def _parse_output(self, output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    def _expand_dir(self, curr_dir: Path, language: str) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if self._visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = self._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = self._parse_output(untracked_output, curr_dir)\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],\n+                    encoding=\"utf-8\",\n+                    stdout=subprocess.PIPE,\n+                    stderr=subprocess.PIPE,\n+                )\n+\n+                # Note find already gives paths relative to pwd so no need to prepend curr_dir\n+                ext_files = self._parse_output(output.stdout, Path(\".\"))\n+                expanded = expanded.union(ext_files)\n+\n+        return expanded\n+\n+    def expand_targets(self, targets: Set[Path], lang: str) -> Set[Path]:\n+        \"\"\"\n+            Explore all directories. Remove duplicates\n+        \"\"\"\n+        expanded = set()\n+        for target in targets:\n+            if not target.exists():\n+                continue\n+\n+            if target.is_dir():\n+                expanded.update(self._expand_dir(target, lang))\n+            else:\n+                expanded.add(target)\n+\n+        return expanded\n+\n+    @staticmethod\n+    def match_glob(path: Path, globs: List[str]) -> bool:\n+        \"\"\"\n+            Return true if path or any parent of path matches any glob in globs\n+        \"\"\"\n+        subpaths = [path, *path.parents]\n+        return any(p.match(glob) for p in subpaths for glob in globs)\n+\n+    @staticmethod\n+    def filter_includes(arr: Set[Path], includes: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Returns all elements in arr that match any includes pattern\n+\n+            If includes is empty, returns arr unchanged\n+        \"\"\"\n+        if not includes:\n+            return arr\n+\n+        return set(elem for elem in arr if TargetManager.match_glob(elem, includes))\n+\n+    @staticmethod\n+    def filter_excludes(arr: Set[Path], excludes: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Returns all elements in arr that do not match any excludes excludes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c29da4b60d1dc227612a19054c1483e601a3554b"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAyODM1OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/core_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0OTo0NVrOGjUFag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoyMToyOFrOGjUX8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjQxMA==", "bodyText": "this will break on large repos", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682410", "createdAt": "2020-06-12T23:49:45Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -273,7 +260,7 @@ def _run_rules(\n                     if equivalences:\n                         cmd += [\"-equivalences\", equiv_fout.name]\n                     cmd += [\"-j\", str(self._jobs)]\n-                    cmd += [*self.targeting_options, *[str(path) for path in targets]]\n+                    cmd += [str(path) for path in targets]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzE1Mg==", "bodyText": "Yeahp. was thinking of using the -target-file argument i added to semgrep-core in a follow up PR", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439687152", "createdAt": "2020-06-13T00:21:28Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -273,7 +260,7 @@ def _run_rules(\n                     if equivalences:\n                         cmd += [\"-equivalences\", equiv_fout.name]\n                     cmd += [\"-j\", str(self._jobs)]\n-                    cmd += [*self.targeting_options, *[str(path) for path in targets]]\n+                    cmd += [str(path) for path in targets]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjQxMA=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAyOTYwOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/target_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MDo0OFrOGjUGFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowNjo0OVrOGjUQTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Mw==", "bodyText": "is this logic duplicated in ocaml or hopefully this is now the single source of truth?", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682583", "createdAt": "2020-06-12T23:50:48Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTE5OA==", "bodyText": "It still is for now. We can pull out the things in a follow up PR", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685198", "createdAt": "2020-06-13T00:06:49Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Mw=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzMTE3OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/target_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjoxMFrOGjUHAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowNjoxNVrOGjUQAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxOA==", "bodyText": "what's the run time of this command? Seems slow compared to extracting globs from .gitignore", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682818", "createdAt": "2020-06-12T23:52:10Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTEyMg==", "bodyText": "find . -type f -name \"*.py\"  0.00s user 0.00s system 87% cpu 0.007 total\ngit ls-files \"*.py\"  0.00s user 0.01s system 74% cpu 0.014 total\nNegligible difference with find tbh", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685122", "createdAt": "2020-06-13T00:06:15Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxOA=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzMTczOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/target_manager.py", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjozOFrOGjUHVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoxODozM1rOGjUWcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ==", "bodyText": "shouldn't we be using Path(.).rglob(\"*\")?", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682901", "createdAt": "2020-06-12T23:52:38Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDY5NA==", "bodyText": "This is exactly what semgrep-core does right now", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439684694", "createdAt": "2020-06-13T00:03:21Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTg0MQ==", "bodyText": "python3 -c \"from pathlib import Path; [p for p in Path('..').rglob('*.py')]\"  0.06s user 0.06s system 96% cpu 0.129 total\npython3 -c \"from pathlib import Path;\"  0.03s user 0.01s system 90% cpu 0.044 total\n\nQuick and dirty experiment is using glob takes 10x more time (70 ms vs 7ms) for the small number of files in semgrep", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685841", "createdAt": "2020-06-13T00:11:41Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjAwMw==", "bodyText": "amazing", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439686003", "createdAt": "2020-06-13T00:12:51Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc2OQ==", "bodyText": "time python3 -c 'import subprocess; subprocess.run([\"find\", \"..\", \"-type\", \"f\", \"-name\", f\"*.py\"])'  0.05s user 0.08s system 69% cpu 0.112 total\nWith subprocess overhead they're around equivalent.", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439686769", "createdAt": "2020-06-13T00:18:33Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, "originalCommit": {"oid": "97ffaf45ad7f0c5fc50189365c034aa790e2e318"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4548, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}