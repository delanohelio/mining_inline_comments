{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NDM2ODI3", "number": 852, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxMDoyMlrOEAgAeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0Nzo1NFrOEAoXmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTU5ODY2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxMDoyMlrOGb0UkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjo0NjozMFrOGb95Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA==", "bodyText": "@rcoh maybe this was the issue. Maybe you were running the ocaml programs with profiling information but\nbecause of -j the job was actually done in another process ...", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431821968", "createdAt": "2020-05-28T13:10:22Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -843,8 +870,25 @@ let main () =\n     spf \"Usage: %s [options] <pattern> <files_or_dirs> \\nOptions:\"\n       (Filename.basename Sys.argv.(0))\n   in\n+\n+  let argv =\n+   (Array.to_list Sys.argv) @\n+   (if Sys.getenv_opt \"SEMGREP_CORE_DEBUG\" <> None then [\"-debug\"] else[])@\n+   (if Sys.getenv_opt \"SEMGREP_CORE_PROFILE\" <> None then [\"-profile\"] else[])\n+  in\n+\n   (* does side effect on many global flags *)\n-  let args = Common.parse_options (options()) usage_msg Sys.argv in\n+  let args = Common.parse_options (options()) usage_msg (Array.of_list argv) in\n+\n+  if !debug then begin\n+    pr2 \"Debug mode On\";\n+    pr2 (spf \"Executed as: %s\" (Sys.argv|>Array.to_list|> String.concat \" \"));\n+  end;\n+  if !profile then begin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a808f872e0d5d98a24c5b9ff7671fa208711afbf"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMTU2NQ==", "bodyText": "Yeah that occurred to me after I read that multi threading in OCaml is actually multiprocessing", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431921565", "createdAt": "2020-05-28T15:22:05Z", "author": {"login": "rcoh"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -843,8 +870,25 @@ let main () =\n     spf \"Usage: %s [options] <pattern> <files_or_dirs> \\nOptions:\"\n       (Filename.basename Sys.argv.(0))\n   in\n+\n+  let argv =\n+   (Array.to_list Sys.argv) @\n+   (if Sys.getenv_opt \"SEMGREP_CORE_DEBUG\" <> None then [\"-debug\"] else[])@\n+   (if Sys.getenv_opt \"SEMGREP_CORE_PROFILE\" <> None then [\"-profile\"] else[])\n+  in\n+\n   (* does side effect on many global flags *)\n-  let args = Common.parse_options (options()) usage_msg Sys.argv in\n+  let args = Common.parse_options (options()) usage_msg (Array.of_list argv) in\n+\n+  if !debug then begin\n+    pr2 \"Debug mode On\";\n+    pr2 (spf \"Executed as: %s\" (Sys.argv|>Array.to_list|> String.concat \" \"));\n+  end;\n+  if !profile then begin", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA=="}, "originalCommit": {"oid": "a808f872e0d5d98a24c5b9ff7671fa208711afbf"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3ODgyMg==", "bodyText": "Well, OCaml has concurrent threads (Xavier Leroy the author of OCaml actually added the first POSIX C thead library for Linux a long time ago, and he did it because he wanted threads in OCaml), but it does not have yet multi-core threads. There is work ongoing to suppor that.\nNote that neither Python/PHP/Ruby/... have multi-core threads either.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431978822", "createdAt": "2020-05-28T16:46:30Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -843,8 +870,25 @@ let main () =\n     spf \"Usage: %s [options] <pattern> <files_or_dirs> \\nOptions:\"\n       (Filename.basename Sys.argv.(0))\n   in\n+\n+  let argv =\n+   (Array.to_list Sys.argv) @\n+   (if Sys.getenv_opt \"SEMGREP_CORE_DEBUG\" <> None then [\"-debug\"] else[])@\n+   (if Sys.getenv_opt \"SEMGREP_CORE_PROFILE\" <> None then [\"-profile\"] else[])\n+  in\n+\n   (* does side effect on many global flags *)\n-  let args = Common.parse_options (options()) usage_msg Sys.argv in\n+  let args = Common.parse_options (options()) usage_msg (Array.of_list argv) in\n+\n+  if !debug then begin\n+    pr2 \"Debug mode On\";\n+    pr2 (spf \"Executed as: %s\" (Sys.argv|>Array.to_list|> String.concat \" \"));\n+  end;\n+  if !profile then begin", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA=="}, "originalCommit": {"oid": "a808f872e0d5d98a24c5b9ff7671fa208711afbf"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDM1NzMzOnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Semgrep_generic.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1Njo0MFrOGb76Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTozOTo1M1rOGcV5sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NjMxOQ==", "bodyText": "FWIW, I prefer having the labeled arguments here \ud83e\udd37", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431946319", "createdAt": "2020-05-28T15:56:40Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Semgrep_generic.ml", "diffHunk": "@@ -322,9 +337,7 @@ let check2 ~hook rules equivs file lang ast =\n (*e: function [[Semgrep_generic.check2]] *)\n \n (*s: function [[Semgrep_generic.check]] *)\n-let check ~hook rules equivs file lang =\n-  Common.profile_code \"Sgrep_generic.check\" (\n-    fun () -> check2 ~hook rules equivs file lang\n-  )\n+let check ~hook a b c d e =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MjE0Nw==", "bodyText": "True, it's just that those Common.profile_code are just hacks because there's no super easy way to profile code. In theory I should just run ocamlprof and get nice stats, but I like the focused profile that allows Common.profile_code. Then I want to mimimize the amount of modifications I have to do to the program to support this non-functional property (profiling), so I do that. A better way probably would be to use the recent OCaml attribute to do that, have something like [@@ profile] let check a b c d = ... Maybe @mjambon knows a good ppx rewriter that support that.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432372147", "createdAt": "2020-05-29T09:39:53Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Semgrep_generic.ml", "diffHunk": "@@ -322,9 +337,7 @@ let check2 ~hook rules equivs file lang ast =\n (*e: function [[Semgrep_generic.check2]] *)\n \n (*s: function [[Semgrep_generic.check]] *)\n-let check ~hook rules equivs file lang =\n-  Common.profile_code \"Sgrep_generic.check\" (\n-    fun () -> check2 ~hook rules equivs file lang\n-  )\n+let check ~hook a b c d e =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NjMxOQ=="}, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDM2NDU4OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Semgrep_generic.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1ODoyN1rOGb7_Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1ODoyN1rOGb7_Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NzU1NQ==", "bodyText": "What about naming the wrapper match_e_e_profiled (et c. for other profiled calls)?\nI know I was rather confused by the ...2 naming scheme when I first met this code base.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431947555", "createdAt": "2020-05-28T15:58:27Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Semgrep_generic.ml", "diffHunk": "@@ -58,19 +58,27 @@ type ('a, 'b) matcher = 'a -> 'b ->\n (*****************************************************************************)\n \n (*s: function [[Semgrep_generic.match_e_e]] *)\n-let match_e_e pattern e =\n+let match_e_e2 pattern e =\n   let env = Matching_generic.empty_environment () in\n   GG.m_expr pattern e env\n (*e: function [[Semgrep_generic.match_e_e]] *)\n+let match_e_e ruleid a b =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDUzODMzOnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Generic_vs_generic.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjo0MTozNVrOGb9uMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo0MTo0MVrOGcV9bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3NTk4Ng==", "bodyText": "Is the motivation to separate these two cases for documentation?\n(vs. | [], _ ->)", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431975986", "createdAt": "2020-05-28T16:41:35Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MzEwMw==", "bodyText": "It's just more precise. there is already a case above for [], [], so [], _ below would be more general that it needs to be.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432373103", "createdAt": "2020-05-29T09:41:41Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3NTk4Ng=="}, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDkzMDE2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Generic_vs_generic.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODozNjoyNVrOGcBtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODozNjoyNVrOGcBtgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTM0NQ==", "bodyText": "+1 for explaining the context and the intent", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432041345", "createdAt": "2020-05-28T18:36:25Z", "author": {"login": "mjambon"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDk2ODU3OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Generic_vs_generic.ml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0Nzo1NFrOGcCGOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo0MjoyNlrOGcV_CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg==", "bodyText": "how does one get documentation on >||>?\n>>= seems common enough that it's nicer than Monad.bind, but I'm struggling to grok >||> and >!>. Maybe use the Googleable version instead?", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432047672", "createdAt": "2020-05-28T18:47:54Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+\n+  (* dots: '...', can also match no statement *)\n+  | [A.ExprStmt (A.Ellipsis _i)], [] ->\n+      return ()\n+\n+  | (A.ExprStmt (A.Ellipsis i))::xsa, xb::xsb ->\n+    (* let's first try the without going deep *)\n+     (\n+      (* can match nothing *)\n+      (m_list__m_stmt xsa (xb::xsb)) >||>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5NTAwNA==", "bodyText": "FWIW:\nhttp://symbolhound.com/?q=%3E%7C%7C%3E+ocaml\nhttp://symbolhound.com/?q=%3E%21%3E+ocaml\nboth return no results.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432095004", "createdAt": "2020-05-28T20:09:16Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+\n+  (* dots: '...', can also match no statement *)\n+  | [A.ExprStmt (A.Ellipsis _i)], [] ->\n+      return ()\n+\n+  | (A.ExprStmt (A.Ellipsis i))::xsa, xb::xsb ->\n+    (* let's first try the without going deep *)\n+     (\n+      (* can match nothing *)\n+      (m_list__m_stmt xsa (xb::xsb)) >||>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5NzgwMQ==", "bodyText": "following", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432097801", "createdAt": "2020-05-28T20:14:54Z", "author": {"login": "rcoh"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+\n+  (* dots: '...', can also match no statement *)\n+  | [A.ExprStmt (A.Ellipsis _i)], [] ->\n+      return ()\n+\n+  | (A.ExprStmt (A.Ellipsis i))::xsa, xb::xsb ->\n+    (* let's first try the without going deep *)\n+     (\n+      (* can match nothing *)\n+      (m_list__m_stmt xsa (xb::xsb)) >||>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MzUxMg==", "bodyText": "It's defined in Matching_generic.ml, which is 'open'ed at the beginning of the file.\nNeither >>= nor >||> are predefined OCaml operators. I've defined those operators\nfor the purpose of the matching process.", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432373512", "createdAt": "2020-05-29T09:42:26Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+\n+  (* dots: '...', can also match no statement *)\n+  | [A.ExprStmt (A.Ellipsis _i)], [] ->\n+      return ()\n+\n+  | (A.ExprStmt (A.Ellipsis i))::xsa, xb::xsb ->\n+    (* let's first try the without going deep *)\n+     (\n+      (* can match nothing *)\n+      (m_list__m_stmt xsa (xb::xsb)) >||>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}, "originalCommit": {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4630, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}