{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODI1OTc1", "number": 24, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTo1MDo1NFrODcCi2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTo1MDo1NFrODcCi2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzI4NDEwOnYy", "diffSide": "RIGHT", "path": "sgrep.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTo1MDo1NFrOFj31xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDo1MDo1NVrOFj5f-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1OTM2Nw==", "bodyText": "@ulziibay should this be under an else:", "url": "https://github.com/returntocorp/semgrep/pull/24#discussion_r373159367", "createdAt": "2020-01-30T19:50:54Z", "author": {"login": "ievans"}, "path": "sgrep.py", "diffHunk": "@@ -270,27 +270,37 @@ def rewrite_message_with_metavars(yaml_rule, sgrep_result):\n     return msg_text\n \n \n-def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+def _collect_rules_from_files(files: List[str], root: Optional[str] = None)-> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n     collected_rules = []\n     errors, not_errors = 0, 0\n-    for root, dirs, files in os.walk(yaml_file_or_dirs):\n-        dirs.sort()\n-        for filename in sorted(files):\n-            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+    for filename in sorted(files):\n+        if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+            if root:\n                 full_path = os.path.join(root, filename)\n-                rules_in_file = parse_sgrep_yml(full_path)\n-                if rules_in_file is None:\n-                    errors += 1\n-                else:\n-                    not_errors += 1\n-                    for rule in rules_in_file:\n-                        prefix = '.'.join([x for x in PurePath(\n-                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n-                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n-                        rule['id'] = new_id\n-                    collected_rules.extend(rules_in_file)\n+            else:\n+                full_path = filename\n+            rules_in_file = parse_sgrep_yml(full_path)\n+            if rules_in_file is None:\n+                errors += 1\n+            else:\n+                not_errors += 1\n+                for rule in rules_in_file:\n+                    prefix = '.'.join([x for x in PurePath(\n+                        pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                    new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                    rule['id'] = new_id\n+                collected_rules.extend(rules_in_file)\n     return collected_rules, (errors, not_errors)\n \n+def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+    if os.path.isfile(yaml_file_or_dirs):\n+        file_path = os.path.abspath(yaml_file_or_dirs)\n+        return _collect_rules_from_files([file_path])\n+\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef6024a10103eadc28b45d52dc00ba9ebeb1603"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NjU1Mw==", "bodyText": "Same logic no? This version is better because of better indentation", "url": "https://github.com/returntocorp/semgrep/pull/24#discussion_r373186553", "createdAt": "2020-01-30T20:50:55Z", "author": {"login": "ulziibay"}, "path": "sgrep.py", "diffHunk": "@@ -270,27 +270,37 @@ def rewrite_message_with_metavars(yaml_rule, sgrep_result):\n     return msg_text\n \n \n-def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+def _collect_rules_from_files(files: List[str], root: Optional[str] = None)-> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n     collected_rules = []\n     errors, not_errors = 0, 0\n-    for root, dirs, files in os.walk(yaml_file_or_dirs):\n-        dirs.sort()\n-        for filename in sorted(files):\n-            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+    for filename in sorted(files):\n+        if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+            if root:\n                 full_path = os.path.join(root, filename)\n-                rules_in_file = parse_sgrep_yml(full_path)\n-                if rules_in_file is None:\n-                    errors += 1\n-                else:\n-                    not_errors += 1\n-                    for rule in rules_in_file:\n-                        prefix = '.'.join([x for x in PurePath(\n-                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n-                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n-                        rule['id'] = new_id\n-                    collected_rules.extend(rules_in_file)\n+            else:\n+                full_path = filename\n+            rules_in_file = parse_sgrep_yml(full_path)\n+            if rules_in_file is None:\n+                errors += 1\n+            else:\n+                not_errors += 1\n+                for rule in rules_in_file:\n+                    prefix = '.'.join([x for x in PurePath(\n+                        pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                    new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                    rule['id'] = new_id\n+                collected_rules.extend(rules_in_file)\n     return collected_rules, (errors, not_errors)\n \n+def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+    if os.path.isfile(yaml_file_or_dirs):\n+        file_path = os.path.abspath(yaml_file_or_dirs)\n+        return _collect_rules_from_files([file_path])\n+\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1OTM2Nw=="}, "originalCommit": {"oid": "6ef6024a10103eadc28b45d52dc00ba9ebeb1603"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4862, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}