{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NjQwOTg1", "number": 5, "title": "initial sgrep lint in python supporting multiple rules in a directory", "bodyText": "Try the rules in https://github.com/returntocorp/sgrep-rules !\n\n friendly yml error messages\n rewrite check ids to reflect directory structure\n preserve check order despite the fact that YAML spec does not care (untested)\n output non-sgrep msgs to stderr\n\nNo actual changes to sgrep binary itself to report ranges or boolean logic (yet). TBH I'm not sure it will make sense to do so.\nine@mp4~/D/r/sgrep (sgrep-lint-python)> ./lint.py ../sgrep-rules/ ../test-repos/airflow/\nrunning 45 rules from 7 yaml files (0 yaml files were invalid)\n{\n  \"results\": [\n    {\n      \"check_id\": \"sgrep-lint\",\n      \"path\": \"tests/www/test_security.py\",\n      \"start\": { \"line\": 78, \"col\": 9 },\n      \"end\": { \"line\": 78, \"col\": 13 },\n      \"extra\": {\n        \"message\":\n          \"sgrep-rules.python.flask.avoid_hardcoded_config_SECRET_KEY: Hardcoded variable `SECRET_KEY` detected. Use environment variables or config files instead\",\n        \"line\": \"NO LINE\"\n      }\n    },", "createdAt": "2020-01-22T03:11:05Z", "url": "https://github.com/returntocorp/semgrep/pull/5", "merged": true, "mergeCommit": {"oid": "6a5127bf7616225075ffa8ce951cca8807542192"}, "closed": true, "closedAt": "2020-01-27T09:46:56Z", "author": {"login": "ievans"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8s1NyAH2gAyMzY1NjQwOTg1OmRkNzI3NTZlMWZkNTdkNTE4YjdmZTI2N2Y3Zjk3MWViYTM5MTYxZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9pTl4gH2gAyMzY1NjQwOTg1OmU4ZDdjNDU2ODk5Y2EwOWIyODU2MGRhYzJkNTdkYTZiMDg5Yjk3MDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dd72756e1fd57d518b7fe267f7f971eba39161f2", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/dd72756e1fd57d518b7fe267f7f971eba39161f2", "committedDate": "2020-01-22T03:04:20Z", "message": "initial sgrep lint in python supporting multiple rules in a directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/abd3d84863cf9030cce5aad3fbbdc6765df93a8e", "committedDate": "2020-01-22T03:11:00Z", "message": "cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODY4MDU1", "url": "https://github.com/returntocorp/semgrep/pull/5#pullrequestreview-346868055", "createdAt": "2020-01-22T20:07:09Z", "commit": {"oid": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrOFgpX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDowNzoxMFrOFgpX3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3NjYwNg==", "bodyText": "I think you currently need also to have -sgrep_lint as an argument.", "url": "https://github.com/returntocorp/semgrep/pull/5#discussion_r369776606", "createdAt": "2020-01-22T20:07:10Z", "author": {"login": "aryx"}, "path": "lint.py", "diffHunk": "@@ -0,0 +1,94 @@\n+#!/usr/bin/env python3\n+import os\n+import pathlib\n+import subprocess\n+import sys\n+import tempfile\n+import traceback\n+from pathlib import PurePath\n+\n+import click\n+import yaml\n+\n+# validate input yaml files\n+\n+# validate patterns inside yaml files\n+\n+# glob yaml files into a single rule files, adjusting check ids\n+MUST_HAVE_KEYS = set(['id', 'pattern', 'message', 'languages', 'severity'])\n+YML_EXTENSIONS = ['.yml', '.yaml']\n+\n+SGREP_PATH = \"sgrep\"\n+\n+\n+def print_error(e):\n+    sys.stderr.write(e + os.linesep)\n+    sys.stderr.flush()\n+\n+\n+def parse_sgrep_yml(file_path: str):\n+    #print_error(f'loading rules from {file_path}...')\n+    try:\n+        y = yaml.safe_load(open(file_path))\n+    except FileNotFoundError:\n+        return None\n+    except yaml.scanner.ScannerError as se:\n+        print_error(se)\n+        return None\n+\n+    if not 'rules' in y:\n+        print_error(f'{file_path} should have top-level key named `rules`')\n+        return None\n+\n+    rules = []\n+    for i, rule in enumerate(y['rules']):\n+        if not rule:\n+            continue\n+        rule_id_err_msg = f'(rule id: {rule[\"id\"]})' if ('id' in rule) else ''\n+        if MUST_HAVE_KEYS != set(rule.keys()):\n+            print_error(\n+                f'{file_path} is missing keys at rule {i}{rule_id_err_msg}, must have: {MUST_HAVE_KEYS}')\n+        else:\n+            rules.append(rule)\n+    return rules\n+\n+\n+@click.command()\n+@click.argument(\"yaml_file_or_dirs\", nargs=1, type=click.Path(),\n+                #help=f\"The YAML file or directory of YAML files ending in {YML_EXTENSIONS} with rules\",\n+                )\n+@click.argument(\"target_files_or_dirs\", nargs=-1, type=click.Path())\n+def main(yaml_file_or_dirs, target_files_or_dirs):\n+    all_rules = []\n+    errors, not_errors = 0, 0\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):\n+        dirs.sort()\n+        for filename in sorted(files):\n+            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+                full_path = os.path.join(root, filename)\n+                rules_in_file = parse_sgrep_yml(full_path)\n+                if rules_in_file is None:\n+                    errors += 1\n+                else:\n+                    not_errors += 1\n+                    for rule in rules_in_file:\n+                        prefix = '.'.join([x for x in PurePath(\n+                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                        rule['id'] = new_id\n+                    all_rules.extend(list(rules_in_file))\n+\n+    # create unified yml file\n+    unified = {'rules': list(all_rules)}\n+    print_error(\n+        f'running {len(all_rules)} rules from {not_errors} yaml files ({errors} yaml files were invalid)')\n+    with tempfile.NamedTemporaryFile('w') as fout:\n+        fout.write(yaml.safe_dump(unified, sort_keys=False))\n+        fout.flush()\n+        cmd = f'{SGREP_PATH} -rule_file={fout.name} {\" \".join(list(target_files_or_dirs))}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd94aa270e678afe1f67aff8c3f2fa7225cfce98", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/dd94aa270e678afe1f67aff8c3f2fa7225cfce98", "committedDate": "2020-01-24T23:56:11Z", "message": "midpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1de99913d9fb647c5dc0f781dcbb0444f001be34", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/1de99913d9fb647c5dc0f781dcbb0444f001be34", "committedDate": "2020-01-25T00:04:48Z", "message": "passing all tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8d7c456899ca09b28560dac2d57da6b089b9703", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/e8d7c456899ca09b28560dac2d57da6b089b9703", "committedDate": "2020-01-25T01:31:49Z", "message": "a bit ugly because not actually recusive but working"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1159, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}