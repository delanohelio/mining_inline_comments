{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDk4Mjcy", "number": 1395, "title": "Filter rules not containing any specific strings contained in the source", "bodyText": "It's useless to run the matching engine on a file not containing\nthe 'eval' string if your rule mentions 'eval'.\nThis seems to improve the speed on semgrep on Zulip and Ajin\n\"benchmarks\".\nTest plan:\nmake test still works!\n(semgrep) pad@yrax:/work/semgrep/zulip$\n(semgrep) pad@yrax:/work/semgrep/zulip$ time semgrep --dangerously-allow-arbitrary-code-execution-from-rules --config tools/semgrep.yml .\nrunning 9 rules...\n100%|                                                                                                                                                    |9/9\nreal\t0m5.479s\nuser\t0m24.776s\nsys\t0m3.019s\n(semgrep) pad@yrax:/work/semgrep/zulip$ export SEMGREP_CORE_EXTRA=''\n(semgrep) pad@yrax:/work/semgrep/zulip$ time semgrep --dangerously-allow-arbitrary-code-execution-from-rules --config tools/semgrep.yml .\nrunning 9 rules...\n100%|                                                                                                                                                    |9/9\nreal\t0m4.415s\nuser\t0m16.017s\nsys\t0m3.082s\nOn juice-shop with Ajin rules I got from 8m52 to 7m52, and more importantly\ngot from 50 Timeout errors to just 18 or so.", "createdAt": "2020-07-29T15:02:15Z", "url": "https://github.com/returntocorp/semgrep/pull/1395", "merged": true, "mergeCommit": {"oid": "d8e855847a7094a1e57b208f3514c2075e39cb38"}, "closed": true, "closedAt": "2020-07-30T09:11:18Z", "author": {"login": "aryx"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5sWSeAH2gAyNDU4NDk4MjcyOjM4YTk3NWQzMTRiZTMyOTk3YjZjY2Q4MzI1MWU1ZTllYzVhMzI2NDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc57kYRAH2gAyNDU4NDk4MjcyOjI4NmFhYjQ4ZDAzZTJiNWZhYTlkYzcyNmI4ZjI0YmVkNmQ0MGFjNWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644", "author": {"user": {"login": "aryx", "name": "Yoann Padioleau"}}, "url": "https://github.com/returntocorp/semgrep/commit/38a975d314be32997b6ccd83251e5e9ec5a32644", "committedDate": "2020-07-29T14:59:56Z", "message": "Filter rules not containing any specific strings contained in the source\n\nIt's useless to run the matching engine on a file not containing\nthe 'eval' string if your rule mentions 'eval'.\n\nThis seems to improve the speed on semgrep on Zulip and Ajin\n\"benchmarks\".\n\nTest plan:\nmake test still works!\n\n(semgrep) pad@yrax:~/work/semgrep/zulip$\n(semgrep) pad@yrax:~/work/semgrep/zulip$ time semgrep --dangerously-allow-arbitrary-code-execution-from-rules --config tools/semgrep.yml .\nrunning 9 rules...\n100%|                                                                                                                                                    |9/9\n\nreal\t0m5.479s\nuser\t0m24.776s\nsys\t0m3.019s\n\n(semgrep) pad@yrax:~/work/semgrep/zulip$ export SEMGREP_CORE_EXTRA=''\n(semgrep) pad@yrax:~/work/semgrep/zulip$ time semgrep --dangerously-allow-arbitrary-code-execution-from-rules --config tools/semgrep.yml .\nrunning 9 rules...\n100%|                                                                                                                                                    |9/9\n\nreal\t0m4.415s\nuser\t0m16.017s\nsys\t0m3.082s\n\nOn juice-shop with Ajin rules I got from 8m52 to 7m52, and more importantly\ngot from 50 Timeout errors to just 18 or so."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjQzMTYw", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457643160", "createdAt": "2020-07-29T15:33:59Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozMzo1OVrOG4-M0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozMzo1OVrOG4-M0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MjUzMQ==", "bodyText": "\ud83d\ude1b", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462392531", "createdAt": "2020-07-29T15:33:59Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjQ2Nzcw", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457646770", "createdAt": "2020-07-29T15:37:58Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozNzo1OFrOG4-X4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTozNzo1OFrOG4-X4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5NTM2MA==", "bodyText": "Have you looked at the implications of running this on, e.g., a large minified js file? It looks like we need to load the entire file into a single block of memory here (not sure how the internals of ocaml Str work, but I assume it wraps a contiguous character array).\nIt might be worth wrapping this in a max memory guard.\nPresumably a streaming solution is even better, but probably an annoying implementation.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462395360", "createdAt": "2020-07-29T15:37:58Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjUzMTAz", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457653103", "createdAt": "2020-07-29T15:45:10Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NToxMFrOG4-rhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NToxMFrOG4-rhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDM4OQ==", "bodyText": "Is this correctly exhaustive?\nI'm wondering what will happen with file and package names, e.g.:\nimport \"fmt\"\npackage foo;", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462400389", "createdAt": "2020-07-29T15:45:10Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjU0ODM2", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457654836", "createdAt": "2020-07-29T15:47:03Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NzowM1rOG4-wmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NzowM1rOG4-wmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMTY5MA==", "bodyText": "... and it's here \ud83d\ude1b . Can we add the filename to the debug message?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462401690", "createdAt": "2020-07-29T15:47:03Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Rules_filter.ml", "diffHunk": "@@ -0,0 +1,155 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file license.txt.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * license.txt for more details.\n+ *)\n+open Common\n+module Flag = Flag_semgrep\n+module R = Rule\n+module V = Visitor_AST\n+open AST_generic\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Rules filtering using regexps.\n+ *\n+ * It is useless to run the engine on rules containing specific IDs\n+ * (e.g., eval) that are never mentioned in the file.\n+ *\n+ * We did something similar in Coccinelle I think. This also has been\n+ * mentioned many times (by Clint, HN, etc.).\n+ *\n+ * notes: I tried to use the ocaml-re (Re) regexp libray instead of Str\n+ * because I thought it would be faster, and because it offers regexp\n+ * combinators (alt, rep, etc.) which might be useful at some point to\n+ * handle patterns containing explicit DisjExpr. However when running\n+ * on Zulip codebase with zulip semgrep rules, Str is actually faster\n+ * than Re.\n+ *\n+ * todo:\n+ *  - we could even avoid parsing the file by using a lazy AST\n+ *    in Semgrep_generic.check.\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers  *)\n+(*****************************************************************************)\n+\n+(* Those functions using Re instead of Str are actually slower on\n+ * Zulip.\n+let regexp_matching_str s =\n+  Re.str s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> Re.compile t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () -> Re.execp re str)\n+*)\n+\n+let regexp_matching_str s =\n+  Str.regexp_string s\n+let compile_regexp t =\n+  Common.profile_code \"Re.compile_regexp\" (fun () -> t)\n+let run_regexp re str =\n+  Common.profile_code \"Re.run_regexp\" (fun () ->\n+   (* bugfix:\n+    * this does not work!:  Str.string_match re str 0\n+    * because you need to add \".*\" in front to make it work,\n+    * (but then you can not use regexp_string above)\n+    * => use Str.search_forward instead.\n+    *)\n+   try\n+     Str.search_forward re str 0 |> ignore; true\n+   with Not_found -> false\n+  )\n+\n+let reserved_id lang str =\n+  Metavars_generic.is_metavar_name str ||\n+  (* in JS field names can be regexps *)\n+  (lang = Lang.Javascript && Matching_generic.is_regexp_string str) ||\n+  (* ugly hack that we then need to handle also here *)\n+  str = AST_generic.special_multivardef_pattern ||\n+  (* ugly: because ast_js_build introduce some extra \"!default\" ids *)\n+  (lang = Lang.Javascript && str = Ast_js.default_entity) ||\n+  (* parser_js.mly inserts some implicit this *)\n+  (lang = Lang.Java && str = \"this\")\n+\n+let reserved_str str =\n+  str = \"...\" ||\n+  Matching_generic.is_regexp_string str\n+\n+(*****************************************************************************)\n+(* ID extractor  *)\n+(*****************************************************************************)\n+let extract_specific_strings lang any =\n+  let res = ref [] in\n+  let visitor = V.mk_visitor {V.default_visitor with\n+     V.kident = (fun (_k, _) (str, _tok) ->\n+       if not (reserved_id lang str)\n+       then Common.push str res\n+     );\n+     V.kexpr = (fun (k, _) x ->\n+       (match x with\n+       (* less: we could extract strings for the other literals too?\n+        * atoms, chars, even int?\n+        *)\n+       | L (String (str, _tok)) ->\n+         if not (reserved_str str)\n+         then Common.push str res\n+       (* do not recurse there, the type does not have to be in the source *)\n+       | TypedMetavar _ ->\n+          ()\n+       | _ -> k x\n+       );\n+     );\n+  } in\n+  visitor any;\n+  !res\n+\n+(*****************************************************************************)\n+(* Entry point *)\n+(*****************************************************************************)\n+\n+let filter_rules_relevant_to_file_using_regexp2 rules lang file =\n+  let str = Common.read_file file in\n+  rules |> List.filter (fun rule ->\n+    let pat = rule.R.pattern in\n+    let xs = extract_specific_strings lang pat in\n+    (* pr2_gen xs; *)\n+    let match_ =\n+    (* we could avoid running multiple regexps on the same file\n+     * by first orring them and do the and only of the or succeed,\n+     * but probably not worth the opti.\n+      let t = xs |> List.map (fun x -> regexp_matching_str x) |> Re.alt in\n+      let re = compile_regexp t in\n+      run_regexp re str\n+      *)\n+      (* Note that right now we do a for_all but it mighe be incorrect\n+       * at some point if the pattern contains DisjExpr for example, in\n+       * which case we will need extract_specific_strings to directly\n+       * extract a complex regexp instead handling itself disjunction.\n+       *)\n+      xs |> List.for_all (fun x ->\n+         let t = regexp_matching_str x in\n+         let re = compile_regexp t in\n+         run_regexp re str\n+    )\n+\n+    in\n+    if !Flag.debug && not match_\n+    then pr2 (spf \"filtering rule %s\" rule.R.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjU1OTYz", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457655963", "createdAt": "2020-07-29T15:48:17Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0ODoxOFrOG4-z_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0ODoxOFrOG4-z_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjU1Ng==", "bodyText": "I assume this shouldn't be added to this PR?", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462402556", "createdAt": "2020-07-29T15:48:18Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/dune", "diffHunk": "@@ -7,6 +7,7 @@\n    pfff-config\n    pfff-h_program-lang\n    pfff-lang_GENERIC pfff-lang_GENERIC-analyze\n+   pfff-lang_js pfff-lang_js-analyze", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjYzMTQ3", "url": "https://github.com/returntocorp/semgrep/pull/1395#pullrequestreview-457663147", "createdAt": "2020-07-29T15:56:00Z", "commit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NjowMFrOG4_JnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NjowMFrOG4_JnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwODA5Mg==", "bodyText": "Can we invert this flag?\nIMO this performance optimization could result in a surprising behavior, and I can anticipate it being quite difficult for users to debug.\nSince most users are likely to not encounter a serious performance issue, I'd rather default filtering to off, then recommend turning this on in our performance troubleshooting documentation.\ncc. @ievans @dlukeomalley for additional thoughts.", "url": "https://github.com/returntocorp/semgrep/pull/1395#discussion_r462408092", "createdAt": "2020-07-29T15:56:00Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -975,6 +975,8 @@ let options () =\n     (*e: [[Main_semgrep_core.options]] other cases *)\n     \"-use_parsing_cache\", Arg.Set_string use_parsing_cache,\n     \" <dir> save and use parsed ASTs in a cache at given directory. Caller responsiblity to clear cache\";\n+    \"-no_filter_rules_regexp\", Arg.Clear Flag.filter_rules_regexp,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38a975d314be32997b6ccd83251e5e9ec5a32644"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "286aab48d03e2b5faa9dc726b8f24bed6d40ac5b", "author": {"user": {"login": "aryx", "name": "Yoann Padioleau"}}, "url": "https://github.com/returntocorp/semgrep/commit/286aab48d03e2b5faa9dc726b8f24bed6d40ac5b", "committedDate": "2020-07-30T08:43:54Z", "message": "Change default of filter_irrelevant_rules opti to false by default\n\nTest plan:\nexport SEMGREP_CORE_EXTRA='-filter_irrelevant_rules'\n(semgrep) pad@yrax:~/work/semgrep/zulip$ time semgrep --dangerously-allow-arbitrary-code-execution-from-rules --config tools/semgrep.yml .\nrunning 9 rules...\n100%|                                                                                                                                                    |9/9\n\nreal\t0m4.034s\nuser\t0m15.313s\nsys\t0m2.594s"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1389, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}