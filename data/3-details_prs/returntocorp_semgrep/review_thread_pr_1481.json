{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1Nzc3OTc1", "number": 1481, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoxODo1N1rOEW_wJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMjo0MDoxOVrOEZB0Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTQ4NjQ2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Matching_generic.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoxODo1N1rOG-i8XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoxODo1N1rOG-i8XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzQwNQ==", "bodyText": "Note that I also print debugging information even when the two node types differ.", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468237405", "createdAt": "2020-08-10T23:18:57Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->\n+    (* Allow identifier nodes to match pure identifier expressions *)\n+      equal_ast_binded_code a (A.I b_id)\n   | _, _ ->\n       false\n+  ) in\n+\n+  if !Flag.debug_matching && not res\n+  then begin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077b799f03753d8221f0c1d6f662105aa02ef049"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTQ5MjE2OnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Matching_generic.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoyMTo0N1rOG-i_yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoyMTo0N1rOG-i_yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzODI4Mw==", "bodyText": "This isn't tail recursive, but it only ever gets to a stack depth of 2, so \ud83e\udd37", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468238283", "createdAt": "2020-08-10T23:21:47Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -198,8 +198,8 @@ let (fail : tin -> tout) = fun _tin ->\n (* pre: both 'a' and 'b' contains only regular code; there are no\n  * metavariables inside them.\n  *)\n-let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n-  match a, b with\n+let rec equal_ast_binded_code (a: AST.any) (b: AST.any) : bool = (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077b799f03753d8221f0c1d6f662105aa02ef049"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODQyNjUxOnYy", "diffSide": "RIGHT", "path": "semgrep-core/matching/Matching_generic.ml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1NjoyNlrOG--ghA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMjo0NDozOVrOHBnLwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA==", "bodyText": "@aryx @mjambon I'm open to suggestions on how to do this better :)", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468689028", "createdAt": "2020-08-11T15:56:26Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0OTc5Mw==", "bodyText": "We might need also to handle the symetric pattern\nA.E (A.ID (a_id, _)), A.I _", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471449793", "createdAt": "2020-08-17T12:39:27Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA=="}, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MjYxMA==", "bodyText": "Maybe add a comment such as\n\"you should prefer to add metavar as expression (A.E), not id (A.I), see Generic_vs_generic.m_ident_and_id_info_add_in_env_Expr  but in some cases you have no choice\nand you need to match an expression metavar with an id metavar.\nFor example, we want the pattern 'const $X = foo.$X'  to match 'const bar = foo.bar' (this is useful in the Javascript transpilation context of complex pattern parameter).\"", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471452610", "createdAt": "2020-08-17T12:44:39Z", "author": {"login": "aryx"}, "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA=="}, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Njc5NTcwOnYy", "diffSide": "RIGHT", "path": "semgrep-core/tests/js/misc_destructuring_2.sgrep", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMjo0MDoxOVrOHBnCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzowNjoxOVrOHBxZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA==", "bodyText": "I would also add the simpler  const $X = foo.$X; more obvious testcase.", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471450268", "createdAt": "2020-08-17T12:40:19Z", "author": {"login": "aryx"}, "path": "semgrep-core/tests/js/misc_destructuring_2.sgrep", "diffHunk": "@@ -0,0 +1,3 @@\n+function $F ({$FOO}, ...) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxNzg3NA==", "bodyText": "Oddly enough you can not write this pattern \ud83e\udd37", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471617874", "createdAt": "2020-08-17T17:04:33Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/tests/js/misc_destructuring_2.sgrep", "diffHunk": "@@ -0,0 +1,3 @@\n+function $F ({$FOO}, ...) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA=="}, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxOTkyMw==", "bodyText": "Apparently you can only write this pattern via transpilation from destructuring; it can not be parsed directly.", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471619923", "createdAt": "2020-08-17T17:06:19Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/tests/js/misc_destructuring_2.sgrep", "diffHunk": "@@ -0,0 +1,3 @@\n+function $F ({$FOO}, ...) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA=="}, "originalCommit": {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4904, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}