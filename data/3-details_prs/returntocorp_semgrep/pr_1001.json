{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzOTM5NDcz", "number": 1001, "title": "core_runner: pass targets using -target_file instead of as list", "bodyText": "Passing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option.", "createdAt": "2020-06-13T01:19:35Z", "url": "https://github.com/returntocorp/semgrep/pull/1001", "merged": true, "mergeCommit": {"oid": "ca28e71eb729aa59643f6389a4ea129967703b63"}, "closed": true, "closedAt": "2020-06-15T20:10:33Z", "author": {"login": "brendongo"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqtygqAH2gAyNDMzOTM5NDczOjdhMWZlMDNkNWRmNjRiMDcyNzI1YTY0ZTJlMWYyNGU2NTg0MzdhNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrlNuJAH2gAyNDMzOTM5NDczOmZiOWViZWRkNjViMTg0OTc2MTQ4ZTVhOTdkYzVmYjM1OTE4ZGM2ODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "author": {"user": {"login": "brendongo", "name": "Brendon Go"}}, "url": "https://github.com/returntocorp/semgrep/commit/7a1fe03d5df64b072725a64e2e1f24e658437a57", "committedDate": "2020-06-13T02:11:48Z", "message": "core_runner: pass targets using -target_file instead of as list\n\nPassing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e5f740e15f368655b9f3dafb498e097b6caf6e8", "author": {"user": {"login": "brendongo", "name": "Brendon Go"}}, "url": "https://github.com/returntocorp/semgrep/commit/3e5f740e15f368655b9f3dafb498e097b6caf6e8", "committedDate": "2020-06-13T01:18:25Z", "message": "core_runner: pass targets using -target_file instead of as list\n\nPassing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option."}, "afterCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "author": {"user": {"login": "brendongo", "name": "Brendon Go"}}, "url": "https://github.com/returntocorp/semgrep/commit/7a1fe03d5df64b072725a64e2e1f24e658437a57", "committedDate": "2020-06-13T02:11:48Z", "message": "core_runner: pass targets using -target_file instead of as list\n\nPassing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODQ0ODUw", "url": "https://github.com/returntocorp/semgrep/pull/1001#pullrequestreview-430844850", "createdAt": "2020-06-15T17:21:38Z", "commit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzoyMTozOFrOGj7l5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzoyMTozOFrOGj7l5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyOTcwMw==", "bodyText": "Most of this diff is deindenting", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440329703", "createdAt": "2020-06-15T17:21:38Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODU1NTE3", "url": "https://github.com/returntocorp/semgrep/pull/1001#pullrequestreview-430855517", "createdAt": "2020-06-15T17:36:31Z", "commit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzozNjozMVrOGj8FuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0MDoxNlrOGj8Nsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzg0OA==", "bodyText": "Hah nice, these loops were getting a bit unwieldy.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440337848", "createdAt": "2020-06-15T17:36:31Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyOTcwMw=="}, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODE3Mg==", "bodyText": "I think we can remove this comment at this point. I'm assuming we're good here since we moved to ruamel instead of yaml.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440338172", "createdAt": "2020-06-15T17:37:09Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODU2NQ==", "bodyText": "We can drop the f-string here, we're not interpolating anything.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440338565", "createdAt": "2020-06-15T17:37:56Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzOTI4OQ==", "bodyText": "Since these two += aren't conditional, we can just include them in the original cmd definition.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440339289", "createdAt": "2020-06-15T17:39:14Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs)]\n+                cmd += [\"-target_file\", target_file.name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzOTg5MQ==", "bodyText": "We can do outputs.extend(PatternMatch(m) for m in output_json[\"matches\"]) (no list comp) here to be a bit more memory efficient.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440339891", "createdAt": "2020-06-15T17:40:16Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs)]\n+                cmd += [\"-target_file\", target_file.name]\n+\n+                debug_print(f\"Running semgrep... '{cmd}'\")\n+                core_run = subprocess.run(\n+                    cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n+                )\n \n-                    re_fn = functools.partial(get_re_matches, patterns_re)\n-                    with multiprocessing.Pool(self._jobs) as pool:\n-                        matches = pool.map(re_fn, targets)\n-\n-                    outputs.extend(\n-                        single_match\n-                        for file_matches in matches\n-                        for single_match in file_matches\n-                    )\n-\n-                patterns_json = [p.to_json() for p in patterns]\n-                # very important not to sort keys here\n-                with tempfile.NamedTemporaryFile(\"w\") as fout:\n-                    yaml = YAML()\n-                    yaml.dump({\"rules\": patterns_json}, fout)\n-                    fout.flush()\n-                    cmd = [SEMGREP_PATH] + [\n-                        \"-lang\",\n-                        language,\n-                        f\"-rules_file\",\n-                        fout.name,\n-                    ]\n+                debug_print(core_run.stderr.decode(\"utf-8\", \"replace\"))\n \n-                    if equivalences:\n-                        cmd += [\"-equivalences\", equiv_fout.name]\n-                    cmd += [\"-j\", str(self._jobs)]\n-                    cmd += [str(path) for path in targets]\n-\n-                    debug_print(f\"Running semgrep... '{cmd}'\")\n-                    core_run = subprocess.run(\n-                        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n-                    )\n-\n-                    debug_print(core_run.stderr.decode(\"utf-8\", \"replace\"))\n-\n-                    if core_run.returncode != 0:\n-                        try:\n-                            # see if semgrep output a JSON error that we can decode\n-                            semgrep_output = core_run.stdout.decode(\"utf-8\", \"replace\")\n-                            output_json = json.loads(semgrep_output)\n-                            if \"error\" in output_json:\n-                                self._semgrep_error_json_to_message_then_exit(\n-                                    output_json\n-                                )\n-                            else:\n-                                raise SemgrepError(\n-                                    f\"unexpected non-json output while invoking semgrep-core:\\n{PLEASE_FILE_ISSUE_TEXT}\"\n-                                )\n-                        except Exception as e:\n+                if core_run.returncode != 0:\n+                    try:\n+                        # see if semgrep output a JSON error that we can decode\n+                        semgrep_output = core_run.stdout.decode(\"utf-8\", \"replace\")\n+                        output_json = json.loads(semgrep_output)\n+                        if \"error\" in output_json:\n+                            self._semgrep_error_json_to_message_then_exit(output_json)\n+                        else:\n                             raise SemgrepError(\n-                                f\"non-zero return code while invoking semgrep-core:\\n\\t{e}\\n{PLEASE_FILE_ISSUE_TEXT}\"\n+                                f\"unexpected non-json output while invoking semgrep-core:\\n{PLEASE_FILE_ISSUE_TEXT}\"\n                             )\n+                    except Exception as e:\n+                        raise SemgrepError(\n+                            f\"non-zero return code while invoking semgrep-core:\\n\\t{e}\\n{PLEASE_FILE_ISSUE_TEXT}\"\n+                        )\n \n-                    output_json = json.loads(\n-                        (core_run.stdout.decode(\"utf-8\", \"replace\"))\n-                    )\n-                    errors.extend(output_json[\"errors\"])\n-                    outputs.extend([PatternMatch(m) for m in output_json[\"matches\"]])\n+                output_json = json.loads((core_run.stdout.decode(\"utf-8\", \"replace\")))\n+                errors.extend(output_json[\"errors\"])\n+                outputs.extend([PatternMatch(m) for m in output_json[\"matches\"]])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODU5MjAw", "url": "https://github.com/returntocorp/semgrep/pull/1001#pullrequestreview-430859200", "createdAt": "2020-06-15T17:41:52Z", "commit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0MTo1MlrOGj8RNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0MTo1MlrOGj8RNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDc4OQ==", "bodyText": "We can do \"\\n\".join(str(t) for t in targets) (no list comp) to be a bit more memory efficient.", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440340789", "createdAt": "2020-06-15T17:41:52Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2773340c769910bfba4d432df20851819170b99c", "author": {"user": {"login": "brendongo", "name": "Brendon Go"}}, "url": "https://github.com/returntocorp/semgrep/commit/2773340c769910bfba4d432df20851819170b99c", "committedDate": "2020-06-15T18:00:52Z", "message": "fixup! core_runner: pass targets using -target_file instead of as list"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTAwNzY0", "url": "https://github.com/returntocorp/semgrep/pull/1001#pullrequestreview-430900764", "createdAt": "2020-06-15T18:42:27Z", "commit": {"oid": "2773340c769910bfba4d432df20851819170b99c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo0MjoyOFrOGj-Qng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo0MjoyOFrOGj-Qng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQwNg==", "bodyText": "Nit: I think we can include these args in the original cmd = ... line. Unless arg ordering matters here?", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440373406", "createdAt": "2020-06-15T18:42:28Z", "author": {"login": "mschwager"}, "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,96 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join(str(t) for t in targets))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    \"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs), \"-target_file\", target_file.name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2773340c769910bfba4d432df20851819170b99c"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb9ebedd65b184976148e5a97dc5fb35918dc682", "author": {"user": {"login": "brendongo", "name": "Brendon Go"}}, "url": "https://github.com/returntocorp/semgrep/commit/fb9ebedd65b184976148e5a97dc5fb35918dc682", "committedDate": "2020-06-15T18:46:18Z", "message": "fixup! core_runner: pass targets using -target_file instead of as list"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1549, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}