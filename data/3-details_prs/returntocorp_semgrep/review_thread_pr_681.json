{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMjU0MDU4", "number": 681, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDozNzozNFrOD5Nt-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo0Mjo1NFrOD5NxVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzIwMTg3OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/output.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDozNzozNFrOGQW_ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDozNzozNFrOGQW_ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzA5OQ==", "bodyText": "eventually we should have an Error object type / data class", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419807099", "createdAt": "2020-05-05T00:37:34Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -105,22 +85,39 @@ def build_normal_output(\n                     severity_prepend = f\"{YELLOW_COLOR}{severity} \"\n                 else:\n                     severity_prepend = f\"{severity} \"\n-            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {finding.get('extra', {}).get('message')}{RESET_COLOR}\"\n+            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {message}{RESET_COLOR}\"\n \n         last_file = current_file\n         last_message = message\n-        yield from finding_to_line(finding, color_output)\n+        yield from finding_to_line(rule_match, color_output)\n         if fix:\n             yield f\"{BLUE_COLOR}autofix:{RESET_COLOR} {fix}\"\n \n \n-def build_output_json(output_json: Dict[str, Any]) -> str:\n+def build_output_json(rule_matches: List[RuleMatch], semgrep_errors: List[Any]) -> str:\n     # wrap errors under \"data\" entry to be compatible with\n     # https://docs.r2c.dev/en/latest/api/output.html#errors\n-    errors = output_json[\"errors\"]\n-    if errors:\n-        output_json[\"errors\"] = {\n-            \"data\": output_json[\"errors\"],\n-            \"message\": \"SgrepRuntimeErrors\",\n-        }\n+    output_json = {}\n+    output_json[\"results\"] = [rm.to_json() for rm in rule_matches]\n+\n+    errors = []\n+    for error in semgrep_errors:\n+        errors.append(\n+            {\"data\": semgrep_errors, \"message\": \"SemgrepCoreRuntimeErrors\",}\n+        )\n+    output_json[\"errors\"] = errors\n     return json.dumps(output_json)\n+\n+\n+def build_output(\n+    rule_matches: List[RuleMatch],\n+    semgrep_errors: List[Any],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzIwMjg3OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/output.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDozODoxMlrOGQXAIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo1NDoxN1rOGQXQJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzI2NA==", "bodyText": "we could make this return a string instead of a list? idk maybe we use the list in other places", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419807264", "createdAt": "2020-05-05T00:38:12Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -105,22 +85,39 @@ def build_normal_output(\n                     severity_prepend = f\"{YELLOW_COLOR}{severity} \"\n                 else:\n                     severity_prepend = f\"{severity} \"\n-            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {finding.get('extra', {}).get('message')}{RESET_COLOR}\"\n+            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {message}{RESET_COLOR}\"\n \n         last_file = current_file\n         last_message = message\n-        yield from finding_to_line(finding, color_output)\n+        yield from finding_to_line(rule_match, color_output)\n         if fix:\n             yield f\"{BLUE_COLOR}autofix:{RESET_COLOR} {fix}\"\n \n \n-def build_output_json(output_json: Dict[str, Any]) -> str:\n+def build_output_json(rule_matches: List[RuleMatch], semgrep_errors: List[Any]) -> str:\n     # wrap errors under \"data\" entry to be compatible with\n     # https://docs.r2c.dev/en/latest/api/output.html#errors\n-    errors = output_json[\"errors\"]\n-    if errors:\n-        output_json[\"errors\"] = {\n-            \"data\": output_json[\"errors\"],\n-            \"message\": \"SgrepRuntimeErrors\",\n-        }\n+    output_json = {}\n+    output_json[\"results\"] = [rm.to_json() for rm in rule_matches]\n+\n+    errors = []\n+    for error in semgrep_errors:\n+        errors.append(\n+            {\"data\": semgrep_errors, \"message\": \"SemgrepCoreRuntimeErrors\",}\n+        )\n+    output_json[\"errors\"] = errors\n     return json.dumps(output_json)\n+\n+\n+def build_output(\n+    rule_matches: List[RuleMatch],\n+    semgrep_errors: List[Any],\n+    json_format: bool,\n+    color_output: bool,\n+) -> str:\n+    if json_format:\n+        return build_output_json(rule_matches, semgrep_errors)\n+    else:\n+        return \"\\n\".join(\n+            build_normal_output(rule_matches, semgrep_errors, color_output)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwOTA2MQ==", "bodyText": "Oh you're right I don't think it is called anywhere that uses it as a list. Will change.", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419809061", "createdAt": "2020-05-05T00:45:17Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -105,22 +85,39 @@ def build_normal_output(\n                     severity_prepend = f\"{YELLOW_COLOR}{severity} \"\n                 else:\n                     severity_prepend = f\"{severity} \"\n-            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {finding.get('extra', {}).get('message')}{RESET_COLOR}\"\n+            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {message}{RESET_COLOR}\"\n \n         last_file = current_file\n         last_message = message\n-        yield from finding_to_line(finding, color_output)\n+        yield from finding_to_line(rule_match, color_output)\n         if fix:\n             yield f\"{BLUE_COLOR}autofix:{RESET_COLOR} {fix}\"\n \n \n-def build_output_json(output_json: Dict[str, Any]) -> str:\n+def build_output_json(rule_matches: List[RuleMatch], semgrep_errors: List[Any]) -> str:\n     # wrap errors under \"data\" entry to be compatible with\n     # https://docs.r2c.dev/en/latest/api/output.html#errors\n-    errors = output_json[\"errors\"]\n-    if errors:\n-        output_json[\"errors\"] = {\n-            \"data\": output_json[\"errors\"],\n-            \"message\": \"SgrepRuntimeErrors\",\n-        }\n+    output_json = {}\n+    output_json[\"results\"] = [rm.to_json() for rm in rule_matches]\n+\n+    errors = []\n+    for error in semgrep_errors:\n+        errors.append(\n+            {\"data\": semgrep_errors, \"message\": \"SemgrepCoreRuntimeErrors\",}\n+        )\n+    output_json[\"errors\"] = errors\n     return json.dumps(output_json)\n+\n+\n+def build_output(\n+    rule_matches: List[RuleMatch],\n+    semgrep_errors: List[Any],\n+    json_format: bool,\n+    color_output: bool,\n+) -> str:\n+    if json_format:\n+        return build_output_json(rule_matches, semgrep_errors)\n+    else:\n+        return \"\\n\".join(\n+            build_normal_output(rule_matches, semgrep_errors, color_output)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzI2NA=="}, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxMTM2Ng==", "bodyText": "Oh build_normal_output uses yielding that I probably didn't want to deal with refactoring to a single return in this PR", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419811366", "createdAt": "2020-05-05T00:54:17Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -105,22 +85,39 @@ def build_normal_output(\n                     severity_prepend = f\"{YELLOW_COLOR}{severity} \"\n                 else:\n                     severity_prepend = f\"{severity} \"\n-            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {finding.get('extra', {}).get('message')}{RESET_COLOR}\"\n+            yield f\"{severity_prepend}{YELLOW_COLOR}rule:{check_id}: {message}{RESET_COLOR}\"\n \n         last_file = current_file\n         last_message = message\n-        yield from finding_to_line(finding, color_output)\n+        yield from finding_to_line(rule_match, color_output)\n         if fix:\n             yield f\"{BLUE_COLOR}autofix:{RESET_COLOR} {fix}\"\n \n \n-def build_output_json(output_json: Dict[str, Any]) -> str:\n+def build_output_json(rule_matches: List[RuleMatch], semgrep_errors: List[Any]) -> str:\n     # wrap errors under \"data\" entry to be compatible with\n     # https://docs.r2c.dev/en/latest/api/output.html#errors\n-    errors = output_json[\"errors\"]\n-    if errors:\n-        output_json[\"errors\"] = {\n-            \"data\": output_json[\"errors\"],\n-            \"message\": \"SgrepRuntimeErrors\",\n-        }\n+    output_json = {}\n+    output_json[\"results\"] = [rm.to_json() for rm in rule_matches]\n+\n+    errors = []\n+    for error in semgrep_errors:\n+        errors.append(\n+            {\"data\": semgrep_errors, \"message\": \"SemgrepCoreRuntimeErrors\",}\n+        )\n+    output_json[\"errors\"] = errors\n     return json.dumps(output_json)\n+\n+\n+def build_output(\n+    rule_matches: List[RuleMatch],\n+    semgrep_errors: List[Any],\n+    json_format: bool,\n+    color_output: bool,\n+) -> str:\n+    if json_format:\n+        return build_output_json(rule_matches, semgrep_errors)\n+    else:\n+        return \"\\n\".join(\n+            build_normal_output(rule_matches, semgrep_errors, color_output)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzI2NA=="}, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzIwNTAzOnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/rule_match.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDozOToyOFrOGQXBbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDozNDo0OVrOGQaIIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzU5Nw==", "bodyText": "could possible add @lru_cache() if we expect this to be read multiple times. I noticed that black does this for reading .gitignore", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419807597", "createdAt": "2020-05-05T00:39:28Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/rule_match.py", "diffHunk": "@@ -63,6 +65,18 @@ def start(self) -> Dict[str, Any]:\n     def end(self) -> Dict[str, Any]:\n         return self._end\n \n+    @property\n+    def lines(self) -> Iterable[str]:\n+        \"\"\"\n+            Return lines in file that this RuleMatch is referring to.\n+\n+            Assumes file exists.  Note that start/end line is one-indexed\n+        \"\"\"\n+        with self.path.open(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1ODQ2Nw==", "bodyText": "I don't expect this for now but good to know this exists", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419858467", "createdAt": "2020-05-05T04:34:49Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/rule_match.py", "diffHunk": "@@ -63,6 +65,18 @@ def start(self) -> Dict[str, Any]:\n     def end(self) -> Dict[str, Any]:\n         return self._end\n \n+    @property\n+    def lines(self) -> Iterable[str]:\n+        \"\"\"\n+            Return lines in file that this RuleMatch is referring to.\n+\n+            Assumes file exists.  Note that start/end line is one-indexed\n+        \"\"\"\n+        with self.path.open(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzU5Nw=="}, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzIwNjY2OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/rule_match.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo0MDoyN1rOGQXCXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo0ODoxOVrOGQXKHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzgzNg==", "bodyText": "would we ever expect to be able to call self.start.line?", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419807836", "createdAt": "2020-05-05T00:40:27Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/rule_match.py", "diffHunk": "@@ -63,6 +65,18 @@ def start(self) -> Dict[str, Any]:\n     def end(self) -> Dict[str, Any]:\n         return self._end\n \n+    @property\n+    def lines(self) -> Iterable[str]:\n+        \"\"\"\n+            Return lines in file that this RuleMatch is referring to.\n+\n+            Assumes file exists.  Note that start/end line is one-indexed\n+        \"\"\"\n+        with self.path.open(\n+            buffering=1, errors=\"replace\"\n+        ) as fin:  # buffering=1 turns on line-level reads\n+            return list(itertools.islice(fin, self.start[\"line\"] - 1, self.end[\"line\"]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwOTgyMA==", "bodyText": "Yeah start and end should be objects with named fields as well", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419809820", "createdAt": "2020-05-05T00:48:19Z", "author": {"login": "brendongo"}, "path": "semgrep/semgrep/rule_match.py", "diffHunk": "@@ -63,6 +65,18 @@ def start(self) -> Dict[str, Any]:\n     def end(self) -> Dict[str, Any]:\n         return self._end\n \n+    @property\n+    def lines(self) -> Iterable[str]:\n+        \"\"\"\n+            Return lines in file that this RuleMatch is referring to.\n+\n+            Assumes file exists.  Note that start/end line is one-indexed\n+        \"\"\"\n+        with self.path.open(\n+            buffering=1, errors=\"replace\"\n+        ) as fin:  # buffering=1 turns on line-level reads\n+            return list(itertools.islice(fin, self.start[\"line\"] - 1, self.end[\"line\"]))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzgzNg=="}, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzIxMDQ2OnYy", "diffSide": "RIGHT", "path": "semgrep/semgrep/semgrep_main.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo0Mjo1NFrOGQXEsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDo0Mjo1NFrOGQXEsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwODQzNA==", "bodyText": "wish we did the serialization closer to the post but I suspect you want to do this once", "url": "https://github.com/returntocorp/semgrep/pull/681#discussion_r419808434", "createdAt": "2020-05-05T00:42:54Z", "author": {"login": "DrewDennison"}, "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -131,39 +131,27 @@ def rename_rule_ids(valid_configs: Dict[str, Any]) -> Dict[str, Any]:\n ### Handle output\n \n \n-def post_output(output_url: str, output_data: Dict[str, Any]) -> None:\n+def post_output(output_url: str, output: str) -> None:\n     import requests  # here for faster startup times\n \n     print_msg(f\"posting to {output_url}...\")\n-    r = requests.post(output_url, json=output_data)\n+    r = requests.post(output_url, data=output)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73060ccafdd434fb7a4949b26b527b33e62bb3bf"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4676, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}