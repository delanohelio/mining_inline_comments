{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5Nzg1MTgy", "number": 198, "title": "pattern-where-python", "bodyText": "cc @clintgibler\ntests in returntocorp/semgrep-rules#185 and returntocorp/semgrep-rules#196\nwhen complete, closes #101 ; see #166 for prior discussion\nMajor changes include using proper types and classes for the sgrep output as well as BooleanRuleExpression for the formerly-tuple parsed expressions.\nBecause of the potential for arbitrary code execution, these rules are only run if the command-line flag --dangerously-allow-arbitrary-code-execution-from-rules is set", "createdAt": "2020-02-25T20:30:49Z", "url": "https://github.com/returntocorp/semgrep/pull/198", "merged": true, "mergeCommit": {"oid": "c3a559101d6d6a7a5d357341ba0622a23dd2d6e9"}, "closed": true, "closedAt": "2020-02-27T16:26:12Z", "author": {"login": "ievans"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcH4J6oAH2gAyMzc5Nzg1MTgyOjNjODYyMzQzZTBmOWI1MmZlZjljOWY1YmYzNGI5YWYxMzM3OTkyOGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIdyFrAH2gAyMzc5Nzg1MTgyOjFmMjc3YzIwNTY2MmVkOWIwYWU0NDY5M2I4N2NmMDgwZWExMDI0NjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3c862343e0f9b52fef9c9f5bf34b9af13379928f", "author": {"user": {"login": "clintgibler", "name": "Clint Gibler"}}, "url": "https://github.com/returntocorp/semgrep/commit/3c862343e0f9b52fef9c9f5bf34b9af13379928f", "committedDate": "2020-02-25T20:29:04Z", "message": "Prototype where-python pattern, need to fix other test cases, now SgrepRange instead of Range is used (#166)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cb781ffbcfcebf712573c9e3456c9f0fa6dcc98", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/3cb781ffbcfcebf712573c9e3456c9f0fa6dcc98", "committedDate": "2020-02-25T20:29:47Z", "message": "complete port to SRange"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9d0f0b6d299f199fc52509048ea8c4e0ff45f9c", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/f9d0f0b6d299f199fc52509048ea8c4e0ff45f9c", "committedDate": "2020-02-25T20:32:07Z", "message": "black"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dbe3d902f23140f6d39359b86633bbf9fe2da57", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/4dbe3d902f23140f6d39359b86633bbf9fe2da57", "committedDate": "2020-02-25T20:43:16Z", "message": "flags.dangerously_allow_arbitrary_code_execution_from_rules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe05523066c5b876003f5e0c83dcb56df6adf277", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/fe05523066c5b876003f5e0c83dcb56df6adf277", "committedDate": "2020-02-25T22:36:27Z", "message": "switich to a class for rule expression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19ffecf7800d43a584351496f42f32119c05c920", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/19ffecf7800d43a584351496f42f32119c05c920", "committedDate": "2020-02-25T23:36:15Z", "message": "consistent logic for where-python"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07a6f40afbe43a68671cddce32a32d5aba8bc8d5", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/07a6f40afbe43a68671cddce32a32d5aba8bc8d5", "committedDate": "2020-02-25T23:36:51Z", "message": "black"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e5ba8b63ae1faea1f12bc12442ecc3bac01f422", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/7e5ba8b63ae1faea1f12bc12442ecc3bac01f422", "committedDate": "2020-02-25T23:56:46Z", "message": "mypy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bda1b2ead35a7c3c1d176ef78063a6f489ee08fd", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/bda1b2ead35a7c3c1d176ef78063a6f489ee08fd", "committedDate": "2020-02-26T00:36:56Z", "message": "avoid validating patterns that don't need to be sent to sgrep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4e45de6a52131e97a4269696d1bd93a024381c", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/7d4e45de6a52131e97a4269696d1bd93a024381c", "committedDate": "2020-02-26T00:39:57Z", "message": "shut up mypy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c80f2baff2b50a84ef148caa9343273e4742c2d1", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/c80f2baff2b50a84ef148caa9343273e4742c2d1", "committedDate": "2020-02-26T00:40:07Z", "message": "black"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f388d74c706d65f1501ded896d3a8d283c2a1f0", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/1f388d74c706d65f1501ded896d3a8d283c2a1f0", "committedDate": "2020-02-26T00:44:55Z", "message": "pre-commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "committedDate": "2020-02-26T06:22:59Z", "message": "fix single rule id"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTMyNDEy", "url": "https://github.com/returntocorp/semgrep/pull/198#pullrequestreview-365132412", "createdAt": "2020-02-26T18:20:38Z", "commit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMDozOFrOFu2ycA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMTo1MFrOFu21Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NjQ2NA==", "bodyText": "alala, would be nice to have algebraic datatype in Python ...", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676464", "createdAt": "2020-02-26T18:20:38Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ==", "bodyText": "woohoo", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676941", "createdAt": "2020-02-26T18:21:29Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NzE1OQ==", "bodyText": "What is the difference between exec and eval?", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384677159", "createdAt": "2020-02-26T18:21:50Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ=="}, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 289}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0ed4b508298b7666e271a7cc6686bf97434c132", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/a0ed4b508298b7666e271a7cc6686bf97434c132", "committedDate": "2020-02-26T19:41:33Z", "message": "Merge branch 'develop' into feature/where-python"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571f3c24cbbc1f81e376608d7900b248759d3c53", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/571f3c24cbbc1f81e376608d7900b248759d3c53", "committedDate": "2020-02-26T20:29:31Z", "message": "Update sgrep.py\n\nMissing f string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f277c205662ed9b0ae44693b87cf080ea102462", "author": {"user": {"login": "ievans", "name": "Isaac Evans"}}, "url": "https://github.com/returntocorp/semgrep/commit/1f277c205662ed9b0ae44693b87cf080ea102462", "committedDate": "2020-02-27T16:19:26Z", "message": "clearer error messages for invalid YAML files (#215)\n\n* better error messages and tests, close issue #210"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1129, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}