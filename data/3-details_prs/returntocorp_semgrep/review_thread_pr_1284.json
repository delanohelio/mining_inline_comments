{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NDU5MzYw", "number": 1284, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0ODowM1rOEO0EWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo1MDowM1rOEO0HAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTY4NjAyOnYy", "diffSide": "RIGHT", "path": "semgrep-core/parsing/Parse_java_tree_sitter.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0ODowM1rOGyLWlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0OTowOVrOGyLYwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Nzk4OA==", "bodyText": "should this be in a Java parsing PR instead?", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455267988", "createdAt": "2020-07-15T18:48:03Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/parsing/Parse_java_tree_sitter.ml", "diffHunk": "@@ -50,13 +51,11 @@ module G = AST_generic\n \n [@@@warning \"-32\"]\n \n-type env = unit\n+type env = H.env\n \n-let token (env : env) (_tok : Tree_sitter_run.Token.t) =\n-  failwith \"not implemented\"\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2ODU0NQ==", "bodyText": "yes it should ...", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455268545", "createdAt": "2020-07-15T18:49:09Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_java_tree_sitter.ml", "diffHunk": "@@ -50,13 +51,11 @@ module G = AST_generic\n \n [@@@warning \"-32\"]\n \n-type env = unit\n+type env = H.env\n \n-let token (env : env) (_tok : Tree_sitter_run.Token.t) =\n-  failwith \"not implemented\"\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Nzk4OA=="}, "originalCommit": {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTY5MjgyOnYy", "diffSide": "RIGHT", "path": "semgrep-core/parsing/Parse_go_tree_sitter.ml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo1MDowM1rOGyLa0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTowNzoxMlrOGyMAqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA==", "bodyText": "FWIW I'd love to see us, in the future, clearly separating boilerplate vs. contributed code.\nE.g.\nmatch Boilerplate.interpreted_string_literal env v with\n  (v1, v2, v3) -> todo env (v1, v2, v3)\nhere", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455269074", "createdAt": "2020-07-15T18:50:03Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/parsing/Parse_go_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1547 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_go\n+module CST = Tree_sitter_go.CST\n+module PI = Parse_info\n+(* open Ast_go *)\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Go parser using ocaml-tree-sitter-lang/go and converting\n+ * to pfff/lang_go/parsing/ast_go.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_go/analyze/go_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the go CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+[@@@warning \"-32\"]\n+\n+type env = H.env\n+\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token\n+\n+let blank (env : env) () = ()\n+\n+let todo (env : env) _ =\n+   failwith \"not implemented\"\n+\n+let int_literal (env : env) (tok : CST.int_literal) =\n+  token env tok (* int_literal *)\n+\n+let identifier (env : env) (tok : CST.identifier) =\n+  token env tok (* identifier *)\n+\n+let raw_string_literal (env : env) (tok : CST.raw_string_literal) =\n+  token env tok (* raw_string_literal *)\n+\n+let rune_literal (env : env) (tok : CST.rune_literal) =\n+  token env tok (* rune_literal *)\n+\n+let float_literal (env : env) (tok : CST.float_literal) =\n+  token env tok (* float_literal *)\n+\n+let imaginary_literal (env : env) (tok : CST.imaginary_literal) =\n+  token env tok (* imaginary_literal *)\n+\n+let escape_sequence (env : env) (tok : CST.escape_sequence) =\n+  token env tok (* escape_sequence *)\n+\n+let qualified_type (env : env) ((v1, v2, v3) : CST.qualified_type) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \".\" *) in\n+  let v3 = token env v3 (* identifier *) in\n+  todo env (v1, v2, v3)\n+\n+let package_clause (env : env) ((v1, v2) : CST.package_clause) =\n+  let v1 = token env v1 (* \"package\" *) in\n+  let v2 = token env v2 (* identifier *) in\n+  todo env (v1, v2)\n+\n+let empty_labeled_statement (env : env) ((v1, v2) : CST.empty_labeled_statement) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \":\" *) in\n+  todo env (v1, v2)\n+\n+let interpreted_string_literal (env : env) ((v1, v2, v3) : CST.interpreted_string_literal) =\n+  let v1 = token env v1 (* \"\\\"\" *) in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTg2OQ==", "bodyText": "The motivation is to reduce, as much as possible, any manual work when rev'ing the grammar later.", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455269869", "createdAt": "2020-07-15T18:51:27Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/parsing/Parse_go_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1547 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_go\n+module CST = Tree_sitter_go.CST\n+module PI = Parse_info\n+(* open Ast_go *)\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Go parser using ocaml-tree-sitter-lang/go and converting\n+ * to pfff/lang_go/parsing/ast_go.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_go/analyze/go_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the go CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+[@@@warning \"-32\"]\n+\n+type env = H.env\n+\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token\n+\n+let blank (env : env) () = ()\n+\n+let todo (env : env) _ =\n+   failwith \"not implemented\"\n+\n+let int_literal (env : env) (tok : CST.int_literal) =\n+  token env tok (* int_literal *)\n+\n+let identifier (env : env) (tok : CST.identifier) =\n+  token env tok (* identifier *)\n+\n+let raw_string_literal (env : env) (tok : CST.raw_string_literal) =\n+  token env tok (* raw_string_literal *)\n+\n+let rune_literal (env : env) (tok : CST.rune_literal) =\n+  token env tok (* rune_literal *)\n+\n+let float_literal (env : env) (tok : CST.float_literal) =\n+  token env tok (* float_literal *)\n+\n+let imaginary_literal (env : env) (tok : CST.imaginary_literal) =\n+  token env tok (* imaginary_literal *)\n+\n+let escape_sequence (env : env) (tok : CST.escape_sequence) =\n+  token env tok (* escape_sequence *)\n+\n+let qualified_type (env : env) ((v1, v2, v3) : CST.qualified_type) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \".\" *) in\n+  let v3 = token env v3 (* identifier *) in\n+  todo env (v1, v2, v3)\n+\n+let package_clause (env : env) ((v1, v2) : CST.package_clause) =\n+  let v1 = token env v1 (* \"package\" *) in\n+  let v2 = token env v2 (* identifier *) in\n+  todo env (v1, v2)\n+\n+let empty_labeled_statement (env : env) ((v1, v2) : CST.empty_labeled_statement) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \":\" *) in\n+  todo env (v1, v2)\n+\n+let interpreted_string_literal (env : env) ((v1, v2, v3) : CST.interpreted_string_literal) =\n+  let v1 = token env v1 (* \"\\\"\" *) in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA=="}, "originalCommit": {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODc2MQ==", "bodyText": "I don't think we can call Boilerplate from Parse_go_tree_sitter.ml. We copy-paste Boilerplate.ml initially but\nin my next diff I will update every final \"actions\" in Parse_go_tree_sitter.ml.\nWhen we rev'ing the grammar later, we will regenerate CST.ml and the OCaml compiler will help us pinpoint\nall the place in Parse_go_tree_sitter.ml we need to update. I don't think it will be too much work.", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455278761", "createdAt": "2020-07-15T19:07:12Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_go_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1547 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_go\n+module CST = Tree_sitter_go.CST\n+module PI = Parse_info\n+(* open Ast_go *)\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Go parser using ocaml-tree-sitter-lang/go and converting\n+ * to pfff/lang_go/parsing/ast_go.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_go/analyze/go_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the go CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+[@@@warning \"-32\"]\n+\n+type env = H.env\n+\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token\n+\n+let blank (env : env) () = ()\n+\n+let todo (env : env) _ =\n+   failwith \"not implemented\"\n+\n+let int_literal (env : env) (tok : CST.int_literal) =\n+  token env tok (* int_literal *)\n+\n+let identifier (env : env) (tok : CST.identifier) =\n+  token env tok (* identifier *)\n+\n+let raw_string_literal (env : env) (tok : CST.raw_string_literal) =\n+  token env tok (* raw_string_literal *)\n+\n+let rune_literal (env : env) (tok : CST.rune_literal) =\n+  token env tok (* rune_literal *)\n+\n+let float_literal (env : env) (tok : CST.float_literal) =\n+  token env tok (* float_literal *)\n+\n+let imaginary_literal (env : env) (tok : CST.imaginary_literal) =\n+  token env tok (* imaginary_literal *)\n+\n+let escape_sequence (env : env) (tok : CST.escape_sequence) =\n+  token env tok (* escape_sequence *)\n+\n+let qualified_type (env : env) ((v1, v2, v3) : CST.qualified_type) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \".\" *) in\n+  let v3 = token env v3 (* identifier *) in\n+  todo env (v1, v2, v3)\n+\n+let package_clause (env : env) ((v1, v2) : CST.package_clause) =\n+  let v1 = token env v1 (* \"package\" *) in\n+  let v2 = token env v2 (* identifier *) in\n+  todo env (v1, v2)\n+\n+let empty_labeled_statement (env : env) ((v1, v2) : CST.empty_labeled_statement) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \":\" *) in\n+  todo env (v1, v2)\n+\n+let interpreted_string_literal (env : env) ((v1, v2, v3) : CST.interpreted_string_literal) =\n+  let v1 = token env v1 (* \"\\\"\" *) in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA=="}, "originalCommit": {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4942, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}