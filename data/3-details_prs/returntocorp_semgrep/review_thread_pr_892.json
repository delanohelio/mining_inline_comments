{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NjIzMjcz", "number": 892, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNToxNDoyMVrOEBymww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzo0NDo0N1rOEB2gPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzEzMTU1OnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNToxNDoyMVrOGd2eXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzowNjowNFrOGd7cvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NDM5OA==", "bodyText": "What are your thoughts re. adding the file md5 checksum here? This would enable the Python wrapper to skip calculating this value itself.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433954398", "createdAt": "2020-06-02T15:14:21Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NDYzMQ==", "bodyText": "we don't compute the md5sum of the file content, just of the filename", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433964631", "createdAt": "2020-06-02T15:28:28Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NDM5OA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2OTQ2Mw==", "bodyText": "The suggestion here is that we do calculate the md5 sum of the file content. Given that we're already lexing the entire file, this seems relatively cheap for us here, vs. done in the Python wrapper.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433969463", "createdAt": "2020-06-02T15:35:18Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NDM5OA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNTkwMQ==", "bodyText": "I think caching on md5 sum most reasonable approach. Caching on filename / time which has weird issues among other things inside K8S based docker containers isn't worthwhile.\nI don't think in real world analysis that parsing seems to be a big part of runtime anyway?", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r434035901", "createdAt": "2020-06-02T17:06:04Z", "author": {"login": "rcoh"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NDM5OA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzE0MDE3OnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNToxNjoyMlrOGd2kAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMToxMToyMVrOGeEG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NTg0MQ==", "bodyText": "What's the purpose of hashing the filename here?", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433955841", "createdAt": "2020-06-02T15:16:22Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in\n+  if not (Sys.file_exists dir)\n+  then Unix.mkdir dir 0o700;\n+  (* hopefully there will be no collision *)\n+  let md5 = Digest.string filename in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NDI3OQ==", "bodyText": "Just to create easily a filename in /tmp/semgrep_core_cache/ that correspond to a complex path. semgrep will pass me  /path/to/project/nested/dir/foo.c  and I will hash that.\nI could also replace all / with __, but I might get escaping issues, so just using the md5sum of the path seemed simpler. Also it prevents people to play with the cache directory. Those filename are a bit more opaque than a /tmp/semgrep_core/path__to__project__nested__dir__foo_c", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433964279", "createdAt": "2020-06-02T15:27:58Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in\n+  if not (Sys.file_exists dir)\n+  then Unix.mkdir dir 0o700;\n+  (* hopefully there will be no collision *)\n+  let md5 = Digest.string filename in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NTg0MQ=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MDI4NA==", "bodyText": "Gotcha. What does happen if there's a collision? Can we at least store the full file path in the cache data, along with the NamedAST? That way we can tell when we've hit a collision.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433970284", "createdAt": "2020-06-02T15:36:29Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in\n+  if not (Sys.file_exists dir)\n+  then Unix.mkdir dir 0o700;\n+  (* hopefully there will be no collision *)\n+  let md5 = Digest.string filename in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NTg0MQ=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3Nzc3Nw==", "bodyText": "Good idea!", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r434177777", "createdAt": "2020-06-02T21:11:21Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in\n+  if not (Sys.file_exists dir)\n+  then Unix.mkdir dir 0o700;\n+  (* hopefully there will be no collision *)\n+  let md5 = Digest.string filename in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1NTg0MQ=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzE0NjQwOnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNToxNzo1M1rOGd2oFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNToxNzo1M1rOGd2oFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk1Njg4NQ==", "bodyText": "Not sure how Docker cp works, but just flagging that this computation might always return false for the Docker container used with Docker CP.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433956885", "createdAt": "2020-06-02T15:17:53Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzIzMjUxOnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTozNzo0NVrOGd3fzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMToxMzoxOVrOGeEKhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTE1MA==", "bodyText": "I suggest that this be the full version (including git commit) of pfff, so that any rev to pfff invalidates the cache.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433971150", "createdAt": "2020-06-02T15:37:45Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -136,6 +136,17 @@ let supported_langs: string = String.concat \", \" keys\n let ncores = ref 1\n (*e: constant [[Main_semgrep_core.ncores]] *)\n \n+(* TODO: we may need to put that in AST_generic.ml at some point\n+ * and people should bump this number each time they make a modification\n+ * to the generic AST (or to some analysis such as Naming_AST.ml which\n+ * will have an impact on the marshalled AST). Otherwise, we may\n+ * get some segmentation fault as OCaml marshalling is not entirely\n+ * type-safe!!\n+ *)\n+let ast_version = 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTQ4Nw==", "bodyText": "For development, forcing invalidation whenever pfff is dirty would also prevent developer pain.", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r433971487", "createdAt": "2020-06-02T15:38:16Z", "author": {"login": "nbrahms"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -136,6 +136,17 @@ let supported_langs: string = String.concat \", \" keys\n let ncores = ref 1\n (*e: constant [[Main_semgrep_core.ncores]] *)\n \n+(* TODO: we may need to put that in AST_generic.ml at some point\n+ * and people should bump this number each time they make a modification\n+ * to the generic AST (or to some analysis such as Naming_AST.ml which\n+ * will have an impact on the marshalled AST). Otherwise, we may\n+ * get some segmentation fault as OCaml marshalling is not entirely\n+ * type-safe!!\n+ *)\n+let ast_version = 2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTE1MA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3ODY5NA==", "bodyText": "Sgtm. I think brendon generate a version.ml that we can use here", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r434178694", "createdAt": "2020-06-02T21:13:19Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -136,6 +136,17 @@ let supported_langs: string = String.concat \", \" keys\n let ncores = ref 1\n (*e: constant [[Main_semgrep_core.ncores]] *)\n \n+(* TODO: we may need to put that in AST_generic.ml at some point\n+ * and people should bump this number each time they make a modification\n+ * to the generic AST (or to some analysis such as Naming_AST.ml which\n+ * will have an impact on the marshalled AST). Otherwise, we may\n+ * get some segmentation fault as OCaml marshalling is not entirely\n+ * type-safe!!\n+ *)\n+let ast_version = 2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTE1MA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzc3MDIyOnYy", "diffSide": "RIGHT", "path": "semgrep-core/bin/Main.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzo0NDo0N1rOGd82pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMToxNDo1OVrOGeENcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1ODkxOA==", "bodyText": "About /tmp: you can use Filename.get_temp_dir_name () instead of assuming /tmp exists. (this point was raised by @mschwager )\nfrom https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html :\nval get_temp_dir_name : unit -> string\n\n\nThe name of the temporary directory: Under Unix, the value of the TMPDIR environment variable, or \"/tmp\" if the variable is not set. Under Windows, the value of the TEMP environment variable, or \".\" if the variable is not set. The temporary directory can be changed with Filename.set_temp_dir_name.\nSince 4.00.0", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r434058918", "createdAt": "2020-06-02T17:44:47Z", "author": {"login": "mjambon"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3OTQ0MQ==", "bodyText": "Good idea!", "url": "https://github.com/returntocorp/semgrep/pull/892#discussion_r434179441", "createdAt": "2020-06-02T21:14:59Z", "author": {"login": "aryx"}, "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -264,6 +275,55 @@ let gen_layer ~root ~query file =\n   ()\n (*e: function [[Main_semgrep_core.gen_layer]] *)\n \n+let filemtime file =\n+  (Unix.stat file).Unix.st_mtime\n+\n+(* The function below is mostly a copy-paste of Common.cache_computation.\n+ * This function is slightly more flexible because we can put the cache file\n+ * anywhere thanks to the argument 'cache_file_of_file'.\n+ * We also try to be a bit more type-safe by using the version tag above.\n+ * TODO: merge in pfff/commons/Common.ml at some point\n+ *)\n+let cache_computation file cache_file_of_file f =\n+  if not !use_parsing_cache\n+  then f ()\n+  else begin\n+    if not (Sys.file_exists file)\n+    then begin\n+      pr2 (\"WARNING: cache_computation: can't find file \"  ^ file);\n+      pr2 (\"defaulting to calling the function\");\n+      f ()\n+    end else begin\n+    profile_code \"Main.cache_computation\" (fun () ->\n+\n+      let file_cache = cache_file_of_file file in\n+      if Sys.file_exists file_cache && filemtime file_cache >= filemtime file\n+      then begin\n+        if !verbose then pr2 (\"using cache: \" ^ file_cache);\n+        let (version, res) = Common2.get_value file_cache in\n+        if version != ast_version\n+        then failwith (spf \"Version mismatch! Clean the cache file %s\"\n+                      file_cache);\n+        res\n+      end\n+      else begin\n+        let res = f () in\n+        Common2.write_value (ast_version, res) file_cache;\n+        res\n+      end\n+      )\n+    end\n+  end\n+\n+\n+let cache_file_of_file filename =\n+  let dir = spf \"/tmp/semgrep_core_cache_%d\" (Unix.getuid()) in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1ODkxOA=="}, "originalCommit": {"oid": "133ca6c3f4e4db03e95e7c29955a136615fa5d2e"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4646, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}