{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTYyMzAy", "number": 2125, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo0NzozNVrOE9Zugw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo0NzozNVrOE9Zugw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODIwMDk5OnYy", "diffSide": "RIGHT", "path": "semgrep-core/parsing/Parse_c_tree_sitter.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo0NzozNVrOH6E0-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo0NzozNVrOH6E0-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1ODU1NQ==", "bodyText": "Maybe rename it to Number if it can hold an int or a float?", "url": "https://github.com/returntocorp/semgrep/pull/2125#discussion_r530658555", "createdAt": "2020-11-25T21:47:35Z", "author": {"login": "mjambon"}, "path": "semgrep-core/parsing/Parse_c_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1746 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_c\n+module CST = Tree_sitter_c.CST\n+module PI = Parse_info\n+open Cst_cpp\n+open Ast_c\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* C parser using ocaml-tree-sitter-lang/c and converting\n+ * to pfff/lang_c/parsing/ast_c.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_c/analyze/c_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type extra = {\n+  (* gensym *)\n+  mutable cnt: int;\n+  mutable struct_defs_toadd: struct_def list;\n+  mutable enum_defs_toadd: enum_def list;\n+  mutable typedefs_toadd: type_def list;\n+}\n+(* similar to Ast_c_build env *)\n+let default_extra_env = {\n+  cnt = 0;\n+\n+  struct_defs_toadd = [];\n+  enum_defs_toadd = [];\n+  typedefs_toadd = [];\n+}\n+let gensym_struct cnt =\n+  spf \"__anon_struct_%d\" cnt\n+\n+let gensym_enum cnt =\n+  spf \"__anon_enum_%d\" cnt\n+\n+type env = extra H.env\n+\n+let _fake = G.fake\n+let token = H.token\n+let str = H.str\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the c CST\n+   to another type of tree.\n+*)\n+\n+let anon_choice_BANG_67174d6 (env : env) (x : CST.anon_choice_BANG_67174d6) =\n+  (match x with\n+  | `BANG tok -> Not, token env tok (* \"!\" *)\n+  | `TILDE tok -> Tilde, token env tok (* \"~\" *)\n+  | `DASH tok -> UnMinus, token env tok (* \"-\" *)\n+  | `PLUS tok -> UnPlus, token env tok (* \"+\" *)\n+  )\n+\n+\n+let type_qualifier (env : env) (x : CST.type_qualifier) =\n+  (match x with\n+  | `Const tok -> token env tok (* \"const\" *)\n+  | `Vola tok -> token env tok (* \"volatile\" *)\n+  | `Rest tok -> token env tok (* \"restrict\" *)\n+  | `X__Atomic tok -> token env tok (* \"_Atomic\" *)\n+  )\n+\n+\n+let identifier (env : env) (tok : CST.identifier) : name =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let storage_class_specifier (env : env) (x : CST.storage_class_specifier) =\n+  (match x with\n+  | `Extern tok -> token env tok (* \"extern\" *)\n+  | `Static tok -> token env tok (* \"static\" *)\n+  | `Auto tok -> token env tok (* \"auto\" *)\n+  | `Regi tok -> token env tok (* \"register\" *)\n+  | `Inline tok -> token env tok (* \"inline\" *)\n+  )\n+\n+let ms_call_modifier (env : env) (x : CST.ms_call_modifier) =\n+  (match x with\n+  | `X___cdecl tok -> token env tok (* \"__cdecl\" *)\n+  | `X___clrc tok -> token env tok (* \"__clrcall\" *)\n+  | `X___stdc tok -> token env tok (* \"__stdcall\" *)\n+  | `X___fast tok -> token env tok (* \"__fastcall\" *)\n+  | `X___this tok -> token env tok (* \"__thiscall\" *)\n+  | `X___vect tok -> token env tok (* \"__vectorcall\" *)\n+  )\n+\n+let ms_unaligned_ptr_modifier (env : env) (x : CST.ms_unaligned_ptr_modifier) =\n+  (match x with\n+  | `X__unal tok -> token env tok (* \"_unaligned\" *)\n+  | `X___unal tok -> token env tok (* \"__unaligned\" *)\n+  )\n+\n+let anon_choice_DASHDASH_d11def2 (env : env) (x : CST.anon_choice_DASHDASH_d11def2) =\n+  (match x with\n+  | `DASHDASH tok -> Dec, token env tok (* \"--\" *)\n+  | `PLUSPLUS tok -> Inc, token env tok (* \"++\" *)\n+  )\n+\n+let string_literal (env : env) ((v1, v2, v3) : CST.string_literal) : string wrap =\n+  let v1 =\n+    (match v1 with\n+    | `LDQUOT tok -> token env tok (* \"L\\\"\" *)\n+    | `UDQUOT_c163aae tok -> token env tok (* \"u\\\"\" *)\n+    | `UDQUOT_df3447d tok -> token env tok (* \"U\\\"\" *)\n+    | `U8DQUOT tok -> token env tok (* \"u8\\\"\" *)\n+    | `DQUOT tok -> token env tok (* \"\\\"\" *)\n+    )\n+  in\n+  let v2 =\n+    List.map (fun x ->\n+      (match x with\n+      | `Imm_tok_pat_c7f65b4 tok ->\n+          str env tok (* pattern \"[^\\\\\\\\\\\"\\\\n]+\" *)\n+      | `Esc_seq tok -> str env tok (* escape_sequence *)\n+      )\n+    ) v2\n+  in\n+  let v3 = token env v3 (* \"\\\"\" *) in\n+  let s = v2 |> List.map fst |> String.concat \"\" in\n+  s, PI.combine_infos v1 (List.map snd v2 @ [v3])\n+\n+let char_literal (env : env) ((v1, v2, v3) : CST.char_literal) : string wrap =\n+  let v1 =\n+    (match v1 with\n+    | `LSQUOT tok -> token env tok (* \"L'\" *)\n+    | `USQUOT_d861d39 tok -> token env tok (* \"u'\" *)\n+    | `USQUOT_2701bdc tok -> token env tok (* \"U'\" *)\n+    | `U8SQUOT tok -> token env tok (* \"u8'\" *)\n+    | `SQUOT tok -> token env tok (* \"'\" *)\n+    )\n+  in\n+  let v2 =\n+    (match v2 with\n+    | `Esc_seq tok -> str env tok (* escape_sequence *)\n+    | `Imm_tok_pat_36637e2 tok ->\n+        str env tok (* pattern \"[^\\\\n']\" *)\n+    )\n+  in\n+  let v3 = token env v3 (* \"'\" *) in\n+  let s = fst v2 in\n+  s, PI.combine_infos v1 ([snd v2; v3])\n+\n+\n+let anon_choice_pat_25b90ba_4a37f8c (env : env) (x : CST.anon_choice_pat_25b90ba_4a37f8c) =\n+  (match x with\n+  | `Pat_25b90ba tok ->\n+      token env tok (* pattern #[ \t]*ifdef *)\n+  | `Pat_9d92f6a tok ->\n+      token env tok (* pattern #[ \t]*ifndef *)\n+  )\n+\n+let ms_pointer_modifier (env : env) (x : CST.ms_pointer_modifier) =\n+  (match x with\n+  | `Ms_unal_ptr_modi x -> ms_unaligned_ptr_modifier env x\n+  | `Ms_rest_modi tok -> token env tok (* \"__restrict\" *)\n+  | `Ms_unsi_ptr_modi tok -> token env tok (* \"__uptr\" *)\n+  | `Ms_signed_ptr_modi tok -> token env tok (* \"__sptr\" *)\n+  )\n+\n+(* can actually contain a complex expression, but just parsed as a string\n+ * until non-escaped newline in tree-sitter-c.\n+ *)\n+let preproc_arg env tok =\n+  str env tok\n+\n+let preproc_call (env : env) ((v1, v2, v3) : CST.preproc_call) =\n+  let v1 = identifier env v1 (* pattern #[ \\t]*[a-zA-Z]\\w* *) in\n+  let _v3 = token env v3 (* \"\\n\" *) in\n+  let v2 =\n+    (match v2 with\n+    | Some tok -> Some (preproc_arg env tok) (* preproc_arg *)\n+    | None -> None\n+    )\n+  in\n+  OtherDirective (v1, v2)\n+\n+let field_designator (env : env) ((v1, v2) : CST.field_designator) : name =\n+  let _v1 = token env v1 (* \".\" *) in\n+  let v2 = str env v2 (* pattern [a-zA-Z_]\\w* *) in\n+  v2\n+\n+let preproc_defined (env : env) (x : CST.preproc_defined) : tok * name =\n+  (match x with\n+  | `Defi_LPAR_id_RPAR (v1, v2, v3, v4) ->\n+      let v1 = token env v1 (* \"defined\" *) in\n+      let _v2 = token env v2 (* \"(\" *) in\n+      let v3 = identifier env v3 (* pattern [a-zA-Z_]\\w* *) in\n+      let _v4 = token env v4 (* \")\" *) in\n+      v1, v3\n+  | `Defi_id (v1, v2) ->\n+      let v1 = token env v1 (* \"defined\" *) in\n+      let v2 = identifier env v2 (* pattern [a-zA-Z_]\\w* *) in\n+      v1, v2\n+  )\n+\n+let anon_choice_type_id_d3c4b5f (env : env) (x : CST.anon_choice_type_id_d3c4b5f) =\n+  (match x with\n+  | `Id tok -> str env tok (* pattern [a-zA-Z_]\\w* *)\n+  | `DOTDOTDOT tok -> \"...\", token env tok (* \"...\" *)\n+  )\n+\n+let ms_declspec_modifier (env : env) ((v1, v2, v3, v4) : CST.ms_declspec_modifier) =\n+  let _v1 = token env v1 (* \"__declspec\" *) in\n+  let _v2 = token env v2 (* \"(\" *) in\n+  let _v3 = token env v3 (* pattern [a-zA-Z_]\\w* *) in\n+  let _v4 = token env v4 (* \")\" *) in\n+  ()\n+\n+let preproc_def (env : env) ((v1, v2, v3, v4) : CST.preproc_def) : directive =\n+  let v1 = token env v1 (* pattern #[ \t]*define *) in\n+  let v2 = str env v2 (* pattern [a-zA-Z_]\\w* *) in\n+  let v3 =\n+    (match v3 with\n+    | Some tok -> Some (preproc_arg env tok) (* preproc_arg *)\n+    | None -> None)\n+  in\n+  let _v4 = token env v4 (* \"\\n\" *) in\n+  (match v3 with\n+  | Some x -> Define (v1, v2, Some (CppExpr (String x)))\n+  | None -> Define (v1, v2, None)\n+  )\n+\n+let rec preproc_argument_list (env : env) ((v1, v2, v3) : CST.preproc_argument_list) : argument list bracket =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+    | Some (v1, v2) ->\n+        let v1 = preproc_expression env v1 in\n+        let v2 =\n+          List.map (fun (v1, v2) ->\n+            let _v1 = token env v1 (* \",\" *) in\n+            let v2 = preproc_expression env v2 in\n+            v2\n+          ) v2\n+        in\n+        v1::v2\n+    | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v1, (v2 |> List.map (fun x -> Arg x)), v3\n+\n+and preproc_binary_expression (env : env) (x : CST.preproc_binary_expression)\n+ : expr =\n+  (match x with\n+  | `Prep_exp_PLUS_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"+\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Plus in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_DASH_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"-\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Minus in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_STAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"*\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Mul in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_SLASH_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"/\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Div in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_PERC_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"%\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Mod in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BARBAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"||\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical OrLog in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_AMPAMP_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"&&\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical AndLog in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"|\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Or in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_HAT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"^\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Xor in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_AMP_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"&\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith And in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_EQEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"==\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Eq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BANGEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"!=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical NotEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Sup in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GTEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical SupEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LTEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical InfEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Inf in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LTLT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<<\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith DecLeft in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GTGT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">>\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith DecRight in\n+      Binary (v1, (op, v2), v3)\n+  )\n+\n+and preproc_call_expression (env : env) ((v1, v2) : CST.preproc_call_expression) =\n+  let v1 = identifier env v1 (* pattern [a-zA-Z_]\\w* *) in\n+  let v2 = preproc_argument_list env v2 in\n+  Call (Id v1, v2)\n+\n+(* Int or Float ! *)\n+and number_literal env tok =\n+  let n = str env tok in\n+  Int n", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3afa705b43541bc12d47d2f56eefdfeeb903bd4"}, "originalPosition": 389}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4754, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}