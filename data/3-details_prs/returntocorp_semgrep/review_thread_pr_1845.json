{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0NDg2NDE0", "number": 1845, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNjowMlrOEuVomA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozMTowM1rOEuVynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDI0NDA4OnYy", "diffSide": "RIGHT", "path": "spacegrep/src/lib/Semgrep.atd", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNjowMlrOHirEzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNjowMlrOHirEzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExOTM3NQ==", "bodyText": "Type definitions for JSON communication with the semgrep Python wrapper.", "url": "https://github.com/returntocorp/semgrep/pull/1845#discussion_r506119375", "createdAt": "2020-10-16T07:26:02Z", "author": {"login": "aryx"}, "path": "spacegrep/src/lib/Semgrep.atd", "diffHunk": "@@ -0,0 +1,71 @@\n+(*\n+   Type definitions for json communication with semgrep.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0441f342a9a157718db11e5df8c9f2c81f9a1c99"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDI0ODc0OnYy", "diffSide": "RIGHT", "path": "spacegrep/src/lib/Semgrep.atd", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNjo0M1rOHirIQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNjo0M1rOHirIQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyMDI1OQ==", "bodyText": "Nice!\nI should probably use it in semgrep-core too now that they are in the same repo :)", "url": "https://github.com/returntocorp/semgrep/pull/1845#discussion_r506120259", "createdAt": "2020-10-16T07:26:43Z", "author": {"login": "aryx"}, "path": "spacegrep/src/lib/Semgrep.atd", "diffHunk": "@@ -0,0 +1,71 @@\n+(*\n+   Type definitions for json communication with semgrep.\n+\n+   Inferred from JSON_report.ml in semgrep-core.\n+*)\n+\n+type match_results = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0441f342a9a157718db11e5df8c9f2c81f9a1c99"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDI1NDI4OnYy", "diffSide": "RIGHT", "path": "spacegrep/src/lib/Semgrep.atd", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNzo0OFrOHirL3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzoyNzo0OFrOHirL3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyMTE4MQ==", "bodyText": "it's actually in pfff/h_program-lang/R2c.ml", "url": "https://github.com/returntocorp/semgrep/pull/1845#discussion_r506121181", "createdAt": "2020-10-16T07:27:48Z", "author": {"login": "aryx"}, "path": "spacegrep/src/lib/Semgrep.atd", "diffHunk": "@@ -0,0 +1,71 @@\n+(*\n+   Type definitions for json communication with semgrep.\n+\n+   Inferred from JSON_report.ml in semgrep-core.\n+*)\n+\n+type match_results = {\n+  matches: match_ list;\n+  errors: error list;\n+  stats: stats;\n+}\n+\n+type stats = {\n+  okfiles: int;\n+  errorfiles: int;\n+}\n+\n+type match_ = {\n+  ?check_id: string option; (* rule ID *)\n+  path: string; (* source file *)\n+  start: position;\n+  end_ <json name=\"end\">: position;\n+  extra: match_extra;\n+}\n+\n+(* See R2c.ml in semgrep-core *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0441f342a9a157718db11e5df8c9f2c81f9a1c99"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDI2NzA0OnYy", "diffSide": "RIGHT", "path": "spacegrep/src/lib/Semgrep.atd", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozMDoxNlrOHirUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozMDoxNlrOHirUAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyMzI2NA==", "bodyText": "Anyway you should need it. It's used when a metavariable matches an identifier and we want to make sure that independent matches on the same identifer name correspond to same scoped identifier (see Naming_AST.ml in pfff))", "url": "https://github.com/returntocorp/semgrep/pull/1845#discussion_r506123264", "createdAt": "2020-10-16T07:30:16Z", "author": {"login": "aryx"}, "path": "spacegrep/src/lib/Semgrep.atd", "diffHunk": "@@ -0,0 +1,71 @@\n+(*\n+   Type definitions for json communication with semgrep.\n+\n+   Inferred from JSON_report.ml in semgrep-core.\n+*)\n+\n+type match_results = {\n+  matches: match_ list;\n+  errors: error list;\n+  stats: stats;\n+}\n+\n+type stats = {\n+  okfiles: int;\n+  errorfiles: int;\n+}\n+\n+type match_ = {\n+  ?check_id: string option; (* rule ID *)\n+  path: string; (* source file *)\n+  start: position;\n+  end_ <json name=\"end\">: position;\n+  extra: match_extra;\n+}\n+\n+(* See R2c.ml in semgrep-core *)\n+type error = {\n+  ?check_id: string option;\n+  path: string;\n+  start: position;\n+  end_ <json name=\"end\">: position;\n+  extra: error_extra;\n+}\n+\n+type position = {\n+  line: int; (* starts at 1 *)\n+  col: int; (* starts at 1 *)\n+  offset: int; (* byte position from the beginning of the file, starts at 0 *)\n+}\n+\n+type match_extra = {\n+  ?message: string option; (* rule.message (?) *)\n+  metavars: (string * metavar_value) list <json repr=\"object\">;\n+}\n+\n+type error_extra = {\n+  message: string;\n+  line: string;\n+}\n+\n+type metavar_value = {\n+  start: position;\n+  end_ <json name=\"end\">: position;\n+  abstract_content: string; (* value? *)\n+  unique_id: unique_id;\n+}\n+\n+(*\n+   This is just the variant for type=AST.\n+   In order to accommodate two record types into one variant, use\n+   the atdgen feature called a json adapter.\n+*)\n+type unique_id = {\n+  type_ <json name=\"type\">: unique_id_type;\n+  md5sum: string;\n+}\n+\n+type unique_id_type = [\n+(*  | ID <json name=\"id\"> *) (* variant not supported at the moment *)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0441f342a9a157718db11e5df8c9f2c81f9a1c99"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDI2OTczOnYy", "diffSide": "RIGHT", "path": "spacegrep/src/lib/Semgrep.ml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozMTowM1rOHirVhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozMTowM1rOHirVhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyMzY1NQ==", "bodyText": "Nice! I need to use this atdgen more.", "url": "https://github.com/returntocorp/semgrep/pull/1845#discussion_r506123655", "createdAt": "2020-10-16T07:31:03Z", "author": {"login": "aryx"}, "path": "spacegrep/src/lib/Semgrep.ml", "diffHunk": "@@ -0,0 +1,78 @@\n+(*\n+   Convert matches to the format expected by the semgrep wrapper,\n+   similar to what semgrep-core produces.\n+*)\n+\n+open Match\n+open Semgrep_t\n+\n+let semgrep_pos (x : Lexing.position) : Semgrep_t.position =\n+  {\n+    line = x.pos_lnum + 1;\n+    col = x.pos_cnum - x.pos_bol + 1;\n+    offset = x.pos_cnum;\n+  }\n+\n+let unique_id_of_loc (loc : Loc.t) : unique_id =\n+  let md5sum =\n+    Marshal.to_string loc []\n+    |> Digest.string\n+    |> Digest.to_hex\n+  in\n+  {\n+    type_ = `AST;\n+    md5sum;\n+  }\n+\n+let convert_capture x =\n+  let pos1, pos2 = x.loc in\n+  x.name, {\n+    start = semgrep_pos pos1;\n+    end_ = semgrep_pos pos2;\n+    abstract_content = x.value;\n+    unique_id = unique_id_of_loc x.loc;\n+  }\n+\n+(*\n+   Convert match results to the format expected by semgrep.\n+*)\n+let make_semgrep_json doc_matches : Semgrep_t.match_results =\n+  let matches =\n+    List.map (fun (src, pat_matches) ->\n+      let path = Src_file.source_string src in\n+      List.map (fun (pat_id, matches) ->\n+        let check_id = Some (string_of_int pat_id) in\n+        List.map (fun match_ ->\n+          let ((pos1, _), (_, pos2)) = match_.region in\n+          let metavars = List.map convert_capture match_.captures in\n+          let extra = {\n+            message = None;\n+            metavars;\n+          } in\n+          ({\n+            check_id;\n+            path;\n+            start = semgrep_pos pos1;\n+            end_ = semgrep_pos pos2;\n+            extra;\n+          } : match_)\n+        ) matches\n+      ) pat_matches\n+      |> List.flatten\n+    ) doc_matches\n+    |> List.flatten\n+  in\n+  {\n+    matches;\n+    errors = [];\n+    stats = {\n+      okfiles = List.length doc_matches;\n+      errorfiles = 0;\n+    };\n+  }\n+\n+let print_semgrep_json doc_matches =\n+  make_semgrep_json doc_matches\n+  |> Semgrep_j.string_of_match_results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0441f342a9a157718db11e5df8c9f2c81f9a1c99"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4807, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}