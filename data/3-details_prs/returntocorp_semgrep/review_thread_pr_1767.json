{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2MzE5MjI4", "number": 1767, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo1MzozOVrOEpidkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo1MzozOVrOEpidkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTkxNjk3OnYy", "diffSide": "RIGHT", "path": "semgrep-core/parsing/Parse_tree_sitter_helpers.ml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo1MzozOVrOHbQ8zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjowMjowMFrOHbRSLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1MTMxMA==", "bodyText": "To get the constructor, you can do Printexc.exn_slot_name exn (since ocaml 4.02). But I don't see how to do the rest without Obj, other than catching the exception in the child (or make the parser return an Ok/Error).", "url": "https://github.com/returntocorp/semgrep/pull/1767#discussion_r498351310", "createdAt": "2020-10-01T15:53:39Z", "author": {"login": "mjambon"}, "path": "semgrep-core/parsing/Parse_tree_sitter_helpers.ml", "diffHunk": "@@ -92,6 +92,45 @@ let combine_tokens env xs =\n       let t = token env x in\n       t\n \n+let mk_tree_sitter_error (err : Tree_sitter_run.Tree_sitter_error.t) =\n+  let start = err.start_pos in\n+  let loc = {\n+    PI.str = err.substring;\n+    charpos = 0; (* fake *)\n+    line = start.row + 1;\n+    column = start.column;\n+    file = err.file.name;\n+  } in\n+  loc\n+\n+let convert_tree_sitter_exn_to_pfff_exn f =\n+  try f ()\n+  with\n+  (* The case below is what we would like to do! However if\n+   * you use Parallel.invoke to invoke the tree-sitter parser, this\n+   * code below will never trigger. Indeed, unmarshalled exn\n+   * can't be used in match or try or used for structural equality\n+   * hence the ugly workaround below. See marshal.mli or Paralle.ml for\n+   * more information.\n+   *)\n+  | Tree_sitter_run.Tree_sitter_error.Error ts_error ->\n+    let loc = mk_tree_sitter_error ts_error in\n+    let info = { PI.token = PI.OriginTok loc; transfo = PI.NoTransfo } in\n+    raise (PI.Parsing_error info)\n+\n+  (* !!!UGLY!!! remove this once we don't use Paralle.invoke *)\n+  | exn ->\n+      let s = Common.exn_to_s exn in\n+      if s = \"Tree_sitter_run.Tree_sitter_error.Error(_)\" then begin\n+        let t = Obj.repr exn in\n+        let info = Obj.field t 1 in\n+        let (ts_error : Tree_sitter_run.Tree_sitter_error.t) = Obj.obj info in\n+        let loc = mk_tree_sitter_error ts_error in\n+        let info = { PI.token = PI.OriginTok loc; transfo = PI.NoTransfo } in\n+        raise (PI.Parsing_error info)\n+      end else raise exn", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2687b409a587e12d13b1b23604d8319bcdcab261"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1Njc4MQ==", "bodyText": "yep, the parser could return an algebraic data type. Only exn (open variants) have this marshalling issue.\nStill, I like this hacky solution :)", "url": "https://github.com/returntocorp/semgrep/pull/1767#discussion_r498356781", "createdAt": "2020-10-01T16:02:00Z", "author": {"login": "aryx"}, "path": "semgrep-core/parsing/Parse_tree_sitter_helpers.ml", "diffHunk": "@@ -92,6 +92,45 @@ let combine_tokens env xs =\n       let t = token env x in\n       t\n \n+let mk_tree_sitter_error (err : Tree_sitter_run.Tree_sitter_error.t) =\n+  let start = err.start_pos in\n+  let loc = {\n+    PI.str = err.substring;\n+    charpos = 0; (* fake *)\n+    line = start.row + 1;\n+    column = start.column;\n+    file = err.file.name;\n+  } in\n+  loc\n+\n+let convert_tree_sitter_exn_to_pfff_exn f =\n+  try f ()\n+  with\n+  (* The case below is what we would like to do! However if\n+   * you use Parallel.invoke to invoke the tree-sitter parser, this\n+   * code below will never trigger. Indeed, unmarshalled exn\n+   * can't be used in match or try or used for structural equality\n+   * hence the ugly workaround below. See marshal.mli or Paralle.ml for\n+   * more information.\n+   *)\n+  | Tree_sitter_run.Tree_sitter_error.Error ts_error ->\n+    let loc = mk_tree_sitter_error ts_error in\n+    let info = { PI.token = PI.OriginTok loc; transfo = PI.NoTransfo } in\n+    raise (PI.Parsing_error info)\n+\n+  (* !!!UGLY!!! remove this once we don't use Paralle.invoke *)\n+  | exn ->\n+      let s = Common.exn_to_s exn in\n+      if s = \"Tree_sitter_run.Tree_sitter_error.Error(_)\" then begin\n+        let t = Obj.repr exn in\n+        let info = Obj.field t 1 in\n+        let (ts_error : Tree_sitter_run.Tree_sitter_error.t) = Obj.obj info in\n+        let loc = mk_tree_sitter_error ts_error in\n+        let info = { PI.token = PI.OriginTok loc; transfo = PI.NoTransfo } in\n+        raise (PI.Parsing_error info)\n+      end else raise exn", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1MTMxMA=="}, "originalCommit": {"oid": "2687b409a587e12d13b1b23604d8319bcdcab261"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4885, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}