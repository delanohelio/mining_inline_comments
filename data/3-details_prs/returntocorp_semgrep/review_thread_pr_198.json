{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5Nzg1MTgy", "number": 198, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMDozOFrODjL9sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMToyOVrODjL-5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjIyNzY5OnYy", "diffSide": "RIGHT", "path": "sgrep.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMDozOFrOFu2ycA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMDozOFrOFu2ycA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NjQ2NA==", "bodyText": "alala, would be nice to have algebraic datatype in Python ...", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676464", "createdAt": "2020-02-26T18:20:38Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjIzMDc3OnYy", "diffSide": "RIGHT", "path": "sgrep.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMToyOVrOFu20TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDoxNToxNlrOFvBCdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ==", "bodyText": "woohoo", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676941", "createdAt": "2020-02-26T18:21:29Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NzE1OQ==", "bodyText": "What is the difference between exec and eval?", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384677159", "createdAt": "2020-02-26T18:21:50Z", "author": {"login": "aryx"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ=="}, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NDQwNw==", "bodyText": "https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile/29456463#29456463 @aryx this is a great explanation", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384844407", "createdAt": "2020-02-27T00:15:16Z", "author": {"login": "ievans"}, "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ=="}, "originalCommit": {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e"}, "originalPosition": 289}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4833, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}