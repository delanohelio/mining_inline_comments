{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTg3NDY2", "number": 1920, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzoyNjozMlrODqGLhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo1MToxNFrODqGRyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY4MDM4OnYy", "diffSide": "RIGHT", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzoyNjozMlrOF5qnQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwMDowNToyNFrOF5sZ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTMzMA==", "bodyText": "Could be use the new DynamicModel here?", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396011330", "createdAt": "2020-03-21T17:26:32Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDY3OA==", "bodyText": "I'll have a look, and perhaps also create an overload that accepts a ModelFactory.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040678", "createdAt": "2020-03-22T00:05:24Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTMzMA=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY4Mjg5OnYy", "diffSide": "RIGHT", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzozMDozOVrOF5qomQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwMDowNDoyNlrOF5sZvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw==", "bodyText": "This kind of use of .filter(....) shows that we really need a .select(...) instead. I think .filter(....) is too heavyweight with all its guarantees about returning a model that reflects the underlying model...while all we really need here is at iterator.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396011673", "createdAt": "2020-03-21T17:30:39Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjI5MQ==", "bodyText": "I think it might be faster to have a java switch over model.filter(s.getSubject(), null, null) instead of doing a model.filter for each.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012291", "createdAt": "2020-03-21T17:38:21Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDYzOA==", "bodyText": "This kind of use of .filter(....) shows that we really need a .select(...) instead. I think .filter(....) is too heavyweight with all its guarantees about returning a model that reflects the underlying model...while all we really need here is at iterator.\n\nAgreed. Issue logged: #2030", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040638", "createdAt": "2020-03-22T00:04:26Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY4OTY4OnYy", "diffSide": "RIGHT", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0MTozOFrOF5qsIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0MTozOFrOF5qsIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjU3OA==", "bodyText": "DynamicModel", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012578", "createdAt": "2020-03-21T17:41:38Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);\n+\t\t\tif (!(subject instanceof IRI) && !(subject instanceof BNode)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tValue predicate = object(model.filter(s.getSubject(), RDF.PREDICATE, null)).orElse(null);\n+\t\t\tif (!(predicate instanceof IRI)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tValue object = object(model.filter(s.getSubject(), RDF.OBJECT, null)).orElse(null);\n+\t\t\tif (!(object instanceof Value)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tTriple t = vf.createTriple((Resource) subject, (IRI) predicate, object);\n+\t\t\tconvertedStatements.put(s.getSubject(), t);\n+\t\t});\n+\n+\t\tfor (Map.Entry<Resource, Triple> e : convertedStatements.entrySet()) {\n+\t\t\tTriple t = e.getValue();\n+\t\t\tResource subject = convertedStatements.get(t.getSubject());\n+\t\t\tResource object = convertedStatements.get(t.getObject());\n+\t\t\tif (subject != null || object != null) {\n+\t\t\t\t// Triples within triples, replace them in the map\n+\t\t\t\tTriple nt = vf.createTriple(subject != null ? subject : t.getSubject(), t.getPredicate(),\n+\t\t\t\t\t\tobject != null ? object : t.getObject());\n+\t\t\t\te.setValue(nt);\n+\t\t\t}\n+\t\t}\n+\n+\t\tmodel.forEach((s) -> {\n+\t\t\tResource subject = s.getSubject();\n+\t\t\tIRI predicate = s.getPredicate();\n+\t\t\tValue object = s.getObject();\n+\t\t\tTriple subjectTriple = convertedStatements.get(subject);\n+\t\t\tTriple objectTriple = convertedStatements.get(object);\n+\n+\t\t\tif (subjectTriple == null && objectTriple == null) {\n+\t\t\t\t// Statement not part of detected reification, add it as is\n+\t\t\t\tconsumer.accept(s);\n+\t\t\t} else if (subjectTriple == null || ((!RDF.TYPE.equals(predicate) || !RDF.STATEMENT.equals(object))\n+\t\t\t\t\t&& !RDF.SUBJECT.equals(predicate) && !RDF.PREDICATE.equals(predicate)\n+\t\t\t\t\t&& !RDF.OBJECT.equals(predicate))) {\n+\t\t\t\t// Statement uses reified data and needs to be converted\n+\t\t\t\tStatement ns = vf.createStatement(subjectTriple != null ? subjectTriple : s.getSubject(),\n+\t\t\t\t\t\ts.getPredicate(), objectTriple != null ? objectTriple : s.getObject(), s.getContext());\n+\t\t\t\tconsumer.accept(ns);\n+\t\t\t} // else: Statement part of reification and needs to be removed (skipped)\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(Model model, Consumer<Statement> consumer) {\n+\t\tconvertReificationToRDFStar(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to an RDF* model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertReificationToRDFStar(ValueFactory vf, Model model) {\n+\t\tModel rdfStarModel = new LinkedHashModel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY5MTg2OnYy", "diffSide": "RIGHT", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0NToxN1rOF5qtRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQyMzoyOTo0MFrOF5zpUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ==", "bodyText": "Does this risk bnode identifiers being really long of the Triple contains a long literal?", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012869", "createdAt": "2020-03-21T17:45:17Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -26,6 +31,16 @@\n  */\n public class Statements {\n \n+\t/**\n+\t * A {@link Function} that maps {@link Triple} to {@link org.eclipse.rdf4j.model.BNode} consistently. Multiple\n+\t * invocations for the same {@link Triple} will return the same {@link org.eclipse.rdf4j.model.BNode}.\n+\t *\n+\t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n+\t * of the {@link Triple} using base64 URL-safe encoding.\n+\t */\n+\tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n+\t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MTQwNg==", "bodyText": "I don't see that as a major issue, but if it becomes a problem we could switch to using a fixed-length message digest hash (MD5) as an alternative. I'd suggest it's YAGNI for now though.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396041406", "createdAt": "2020-03-22T00:18:53Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -26,6 +31,16 @@\n  */\n public class Statements {\n \n+\t/**\n+\t * A {@link Function} that maps {@link Triple} to {@link org.eclipse.rdf4j.model.BNode} consistently. Multiple\n+\t * invocations for the same {@link Triple} will return the same {@link org.eclipse.rdf4j.model.BNode}.\n+\t *\n+\t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n+\t * of the {@link Triple} using base64 URL-safe encoding.\n+\t */\n+\tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n+\t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3NDcxNA==", "bodyText": "Would collisions be an issue then?", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396074714", "createdAt": "2020-03-22T09:56:48Z", "author": {"login": "hmottestad"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -26,6 +31,16 @@\n  */\n public class Statements {\n \n+\t/**\n+\t * A {@link Function} that maps {@link Triple} to {@link org.eclipse.rdf4j.model.BNode} consistently. Multiple\n+\t * invocations for the same {@link Triple} will return the same {@link org.eclipse.rdf4j.model.BNode}.\n+\t *\n+\t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n+\t * of the {@link Triple} using base64 URL-safe encoding.\n+\t */\n+\tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n+\t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTMxMw==", "bodyText": "IIRC collision risk of MD5 is 1:2^128. For our purposes safe enough I'd say.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396159313", "createdAt": "2020-03-22T23:29:40Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -26,6 +31,16 @@\n  */\n public class Statements {\n \n+\t/**\n+\t * A {@link Function} that maps {@link Triple} to {@link org.eclipse.rdf4j.model.BNode} consistently. Multiple\n+\t * invocations for the same {@link Triple} will return the same {@link org.eclipse.rdf4j.model.BNode}.\n+\t *\n+\t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n+\t * of the {@link Triple} using base64 URL-safe encoding.\n+\t */\n+\tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n+\t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY5NDY1OnYy", "diffSide": "RIGHT", "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/ModelsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0ODoxMlrOF5qung==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwMDoxODoyM1rOF5scnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzIxNA==", "bodyText": "I believe you can use .equals on models and it uses isomorphic underneath.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013214", "createdAt": "2020-03-21T17:48:12Z", "author": {"login": "hmottestad"}, "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/ModelsTest.java", "diffHunk": "@@ -445,4 +446,77 @@ public void testStripContextsSpecificContext() {\n \t\tassertThat(graph2Stripped.size()).isEqualTo(model1.size());\n \t}\n \n+\t@Test\n+\tpublic void testConvertReificationToRDFStar() {\n+\t\tModel reificationModel = RDFStarTestHelper.createRDFReificationModel();\n+\t\tModel referenceRDFStarModel = RDFStarTestHelper.createRDFStarModel();\n+\n+\t\tModel rdfStarModel1 = Models.convertReificationToRDFStar(VF, reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel1, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel2 = Models.convertReificationToRDFStar(reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel2, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel3 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(VF, reificationModel, rdfStarModel3::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel3, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel4 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(reificationModel, rdfStarModel4::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel4, referenceRDFStarModel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MTM3NQ==", "bodyText": "I believe you can use .equals on models and it uses isomorphic underneath.\n\nIt does but I've just checked and we don't actually specify this in the API, as far as I can tell. So I'll leave this explicit for now.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396041375", "createdAt": "2020-03-22T00:18:23Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/ModelsTest.java", "diffHunk": "@@ -445,4 +446,77 @@ public void testStripContextsSpecificContext() {\n \t\tassertThat(graph2Stripped.size()).isEqualTo(model1.size());\n \t}\n \n+\t@Test\n+\tpublic void testConvertReificationToRDFStar() {\n+\t\tModel reificationModel = RDFStarTestHelper.createRDFReificationModel();\n+\t\tModel referenceRDFStarModel = RDFStarTestHelper.createRDFStarModel();\n+\n+\t\tModel rdfStarModel1 = Models.convertReificationToRDFStar(VF, reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel1, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel2 = Models.convertReificationToRDFStar(reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel2, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel3 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(VF, reificationModel, rdfStarModel3::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel3, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel4 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(reificationModel, rdfStarModel4::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel4, referenceRDFStarModel));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzIxNA=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY5NTM1OnYy", "diffSide": "RIGHT", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0OTo0M1rOF5qvDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo0OTo0M1rOF5qvDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzMyNw==", "bodyText": "{ } is missing", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013327", "createdAt": "2020-03-21T17:49:43Z", "author": {"login": "hmottestad"}, "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+package org.eclipse.rdf4j.query.algebra.evaluation.function.triple;\n+\n+import org.eclipse.rdf4j.model.Triple;\n+import org.eclipse.rdf4j.model.Value;\n+import org.eclipse.rdf4j.model.ValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.query.algebra.evaluation.ValueExprEvaluationException;\n+import org.eclipse.rdf4j.query.algebra.evaluation.function.Function;\n+\n+/**\n+ * Function that return \"true\"^^xsd:boolean if its argument is RDF* Triple otherwise return \"false\"^^xsd:boolean the\n+ * function's IRI uses RDF namespace to match the other functions in the package\n+ * \n+ * @author damyan.ognyanov\n+ *\n+ */\n+public class IsTripleFunction implements Function {\n+\t@Override\n+\tpublic String getURI() {\n+\t\treturn RDF.NAMESPACE + \"isTriple\";\n+\t}\n+\n+\t@Override\n+\tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n+\t\tif (args.length != 1)\n+\t\t\tthrow new ValueExprEvaluationException(\"expect exactly 1 argument\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY5NTUzOnYy", "diffSide": "RIGHT", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo1MDowNVrOF5qvMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo1MDowNVrOF5qvMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzM2MQ==", "bodyText": "{ }  is missing", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013361", "createdAt": "2020-03-21T17:50:05Z", "author": {"login": "hmottestad"}, "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+package org.eclipse.rdf4j.query.algebra.evaluation.function.triple;\n+\n+import org.eclipse.rdf4j.model.IRI;\n+import org.eclipse.rdf4j.model.Resource;\n+import org.eclipse.rdf4j.model.Value;\n+import org.eclipse.rdf4j.model.ValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.query.algebra.evaluation.ValueExprEvaluationException;\n+import org.eclipse.rdf4j.query.algebra.evaluation.function.Function;\n+\n+/**\n+ * Function constructing RDF* Triple from its 3 arguments reused the IRI of rdf:Statement as name\n+ * \n+ * @author damyan.ognyanov\n+ *\n+ */\n+public class StatementFunction implements Function {\n+\t@Override\n+\tpublic String getURI() {\n+\t\treturn RDF.STATEMENT.toString();\n+\t}\n+\n+\t@Override\n+\tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n+\t\tif (args.length != 3)\n+\t\t\tthrow new ValueExprEvaluationException(\"expect exactly 3 arguments\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDY5NjQxOnYy", "diffSide": "RIGHT", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/util/ValueComparator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNzo1MToxNFrOF5qvsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwNjoyOTo0M1rOF54OZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ==", "bodyText": "@jeenbroekstra why do we have two ValueComapartors?", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013491", "createdAt": "2020-03-21T17:51:14Z", "author": {"login": "hmottestad"}, "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/util/ValueComparator.java", "diffHunk": "@@ -69,8 +70,21 @@ public int compare(Value o1, Value o2) {\n \t\t\treturn 1;\n \t\t}\n \n-\t\t// 4. RDF literals\n-\t\treturn compareLiterals((Literal) o1, (Literal) o2);\n+\t\t// 4. Literals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDg2OA==", "bodyText": "@jeenbroekstra why do we have two ValueComapartors?\n\nI'm probably overlooking something. What other one besides this class do you see?", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040868", "createdAt": "2020-03-22T00:08:49Z", "author": {"login": "jeenbroekstra"}, "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/util/ValueComparator.java", "diffHunk": "@@ -69,8 +70,21 @@ public int compare(Value o1, Value o2) {\n \t\t\treturn 1;\n \t\t}\n \n-\t\t// 4. RDF literals\n-\t\treturn compareLiterals((Literal) o1, (Literal) o2);\n+\t\t// 4. Literals", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzNDM0MA==", "bodyText": "Never mind, my fault. I had mistaken the LexicalValueComparator for being SPARQL compliant.", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396234340", "createdAt": "2020-03-23T06:29:43Z", "author": {"login": "hmottestad"}, "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/util/ValueComparator.java", "diffHunk": "@@ -69,8 +70,21 @@ public int compare(Value o1, Value o2) {\n \t\t\treturn 1;\n \t\t}\n \n-\t\t// 4. RDF literals\n-\t\treturn compareLiterals((Literal) o1, (Literal) o2);\n+\t\t// 4. Literals", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ=="}, "originalCommit": {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1651, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}