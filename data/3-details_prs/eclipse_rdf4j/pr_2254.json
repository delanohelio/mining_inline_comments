{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNDI4MTc5", "number": 2254, "title": "GH-405 add alt bag seq utility functions", "bodyText": "GitHub issue resolved: #405\n\nWe have referred RDFCollections.java to implement the consumeContainer() (analogous to consumeCollection()) in the newly created RDFContainers.java, and same for asRDF() method. We are taking the type of collection from the input, and are checking that it should only be one out of RDF.ALT, RDF.BAG and RDF.SEQ.\nIn the last consumeContainer() method, we have iterated over the supplied values iterable, and added 2 types of predicates for every element:\n\nvalue rdfs:member container\ncontainer rdf:_nnn value\n\nIn the above example, container is the actual Resource representing the container in RDF.", "createdAt": "2020-05-21T15:40:48Z", "url": "https://github.com/eclipse/rdf4j/pull/2254", "merged": true, "mergeCommit": {"oid": "008e215989d2124e56d37b9f3a90e0d51574d4c1"}, "closed": true, "closedAt": "2020-05-26T01:40:36Z", "author": {"login": "reeshabhranjan"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdF6tKAH2gAyNDIxNDI4MTc5OjQxZTY5NGJmM2Y4ODM0MWRhMTU1NDU0NWMzZmM4YWMwZDA2MWE3NWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABck6gcMgFqTQxNzkyMjA0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "41e694bf3f88341da1554545c3fc8ac0d061a75f", "author": {"user": {"login": "reeshabhranjan", "name": "Reeshabh Kumar Ranjan"}}, "url": "https://github.com/eclipse/rdf4j/commit/41e694bf3f88341da1554545c3fc8ac0d061a75f", "committedDate": "2020-05-01T18:23:32Z", "message": "#405 Add file for the new feature\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5c0febd20e54349d0976ec422946b242987ec5", "author": {"user": {"login": "reeshabhranjan", "name": "Reeshabh Kumar Ranjan"}}, "url": "https://github.com/eclipse/rdf4j/commit/ea5c0febd20e54349d0976ec422946b242987ec5", "committedDate": "2020-05-21T14:10:50Z", "message": "Merge branch 'master' of https://github.com/eclipse/rdf4j into GH-405-add-alt-bag-seq"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "author": {"user": {"login": "reeshabhranjan", "name": "Reeshabh Kumar Ranjan"}}, "url": "https://github.com/eclipse/rdf4j/commit/51793a2136fc54ea8fb32a5e656bed794b9cf653", "committedDate": "2020-05-21T15:18:09Z", "message": "#405 Add code for consumeCollection for RDFContainers\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTY5MTQ2", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-416569146", "createdAt": "2020-05-22T00:03:45Z", "commit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDowMzo0NVrOGZGrag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoxMDozNVrOGZGyTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzAwMg==", "bodyText": "I'd do a check with an exception thrown here, rather than an assertion.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428977002", "createdAt": "2020-05-22T00:03:45Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tassert validType: \"containerType should be one of ALT, BAG or SEQ\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzQ1Mg==", "bodyText": "Our formatting guidelines don't allow wildcard imports. Have a look at https://github.com/eclipse/rdf4j/blob/master/.github/CONTRIBUTING.md#code-formatting for some tips on how set up your environment and/or run a few quick maven commands to fix your formatting.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428977452", "createdAt": "2020-05-22T00:05:41Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODc2NQ==", "bodyText": "Isn't this duplicating information? having :foo rdf:_1 :bar already implies that :foo rdfs:member :bar. I don't think you need to insert the rdfs:member property explicitly. Or do you have a specific use case in mind?", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428978765", "createdAt": "2020-05-22T00:10:35Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tassert validType: \"containerType should be one of ALT, BAG or SEQ\";\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTczMjUw", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-416573250", "createdAt": "2020-05-22T00:16:57Z", "commit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoxNjo1N1rOGZG46w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoxNjo1N1rOGZG46w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ==", "bodyText": "Perhaps a nice addition would be to also have conversion methods that pick the container type, e.g asAlt, asSeq, and asBag.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428980459", "createdAt": "2020-05-22T00:16:57Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99f47b25bf0cbc90a038e91b9da1171c6b048710", "author": {"user": {"login": "reeshabhranjan", "name": "Reeshabh Kumar Ranjan"}}, "url": "https://github.com/eclipse/rdf4j/commit/99f47b25bf0cbc90a038e91b9da1171c6b048710", "committedDate": "2020-05-22T19:02:10Z", "message": "#405 Replace assertion with throwing a runtime exception, add untested code for consumeValues() method for RDFContainers.java (documentation pending)\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7", "author": {"user": {"login": "reeshabhranjan", "name": "Reeshabh Kumar Ranjan"}}, "url": "https://github.com/eclipse/rdf4j/commit/9369b054be8784eb86496fb3052c0c3e07852fc7", "committedDate": "2020-05-22T20:18:16Z", "message": "#405 Add remaining methods (as present in RDFCollection) (documentation pending)\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d768b869e2064b602d8d68377eaf65d9dca6a354", "author": {"user": {"login": "prince17080", "name": "Prince Sachdeva"}}, "url": "https://github.com/eclipse/rdf4j/commit/d768b869e2064b602d8d68377eaf65d9dca6a354", "committedDate": "2020-05-23T13:03:36Z", "message": "#405 Add documentation\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf47ea4c78be83fcd8d89e441362db7dbece69d7", "author": {"user": {"login": "prince17080", "name": "Prince Sachdeva"}}, "url": "https://github.com/eclipse/rdf4j/commit/bf47ea4c78be83fcd8d89e441362db7dbece69d7", "committedDate": "2020-05-23T13:13:02Z", "message": "#405 Format the file\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02", "author": {"user": {"login": "prince17080", "name": "Prince Sachdeva"}}, "url": "https://github.com/eclipse/rdf4j/commit/079ef6278d1efa0788583fa5d4fc3e692b169a02", "committedDate": "2020-05-23T16:03:54Z", "message": "#405 Correct the RDFS.Member triple in consumeContainer method\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzE2NjA0", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-417316604", "createdAt": "2020-05-23T23:54:11Z", "commit": {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzo1NDoxMVrOGZr6Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzo1NzoxMFrOGZr6sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Njk5OQ==", "bodyText": "I think that should be '3.3.0'.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429586999", "createdAt": "2020-05-23T23:54:11Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tResource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param vf            the {@link ValueFactory} to be used for creation of RDF model objects. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts an RDF Containter to a Java {@link Collection} of {@link Value} objects. The RDF Containter is given by\n+\t * the supplied {@link Model} and {@code container}. This method expects the RDF Containter to be well-formed. If\n+\t * the collection is not well-formed the method may return part of the collection, or may throw a\n+\t * {@link ModelException}.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param m             the Model containing the collection to read.\n+\t * @param container     the {@link Resource} that represents the container head, that is the start resource of the\n+\t *                      RDF Container to be read. May not be {@code null}.\n+\t * @param collection    the Java {@link Collection} to add the collection items to.\n+\t * @param contexts      the context(s) from which to read the RDF Containter. This argument is an optional vararg\n+\t *                      and can be left out.\n+\t * @return the supplied Java {@link Collection}, filled with the items from the RDF Containter (if any).\n+\t * @throws ModelException if a problem occurs reading the RDF Containter, for example if the Collection is not\n+\t *                        well-formed.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container,\n+\t\t\tC collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Containter. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Containter. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Container. The\n+\t * statements making up the new RDF Container will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Container. May not be {@code null}. The method attempts to convert each value that\n+\t *                      is not already an instance of {@link Value} to a {@link Literal}. This conversion will fail\n+\t *                      with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Container. May not be\n+\t *                      {@code null}.\n+\t * @param vf            the {@link ValueFactory} to use for creation of new model objects. May not be {@code null}\n+\t * @param contexts      the context(s) in which to add the RDF Container. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t *\n+\t * @since 3.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NzA0Mw==", "bodyText": "I think this should be a ModelException, rather than a generic RuntimeException.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429587043", "createdAt": "2020-05-23T23:55:03Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tResource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param vf            the {@link ValueFactory} to be used for creation of RDF model objects. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts an RDF Containter to a Java {@link Collection} of {@link Value} objects. The RDF Containter is given by\n+\t * the supplied {@link Model} and {@code container}. This method expects the RDF Containter to be well-formed. If\n+\t * the collection is not well-formed the method may return part of the collection, or may throw a\n+\t * {@link ModelException}.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param m             the Model containing the collection to read.\n+\t * @param container     the {@link Resource} that represents the container head, that is the start resource of the\n+\t *                      RDF Container to be read. May not be {@code null}.\n+\t * @param collection    the Java {@link Collection} to add the collection items to.\n+\t * @param contexts      the context(s) from which to read the RDF Containter. This argument is an optional vararg\n+\t *                      and can be left out.\n+\t * @return the supplied Java {@link Collection}, filled with the items from the RDF Containter (if any).\n+\t * @throws ModelException if a problem occurs reading the RDF Containter, for example if the Collection is not\n+\t *                        well-formed.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container,\n+\t\t\tC collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Containter. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Containter. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Container. The\n+\t * statements making up the new RDF Container will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Container. May not be {@code null}. The method attempts to convert each value that\n+\t *                      is not already an instance of {@link Value} to a {@link Literal}. This conversion will fail\n+\t *                      with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Container. May not be\n+\t *                      {@code null}.\n+\t * @param vf            the {@link ValueFactory} to use for creation of new model objects. May not be {@code null}\n+\t * @param contexts      the context(s) in which to add the RDF Container. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t *\n+\t * @since 3.0\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NzEyMQ==", "bodyText": "Like @hmottestad also suggested above, I think renaming this to toRDF (and similarly, also rename asValues to toValues) is better. I realize you followed the naming we used in RDFCollections for this but I think we got this wrong there, and we might as well do it right in this one (we'll fix it in the RDFCollections later as well, but that's a separate issue).", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429587121", "createdAt": "2020-05-23T23:57:10Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjU4MjY1", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-417258265", "createdAt": "2020-05-23T07:29:05Z", "commit": {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwNzoyOTowNVrOGZoARw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwNzozMTozMlrOGZoA4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzAxNQ==", "bodyText": "Here I am using regex to find properties of type rdf:_nnn and simple .equals() to check for rdfs:member.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523015", "createdAt": "2020-05-23T07:29:05Z", "author": {"login": "reeshabhranjan"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzEwMA==", "bodyText": "I will loop through the statements of the form ?s rdf:_nnn ?o until it exists.", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523100", "createdAt": "2020-05-23T07:30:30Z", "author": {"login": "reeshabhranjan"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C getContainer(IRI containerType, Model sourceModel, Resource head, C sink,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"input model may not be null\");\n+\t\textract(containerType, sourceModel, head, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static void extract(IRI containerType, Model sourceModel, Resource container, Consumer<Statement> consumer, Resource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"source model may not be null\");\n+\t\tGetStatementOptional statementSupplier = (s, p, o,\n+\t\t\t\tc) -> ((Model) sourceModel).filter(s, p, o, c).stream().findAny();\n+\t\textract(containerType, statementSupplier, container, consumer, Models::modelException, contexts);\n+\t}\n+\n+\tpublic static <E extends RDF4JException> void extract(IRI containerType, GetStatementOptional statementSupplier, Resource container,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Consumer<Statement> collectionConsumer, Function<String, Supplier<E>> exceptionSupplier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Resource... contexts) throws E {\n+\t\tOpenRDFUtil.verifyContextNotNull(contexts);\n+\t\tObjects.requireNonNull(container, \"list head may not be null\");\n+\t\tObjects.requireNonNull(collectionConsumer, \"collection consumer may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tResource current = container;\n+\t\tfinal Set<Value> encountered = new HashSet<>();\n+\n+\t\tfor (int annotatedMembershipPropertyCounter = 1; true ; annotatedMembershipPropertyCounter++) {\n+\n+\n+\t\t\tIRI annotatedMembershipPredicate = getAnnotatedMemberPredicate(vf, annotatedMembershipPropertyCounter);\n+\t\t\tif (statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).equals(Optional.empty())) {\n+\t\t\t\tbreak;\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzE2OA==", "bodyText": "Only for rdf:Alt, I have added this check to make sure that distinct elements are passed. Instead of throwing the exception, should I just skip adding the duplicate elements?", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523168", "createdAt": "2020-05-23T07:31:32Z", "author": {"login": "reeshabhranjan"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C getContainer(IRI containerType, Model sourceModel, Resource head, C sink,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"input model may not be null\");\n+\t\textract(containerType, sourceModel, head, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static void extract(IRI containerType, Model sourceModel, Resource container, Consumer<Statement> consumer, Resource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"source model may not be null\");\n+\t\tGetStatementOptional statementSupplier = (s, p, o,\n+\t\t\t\tc) -> ((Model) sourceModel).filter(s, p, o, c).stream().findAny();\n+\t\textract(containerType, statementSupplier, container, consumer, Models::modelException, contexts);\n+\t}\n+\n+\tpublic static <E extends RDF4JException> void extract(IRI containerType, GetStatementOptional statementSupplier, Resource container,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Consumer<Statement> collectionConsumer, Function<String, Supplier<E>> exceptionSupplier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Resource... contexts) throws E {\n+\t\tOpenRDFUtil.verifyContextNotNull(contexts);\n+\t\tObjects.requireNonNull(container, \"list head may not be null\");\n+\t\tObjects.requireNonNull(collectionConsumer, \"collection consumer may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tResource current = container;\n+\t\tfinal Set<Value> encountered = new HashSet<>();\n+\n+\t\tfor (int annotatedMembershipPropertyCounter = 1; true ; annotatedMembershipPropertyCounter++) {\n+\n+\n+\t\t\tIRI annotatedMembershipPredicate = getAnnotatedMemberPredicate(vf, annotatedMembershipPropertyCounter);\n+\t\t\tif (statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).equals(Optional.empty())) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tStatement statement = statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).get();\n+\n+\t\t\tif (containerType.equals(RDF.ALT)) {\n+\t\t\t\tif (encountered.contains(statement.getObject())) {\n+\t\t\t\t\tthrow exceptionSupplier.apply(\"rdf:alt cannot contain duplicate values\").get();\n+\t\t\t\t}\n+\t\t\t\tencountered.add(statement.getObject());\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1d35468e3aac921a248978c79aeb5fcb1096b3b", "author": {"user": {"login": "prince17080", "name": "Prince Sachdeva"}}, "url": "https://github.com/eclipse/rdf4j/commit/d1d35468e3aac921a248978c79aeb5fcb1096b3b", "committedDate": "2020-05-24T09:54:07Z", "message": "#405 Change 'as' to 'to', Change version 3.0 to 3.3.0, Run mvn impsort:sort\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NDE0ODc3", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-417414877", "createdAt": "2020-05-25T01:21:11Z", "commit": {"oid": "d1d35468e3aac921a248978c79aeb5fcb1096b3b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f5c8a1345e2e8662ae41102e1bda5c8aee2ecd9", "author": {"user": {"login": "guvi007", "name": "Gaurav Aggarwal"}}, "url": "https://github.com/eclipse/rdf4j/commit/7f5c8a1345e2e8662ae41102e1bda5c8aee2ecd9", "committedDate": "2020-05-25T17:27:31Z", "message": "#405 Add tests for RDF Containers in RDFContainersTest.java, Remove distinct element check for rdf:alt in RDFContainers.java\n\nSigned-off-by: Gaurav Aggarwal <gaurav17288@iiitd.ac.in>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3OTIyMDQ4", "url": "https://github.com/eclipse/rdf4j/pull/2254#pullrequestreview-417922048", "createdAt": "2020-05-26T01:37:17Z", "commit": {"oid": "7f5c8a1345e2e8662ae41102e1bda5c8aee2ecd9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 164, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}