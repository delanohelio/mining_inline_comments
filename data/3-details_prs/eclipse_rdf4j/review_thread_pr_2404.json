{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjM5ODQ2", "number": 2404, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTowMzo1N1rOETewzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTowMzo1N1rOETewzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODYyNDEyOnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTowMzo1N1rOG5PYqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMzo0MFrOG5bjPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NDA4OA==", "bodyText": "Shouldn't you check if the subject is a blank node before adding it?", "url": "https://github.com/eclipse/rdf4j/pull/2404#discussion_r462674088", "createdAt": "2020-07-30T01:03:57Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -293,58 +299,74 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = stmtBySubject.get(key);\n+\t\tSet<Statement> stmts = statementBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\t\t\tStatement st;\n \n \t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<Statement>();\n+\t\t\tArrayList<Statement> statements = new ArrayList<>();\n \n \t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurence = new HashMap<BNode, Integer>();\n+\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n \n+\t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n \t\t\t\tstatements.add(st);\n+\n \t\t\t\tValue obj = st.getObject();\n \n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurence\n+\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n \t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tBNode bNode = (BNode) obj;\n-\t\t\t\t\tif (!bNodeOccurence.containsKey(bNode)) {\n-\t\t\t\t\t\tbNodeOccurence.put(bNode, 0);\n+\t\t\t\t\tbNodeOccurrences.compute(\n+\t\t\t\t\t\t\t(BNode) obj,\n+\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n+\t\t\t\t\t\tnoneInlinedNodes.add(st.getSubject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c48787f21aa64041cd04d4a9c7b95ff8860c57b5"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczMTM1MA==", "bodyText": "I've tweaked this locally and it seems to solve the inlining issue where you had to adjust the test case, without compromising on your own new test case. I'll push a change.", "url": "https://github.com/eclipse/rdf4j/pull/2404#discussion_r462731350", "createdAt": "2020-07-30T04:44:59Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -293,58 +299,74 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = stmtBySubject.get(key);\n+\t\tSet<Statement> stmts = statementBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\t\t\tStatement st;\n \n \t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<Statement>();\n+\t\t\tArrayList<Statement> statements = new ArrayList<>();\n \n \t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurence = new HashMap<BNode, Integer>();\n+\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n \n+\t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n \t\t\t\tstatements.add(st);\n+\n \t\t\t\tValue obj = st.getObject();\n \n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurence\n+\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n \t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tBNode bNode = (BNode) obj;\n-\t\t\t\t\tif (!bNodeOccurence.containsKey(bNode)) {\n-\t\t\t\t\t\tbNodeOccurence.put(bNode, 0);\n+\t\t\t\t\tbNodeOccurrences.compute(\n+\t\t\t\t\t\t\t(BNode) obj,\n+\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n+\t\t\t\t\t\tnoneInlinedNodes.add(st.getSubject());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NDA4OA=="}, "originalCommit": {"oid": "c48787f21aa64041cd04d4a9c7b95ff8860c57b5"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MzQwNQ==", "bodyText": "Not sure actually. But if it works better now than I'm fine with it.", "url": "https://github.com/eclipse/rdf4j/pull/2404#discussion_r462873405", "createdAt": "2020-07-30T09:33:40Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -293,58 +299,74 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = stmtBySubject.get(key);\n+\t\tSet<Statement> stmts = statementBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\t\t\tStatement st;\n \n \t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<Statement>();\n+\t\t\tArrayList<Statement> statements = new ArrayList<>();\n \n \t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurence = new HashMap<BNode, Integer>();\n+\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n \n+\t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n \t\t\t\tstatements.add(st);\n+\n \t\t\t\tValue obj = st.getObject();\n \n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurence\n+\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n \t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tBNode bNode = (BNode) obj;\n-\t\t\t\t\tif (!bNodeOccurence.containsKey(bNode)) {\n-\t\t\t\t\t\tbNodeOccurence.put(bNode, 0);\n+\t\t\t\t\tbNodeOccurrences.compute(\n+\t\t\t\t\t\t\t(BNode) obj,\n+\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n+\t\t\t\t\t\tnoneInlinedNodes.add(st.getSubject());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NDA4OA=="}, "originalCommit": {"oid": "c48787f21aa64041cd04d4a9c7b95ff8860c57b5"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1457, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}