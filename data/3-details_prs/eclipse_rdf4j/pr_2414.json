{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwODEyNTc0", "number": 2414, "title": "GH-2324 obsolete ArrangedWriter; move node inlining and sorting logic into TurtleWriter", "bodyText": "GitHub issue resolved: #2324 \nBriefly describe the changes proposed in this PR:\n\ndeprecate and disuse ArrangedWriter\nadd internal buffer (a Model) to TurtleWriter, use basic grouping/sorting filtering to output statements in correct order\ndetermine if node can be inlined per node instead of per statement\n\n\nPR Author Checklist (see the contributor guidelines for more details):\n\n my pull request is self-contained\n I've added tests for the changes I made\n I've applied code formatting (you can use mvn process-resources to format from the command line)\n every commit message starts with the issue number (GH-xxxx) followed by a meaningful description of the change\n every commit has been signed off\n\nNote: we merge all feature pull requests using squash and merge. See RDF4J git merge strategy for more details.", "createdAt": "2020-08-01T05:42:44Z", "url": "https://github.com/eclipse/rdf4j/pull/2414", "merged": true, "mergeCommit": {"oid": "08835629d1be154f394722fc5d3c02757867b77d"}, "closed": true, "closedAt": "2020-08-04T00:44:36Z", "author": {"login": "jeenbroekstra"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6iSKZABqjM2MTEyODI3MTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7RXSPAFqTQ1OTk5MjgwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52e678e88ebfe5b84de99b82caa1b72e16d0aa69", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/52e678e88ebfe5b84de99b82caa1b72e16d0aa69", "committedDate": "2020-08-01T05:39:04Z", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly"}, "afterCommit": {"oid": "2ab5debc929f75fd0a9230c36051646bda575bf0", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/2ab5debc929f75fd0a9230c36051646bda575bf0", "committedDate": "2020-08-01T05:50:04Z", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "103f9905e685379438bdbbaee09615ccda3349a5", "author": {"user": {"login": "hmottestad", "name": null}}, "url": "https://github.com/eclipse/rdf4j/commit/103f9905e685379438bdbbaee09615ccda3349a5", "committedDate": "2020-08-01T06:10:06Z", "message": "Revert \"GH-2324 inlining blank nodes (#2404)\"\n\nThis reverts commit d7b51c198c0d07361a7f1899d82b27fe0fc83ae2."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc29b7ed8a6d4fe27e64d2d08f4fda5fcc6cdaad", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/fc29b7ed8a6d4fe27e64d2d08f4fda5fcc6cdaad", "committedDate": "2020-08-01T06:10:06Z", "message": "GH-2324 handle prettyprint/inlining inside TurtleWriter itself [WIP]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa13be5260b2afd96dc923b276967d503d21a1fa", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/fa13be5260b2afd96dc923b276967d503d21a1fa", "committedDate": "2020-08-01T06:10:06Z", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9db569889b526c187abb2d814cf5a87e9578620", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/b9db569889b526c187abb2d814cf5a87e9578620", "committedDate": "2020-08-01T06:04:03Z", "message": "GH-2324 test cleanup"}, "afterCommit": {"oid": "fa13be5260b2afd96dc923b276967d503d21a1fa", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/fa13be5260b2afd96dc923b276967d503d21a1fa", "committedDate": "2020-08-01T06:10:06Z", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c817bbae4be20c144e008c1aee4e76c9e29bf9e", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/6c817bbae4be20c144e008c1aee4e76c9e29bf9e", "committedDate": "2020-08-01T06:20:20Z", "message": "GH-2324 some test debugging output options"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "608f296cff1db08ae5bdc4f3229200417a9ec803", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/608f296cff1db08ae5bdc4f3229200417a9ec803", "committedDate": "2020-08-02T01:48:08Z", "message": "GH-2324 handle blank node subjects in correct order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44b5ab81fac6fffaa06be9e9d1dede308375e77f", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/44b5ab81fac6fffaa06be9e9d1dede308375e77f", "committedDate": "2020-08-02T02:53:55Z", "message": "GH-2324 do not skip subjects if not bnode-inlining"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/0ad7766d767bb39c30be01395fb494f9fd2dedbd", "committedDate": "2020-08-02T03:11:00Z", "message": "GH-2324 clean up TriGWriter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjE4MDI4", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459618028", "createdAt": "2020-08-02T03:54:15Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMzo1NDoxNVrOG6h_4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMzo1NDoxNVrOG6h_4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAyNzYxOA==", "bodyText": "locally change to debug to see results of writing on stdout in several tests. Don't forget to change back before committing to avoid blowing up the build log.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464027618", "createdAt": "2020-08-02T03:54:15Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/api/src/test/resources/logback-test.xml", "diffHunk": "@@ -5,6 +5,9 @@\n \t\t\t<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %msg%n</pattern>\n \t\t</encoder>\n \t</appender>\n+\t<logger name=\"org.eclipse.rdf4j.rio\">\n+\t\t<level value=\"warn\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjE4NDgz", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459618483", "createdAt": "2020-08-02T04:06:17Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNDowNjoxN1rOG6iDJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNDowNjoxN1rOG6iDJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAyODQ1NQ==", "bodyText": "All the changes in this file are just the result of me reverting some earlier attempts to fix the inlining issues. They're not really relevant as the ArrangedWriter class is no longer used and only left in place on the off-chance that some third party uses it (unlikely but you never know).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464028455", "createdAt": "2020-08-02T04:06:17Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -205,29 +203,27 @@ protected synchronized void consumeStatement(Statement st) throws RDFHandlerExce\n \t}\n \n \tprivate synchronized Statement nextStatement() {\n-\n-\t\tif (statementBySubject.isEmpty() && blanks.isEmpty()) {\n+\t\tif (stmtBySubject.isEmpty() && blanks.isEmpty()) {\n \t\t\tassert queueSize == 0;\n \t\t\treturn null;\n \t\t}\n-\t\tSet<Statement> statements = null;\n-\t\twhile (statements == null) {\n+\t\tSet<Statement> stmts = null;\n+\t\twhile (stmts == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjU5MjI3", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459659227", "createdAt": "2020-08-02T15:49:54Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo0OTo1NVrOG6mALw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo0OTo1NVrOG6mALw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzIzMQ==", "bodyText": "This looks like you've reverted quite a lot of history.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093231", "createdAt": "2020-08-02T15:49:55Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -298,105 +294,25 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = statementBySubject.get(key);\n+\t\tSet<Statement> stmts = stmtBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\n-\t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<>();\n-\n-\t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n-\n \t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n-\t\t\t\tstatements.add(st);\n-\n-\t\t\t\tValue obj = st.getObject();\n-\n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n-\t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tbNodeOccurrences.compute(\n-\t\t\t\t\t\t\t(BNode) obj,\n-\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n-\t\t\t\t\t\tif (st.getSubject() instanceof BNode) {\n-\t\t\t\t\t\t\tnonInlinedNodes.add(st.getSubject());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tnonInlinedNodes.add(obj);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tdelegate.handleStatement(st);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjU5MzMz", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459659333", "createdAt": "2020-08-02T15:51:31Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MTozMVrOG6mAyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MTozMVrOG6mAyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM4NQ==", "bodyText": "These should be ArrayDeque, unless we expect them to grow very very large (since expanding the ArrayDeque gets costlier the bigger it is, talking millions of entries).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093385", "createdAt": "2020-08-02T15:51:31Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -70,12 +85,6 @@\n \tprotected Resource lastWrittenSubject;\n \tprotected IRI lastWrittenPredicate;\n \n-\t/**\n-\t * Always null\n-\t */\n-\t@Deprecated\n-\tprotected Model prettyPrintModel;\n-\n \tprivate final Deque<Resource> stack = new LinkedList<>();\n \tprivate final Deque<IRI> path = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjU5Mzky", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459659392", "createdAt": "2020-08-02T15:52:26Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MjoyNlrOG6mBFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MjoyNlrOG6mBFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzQ2Mw==", "bodyText": "You could just make it protected and then others could override this method if they have a better Model implementation they want to use.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093463", "createdAt": "2020-08-02T15:52:26Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -108,6 +117,11 @@ public TurtleWriter(OutputStream out, ParsedIRI baseIRI) {\n \t\tthis.writer = new IndentingWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n \t}\n \n+\t// TODO make injectable\n+\tprivate ModelFactory getModelFactory() {\n+\t\treturn new LinkedHashModelFactory();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjU5NzY3", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459659767", "createdAt": "2020-08-02T15:56:25Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1NjoyNVrOG6mDOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1NjoyNVrOG6mDOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDAxMA==", "bodyText": "Btw. If you use a long for bufferSize you can just set it to be Long.MAX_VALUE and you don't have to deal with -1 as a special case. Dunno if it would help, but it's a decent approach since you would run out of memory way before reaching that limit (minimum 4 611 686  terabytes).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094010", "createdAt": "2020-08-02T15:56:25Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -145,6 +159,12 @@ public void startRDF() throws RDFHandlerException {\n \t\t\txsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);\n \t\t\tprettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);\n \t\t\tinlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);\n+\n+\t\t\tif (isBuffering()) {\n+\t\t\t\tthis.bufferedStatements = getModelFactory().createEmptyModel();\n+\t\t\t\tthis.bufferSize = inlineBNodes ? -1 : DEFAULT_BUFFER_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjU5OTY2", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459659966", "createdAt": "2020-08-02T15:58:49Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1ODo0OVrOG6mEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1ODo0OVrOG6mEPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDI3MQ==", "bodyText": "List handling in the pretty printed turtle code has always been bad. I should make some tests for that to see if you've fixed it now.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094271", "createdAt": "2020-08-02T15:58:49Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -256,57 +276,71 @@ protected void handleStatementInternal(Statement st, boolean endRDFCalled, boole\n \t\tResource subj = st.getSubject();\n \t\tIRI pred = st.getPredicate();\n \t\tValue obj = st.getObject();\n+\n \t\ttry {\n-\t\t\tif (subj.equals(lastWrittenSubject)) {\n-\t\t\t\tif (pred.equals(lastWrittenPredicate)) {\n-\t\t\t\t\t// Identical subject and predicate\n-\t\t\t\t\twriter.write(\",\");\n-\t\t\t\t\twrapLine(prettyPrint);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Identical subject, new predicate\n-\t\t\t\t\twriter.write(\";\");\n-\t\t\t\t\twriter.writeEOL();\n-\n-\t\t\t\t\t// Write new predicate\n-\t\t\t\t\twriter.decreaseIndentation();\n-\t\t\t\t\twritePredicate(pred);\n-\t\t\t\t\twriter.increaseIndentation();\n-\t\t\t\t\twrapLine(true);\n-\t\t\t\t\tpath.removeLast();\n-\t\t\t\t\tpath.addLast(pred);\n-\t\t\t\t\tlastWrittenPredicate = pred;\n-\t\t\t\t}\n+\t\t\tif (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {\n+\t\t\t\thandleList(st);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYwMjMx", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459660231", "createdAt": "2020-08-02T16:03:04Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowMzowNFrOG6mFzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowMzowNFrOG6mFzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDY3MQ==", "bodyText": "Does this now support pretty printing TriG? That would be awesome.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094671", "createdAt": "2020-08-02T16:03:04Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 293}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYwMzEz", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459660313", "createdAt": "2020-08-02T16:04:35Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNDozNVrOG6mGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNDozNVrOG6mGXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDgxMw==", "bodyText": "I wonder if this could be checked in some way. To assert that we're not calling this method from multiple threads.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094813", "createdAt": "2020-08-02T16:04:35Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 277}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYwNDAy", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459660402", "createdAt": "2020-08-02T16:06:07Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNjowN1rOG6mG9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNjowN1rOG6mG9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDk2NQ==", "bodyText": "Nice use of optional!", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094965", "createdAt": "2020-08-02T16:06:07Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 320}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYwODU0", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459660854", "createdAt": "2020-08-02T16:14:20Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNDoyMFrOG6mJ-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNDoyMFrOG6mJ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA==", "bodyText": "Since these pieces of code are so similar I'm wondering if maybe you would prefer to use the java 8 streams grouping collector (https://www.baeldung.com/java-groupingby-collector) and then sort it so that rdf:type gets preference.\nA more performant alternative would be to sort contextData.getStatements(subject, null, null) by the predicate with preference to rdf:type and then grouping could be done by looking at the previous predicate.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095738", "createdAt": "2020-08-02T16:14:20Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 359}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYwOTYz", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459660963", "createdAt": "2020-08-02T16:16:22Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNjoyM1rOG6mKtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNjoyM1rOG6mKtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTkyNQ==", "bodyText": "Maybe this should be canInlineValue to indicate that it checks if inlining is allowed.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095925", "createdAt": "2020-08-02T16:16:23Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 372}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjYxMTIz", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459661123", "createdAt": "2020-08-02T16:18:58Z", "commit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxODo1OFrOG6mLeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxODo1OFrOG6mLeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjEyMA==", "bodyText": "I'm wondering what happened to the buffer size value, shouldn't it be used in some form when deciding if we are buffering or not?", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464096120", "createdAt": "2020-08-02T16:18:58Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean isBuffering() {\n+\t\treturn inlineBNodes || prettyPrint;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 376}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d15e9090fa206dbf228d9f88f93a83169e9397a", "author": {"user": {"login": "jeenbroekstra", "name": "Jeen Broekstra"}}, "url": "https://github.com/eclipse/rdf4j/commit/6d15e9090fa206dbf228d9f88f93a83169e9397a", "committedDate": "2020-08-03T00:41:03Z", "message": "GH-2324 fixes from review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5OTkyODA0", "url": "https://github.com/eclipse/rdf4j/pull/2414#pullrequestreview-459992804", "createdAt": "2020-08-03T12:41:26Z", "commit": {"oid": "6d15e9090fa206dbf228d9f88f93a83169e9397a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 141, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}