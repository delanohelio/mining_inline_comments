{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNDQxMDAz", "number": 1910, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTowMDoyM1rODeMNyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTowMDoyM1rODeMNyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTg0MDExOnYy", "diffSide": "RIGHT", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTowMDoyNFrOFnONsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0Njo0N1rOFnfkKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3MTY2Ng==", "bodyText": "Won't this result in different BNodes for the same triple? For example, when we have sth like this:\n <<ex:s1 ex:p1 ex:o1>> rdfs:label \"statement 1\"; \n                       rdfs:comment \"it's a statement!\" .", "url": "https://github.com/eclipse/rdf4j/pull/1910#discussion_r376671666", "createdAt": "2020-02-08T01:00:24Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -121,4 +124,92 @@ public static boolean isSameTriple(Statement st1, Statement st2) {\n \t\treturn st1.getPredicate().equals(st2.getPredicate()) && st1.getSubject().equals(st2.getSubject())\n \t\t\t\t&& st1.getObject().equals(st2.getObject());\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* statement to RDF reification statements, and sends the resultant statements to the\n+\t * supplied consumer. If the supplied statement is not RDF* it will be sent to the consumer as is.\n+\t * <p>\n+\t * The statements needed to represent reification will use blank nodes.\n+\t *\n+\t * @param st       the {@link Statement} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Statement st, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), st, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* statement to RDF reification statements, and sends the resultant statements to the\n+\t * supplied consumer. If the supplied statement is not RDF* it will be sent to the consumer as is.\n+\t * <p>\n+\t * The statements needed to represent reification will use blank nodes.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements and blank nodes.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param st       the {@link Statement} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Statement st, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(vf, (t) -> vf.createBNode(), st, consumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84afe7743cda3f37dffa2d4a8b0beb76764977a6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTk0Ng==", "bodyText": "You are right. As I started from Statement I didn't really consider this in the context of e.g. Model. Even though the converted data will be OK (you can reach the subject/predicate/object of the rdf:Statement) I agree it would be best to have a consistent mapping for identical triples. I just committed a fix that uses the triple's stringValue() + base64 encoding to derive the BNode ID. It uses SimpleValueFactory (before it used the passed value factory) to ensure that you get the ID you want. I also extended the tests to cover this case.", "url": "https://github.com/eclipse/rdf4j/pull/1910#discussion_r376955946", "createdAt": "2020-02-10T09:46:47Z", "author": {"login": "avataar"}, "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -121,4 +124,92 @@ public static boolean isSameTriple(Statement st1, Statement st2) {\n \t\treturn st1.getPredicate().equals(st2.getPredicate()) && st1.getSubject().equals(st2.getSubject())\n \t\t\t\t&& st1.getObject().equals(st2.getObject());\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* statement to RDF reification statements, and sends the resultant statements to the\n+\t * supplied consumer. If the supplied statement is not RDF* it will be sent to the consumer as is.\n+\t * <p>\n+\t * The statements needed to represent reification will use blank nodes.\n+\t *\n+\t * @param st       the {@link Statement} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Statement st, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), st, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* statement to RDF reification statements, and sends the resultant statements to the\n+\t * supplied consumer. If the supplied statement is not RDF* it will be sent to the consumer as is.\n+\t * <p>\n+\t * The statements needed to represent reification will use blank nodes.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements and blank nodes.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param st       the {@link Statement} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Statement st, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(vf, (t) -> vf.createBNode(), st, consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3MTY2Ng=="}, "originalCommit": {"oid": "84afe7743cda3f37dffa2d4a8b0beb76764977a6"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1648, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}