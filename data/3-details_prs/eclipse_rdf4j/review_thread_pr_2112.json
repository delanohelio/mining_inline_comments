{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MDA0MDI5", "number": 2112, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNzoxNFrOD0lepw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozODo0MlrOD0lgtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDY2NTk5OnYy", "diffSide": "RIGHT", "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNzoxNFrOGJlvtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNzoxNFrOGJlvtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwODc4OA==", "bodyText": "Should probably synchronise this too.", "url": "https://github.com/eclipse/rdf4j/pull/2112#discussion_r412708788", "createdAt": "2020-04-22T06:37:14Z", "author": {"login": "hmottestad"}, "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "diffHunk": "@@ -105,52 +132,111 @@ public final File getFile() {\n \n \t/**\n \t * Gets the largest ID that is stored in this ID file.\n-\t * \n+\t *\n \t * @return The largest ID, or <tt>0</tt> if the file does not contain any data.\n \t * @throws IOException If an I/O error occurs.\n \t */\n \tpublic int getMaxID() throws IOException {\n-\t\treturn (int) (nioFile.size() / ITEM_SIZE) - 1;\n+\t\treturn (int) (nioFileSize / ITEM_SIZE) - 1;\n \t}\n \n \t/**\n \t * Stores the offset of a new data entry, returning the ID under which is stored.\n \t */\n \tpublic int storeOffset(long offset) throws IOException {\n-\t\tlong fileSize = nioFile.size();\n+\t\tlong fileSize = nioFileSize;\n \t\tnioFile.writeLong(offset, fileSize);\n+\t\tnioFileSize += ITEM_SIZE;\n \t\treturn (int) (fileSize / ITEM_SIZE);\n \t}\n \n \t/**\n \t * Sets or updates the stored offset for the specified ID.\n-\t * \n+\t *\n \t * @param id     The ID to set the offset for, must be larger than 0.\n \t * @param offset The (new) offset for the specified ID.\n \t */\n \tpublic void setOffset(int id, long offset) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n \t\tnioFile.writeLong(offset, ITEM_SIZE * id);\n+\n+\t\t// We need to update the cache after writing to file (not before) so that if anyone refreshes the cache it will\n+\t\t// include the write above.\n+\t\t// The scenario is as follows:\n+\t\t// 1. there is nothing in the cache, everything is fine\n+\t\t// 2. the relevant cache line is from before the writeLong operation above, in which case we update it\n+\t\t// 3. the relevant cache line is from right after the write in which case updating it doesnt matter\n+\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\tcacheLine[cacheLineLookupIndex] = offset;\n+\t\t}\n+\n \t}\n \n \t/**\n \t * Gets the offset of the data entry with the specified ID.\n-\t * \n+\t *\n \t * @param id The ID to get the offset for, must be larger than 0.\n \t * @return The offset for the ID.\n \t */\n \tpublic long getOffset(int id) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n+\t\t// the index used to lookup the cache line\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\n+\t\t// the index used to lookup the actual value inside the cache line\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\t// the cache line which is of size cacheLineSize\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\treturn cacheLine[cacheLineLookupIndex];\n+\t\t}\n+\n+\t\t// We only cache complete lines og size cacheLineSize. This means that the last line in the file will almost\n+\t\t// never be cached. This simplifies the code since we don't have to deal with partial lines.\n+\t\tif (getMaxID() > cacheLineSize && id < getMaxID() - cacheLineSize) {\n+\n+\t\t\t// doing one big read is considerably faster than doing a single read per id\n+\t\t\tbyte[] bytes = nioFile.readBytes(ITEM_SIZE * (cacheLookupIndex << cacheLineShift),\n+\t\t\t\t\t(int) (ITEM_SIZE * cacheLineSize));\n+\n+\t\t\tcacheLine = convertBytesToLongs(bytes);\n+\n+\t\t\tsynchronized (this) {\n+\t\t\t\t// we try not to overwrite an existing cache line\n+\t\t\t\tif (!cache.containsKey(cacheLineLookupIndex)) {\n+\t\t\t\t\tcache.put(cacheLookupIndex, cacheLine);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tgcReducingCache = cacheLine;\n+\t\t\tgcReducingCacheIndex = cacheLookupIndex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dce0457a6e964ff5e5ae78405e6762e20618621"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDY2ODAxOnYy", "diffSide": "RIGHT", "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNzo0NlrOGJlwyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNzo0NlrOGJlwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwOTA2NA==", "bodyText": "Typo og=of", "url": "https://github.com/eclipse/rdf4j/pull/2112#discussion_r412709064", "createdAt": "2020-04-22T06:37:46Z", "author": {"login": "hmottestad"}, "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "diffHunk": "@@ -105,52 +132,111 @@ public final File getFile() {\n \n \t/**\n \t * Gets the largest ID that is stored in this ID file.\n-\t * \n+\t *\n \t * @return The largest ID, or <tt>0</tt> if the file does not contain any data.\n \t * @throws IOException If an I/O error occurs.\n \t */\n \tpublic int getMaxID() throws IOException {\n-\t\treturn (int) (nioFile.size() / ITEM_SIZE) - 1;\n+\t\treturn (int) (nioFileSize / ITEM_SIZE) - 1;\n \t}\n \n \t/**\n \t * Stores the offset of a new data entry, returning the ID under which is stored.\n \t */\n \tpublic int storeOffset(long offset) throws IOException {\n-\t\tlong fileSize = nioFile.size();\n+\t\tlong fileSize = nioFileSize;\n \t\tnioFile.writeLong(offset, fileSize);\n+\t\tnioFileSize += ITEM_SIZE;\n \t\treturn (int) (fileSize / ITEM_SIZE);\n \t}\n \n \t/**\n \t * Sets or updates the stored offset for the specified ID.\n-\t * \n+\t *\n \t * @param id     The ID to set the offset for, must be larger than 0.\n \t * @param offset The (new) offset for the specified ID.\n \t */\n \tpublic void setOffset(int id, long offset) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n \t\tnioFile.writeLong(offset, ITEM_SIZE * id);\n+\n+\t\t// We need to update the cache after writing to file (not before) so that if anyone refreshes the cache it will\n+\t\t// include the write above.\n+\t\t// The scenario is as follows:\n+\t\t// 1. there is nothing in the cache, everything is fine\n+\t\t// 2. the relevant cache line is from before the writeLong operation above, in which case we update it\n+\t\t// 3. the relevant cache line is from right after the write in which case updating it doesnt matter\n+\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\tcacheLine[cacheLineLookupIndex] = offset;\n+\t\t}\n+\n \t}\n \n \t/**\n \t * Gets the offset of the data entry with the specified ID.\n-\t * \n+\t *\n \t * @param id The ID to get the offset for, must be larger than 0.\n \t * @return The offset for the ID.\n \t */\n \tpublic long getOffset(int id) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n+\t\t// the index used to lookup the cache line\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\n+\t\t// the index used to lookup the actual value inside the cache line\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\t// the cache line which is of size cacheLineSize\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\treturn cacheLine[cacheLineLookupIndex];\n+\t\t}\n+\n+\t\t// We only cache complete lines og size cacheLineSize. This means that the last line in the file will almost", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dce0457a6e964ff5e5ae78405e6762e20618621"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDY3MTI0OnYy", "diffSide": "RIGHT", "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozODo0MlrOGJlypA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozODo0MlrOGJlypA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwOTU0MA==", "bodyText": "Clear Cache!", "url": "https://github.com/eclipse/rdf4j/pull/2112#discussion_r412709540", "createdAt": "2020-04-22T06:38:42Z", "author": {"login": "hmottestad"}, "path": "core/sail/nativerdf/src/main/java/org/eclipse/rdf4j/sail/nativerdf/datastore/IDFile.java", "diffHunk": "@@ -105,52 +132,111 @@ public final File getFile() {\n \n \t/**\n \t * Gets the largest ID that is stored in this ID file.\n-\t * \n+\t *\n \t * @return The largest ID, or <tt>0</tt> if the file does not contain any data.\n \t * @throws IOException If an I/O error occurs.\n \t */\n \tpublic int getMaxID() throws IOException {\n-\t\treturn (int) (nioFile.size() / ITEM_SIZE) - 1;\n+\t\treturn (int) (nioFileSize / ITEM_SIZE) - 1;\n \t}\n \n \t/**\n \t * Stores the offset of a new data entry, returning the ID under which is stored.\n \t */\n \tpublic int storeOffset(long offset) throws IOException {\n-\t\tlong fileSize = nioFile.size();\n+\t\tlong fileSize = nioFileSize;\n \t\tnioFile.writeLong(offset, fileSize);\n+\t\tnioFileSize += ITEM_SIZE;\n \t\treturn (int) (fileSize / ITEM_SIZE);\n \t}\n \n \t/**\n \t * Sets or updates the stored offset for the specified ID.\n-\t * \n+\t *\n \t * @param id     The ID to set the offset for, must be larger than 0.\n \t * @param offset The (new) offset for the specified ID.\n \t */\n \tpublic void setOffset(int id, long offset) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n \t\tnioFile.writeLong(offset, ITEM_SIZE * id);\n+\n+\t\t// We need to update the cache after writing to file (not before) so that if anyone refreshes the cache it will\n+\t\t// include the write above.\n+\t\t// The scenario is as follows:\n+\t\t// 1. there is nothing in the cache, everything is fine\n+\t\t// 2. the relevant cache line is from before the writeLong operation above, in which case we update it\n+\t\t// 3. the relevant cache line is from right after the write in which case updating it doesnt matter\n+\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\tcacheLine[cacheLineLookupIndex] = offset;\n+\t\t}\n+\n \t}\n \n \t/**\n \t * Gets the offset of the data entry with the specified ID.\n-\t * \n+\t *\n \t * @param id The ID to get the offset for, must be larger than 0.\n \t * @return The offset for the ID.\n \t */\n \tpublic long getOffset(int id) throws IOException {\n \t\tassert id > 0 : \"id must be larger than 0, is: \" + id;\n+\n+\t\t// the index used to lookup the cache line\n+\t\tint cacheLookupIndex = id >> cacheLineShift;\n+\n+\t\t// the index used to lookup the actual value inside the cache line\n+\t\tint cacheLineLookupIndex = id % cacheLineSize;\n+\n+\t\t// the cache line which is of size cacheLineSize\n+\t\tLong[] cacheLine = getCacheLine(cacheLookupIndex);\n+\n+\t\tif (cacheLine != null) {\n+\t\t\treturn cacheLine[cacheLineLookupIndex];\n+\t\t}\n+\n+\t\t// We only cache complete lines og size cacheLineSize. This means that the last line in the file will almost\n+\t\t// never be cached. This simplifies the code since we don't have to deal with partial lines.\n+\t\tif (getMaxID() > cacheLineSize && id < getMaxID() - cacheLineSize) {\n+\n+\t\t\t// doing one big read is considerably faster than doing a single read per id\n+\t\t\tbyte[] bytes = nioFile.readBytes(ITEM_SIZE * (cacheLookupIndex << cacheLineShift),\n+\t\t\t\t\t(int) (ITEM_SIZE * cacheLineSize));\n+\n+\t\t\tcacheLine = convertBytesToLongs(bytes);\n+\n+\t\t\tsynchronized (this) {\n+\t\t\t\t// we try not to overwrite an existing cache line\n+\t\t\t\tif (!cache.containsKey(cacheLineLookupIndex)) {\n+\t\t\t\t\tcache.put(cacheLookupIndex, cacheLine);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tgcReducingCache = cacheLine;\n+\t\t\tgcReducingCacheIndex = cacheLookupIndex;\n+\n+\t\t\treturn cacheLine[cacheLineLookupIndex];\n+\n+\t\t}\n+\n+\t\t// we did not find a cached value and we did not create a new cache line\n \t\treturn nioFile.readLong(ITEM_SIZE * id);\n \t}\n \n \t/**\n \t * Discards all stored data.\n-\t * \n+\t *\n \t * @throws IOException If an I/O error occurred.\n \t */\n \tpublic void clear() throws IOException {\n \t\tnioFile.truncate(HEADER_LENGTH);\n+\t\tnioFileSize = nioFile.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dce0457a6e964ff5e5ae78405e6762e20618621"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1599, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}