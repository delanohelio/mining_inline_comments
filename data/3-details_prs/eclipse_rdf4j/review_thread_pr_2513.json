{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NDk3MDky", "number": 2513, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo1OTozNFrOEkxAhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzozOToyMVrOEl4GWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTg3MTQxOnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo1OTozNFrOHT5ZRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo1OTozNFrOHT5ZRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNTM0OA==", "bodyText": "Instead of printing to STDOUT, let's send this to the logging framework:\nlogger.warn(\"error while processing geo property\", e);\n\nNot sure if this class has a logger field yet, if not, you can add it like this:\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nprivate final Logger logger = LoggerFactory.getLogger(getClass());", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490625348", "createdAt": "2020-09-17T23:59:34Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");\n \t\t\t}\n-\t\t} catch (ParseException e) {\n-\t\t\t// ignore\n+\t\t} catch (Exception e) {\n+\t\t\te.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTg3NDgzOnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDowMToxNlrOHT5bLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDowMToxNlrOHT5bLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNTgzOA==", "bodyText": "Let's be specific about the exceptions we're catching here:\n catch (ParseException | IllegalArgumentException e) {", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490625838", "createdAt": "2020-09-18T00:01:16Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");\n \t\t\t}\n-\t\t} catch (ParseException e) {\n-\t\t\t// ignore\n+\t\t} catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTg3NjUyOnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDowMjoyM1rOHT5cQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDowMjoyM1rOHT5cQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNjExNA==", "bodyText": "A minor thing, but: our code conventions don't use wildcard imports, could you roll this back here (and in other places where this has been changed)?", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490626114", "createdAt": "2020-09-18T00:02:23Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -8,15 +8,29 @@\n package org.eclipse.rdf4j.sail.lucene;\n \n import java.text.ParseException;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTg4ODkxOnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDowOToyNlrOHT5jkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxMzoyNTo0NFrOHUq1yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzk4Ng==", "bodyText": "Could we add the shape object to the exception message? Not sure it has a readable string representation but on the off chance, it could help pinpoint the error.", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490627986", "createdAt": "2020-09-18T00:09:26Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjk0NQ==", "bodyText": "More generally: I don't know the geospatial support well enough to really follow, but I'm a little uncomfortable to have this if..else construction in our code base. Here, we make a choice to just support Polygon, Line, and coordinate tuples as possible Shapes, and everything else we just throw an exception. Are there no other possible shapes that could come from processing the WKT literal that could be indexed by Lucene? For example what about multiline shapes, or rectangles/envelopes, or more generally Geometry collections?", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490632945", "createdAt": "2020-09-18T00:26:41Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzk4Ng=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc4Mzk3OQ==", "bodyText": "Yes you are totally right, Lucene could parse all those types:(\"MULTIPOLYGON\",\"POLYGON\",\"POINT\",\"MULTIPOINT\",\"LINESTRING\",\"MULTILINESTRING\",\"ENVELOPE\",\"GEOMETRYCOLLECTION\").\nI can support those extra shapes at index time but what would you suggest to remove this if else construction ? Is there a specific style you prefer so that I can follow ?", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490783979", "createdAt": "2020-09-18T08:23:38Z", "author": {"login": "AlyHdr"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzk4Ng=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNjc5Ng==", "bodyText": "I had a closer look at how createIndexableFields works and I guess we're stuck with the approach. It's somewhat inevitable since the output of SimpleWKTShapeParser is an Object - so the core of the problem is not in our code but in how that parser's api is designed.\nThat's a long-winded way of saying that I'm fine with sticking with the if-else construction :)", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r491236796", "createdAt": "2020-09-18T23:42:44Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzk4Ng=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQzNTQ2Ng==", "bodyText": "At some point this logic has to be done somewhere, in the current implementation in spatial4j, it was done by inherting the Shape class to any other geometry and at index time the indexer wouldn't care about the type. But with the Lucene parser and the new indexing scenario there should some logic because (shapes are not indexed with points.. etc). I have changed the code again based on your demand to cover all the available WKT geomerties, and even at search time I did some modifications for the new parser,indexer and searcher.. I will commit the modifications soon.", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r491435466", "createdAt": "2020-09-19T13:25:44Z", "author": {"login": "AlyHdr"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneDocument.java", "diffHunk": "@@ -140,13 +154,33 @@ public boolean hasProperty(String fieldName, String value) {\n \tpublic void addGeoProperty(String field, String value) {\n \t\tLuceneIndex.addStoredOnlyPredicateField(field, value, doc);\n \t\ttry {\n-\t\t\tSpatialStrategy geoStrategy = geoStrategyMapper.apply(field);\n-\t\t\tShape shape = geoStrategy.getSpatialContext().readShapeFromWkt(value);\n-\t\t\tfor (IndexableField f : geoStrategy.createIndexableFields(shape)) {\n-\t\t\t\tdoc.add(f);\n+\t\t\tString wkt = value;\n+\t\t\t// wkt = wkt.replace(\"\\\"\", \"\").replace(\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>\", \"\");\n+\t\t\t// System.out.println(wkt);\n+\t\t\tObject shape = SimpleWKTShapeParser.parse(wkt);\n+\t\t\tif (shape instanceof Polygon[]) {\n+\t\t\t\tfor (Polygon p : (Polygon[]) shape) {\n+\t\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, p)) {\n+\t\t\t\t\t\tdoc.add(f);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Polygon) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Polygon) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof Line) {\n+\t\t\t\tfor (Field f : LatLonShape.createIndexableFields(field, (Line) shape)) {\n+\t\t\t\t\tdoc.add(f);\n+\t\t\t\t}\n+\t\t\t} else if (shape instanceof double[]) {\n+\t\t\t\tdouble point[] = (double[]) shape;\n+\t\t\t\t// System.out.println(point[0]+\" \"+point[1]);\n+\t\t\t\tdoc.add(new LatLonPoint(field, point[1], point[0]));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Geometry is not supported\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzk4Ng=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTk1NDg2OnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/test/java/org/eclipse/rdf4j/sail/lucene/examples/LuceneSailExample.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDo0NDozNlrOHT6I_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDo0NDozNlrOHT6I_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNzU2NA==", "bodyText": "This looks like you've used the example for your own tests - which is fine of course, but I think it needs some cleaning up.", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490637564", "createdAt": "2020-09-18T00:44:36Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/test/java/org/eclipse/rdf4j/sail/lucene/examples/LuceneSailExample.java", "diffHunk": "@@ -69,45 +75,35 @@ public static void createSimple() throws Exception {\n \t\ttry ( // add some test data, the FOAF ont\n \t\t\t\tSailRepositoryConnection connection = repository.getConnection()) {\n \t\t\tconnection.begin();\n-\t\t\tconnection.add(LuceneSailExample.class.getResourceAsStream(\"/org/openrdf/sail/lucene/examples/foaf.rdfs\"),\n-\t\t\t\t\t\"\", RDFFormat.RDFXML);\n+\t\t\tconnection.add(new FileInputStream(new File(\"some_dir\")),\n+\t\t\t\t\t\"\", RDFFormat.NTRIPLES);\n \t\t\tconnection.commit();\n \n \t\t\t// search for resources that mention \"person\"\n-\t\t\tString queryString = \"PREFIX search:   <\" + LuceneSailSchema.NAMESPACE + \"> \\n\"\n-\t\t\t\t\t+ \"PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> \\n\" + \"SELECT * WHERE { \\n\"\n-\t\t\t\t\t+ \"?subject search:matches ?match . \\n\" + \"?match search:query \\\"person\\\" ; \\n\"\n-\t\t\t\t\t+ \"       search:property ?property ; \\n\" + \"       search:score ?score ; \\n\"\n-\t\t\t\t\t+ \"       search:snippet ?snippet . \\n\" + \"?subject rdf:type ?type . \\n\" + \"} LIMIT 3 \\n\"\n-\t\t\t\t\t+ \"BINDINGS ?type { \\n\" + \" (<http://www.w3.org/2002/07/owl#Class>) \\n\" + \"}\";\n-\t\t\ttupleQuery(queryString, connection);\n-\n-\t\t\t// search for property \"name\" with domain \"person\"\n-\t\t\tqueryString = \"PREFIX search: <\" + LuceneSailSchema.NAMESPACE + \"> \\n\"\n-\t\t\t\t\t+ \"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> \\n\" + \"SELECT * WHERE { \\n\"\n-\t\t\t\t\t+ \"?subject rdfs:domain ?domain . \\n\" + \"?subject search:matches ?match . \\n\"\n-\t\t\t\t\t+ \"?match search:query \\\"chat\\\" ; \\n\" + \"       search:score ?score . \\n\"\n-\t\t\t\t\t+ \"?domain search:matches ?match2 . \\n\" + \"?match2 search:query \\\"person\\\" ; \\n\"\n-\t\t\t\t\t+ \"        search:score ?score2 . \\n\" + \"} LIMIT 5\";\n+\t\t\t// String queryString = \"PREFIX geof: <http://www.opengis.net/def/function/geosparql/> PREFIX geo:\n+\t\t\t// <http://www.opengis.net/ont/geosparql#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> PREFIX\n+\t\t\t// rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?id WHERE { ?s <http://nuts.de/geometry> ?o . FILTER\n+\t\t\t// (geof:sfWithin(\\\"Point(-2.7633 47.826)\\\"^^geo:wktLiteral,?o)) }\";\n+\t\t\t// String queryString = \"PREFIX geof: <http://www.opengis.net/def/function/geosparql/> PREFIX geo:\n+\t\t\t// <http://www.opengis.net/ont/geosparql#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> PREFIX\n+\t\t\t// rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?id WHERE { ?s <http://nuts.de/geometry> ?o . FILTER\n+\t\t\t// (geof:sfContains(?o,\\\"POINT(33.30260 38.675310)\\\"^^geo:wktLiteral)) ?s <http://example.com/id> ?id . }\";\n+\t\t\t// String queryString = \"PREFIX geof: <http://www.opengis.net/def/function/geosparql/> PREFIX geo:\n+\t\t\t// <http://www.opengis.net/ont/geosparql#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> PREFIX\n+\t\t\t// rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?id WHERE { ?s <http://nuts.de/geometry> ?o . FILTER\n+\t\t\t// (geof:sfWithin(\\\"Point(7.98 45.363)\\\"^^geo:wktLiteral,?o)) ?s <http://nuts.de/id> ?id . }\";\n+\t\t\tString queryString = \"SELECT ?s0 where { ?s0 <https://linkedopendata.eu/prop/direct/P127> ?coordinates . FILTER ( <http://www.opengis.net/def/function/geosparql/distance>(\\\"Point(12.2018 44.4161)\\\"^^<http://www.opengis.net/ont/geosparql#wktLiteral>,?coordinates,<http://www.opengis.net/def/uom/OGC/1.0/metre>)< 100000) .    ?s0 <https://linkedopendata.eu/prop/direct/P35> <https://linkedopendata.eu/entity/Q9934> .}\";\n+\t\t\t/*\n+\t\t\t * String queryString = \"PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\" +\n+\t\t\t * \"PREFIX geof: <http://www.opengis.net/def/function/geosparql/>\\n\" +\n+\t\t\t * \"PREFIX uom: <http://www.opengis.net/def/uom/OGC/1.0/>\\n\" + \"PREFIX ex: <http://example.org/>\\n\" +\n+\t\t\t * \"SELECT *\\n\" + \"WHERE {\\n\" + \"  ?lmA a ex:Landmark ;\\n\" +\n+\t\t\t * \"       geo:hasGeometry [ geo:asWKT ?coord1 ].\\n\" + \"  ?lmB a ex:Landmark ;\\n\" +\n+\t\t\t * \"       geo:hasGeometry [ geo:asWKT ?coord2 ].\\n\" +\n+\t\t\t * \"  BIND((geof:distance(?coord1, ?coord2, uom:metre)/1000) as ?dist) .\\n\" +\n+\t\t\t * \"  FILTER (str(?lmA) < str(?lmB))\\n\" + \"}\";\n+\t\t\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTk1NzUxOnYy", "diffSide": "RIGHT", "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneIndex.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMDo0NjowOVrOHT6Kkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzo1MDoxM1rOHVmMeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNzk3MQ==", "bodyText": "This brings up a point: are these changes compatible with existing indexes? What would happen if you ran this code on a Lucene index that was generated with an older version of RDF4J?", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r490637971", "createdAt": "2020-09-18T00:46:09Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneIndex.java", "diffHunk": "@@ -753,11 +751,15 @@ public DocumentScore apply(ScoreDoc doc) {\n \t\tSpatialStrategy strategy = getSpatialStrategyMapper().apply(geoField);\n \t\tfinal Shape boundingCircle = strategy.getSpatialContext().getShapeFactory().circle(p, degs);\n \t\tQuery q = strategy.makeQuery(new SpatialArgs(SpatialOperation.Intersects, boundingCircle));\n+\n+\t\t// use LatLonPoint for distance query after indexing it with the same data structure\n+\n+\t\tq = LatLonPoint.newDistanceQuery(geoField, p.getY(), p.getX(), distance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwNjE3OA==", "bodyText": "@jeenbroekstra  In this scenario it would not work and basically it is better to re-index things in Lucene because in the current implementation it was failing to index all other geometries - check the issue #2489 . Adding to this, that I tried to index some polygons using the current indexing algorithm after doing some modifications and it took a very long time while using this new algorithm it is much faster. That is to say that this modification is worth it and if you would like to have a turnaround to still support old index at search time, one have to figure out the shape of the index and then choose to search using the old or the new algorithm which is something not so practical.", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r492106178", "createdAt": "2020-09-21T14:46:28Z", "author": {"login": "AlyHdr"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneIndex.java", "diffHunk": "@@ -753,11 +751,15 @@ public DocumentScore apply(ScoreDoc doc) {\n \t\tSpatialStrategy strategy = getSpatialStrategyMapper().apply(geoField);\n \t\tfinal Shape boundingCircle = strategy.getSpatialContext().getShapeFactory().circle(p, degs);\n \t\tQuery q = strategy.makeQuery(new SpatialArgs(SpatialOperation.Intersects, boundingCircle));\n+\n+\t\t// use LatLonPoint for distance query after indexing it with the same data structure\n+\n+\t\tq = LatLonPoint.newDistanceQuery(geoField, p.getY(), p.getX(), distance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNzk3MQ=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwNzkyOQ==", "bodyText": "Oh I'm not disputing the usefulness of this fix, the reason I asked is that I wanted to know if we will need to put anything in the release notes about updating existing indexes. Which, apparently, we do, so I'll make a note of that. Thanks!", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r492407929", "createdAt": "2020-09-21T23:50:13Z", "author": {"login": "jeenbroekstra"}, "path": "core/sail/lucene/src/main/java/org/eclipse/rdf4j/sail/lucene/LuceneIndex.java", "diffHunk": "@@ -753,11 +751,15 @@ public DocumentScore apply(ScoreDoc doc) {\n \t\tSpatialStrategy strategy = getSpatialStrategyMapper().apply(geoField);\n \t\tfinal Shape boundingCircle = strategy.getSpatialContext().getShapeFactory().circle(p, degs);\n \t\tQuery q = strategy.makeQuery(new SpatialArgs(SpatialOperation.Intersects, boundingCircle));\n+\n+\t\t// use LatLonPoint for distance query after indexing it with the same data structure\n+\n+\t\tq = LatLonPoint.newDistanceQuery(geoField, p.getY(), p.getX(), distance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNzk3MQ=="}, "originalCommit": {"oid": "07a8524598a8fdb604e51bf2c4d22dfa2d5e36bf"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTUxODk4OnYy", "diffSide": "RIGHT", "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/RDFCollectionsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzozOToyMVrOHVmAzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozNDo0NFrOHVx6-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwNDk0MQ==", "bodyText": "Not sure why this shows up in your PR, as these changes are already present on the master branch. Possibly caused by your fork being out of sync with the upstream repo.\nIt's probably not a problem, but just to be sure, could you update your fork's master branch and then run git rebase master on your feature branch? After you force-pushed that, these older commits should no longer show up in this PR.", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r492404941", "createdAt": "2020-09-21T23:39:21Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/RDFCollectionsTest.java", "diffHunk": "@@ -71,35 +70,34 @@ public void testConversionRoundtrip() {\n \n \t}\n \n-\t@Test\n-\tpublic void testNonWellformedCollection() {\n+\t@Test(expected = ModelException.class)\n+\tpublic void testNonWellformedCollection_MissingTerminator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01093a67bfc6a6c93facaa4c52937db9a9ce6f93"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMTAzNA==", "bodyText": "Apart from this, by the way, I think the fix now looks really good, thanks!", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r492411034", "createdAt": "2020-09-22T00:01:11Z", "author": {"login": "jeenbroekstra"}, "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/RDFCollectionsTest.java", "diffHunk": "@@ -71,35 +70,34 @@ public void testConversionRoundtrip() {\n \n \t}\n \n-\t@Test\n-\tpublic void testNonWellformedCollection() {\n+\t@Test(expected = ModelException.class)\n+\tpublic void testNonWellformedCollection_MissingTerminator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwNDk0MQ=="}, "originalCommit": {"oid": "01093a67bfc6a6c93facaa4c52937db9a9ce6f93"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDA1OQ==", "bodyText": "Ok sounds good ! Thank you for your collaboration and I fixed this it was my fault ..", "url": "https://github.com/eclipse/rdf4j/pull/2513#discussion_r492600059", "createdAt": "2020-09-22T09:34:44Z", "author": {"login": "AlyHdr"}, "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/RDFCollectionsTest.java", "diffHunk": "@@ -71,35 +70,34 @@ public void testConversionRoundtrip() {\n \n \t}\n \n-\t@Test\n-\tpublic void testNonWellformedCollection() {\n+\t@Test(expected = ModelException.class)\n+\tpublic void testNonWellformedCollection_MissingTerminator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwNDk0MQ=="}, "originalCommit": {"oid": "01093a67bfc6a6c93facaa4c52937db9a9ce6f93"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1374, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}